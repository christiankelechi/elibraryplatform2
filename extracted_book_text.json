{
    "text": "Beginning Java \n17 Fundamentals\nObjectOriented Programming in Java 17\n\nThird Edition\n\nKishori Sharan\nAdam L DavisBeginning Java 17 \nFundamentals\nObjectOriented Programming in  Java 17\nThird Edition\nKishori  Sharan\nAdam  L DavisKishori\u00a0Sharan\nMontgomery AL USAAdam\u00a0L\u00a0Davis\nOviedo FL USABeginning Java 17 Fundamentals ObjectOriented Programming in Java 17\nISBN13 pbk 9781484273067    ISBN13 electronic 9781484273074\nhttpsdoiorg1010079781484273074\nCopyright  2022 by Kishori Sharan and Adam L\u00a0Davis\nThis work is subject to copyright All rights are reserved by the Publisher whether the whole or part of the \nmaterial is concerned specifically the rights of translation reprinting reuse of illustrations recitation \nbroadcasting reproduction on microfilms or in any other physical way and transmission or information \nstorage and retrieval electronic adaptation computer software or by similar or dissimilar methodology now \nknown or hereafter developed\nTrademarked names logos and images may appear in this book Rather than use a trademark symbol with \nevery occurrence of a trademarked name logo or image we use the names logos and images only in an \neditorial fashion and to the benefit of the trademark owner with no intention of infringement of the \ntrademark \nThe use in this publication of trade names trademarks service marks and similar terms even if they are not \nidentified as such is not to be taken as an expression of opinion as to whether or not they are subject to \nproprietary rights\nWhile the advice and information in this book are believed to be true and accurate at the date of publication \nneither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or \nomissions that may be made The publisher makes no warranty express or implied with respect to the \nmaterial contained herein\nManaging Director Apress Media LLC Welmoed Spahr\nAcquisitions Editor Steve Anglin\nDevelopment Editor Matthew Moodie\nCoordinating Editor Mark Powers\nCover designed by eStudioCalamar\nCover image by Christina Rumpf on Unsplash wwwunsplashcom\nDistributed to the book trade worldwide by Apress Media LLC 1 New\u00a0York Plaza New\u00a0York NY 10004 \nUSA\u00a0Phone 1800SPRINGER fax 201 3484505 email ordersnyspringersbmcom  or visit  \nwwwspringeronlinecom  Apress Media LLC is a California LLC and the sole member owner is Springer \nScience  Business Media Finance Inc SSBM Finance Inc SSBM Finance Inc is a Delaware  corporation\nFor information on translations please email booktranslationsspringernaturecom  for reprint \npaperback or audio rights please email bookpermissionsspringernaturecom \nApress titles may be purchased in bulk for academic corporate or promotional use eBook versions and \nlicenses are also available for most titles For more information reference our Print and eBook Bulk Sales \nweb page at httpwwwapresscombulksales \nAny source code or other supplementary material referenced by the author in this book is available to \nreaders on GitHub via the books product page located at wwwapresscom9781484273067  For more \ndetailed information please visit httpwwwapresscomsource  code \nPrinted on acidfree paperiiiTable of Contents\n Chapter 1  Progr amming Concepts   1\nWhat Is Prog ramming   1\nComponents of a Prog ramming Language   4\nProgramming Paradigms   4\nImperative Paradigm   6\nProcedural Par adigm   7\nDeclar ative Paradigm   7\nFunctional Par adigm   8\nLogic Par adigm   8\nObjectOriented Par adigm   9\nWhat Is Java   12\nThe ObjectOriented Paradigm and Ja va  13\nAbstraction   14\nEncapsulation and Information Hiding   23\nInheritance   25\nPolymorphism   26\nSummary   31About the Authors   xxv\nAbout the T echnical Reviewer   xxvii\nAcknowledgments   xxix\nIntroduction   xxxi Table of Con TenTs\niv Chapter 2  Setting Up the Environment   33\nSystem Requir ements   33\nInstalling JDK 17   33\nThe JDK Dir ectory Structure   34\nVerifying the JDK Installation   37\nStarting the JShell Tool  38\nInstalling NetBeans 12   38\nConfiguring NetBeans   38\nSummar y  43\n Chapter 3  Writing Ja va Programs   45\nThe Goal Statement   45\nUsing the JShell Tool  46\nWhat Is a Ja va Program   46\nWriting the Sour ce Code   47\nWriting Comments   48\nDeclaring a Module   49\nDeclaring T ypes  51\nPackage Declaration   51\nImport Declarations   53\nClass Declar ation   54\nTypes Have Two Names   59\nCompiling the Source Code   59\nPackaging the Compiled Code  62\nRunning a Java Program   64\nPlaying with Module Options   70\nListing Observable Modules   70\nLimiting the Observ able Modules   71\nDescribing a Module   72 Table of Con TenTs\nvPrinting Module Resolution Details   73\nDryRunning Your Program   74\nEnhancing a Module Descriptor   74\nRunning Jav a Programs in Legacy Mode   76\nDuplicate Modules on a Module Path   78\nSyntax for CommandLine Options   80\nWriting Ja va Programs Using the NetBeans IDE   81\nCreating a Java Project   82\nCreating Modular JARs in NetBeans   90\nNetBeans Project Dir ectory Structure   91\nAdding Classes to a Module   91\nCustomizing NetBeans Project Properties   91\nOpening an Existing NetBeans Project   93\nBehind the Scenes   94\nSummary   97\n Chapter 4  Data Types   101\nWhat Is a Data Type  101\nWhat Is an Identifier   102\nKeyw ords  104\nData Types in Java   105\nLocal V ariable Type Inference   110\nPrimitive Data Types in Java   110\nIntegral Data Types   111\nFloatingPoint Data T ypes  121\nUnderscores in Numeric Literals   126\nJava Compiler and Unicode Escape Sequence   127\nA Short Br eak  128 Table of Con TenTs\nviBinary Representation of Integers   129\nDiminished Radix Complement   130\nRadix Complement   131\nBinary Representation of FloatingPoint Numbers   132\n32 Bit SinglePrecision FloatingPoint For mat  134\nSpecial FloatingPoint Numbers   137\nSigned Zeros   137\nSigned Infinities   137\nNaN  138\nDenor mals   139\nRounding Modes   139\nRounding Toward Zero   140\nRounding T oward Positive Infinity   140\nRounding Toward Negative Infinity   140\nRounding T oward Nearest   141\nIEEE FloatingPoint Exceptions   141\nDivision by Zero Exception   141\nInvalid Oper ation Exception   141\nOverflo w Exception   142\nUnderflo w Exception   142\nInexact Exception   142\nJava and IEEE FloatingPoint Standards   143\nLittleEndian and BigEndian  143\nSummary   144\n Chapter 5  Operators   147\nWhat Is an Oper ator   147\nAssignment Oper ator  149\nDeclar ation Initialization and Assignment   151 Table of Con TenTs\nviiArithmetic Operators   152\nAddition Operator    153\nSubtraction Oper ator    155\nMultiplication Oper ator    156\nDivision Oper ator    156\nModulus Oper ator    158\nUnar y Plus Operator    160\nUnar y Minus Operator    161\nCompound Arithmetic Assignment Operators   161\nIncrement  and Decr ement  Operators   163\nString Concatenation Operator    165\nRelational Operators   169\nEquality Operator    170\nInequality Operator    172\nGreater Than Operator   173\nGreater Than or Equal to Operator    173\nLess Than Operator    174\nLess Than or Equal to Operator    174\nBoolean Logical Operators   174\nLogical NOT Operator    175\nLogical ShortCircuit AND Operator    175\nLogical AND Operator    177\nLogical ShortCir cuit OR Operator    177\nLogical OR Oper ator    178\nLogical XOR Oper ator    178\nCompound Boolean Logical Assignment Operators   179\nTernary Operator     179\nBitwise Operators   180\nOper ator Precedence   184\nSummar y  186 Table of Con TenTs\nviii Chapter 6  Statements   191\nWhat Is a Statement   191\nTypes of Statements   192\nDeclaration Statement   192\nExpression Statement   192\nControl Flo w Statement   193\nA Block Statement   193\nThe ifelse Statement   195\nThe switc h Statement   199\nThe switc h Expression   203\nThe for Statement   204\nInitialization   206\nCondition Expression   207\nExpression List   207\nThe foreach Statement   210\nThe while Statement   211\nThe dowhile Statement   213\nThe br eak Statement   215\nThe continue Statement   218\nAn Empty Statement  219\nSummary   220\n Chapter 7  Classes   225\nWhat Is a Class   225\nDeclaring a Class   226\nDeclaring Fields in a Class   227\nCreating Instances of a Class   228\nThe null Refer ence Type   230\nUsing Dot Notation to Access Fields of a Class   231\nDefault Initialization of Fields   234 Table of Con TenTs\nixAccess Level Modifiers for a Class   235\nImport Declarations   238\nSingleType Import Declaration   239\nImportonDemand Declaration   241\nImport Declar ations and Type Search Order   243\nAutomatic Import Declarations   248\nStatic Import Declar ations   249\nDeclaring a Record   253\nSummary   254\n Chapter 8  Methods   257\nWhat Is a Method   257\nDeclaring Methods of a Class   257\nLocal V ariables   262\nRule 1   263\nRule 2   263\nRule 3   263\nRule 4   263\nInstance Methods and Class Methods   266\nInvoking a Method   267\nThe Special main Method  268\nWhat Is this   271\nAccess Levels for Class Members   276\nAccess Level  A Case Study   283\nWhat Is a VarArgs Method   288\nOverloading a VarArgs Method   293\nVarArgs Methods and the main Method   294\nParameterPassing Mechanisms   295\nPass by Value   297\nPass by Constant Value   299\nPass b y Reference   299 Table of Con TenTs\nxPass by Reference Value   303\nPass b y Constant Reference Value   304\nPass b y Result   304\nPass b y Value Result   304\nPass b y Name   305\nPass b y Need   306\nParameterPassing Mechanisms in Java   306\nSummary   318\n Chapter 9  Constructors   323\nWhat Is a Constructor   323\nDeclaring a Constructor  323\nOverloading a Constructor   326\nWriting Code for a Constructor   327\nCalling a Constructor from Another Constructor   330\nUsing a r eturn Statement Inside a Constructor   332\nAccess Level Modifier for a Constructor   332\nDefault Constructor   336\nA static Constructor   337\nInstance Initialization Bloc k  338\nStatic Initialization Bloc k  339\nThe final Keyw ord 340\nfinal Local Variables   342\nfinal Parameters   342\nfinal Instance Variables  342\nfinal Class Variables  345\nfinal Reference Variables   345\nCompileT ime vs  Runtime final Variables   346\nGeneric Classes   347\nSummary   350 Table of Con TenTs\nxi Chapter 10  Modules   355\nWhat Is a Module   355\nDeclaring Modules   356\nDeclaring Module Dependence   358\nAn Example of Module Dependence   360\nTroubleshooting   366\nImplicit Dependence   367\nOptional Dependence   373\nOpening Modules and Pac kages   374\nOpen Modules   375\nOpening Packages   376\nSplitting Packages Across Modules   377\nRestrictions in Module Declarations   377\nTypes of Modules   378\nNormal Modules   379\nOpen Modules   379\nAutomatic Modules   379\nUnnamed Modules   383\nAggregator Modules   384\nKnowing About Modules at Runtime   384\nMigration Path to Modules   386\nJava Class Dependency Analyzer   387\nDisassembling Module Definitions   388\nSummar y  391\n Chapter 11  Object and Objects Classes   395\nThe Object Class   395\nRule 1   396\nRule 2   397 Table of Con TenTs\nxiiWhat Is the Class of an Object   398\nComputing the Hash Code of an Object   400\nComparing Objects for Equality   404\nString Repr esentation of an Object   410\nCloning Objects   413\nFinalizing an Object   420\nImmutable Objects   422\nThe Objects Class   427\nBounds Checks   427\nComparing Objects   428\nComputing Hash Code   428\nChec king for Null   429\nValidating Arguments   429\nObtaining String Repr esentation of Objects   430\nUsing the Objects Class   430\nSummary   432\n Chapter 12  Wrapper Classes   435\nWrapper Classes   435\nNumeric Wrapper Classes   438\nThe Character Wrapper Class   441\nThe Boolean Wrapper Class   442\nUnsigned Numeric Operations   442\nAutoboxing and Unboxing  444\nBeware of Null Values   446\nOverloaded Methods and AutoboxingUnboxing   447\nComparison Oper ators and AutoboxingUnboxing   450\nCollections and AutoboxingUnboxing   452\nSummar y  452 Table of Con TenTs\nxiii Chapter 13  Exception Handling   455\nWhat Is an Exception   455\nAn Exception Is an Object   458\nUsing a tr ycatch Block   458\nTransfer of Control   461\nException Class Hier archy   462\nArranging Multiple catch Blocks   464\nA Multicatc h Block   467\nChec ked and Unchecked Exceptions  468\nChecked Exception Catch or Declare   470\nChec ked Exceptions and Initializers   476\nThrowing an Exception   478\nCreating an Exception Class   479\nThe finally Bloc k  482\nRethro wing an Exception   485\nAnalysis of Rethro wn Exceptions   488\nThrowing Too Many Exceptions   489\nAccessing the Stac k of a Thread   490\nThe tr ywithresources Block   493\nSummar y  499\n Chapter 14  Assertions   501\nWhat Is an Assertion   501\nTesting Assertions   503\nEnablingDisabling Assertions   505\nUsing Assertions   507\nChec king for Assertion Status   508\nSummar y  509 Table of Con TenTs\nxiv Chapter 15  Strings  511\nWhat Is a String   511\nString Liter als  512\nEscape Sequence Char acters in String Literals   512\nUnicode Escapes in String Liter als  513\nWhat Is a CharSequence   513\nCreating String Objects   513\nLength of a String   514\nString Liter als Are String Objects   514\nString Objects Are Immutable   515\nComparing Strings   516\nString Pool   518\nString Oper ations   520\nGetting the Character at an Index   520\nTesting Strings for Equality   520\nTesting a String to Be Empty   521\nChanging the Case   521\nSearching for a String   522\nRepresenting Values as Strings   522\nGetting a Substring   522\nTrimming a String   522\nReplacing Part of a String   523\nMatc hing the Start and End of a String   524\nSplitting and Joining Strings   524\nStrings in a switch Statement   525\nTesting a String for Palindrome   527\nStringBuilder and StringBuffer   529\nString Concatenation Oper ator    532 Table of Con TenTs\nxvMultiline Strings   532\nLanguageSensitive String Comparison   533\nSummar y  534\n Chapter 16  Dates and Times   537\nThe DateTime API   537\nDesign Principles   538\nA Quic k Example   539\nEvolution of Timekeeping   540\nTime Zones and Daylight Savings Time   543\nCalendar Systems   544\nThe Julian Calendar   544\nThe Gregorian Calendar   545\nISO8601 Standards for Datetime   546\nExploring the DateTime API  547\nThe ofXxx Methods   548\nThe from Methods   548\nThe withXxx Methods   548\nThe getXxx Methods   549\nThe toXxx Methods   549\nThe atXxx Methods   549\nThe plusXxx and minusXxx Methods   550\nThe multipliedBy  dividedBy and negated Methods   550\nInstants and Durations   550\nDividing a Duration by Another Duration   553\nConverting and Retrieving Duration Parts   554\nTruncating a Duration   555\nHumanScale Time   556\nThe ZoneOffset Class   556\nThe ZoneId Class   557\nUseful DatetimeRelated Enums   560 Table of Con TenTs\nxviLocal Date Time and Datetime   564\nOffset T ime and Datetime   569\nZoned Datetime   570\nSame Instant Different Times   573\nClocks   574\nPeriods   575\nPeriod Between Two Dates and Times   578\nPartials   579\nAdjusting Dates   581\nQuer ying Datetime Objects  586\nNonISO Calendar Systems   591\nFormatting Dates and Times   592\nUsing Predefined Formatters   592\nUsing the format Method of Datetime Classes   594\nUsing UserDefined Patter ns  595\nUsing LocaleSpecific For mats   600\nUsing the DateT imeFormatterBuilder Class   602\nParsing Dates and Times   603\nLegacy Datetime Classes   606\nThe Date Class   606\nThe Calendar Class   607\nThe add Method   608\nThe roll Method   608\nInteroperability with Legacy Datetime Classes   609\nSummary   613\n Chapter 17  Formatting Data   615\nFormatting Dates   615\nUsing Predefined Date Formats   616\nUsing Custom Date Formats   618\nParsing Dates   620 Table of Con TenTs\nxviiFormatting Numbers   622\nUsing Predefined Number Formats   622\nUsing Custom Number Formats   623\nParsing Numbers   624\nprintfStyle Formatting   625\nThe Big Picture   625\nThe Details   628\nRefer encing an Argument Inside a Format Specifier   630\nUsing Flags in a Format Specifier   633\nConversion Char acters   634\nSummary   648\n Chapter 18  Regular Expressions   651\nWhat Is a Regular Expr ession   651\nMetac haracters   654\nCharacter Classes   654\nPredefined Character Classes   655\nMore Powers to Regular Expressions   656\nCompiling Regular Expressions   656\nCreating a Matc her  658\nMatc hing the Pattern   658\nQuerying a Match   660\nBewar e of Backslashes   661\nQuantifiers in Regular Expr essions   661\nMatc hing Boundaries   662\nGroups and Bac k Referencing   663\nUsing Named Groups   668\nResetting the Matc her  671\nFinal W ords on Email Validations   671 Table of Con TenTs\nxviiiFindandReplace Using Regular Expressions   671\nStreams of Matc hed Results   675\nSummar y  677\n Chapter 19  Arrays  681\nWhat Is an Array   681\nArrays Are Objects   683\nAccessing Arr ay Elements   684\nLength of an Array   685\nInitializing Arr ay Elements   686\nBeware of ReferenceType Arrays   687\nExplicit Arr ay Initialization   689\nLimitations of Using Arrays   690\nSimulating V ariableLength Arrays   693\nPassing an Array as a Parameter   696\nArray Parameter Reference   701\nElements of the Arr ay Parameter   701\nThe Objects Referr ed To by the Array Parameter Elements   702\nCommandLine Arguments   705\nMultidimensional Arrays   709\nAccessing Elements of a Multidimensional Array   712\nInitializing Multidimensional Arr ays  713\nEnhanced for Loop for Arrays   713\nArray Declar ation Syntax   714\nRuntime Array Bounds Checks   715\nWhat Is the Class of an Array Object   716\nArray Assignment Compatibility   718\nConverting a List to an Array   719\nPerfor ming Array Operations   721 Table of Con TenTs\nxixConverting Arrays to Another Type   722\nSearching an Array   723\nComparing Arr ays  723\nCopying Arrays   725\nFilling Arr ays  725\nComputing Hash Code   726\nPerfor ming Parallel Accumulation   726\nSorting Arr ays  726\nSummary   727\n Chapter 20  Inheritance   731\nWhat Is Inheritance   731\nInheriting Classes   732\nThe Object Class Is the Default Super class   735\nInheritance and Hier archical Relationship   735\nWhat Is Inherited b y a Subclass   736\nUpcasting and Do wncasting   738\nThe instanceof Oper ator  742\nBinding   744\nEarly Binding   745\nLate Binding   748\nMethod Overriding   751\nMethod Overriding Rule 1   752\nMethod Overriding Rule 2   752\nMethod Overriding Rule 3   753\nMethod Overriding Rule 4   753\nMethod Overriding Rule 5   754\nMethod Overriding Rule 6   754\nAccessing an Overridden Method   757\nMethod Overloading   759 Table of Con TenTs\nxxInheritance and Constructors   763\nMethod Hiding   770\nField Hiding   772\nDisabling Inheritance   776\nSealed Classes   777\nAbstr act Classes and Methods   777\nMethod Overriding and Generic Method Signatur es  785\nTypo Danger in Method Overriding   786\nIsa Hasa and Partof Relationships  788\nPatternMatching Switch   790\nNo Multiple Inheritance of Classes   790\nSummar y  791\n Chapter 21  Interfaces   797\nWhat Is an Interface   797\nProposed Solution 1  800\nProposed Solution 2  801\nProposed Solution 3  802\nAn Ideal Solution   802\nDeclaring an Interface   806\nDeclaring Interface Members   807\nConstant Field Declarations   808\nMethod Declarations   809\nNested T ype Declarations   818\nAn Interface Defines a New Type   820\nImplementing an Interface   823\nImplementing Interface Methods   827\nImplementing Multiple Interfaces   830\nImplementing an Interface Partially   832\nThe SupertypeSubtype Relationship   834 Table of Con TenTs\nxxiInterface Inheritance   835\nThe SuperinterfaceSubinterface Relationship   840\nInheriting Conflicting Implementations   841\nThe Superclass Always Wins   841\nThe Most Specific Superinterface Wins   844\nThe Class Must Override the Conflicting Method   844\nThe instanceof Operator   845\nMarker Interfaces   849\nFunctional Interfaces   850\nComparing Objects   851\nUsing the Comparable Interface   851\nUsing the Comparator Interface   853\nPolymorphism One Object Many Views   858\nDynamic Binding and Interfaces   860\nSummar y  861\n Chapter 22  Enum Types   865\nWhat Is an Enum Type   865\nThe Super class of an Enum Type   869\nUsing Enum Types in switch Statements   872\nAssociating Data and Methods to Enum Constants   873\nAssociating a Bod y to an Enum Constant   875\nComparing Two Enum Constants   879\nNested Enum Types   881\nImplementing an Interface to an Enum Type  882\nReverse Lookup for Enum Constants   883\nRange of Enum Constants   884\nSummar y  885 Table of Con TenTs\nxxii Chapter 23  Java Shell   889\nWhat Is the Ja va Shell   890\nThe JShell Architecture   891\nStarting the JShell Tool  893\nExiting the JShell Tool  895\nWhat Are Snippets and Commands   895\nEvaluating Expressions   897\nListing Snippets   899\nEditing Snippets   902\nRerunning Pr evious Snippets   904\nDeclaring V ariables   904\nImport Statements   907\nMethod Declar ations   910\nType Declarations   911\nSetting the Execution Environment   914\nNo Chec ked Exceptions   915\nAutocompletion   916\nHistor y of Snippets and Commands   919\nReading JShell Stac k Trace   920\nReusing JShell Sessions   921\nResetting the JShell State   923\nReloading the JShell State   923\nConfiguring JShell   925\nSetting the Snippet Editor   925\nSetting Feedback Mode   927\nCreating Custom Feedback Modes   929\nSetting Up Startup Snippets   933\nUsing JShell Documentation   936\nThe JShell API   937 Table of Con TenTs\nxxiiiCreating a JShell   938\nWorking with Snippets  939\nHandling Snippet Events   941\nAn Example   941\nSummary   945\n Appendix A Character Encodings   947\nASCII   948\n8 Bit Character Sets   953\nUniversal MultipleOctet Coded Character Set UCS   953\nUCS2  954\nUCS4  955\nUTF16 UCS T ransformation Format 16   955\nUTF8 UCS Tr ansformation Format 8   955\nJava and Character Encodings   956\n Appendix B Documentation Comments   959\nWriting Documentation Comments   960\nList of Block and Inline Tags  962\nauthor authornames   963\ndeprecated explanationte xt  963\nexception classname description   963\nparam parameter name description   964\nreturn description   964\nsee refer ence   964\nserial fielddescription or includeexclude   965\nserialData datadescription   966\nserialField fieldname fieldtype fielddescription   966\nsince description   967\nthrows classname description   967\nversion versiontext   968\ncode text   968 Table of Con TenTs\nxxivdocRoot   968\ninheritDoc  968\nlink package classmember label   969\nlinkplain package classmember label   970\nliteral text   970\nvalue package classfield   970\nhidden   971\nindex keyword description   971\nprovides servicetype description   972\nuses servicetype description   972\nDocumenting Packages   972\n comjdojoutilitypackageinfo java file   973\n comjdojoutilitypackage html file   973\nOverview Documentation   973\nIncluding Unprocessed Files in the Documentation   974\nSkipping Source File Processing   974\nAn Example of Documentation Comments   974\nRunning the javadoc Tool   976\nGenerated Documentation Files   978\nViewing Generated HTML Documentation   979\nSearching Javadoc   980\nSummary   982\n Index   983xxvAbout the Authors\nKishori\u00a0Sharan \u00a0works as a senior software engineer lead at IndraSoft Inc \nHe earned a master of science degree in computer information systems \nfrom Troy University Alabama He is a Suncertified Java 2 programmer \nand has over 20 years of experience in developing enterprise applications \nand providing training to professional developers using the Java platform \nAdam\u00a0L\u00a0Davis \u00a0works as a senior software developer with Deloitte He \nearned his masters degree in computer science from Georgia Institute \nof Technology in Atlanta Georgia He has over 16 years of experience in \nsoftware development and multiple certifications including Java 11 He \nis the author of several Apress titles including Spring Quick Reference \nGuide  Modern Programming Made Easy  Learning Groovy 3  and Reactive \nStreams in Java  \nxxviiAbout the Technical Reviewer\nChd\u00a0shod\u00a0Darby \u00a0is an author instructor and speaker in the Java \ndevelopment world As a recognized authority on Java applications \nand architectures he has presented technical sessions at software \ndevelopment conferences worldwide United States United Kingdom \nIndia Italy Russia Netherlands Singapore Japan and Australia In his \n25 years as a professional software architect hes had the opportunity to \nwork for Blue CrossBlue Shield Merck Boeing Red Hat and a handful of \nstartup companies\nChd is a contributing author to several Java books including \nProfessional Java ECommerce  Wrox Press Beginning Java Networking  \nWrox Press and XML and Web Services Unleashed  Sams Publishing \nChd has Java certifications from Oracle and IBM\u00a0He holds a BS in \ncomputer science from Carnegie Mellon University \nxxixAcknowledgments\nI would like to thank my family members and friends for their encouragement and support my mom \nPratima Devi my elder brothers Janki Sharan and Dr Sita Sharan my nephews Gaurav and Saurav my \nsister Ratna my friends Karthikeya Venkatesan Rahul Nagpal Ravi Datla Mahbub Choudhury and Richard \nCastillo and many more friends not mentioned here\nMy wife Ellen was always patient when I spent long hours at my computer desk working on this book I \nwant to thank her for all of her support in writing this book\nMy special thanks to my friend Preethi Vasudev for offering her valuable time for providing solutions \nto the exercises in this book She likes programming challengesparticularly Google Code Jam I bet she \nenjoyed solving the exercises in each chapter of this book\nMy sincere thanks are due to the wonderful team at Apress for their support during the publication of \nthis book Thanks to Mark Powers Editorial Operations Manager for providing excellent support Last but \nnot least my sincere thanks to Steve Anglin Lead Editor at Apress for taking the initiative for the publication \nof this book\nKishori SharanxxxiIntroduction\n How This Book Came About\nMy first encounter with the Java programming language was during a oneweek Java training session \nin 1997 I did not get a chance to use Java in a project until 1999 I read two Java books and took a Java 2 \nprogrammer certification examination I did very well on the test scoring 95 The three questions that \nI missed on the test made me realize that the books that I had read did not adequately cover details of all \nthe topics necessary about Java I made up my mind to write a book on the Java programming language \nSo I formulated a plan to cover most of the topics that a Java developer needs to use the Java programming \nlanguage effectively in a project as well as to get a certification I initially planned to cover all essential topics \nin Java in 700800 pages\nAs I progressed I realized that a book covering most of the Java topics in detail could not be written in \n700800 pages One chapter alone that covered data types operators and statements spanned 90 pages I \nwas then faced with the question Should I shorten the content of the book or include all the details that \nI think a Java developer needs I opted for including all the details in the book rather than shortening its \ncontent to keep the number of pages low It has never been my intent to make lots of money from this book \nI was never in a hurry to finish this book because that rush could have compromised the quality and the \ncoverage of its content In short I wrote this book to help the Java community understand and use the Java \nprogramming language effectively without having to read many books on the same subject I wrote this \nbook with the plan that it would be a comprehensive onestop reference for everyone who wants to learn \nand grasp the intricacies of the Java programming language\nOne of my high school teachers used to tell us that if one wanted to understand a building one \nmust first understand the bricks steel and mortar that make up the building The same logic applies to \nmost of the things that we want to understand in our lives It certainly applies to an understanding of the \nJava programming language If you want to master the Java programming language you must start by \nunderstanding its basic building blocks I have used this approach throughout this book endeavoring to \nbuild each topic by describing the basics first In the book you will rarely find a topic described without \nfirst learning its background Wherever possible I have tried to correlate the programming practices with \nactivities in our daily life Most of the books about the Java programming language available on the market \neither do not include any pictures at all or have only a few I believe in the adage  A picture is worth a \nthousand words  To a reader a picture makes a topic easier to understand and remember I have included \nplenty of illustrations in the book to aid readers in understanding and visualizing the contents Developers \nwho have little or no programming experience have difficulty in putting things together to make it a \ncomplete program Keeping them in mind we have included over 290 complete Java programs that are ready \nto be compiled and run in the book\nI spent countless hours doing research for writing this book My main source of research was the Java \nLanguage Specification  whitepapers and articles on Java topics and Java Specification Requests JSRs \nI also spent quite a bit of time reading the Java source code to learn more about some of the Java topics \nSometimes it took a few months researching a topic before I could write the first sentence on the topic \nFinally it was always fun to play with Java programs sometimes for hours to add them to the book InTrodu CTIon\nxxxii Introduction to\u00a0the\u00a0Third Edition\nWe are pleased to present this edition of the Beginning Java 17 Fundamentals  book It is the first book in the \nthreevolume Beginning Java  series It was not possible to include all JDK features in this volume We have \nincluded versionspecific changes at appropriate places in three volumes If you are interested in learning \nonly JDK 9specific topics we suggest you read Java 9 Revealed  To learn more about Java 17 we suggest you \nread More Java 17  There are several changes in this edition and they are as follows\nWe have added a separate chapter Chapter 2 on setting up your environment such as downloading \nand installing JDK 17 verifying the JDK version etc\nIn this edition we have added some introductions to lambda expressions method references and \nStreams throughout the book where they are referenced Weve also included many of the more recently \nintroduced features of Java such as local variable type inference switch expressions sealed classes multiline \ntext blocks and Records\nChapter 3 provides a comprehensive introduction to the module system We provide a stepbystep \nprocess on how to write compile package and run your first Java program using a command prompt and \nthe NetBeans integrated development environment NetBeans IDE Chapter 10 contains an indepth \ncoverage of the module system\nJDK 17 ships with a very valuable tool called the JShell short for Java Shell tool It lets you explore \nthe Java programming language interactively by entering chunks of code rather than writing a fullfledged \nprogram We strongly encourage you to use this tool to play with snippets of Java code when you are writing \na Java program We introduced this tool in Chapter 2 and we have covered it extensively in Chapter 23 The \nreason we did not cover it in one of the first few chapters of the book is because as a beginner you need to \nknow the basics of Java programming first\nThe first edition contained a chapter entitled Classes and Objects which was over 120 pages long \nThis edition has divided this chapter into three chapters titled Classes  Methods  and Constructors \nChapters 79\nWe have updated Appendix B to cover Javadoc features of JDK 17 In the previous edition Appendix B \nincluded frames but they have since been removed from Javadocs\nWe received several emails from the readers about the fact that the first books in this series did not \ninclude questions and exercises which are needed mainly for students and beginners Students use this \nbook in their Java classes as a Java textbook and many beginners use it to learn Java Based on this popular \ndemand over 60 hours was spent preparing questions and exercises at the end of each chapter of this book\nApart from these changes we have updated all chapters that were part of the previous edition We have \nedited the contents to make them flow better changed or added new examples and updated the contents to \ninclude features specific to JDK 917\nIt is our sincere hope that this edition of the book will help you learn Java better\n Structure of\u00a0the\u00a0Book\nThis book contains 23 chapters and two appendixes The chapters contain fundamental topics of Java such \nas syntax data types operators classes objects etc The chapters are arranged in an order that aids learning \nthe Java programming language faster The first chapter Programming Concepts explains basic concepts \nrelated to programming in general without going into too many technical details it introduces Java and its \nfeatures\nThe third chapter Writing Java Programs introduces the first program using Java this chapter is \nespecially written for those learning Java for the first time Subsequent chapters introduce Java topics in an \nincreasing order of complexity The new features of Java are included wherever they fit in the chapter\nAfter finishing this book to take your Java knowledge to the next level two companion books are \navailable by the authors More Java 17  and Modern Programming Made Easy  InTrodu CTIon\nxxxiiiAt the end of each chapter you can find questions and exercises that challenge you with the knowledge \nyou gain in the chapter Questions and exercises are geared toward students taking Java classes and \nbeginners Answers to all questions and solutions to all exercises are available at wwwapresscom \n Audience\nThis book is designed to be useful to anyone who wants to learn the Java programming language If you are \na beginner with little or no programming background you need to read the first chapter to the last in order \nThe book contains topics of various degrees of complexity As a beginner if you find yourself overwhelmed \nwhile reading a section in a chapter you can skip to the next section or the next chapter and revisit it later \nwhen you gain more experience\nIf you are a Java developer with an intermediate or advanced level of experience you can jump to a \nchapter or to a section in a chapter directly If a section uses an unfamiliar topic you need to visit that topic \nbefore continuing the current one\nIf you are reading this book to get a certification in the Java programming language you need to read \nalmost all of the chapters paying attention to all the detailed descriptions and rules Most of the certification \nprograms test your fundamental knowledge of the language not the advanced knowledge You need to \nread only those topics that are part of your certification test Compiling and running over 290 complete Java \nprograms will help you prepare for your certification\nIf you are a student who is attending a class on the Java programming language you need to read the \nfirst ten chapters of this book thoroughly These chapters cover the basics of the Java programming language \nin detail You cannot do well in a Java class unless you first master the basics After covering the basics you \nneed to read only those chapters that are covered in your class syllabus I am sure you as a Java student do \nnot need to read the entire book page by page\n How to\u00a0Use This Book\nThis book is the beginning not the end for you to gain the knowledge of the Java programming language \nIf you are reading this book it means you are heading in the right direction to learn the Java programming \nlanguage that will enable you to excel in your academic and professional career However there is always a \nhigher goal for you to achieve and you must constantly work harder to achieve it The following quotations \nfrom some great thinkers may help you understand the importance of working hard and constantly looking \nfor knowledge with both your eyes and mind open\nThe learning and knowledge that we have is at the most but little compared with that of \nwhich we are ignorant\nPlato\nTrue knowledge exists in knowing that you know nothing And in knowing that you know \nnothing that makes you the smartest of all\nSocrates\nReaders are advised to use the API documentation for the Java programming language as much as \npossible while using this book The Java API documentation is the place where you will find a complete \nlist of documentation for everything available in the Java class library You can download or view the Java \nAPI documentation from the official website of Oracle Corporation at wwworaclecom  While you read this  InTrodu CTIon\nxxxivbook you need to practice writing Java programs yourself You can also practice by tweaking the programs \nprovided in the book It does not help much in your learning process if you just read this book and do not \npractice by writing your own programs Remember that practice makes perfect  which is also true in \nlearning how to program in Java\n Source Code\nSource code for this book can be accessed by clicking the Download Source Code  button located at  \nwwwapresscomusbook9781484273067 1\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730741CHAPTER 1\nProgramming Concepts\nIn this chapter you will learn\n\t The general concept of programming\n\t Different components of programming\n\t Major programming paradigms\n\t What the objectoriented OO paradigm is and how it is used in Java\n What Is Programming\nThe term programming is used in many contexts We discuss its meaning in the context of humanto\ncomputer interaction In the simplest terms programming is the way of writing a sequence of instructions \nto tell a computer to perform a specific task The sequence of instructions for a computer is known as a \nprogram  A set of welldefined notations is used to write a program The set of notations used to write a \nprogram is called a programming language  The person who writes a program is called a programmer  A \nprogrammer uses a programming language to write a program\nHow does a person tell a computer to perform a task Can a person tell a computer to perform any task \nor does a computer have a predefined set of tasks that it can perform Before we look at humantocomputer \ncommunication lets look at humantohuman communication How does a human communicate with \nanother human You would say that humantohuman communication is accomplished using a spoken \nlanguage for example English German Hindi etc However a spoken language is not the only means of \ncommunication between humans We also communicate using written languages or using gestures without \nuttering any words Some people can even communicate sitting miles away from each other without using \nany words or gestures they can communicate at the thought level\nTo have successful communication it is not enough just to use a medium of communication like a \nspoken or written language The main requirement for a successful communication between two parties is \nthe ability of both parties to understand what is communicated from the other party For example suppose \nthere are two people One person knows how to speak English and the other one knows how to speak \nGerman Can they communicate with each other The answer is no because they cannot understand each \nothers language What happens if we add an EnglishGerman translator between them We would agree \nthat they would be able to communicate with the help of a translator even though they do not understand \neach other directly\nComputers understand instructions only in binary format which is a sequence of 0s and 1s The \nsequence of 0s and 1s which all computers understand is called machine language or machine code \nA computer has a fixed set of basic instructions that it understands Each computer has its own set of \ninstructions For example one computer may use 0010 as an instruction to add two numbers whereas Chapter 1  programming Con Cepts\n2another computer may use 0101 for the same purpose Therefore programs written in machine language \nare machinedependent Sometimes machine code is referred to as native code as it is native to the machine \nfor which it is written Programs written in machine language are very difficult if not impossible to write \nread understand and modify Suppose you want to write a program that adds two numbers 15 and 12 \nThe program to add two numbers in machine language will look similar to the one shown here You do \nnot need to understand the sample code written in this section It is only for the purpose of discussion and \nillustration\n0010010010   10010100000100110\n0001000100   01010010001001010\nThese instructions are to add two numbers How difficult will it be to write a program in machine \nlanguage to perform a complex task Based on this code you may now realize that it is very difficult to \nwrite read and understand a program written in machine language But arent computers supposed to \nmake our jobs easier not more difficult We needed to represent the instructions for computers in some \nnotations that were easier to write read and understand so computer scientists came up with another \nlanguage called an assembly language An assembly language provides different notations to write \ninstructions It is a little easier to write read and understand than its predecessor machine language An \nassembly language uses mnemonics to represent instructions as opposed to the binary 0s and 1s used \nin machine language A program written in an assembly language to add two numbers looks similar to the \nfollowing\nli t1 15\nadd t0 t1 12\nIf you compare the two programs written in the two different languages to perform the same task you \ncan see that an assembly language is easier to write read and understand than machine code There is one\ntoone correspondence between an instruction in machine language and that in an assembly language for \na given computer architecture Recall that a computer understands instructions only in machine language \nThe instructions that are written in an assembly language must be translated into machine language before \nthe computer can execute them A program that translates the instructions written in an assembly language \ninto machine language is called an assembler  Figure\u00a0 11 shows the relationship between assembly code an \nassembler and machine code\nMachine and assembly languages are also known as lowlevel languages because a programmer must \nunderstand the lowlevel details of the computer to write a program using these languages For example \nif you were writing programs in these languages you would need to know what memory location you are \nwriting to or reading from which register to use to store a specific value etc Soon programmers realized a \nneed for a higherlevel programming language that could hide the lowlevel details of computers from them \nThe need gave rise to the development of highlevel programming languages like COBOL Pascal FORTRAN \nC C Java C etc The highlevel programming languages use Englishlike words mathematical notation Figure 11  The r elationship between assembly code an assembler and machine codeChapter 1  programming Con Cepts\n3and punctuation to write programs A program written in a highlevel programming language is also called \nsource code  They are closer to the written languages that humans are familiar with The instructions to add \ntwo numbers written in a highlevel programming language for example Java look similar to the following\nint x  15  12\nYou may notice that the programs written in a highlevel language are easier and more intuitive to \nwrite read understand and modify than the programs written in machine and assembly languages You \nmight have realized that computers do not understand programs written in highlevel languages as they \nunderstand only sequences of 0s and 1s So theres a need for a way to translate a program written in a \nhighlevel language to machine language The translation is accomplished by a compiler an interpreter or a \ncombination of both A compiler is a program that translates programs written in a highlevel programming \nlanguage into machine language Compiling a program is an overloaded phrase Typically it means \ntranslating a program written in a highlevel language into machine language Sometimes it is used to \nmean translating a program written in a highlevel programming language into a lowerlevel programming \nlanguage which is not necessarily machine language The code that is generated by a compiler is called \ncompiled code  The compiled program is executed by the computer\nAnother way to execute a program written in a highlevel programming language is to use an \ninterpreter An interpreter does not translate the whole program into machine language at once Rather it \nreads one instruction written in a highlevel programming language at a time translates it into machine \nlanguage and executes it You can view an interpreter as a simulator Sometimes a combination of a \ncompiler and an interpreter may be used to compile and run a program written in a highlevel language \nFor example a program written in Java is compiled into an intermediate language called bytecode An \ninterpreter specifically called a Java virtual machine JVM for the Java platform is used to interpret the \nbytecode and execute it An interpreted program runs slower than a compiled program Most of the JVMs \ntoday use justintime JIT compilers which compile the entire Java program into machine language as \nneeded Sometimes another kind of compiler which is called an aheadoftime AOT compiler is used to \ncompile a program in an intermediate language eg Java bytecode to machine language Figure\u00a0 12 shows \nthe relationship between the source code a compiler and the machine code\nProgramming languages are also categorized as first second third and fourthgeneration languages \nThe higher the generation of the language the closer it gets to the plain spoken human language to write \nprograms in that language The machine language is also known as a firstgeneration programming \nlanguage or 1GL\u00a0The assembly language is also known as a secondgeneration programming language \nor 2GL\u00a0Highlevel procedural programming languages such as C C Java and C in which you have \nto write the algorithm to solve the problem using the language syntax are also known as thirdgeneration \nprogramming languages or 3GLs Highlevel nonprocedural programming languages in which you do not \nneed to write the algorithm to solve the problem are known as fourthgeneration programming languages \nor 4GLs Structured Query Language SQL is the most widely used 4GL which is used to communicate with \ndatabasesFigure 12  The r elationship between source code a compiler and machine codeChapter 1  programming Con Cepts\n4 Components of\u00a0a\u00a0Programming Language\nA programming language is a system of notations used to write instructions for computers It can be \ndescribed using three components\n\t Syntax\n\t Semantics\n\t Pragmatics\nThe syntax part deals with forming valid programming constructs using available notations The \nsemantics part deals with the meaning of the programming constructs The pragmatics part deals with the \nuse of the programming language in practice\nLike a written language eg English a programming language has vocabulary and grammar The \nvocabulary of a programming language consists of a set of words symbols and punctuation marks The \ngrammar of a programming language defines rules on how to use the vocabulary of the language to form \nvalid programming constructs You can think of a valid programming construct in a programming language \nlike a sentence in a written language which is formed using the vocabulary and grammar of the language \nSimilarly a programming construct is formed using the vocabulary and the grammar of the programming \nlanguage The vocabulary and the rules to use that vocabulary to form valid programming constructs are \nknown as the syntax  of the programming language\nIn a written language you may form a grammatically correct sentence which may not have any valid \nmeaning For example The stone is laughing is a grammatically correct sentence However it does not \nmake any sense In a written language this kind of ambiguity is allowed A programming language is meant \nto communicate instructions to computers which have no room for any ambiguity We cannot communicate \nwith computers using ambiguous instructions There is another component of a programming language \nwhich is called semantics  which explains the meaning of the syntactically valid programming constructs \nThe semantics of a programming language answers the question What does this program do when it is run \non a computer Note that a syntactically valid programming construct may not also be semantically valid A \nprogram must be syntactically and semantically correct before it can be executed by a computer\nThe pragmatics of a programming language describes its uses and its effects on the users A program \nwritten in a programming language may be syntactically and semantically correct However it may not \nbe easily understood by other programmers This aspect is related to the pragmatics of the programming \nlanguage The pragmatics is concerned with the practical aspect of a programming language It answers \nquestions about a programming language like its ease of implementation suitability for a particular \napplication efficiency portability support for programming methodologies etc\n Programming Paradigms\nThe online MerriamWebsters Learners Dictionary defines the word paradigm as follows\nA paradigm is a theory or a group of ideas about how something should be done made \nor thought about\nIn the beginning it is a little hard to understand the word paradigm in a programming context \nProgramming is about providing a solution to a realworld problem using computational models supported \nby the programming language The solution is called a program Before we provide a solution to a problem \nin the form of a program we always have a mental view of the problem and its solution Before I discuss \nhow to solve a realworld problem using a computational model lets take an example of a realworld social \nproblem one that has nothing to do with computersChapter 1  programming Con Cepts\n5Suppose there is a place on Earth that has a shortage of food People in that place do not have enough \nfood to eat The problem is shortage of food  Lets ask three people to provide a solution to this problem \nThe three people are a politician a philanthropist and a monk A politician will have a political view about \nthe problem and its solution They may think about it as an opportunity to serve their countrymen by \nenacting some laws to provide food to the hungry people A philanthropist will offer some moneyfood to \nhelp those hungry people because they feel compassion for all humans and so for those hungry people A \nmonk will try to solve this problem using their spiritual views They may preach to them to work and make a \nliving for themselves they may appeal to rich people to donate food to the hungry or they may teach them \nyoga to conquer their hunger Did you see how three people have different views about the same reality \nwhich is shortage of food The ways they look at reality are their paradigms You can think of a paradigm as \na mindset with which a reality is viewed in a particular context It is usual to have multiple paradigms which \nlet one view the same reality differently For example a person who is a philanthropist and politician will \nhave their ability to view the shortage of food problem and its solution differently one with their political \nmindset and one with their philanthropist mindset Three people were given the same problem All of them \nprovided a solution to the problem However their perceptions about the problem and its solution were not \nthe same We can define the term paradigm as a set of concepts and ideas that constitutes a way of viewing \na reality\nWhy do we need to bother about a paradigm anyway Does it matter if a person used their political \nphilanthropical or spiritual paradigm to arrive at the solution Eventually we get a solution to our problem \nDont we\nIt is not enough just to have a solution to a problem The solution must be practical and effective Since \nthe solution to a problem is always related to the way the problem and the solution are thought about the \nparadigm becomes paramount You can see that the solution provided by the monk may kill the hungry \npeople before they can get any help The philanthropists solution may be a good shortterm solution The \npoliticians solution seems to be a longterm solution and the best one It is always important to use the right \nparadigm to solve a problem to arrive at a practical and the most effective solution Note that one paradigm \ncannot be the right paradigm to solve every kind of problem For example if a person is seeking eternal \nhappiness they need to consult a monk not a politician or a philanthropist\nHere is a definition of the term programming paradigm by Robert W\u00a0Floyd who was a prominent \ncomputer scientist He gave this definition in his 1978 ACM Turing Award lecture titled The Paradigms of \nProgramming\nA programming paradigm is a way of conceptualizing what it means to perform \ncomputation and how tasks that are to be carried out on a computer should be structured \nand organized\nYou can observe that the word paradigm in a programming context has a similar meaning to that used \nin the context of daily life Programming is used to solve a realworld problem using computational models \nprovided by a computer The programming paradigm is the way you think and conceptualize about the \nrealworld problem and its solution in the underlying computational models The programming paradigm \ncomes into the picture well before you start writing a program using a programming language It is in the \nanalysis phase when you use a particular paradigm to analyze a problem and its solution in a particular way \nA programming language provides a means to implement a particular programming paradigm suitably A \nprogramming language may provide features that make it suitable for programming using one programming \nparadigm and not the otherChapter 1  programming Con Cepts\n6A program has two componentsdata and algorithm Data is used to represent pieces of information \nAn algorithm is a set of steps that operates on data to arrive at a solution to a problem Different \nprogramming paradigms involve viewing the solution to a problem by combining data and algorithms \nin different ways Many paradigms are used in programming The following are some commonly used \nprogramming paradigms\n\t Imperative paradigm\n\t Procedural paradigm\n\t Declarative paradigm\n\t Functional paradigm\n\t Logic paradigm\n\t Objectoriented paradigm\n Imperative Paradigm\nThe imperative paradigm is also known as an algorithmic paradigm In the imperative paradigm a \nprogram consists of data and an algorithm sequence of commands that manipulates the data The data \nat a particular point in time defines the state of the program The state of the program changes as the \ncommands are executed in a specific sequence The data is stored in memory Imperative programming \nlanguages provide variables to refer to the memory locations an assignment operation to change the value \nof a variable and other constructs to control the flow of a program In imperative programming you need to \nspecify the steps to solve a problem\nSuppose you have an integer say 15 and you want to add 10 to it Your approach would be to add 1 to \n15 ten times and you get the result 25 You can write a program using an imperative language to add 10 \nto 15 as follows Note that you do not need to understand the syntax of the following code Just try to get a \nfeel for it\nint num  15                num holds 15 at this point\nint counter  0             counter holds 0 at this point\nwhile counter  10 \n    num  num  1           Modifying data in num\n    counter  counter  1  Modifying data in counter\n\n num holds 25 at this point\nThe first two lines are variable declarations that represent the data part of the program The while  loop \nrepresents the algorithm part of the program that operates on the data The code inside the while  loop is \nexecuted ten times The loop increments the data stored in the num variable by 1\u00a0in each iteration When the \nloop ends it has incremented the value of num by 10 Note that data in imperative programming is transient \nand the algorithm is permanent FORTRAN COBOL and C are a few examples of programming languages \nthat support the imperative paradigmChapter 1  programming Con Cepts\n7 Procedural Paradigm\nThe procedural paradigm is similar to the imperative paradigm with one difference it combines multiple \ncommands in a unit called a procedure  A procedure is executed as a unit Executing the commands \ncontained in a procedure is known as calling or invoking the procedure A program in a procedural language \nconsists of data and a sequence of procedure calls that manipulate the data The following piece of code is \ntypical for a procedure named addTen \nvoid addTenint num \n    int counter  0\n    while counter  10 \n        num  num  1            Modifying data in num\n        counter  counter  1    Modifying data in counter\n    \n     num has been incremented by 10\n\nThe addTen  procedure uses a placeholder also known as parameter num which is supplied at the time of \nits execution The code ignores the actual value of num It simply adds 10 to the current value of num Lets use the \nfollowing piece of code to add 10 to 15 Note that the code for the addTen  procedure and the following code are \nnot written using any specific programming language They are provided here only for the purpose of illustration\nint x  15  x holds 15 at this point\naddTenx    Call addTen procedure that will increment x by 10\n             x holds 25 at this point\nYou may observe that the code in the imperative paradigm and that in the procedural paradigm are \nsimilar in structure Using procedures results in modular code and increases reusability of algorithms \nSome people ignore this difference and treat the two paradigms imperative and procedural as the same \nNote that even if they are different the procedural paradigm always involves the imperative paradigm In \nthe procedural paradigm the unit of programming is not a sequence of commands Rather you abstract a \nsequence of commands into a procedure and your program consists of a sequence of procedures instead A \nprocedure has side effects It modifies the data part of the program as it executes its logic C C Java and \nCOBOL are a few examples of programming languages that support the procedural paradigm\n Declarative Paradigm\nIn the declarative paradigm a program consists of the description of a problem and the computer finds \nthe solution The program does not specify how to arrive at the solution to the problem It is the computers \njob to arrive at a solution when a problem is described to it Contrast the declarative paradigm with the \nimperative paradigm In the imperative paradigm we are concerned about the how part of the problem In \nthe declarative paradigm we are concerned about the what part of the problem We are concerned about \nwhat the problem is rather than how to solve it The functional paradigm and the logic paradigm which are \ndescribed next are subtypes of the declarative paradigm\nWriting a database query using Structured Query Language SQL falls under programming based \non the declarative paradigm where you specify what data you want and the database engine figures \nout how to retrieve the data for you Unlike the imperative paradigm the data is permanent and the \nalgorithm is transient in the declarative paradigm In the imperative paradigm the data is modified \nas the algorithm is executed In the declarative paradigm data is supplied to the algorithm as input \nand the input data remains unchanged as the algorithm is executed The algorithm produces new data \nrather than modifying the input data In other words in the declarative paradigm execution of an \nalgorithm does not produce side effectsChapter 1  programming Con Cepts\n8 Functional Paradigm\nThe functional paradigm is based on the concept of mathematical functions You can think of a function \nas an algorithm that computes a value from some given inputs Unlike a procedure in procedural \nprogramming a function does not have a side effect In functional programming values are immutable\nA new value is derived by applying a function to the input value The input value does not change \nFunctional programming languages do not use variables and assignments which are used for modifying \ndata In imperative programming a repeated task is performed using a loop construct for example a \nwhile  loop In functional programming a repeated task is performed using recursion which is a way in \nwhich a function is defined in terms of itself In other words a recursive function does some work and \nthen calls itself\nA function always produces the same output when it is applied to the same input A function say add \nthat can be applied to an integer x to add an integer n to it may be defined as follows\nint addx n \n    if n  0 \n        return x\n     else \n        return 1  addx n1  Apply the add function recursively\n    \n\nNote that the add function does not use any variable and does not modify any data It uses recursion \nYou can call the add function to add 10 to 15 as follows\nadd15 10  Results in 25\nHaskell Erlang and Scala are a few examples of programming languages that support the functional \nparadigm\n Ti p Ja va se 8 added a new language construct called lambda expressions  which can be used to write \nfunctional programmingstyle code in Java\n Logic Paradigm\nUnlike the imperative paradigm the logic paradigm focuses on the what part of the problem rather than \nhow to solve it All you need to specify is what needs to be solved The program will figure out the algorithm \nto solve it The algorithm is of less importance to the programmer The primary task of the programmer is \nto describe the problem as closely as possible In the logic paradigm a program consists of a set of axioms \nand a goal statement The set of axioms is the collection of facts and inference rules that make up a theory \nThe goal statement is a theorem The program uses deductions to prove the theorem within the theory \nLogic programming uses a mathematical concept called a relation from set theory A relation in set theory \nis defined as a subset of the Cartesian product of two or more sets Suppose there are two sets Persons  and \nNationality  defined as follows\nPerson  John Li Ravi\nNationality  American Chinese IndianChapter 1  programming Con Cepts\n9The Cartesian product of the two sets denoted as Person x Nationality  would be another set as shown\nPerson x Nationality  John American John Chinese John Indian\n                        Li American Li Chinese Li Indian\n                        Ravi American Ravi Chinese Ravi Indian\nEvery subset of Person x Nationality  is another set that defines a mathematical relation Each \nelement of a relation is called a tuple  Let PersonNationality  be a relation defined as follows\nPersonNationality  John American Li Chinese Ravi Indian\nIn logic programming you can use the PersonNationality  relation as the collection of facts that is \nknown to be true You can state the goal statement or the problem like so\nPersonNationality Chinese\nwhich means give me all the names of people who are Chinese  The program will search through the \nPersonNationality  relation and extract the matching tuples which will be the answer or the solution to \nyour problem In this case the answer will be Li\nProlog is an example of a programming language that supports the logic paradigm\n ObjectOriented Paradigm\nIn the objectoriented OO paradigm a program consists of interacting objects An object encapsulates \ndata and algorithms Data defines the state of an object Algorithms define the behavior of an object An \nobject communicates with other objects by sending messages to them When an object receives a message \nit responds by executing one of its algorithms which may modify its state Contrast the objectoriented \nparadigm with the imperative and functional paradigms In the imperative and functional paradigms \ndata and algorithms are separated whereas in the objectoriented paradigm data and algorithms are not \nseparate they are combined in one entity which is called an object\nClasses are the basic units of programming in the objectoriented paradigm Similar objects are \ngrouped into one definition called a class A classs definition is used to create an object An object is \nalso known as an instance of the class A class consists of instance variables and methods The values of \ninstance variables of an object define the state of the object Different objects of a class maintain their states \nseparately That is each object of a class has its own copy of the instance variables The state of an object \nis kept private to that object That is the state of an object cannot be accessed or modified directly from \noutside the object Methods in a class define the behavior of its objects A method is like a procedure or \nsubroutine in the procedural paradigm Methods can accessmodify the state of the object A message is \nsent to an object by invoking one of its methods\nSuppose you want to represent realworld people in your program You will create a Person  class and \nits instances will represent people in your program The Person  class can be defined as shown in Listing 11 \nThis example uses the syntax of the Java programming language You do not need to understand the syntax \nused in the programs that you are writing at this point I discuss the syntax to define classes and create \nobjects in subsequent chaptersChapter 1  programming Con Cepts\n10Listing 11  The Definition of a Person Class Whose Instances Represent RealWorld Persons in a Program\npackage comjdojoconcepts\npublic class Person \n    private String name\n    private String gender\n    public PersonString initialName String initialGender \n        name  initialName\n        gender  initialGender\n    \n    public String getName \n        return name\n    \n    public void setNameString newName \n        name  newName\n    \n    public String getGender \n        return gender\n    \n\nThe Person  class includes three things\n\t Two instance variables  name  and gender\n\t One constructor  PersonString initialName String initialGender\n\t Three methods  getName  setNameString newName  and getGender\nInstance variables store internal data for an object The value of each instance variable represents the \nvalue of a corresponding property of the object Each instance of the Person  class will have a copy of name  \nand gender  data The values of all properties of an object at a point in time stored in instance variables \ncollectively define the state of the object at that time In the real world a person possesses many properties \nfor example name gender height weight hair color addresses phone numbers etc However when you \nmodel the realworld person as a class you include only those properties of the person that are relevant \nto the system being modeled For this current demonstration lets model only two properties name  and \ngender of a realworld person as two instance variables in the Person  class\nA class contains the definition or blueprint of objects There needs to be a way to construct to create \nor to instantiate objects of a class An object also needs to have the initial values for its properties that will \ndetermine its initial state at the time of its creation A constructor of a class is used to create an object of that \nclass A class can have many constructors to facilitate the creation of its objects with different initial states \nThe Person  class provides one constructor which lets you create its object by specifying the initial values for \nname  and gender  The following snippet of code creates two objects of the Person  class\nPerson john  new PersonJohn Jacobs Male\nPerson donna  new PersonDonna Duncan Female\nThe first object is called john  with John Jacobs  and Male  as the initial values for its name  and \ngender  properties respectively The second object is called donna  with Donna Duncan  and Female  as the \ninitial values for its name  and gender  properties respectively\nMethods of a class represent behaviors of its objects For example in the real world a person has a \nname and their ability to respond when they are asked for their name is one of their behaviors Objects of \nthe Person  class have abilities to respond to three different messages getName  setName  and getGender   Chapter 1  programming Con Cepts\n11The ability of an object to respond to a message is implemented using methods You can send a message say \ngetName  to a Person  object and it will respond by returning its name It is the same as asking What is your \nname and having the person respond by telling you their name\nString johnName  johngetName     Send getName message to john\nString donnaName  donnagetName  Send getName message to donna\nThe setName  message to the Person  object asks to change the current name to a new name The \nfollowing snippet of code changes the name of the donna  object from Donna Duncan  to Donna Jacobs \ndonnasetNameDonna Jacobs\nIf you send the getName  message to the donna  object at this point it will return Donna Jacobs  not \nDonna Duncan\nYou may notice that your Person  objects do not have the ability to respond to a message such as \nsetGender  The gender of a Person object is set when the object is created and it cannot be changed \nafterward However you can query the gender of a Person  object by sending the getGender  message to it \nWhat messages an object may or may not respond to is decided at design time based on the need of the \nsystem being modeled In the case of the Person  objects we decided that they would not have the ability to \nrespond to the setGender  message by not including a setGenderString newGender  method in the Person  \nclass Figure\u00a0 13 shows the state and interface of the Person  object called john \nThe objectoriented paradigm is a very powerful paradigm for modeling realworld phenomena in \na computational model We are used to working with objects all around us in our daily life The object\noriented paradigm is natural and intuitive as it lets you think in terms of objects However it does not give \nyou the ability to think in terms of objects correctly Sometimes the solution to a problem does not fall into \nthe domain of the objectoriented paradigm In such cases you need to use the paradigm that suits the \nproblem domain the most The objectoriented paradigm has a learning curve It is much more than just \ncreating and using objects in your program Abstraction encapsulation polymorphism and inheritance are \nsome of the important features of the objectoriented paradigm You must understand and be able to use \nthese features which this book covers to take full advantage of the objectoriented paradigm In subsequent \nchapters we will discuss these features and how to implement them in programs in detail\nTo name a few C Java and C pronounced C sharp are programming languages that support the \nobjectoriented paradigm Note that a programming language itself is not objectoriented It is the paradigm \nthat is objectoriented A programming language may or may not have features to support the object\noriented paradigmFigure 13  The s tate and the interface for a Person objectChapter 1  programming Con Cepts\n12 What Is Java\nJava is a generalpurpose programming language It has features to support programming based on \nthe objectoriented procedural and functional paradigms You often read a statement like Java is an \nobjectoriented programming language  What is meant is that the Java language has features that support \nthe objectoriented paradigm A programming language is not objectoriented It is the paradigm that \nis objectoriented and a programming language may have features that make it easy to implement the \nobjectoriented paradigm Sometimes programmers have misconceptions that all programs written \nin Java are always objectoriented Java also has features that support the procedural and functional \nparadigms You can write a program in Java that is a 100 procedural program without an iota of object\norientedness in it\nThe initial version of the Java platform was released by Sun Microsystems part of Oracle Corporation \nsince January 2010 in 1995 Development of the Java programming language was started in 1991 Initially \nthe language was called Oak and it was meant to be used in settop boxes for televisions\nSoon after its release Java became a very popular programming language One of the most important \nfeatures for its popularity was its write once run anywhere WORA feature This feature lets you write a \nJava program once and run it on any platform For example you can write and compile a Java program on \nUNIX and run it on a Microsoft Windows Macintosh or UNIX machine without any modifications to the \nsource code WORA is achieved by compiling a Java program into an intermediate language called bytecode \nThe format of bytecode is platformindependent A virtual machine called the Java virtual machine JVM is \nused to run the bytecode on each platform Note that a JVM is a program implemented in software It is not a \nphysical machine and this is the reason it is called a virtual machine The job of a JVM is to transform the \nbytecode into executable code according to the platform it is running on This feature makes Java programs \nplatformindependent That is the same Java program can be run on multiple platforms without any \nmodifications\nThe following are a few characteristics behind Javas popularity and acceptance in the software industry\n\t Simplicity\n\t Wide variety of usage environments\n\t Robustness\nSimplicity may be a subjective word in this context C was the popular and powerful programming \nlanguage widely used in the software industry at the time Java was released If you were a C \nprogrammer Java would provide simplicity for you in its learning and use over the C experience you \nhad Java retained most of the syntax of CC which was helpful for CC programmers trying to learn \nthis new language Even better it excluded some of the most confusing and hardtousecorrectly features \nthough powerful of C For example Java does not have pointers and multiple inheritance which are \npresent in C\nIf you are learning Java as your first programming language whether it is a simple language to learn may \nnot be true for you This is the reason why we say that the simplicity of Java or any programming language \nis very subjective The Java language and its libraries a set of packages containing Java classes have been \ngrowing ever since its first release You will need to put in some serious effort in order to become a serious \nJava developer\nJava can be used to develop programs that can be used in different environments You can write \nprograms in Java that can be used in a clientserver environment The most popular use of Java programs in \nits early days was to develop applets which were deprecated in Java SE 9 An applet is a Java program that is \nembedded in a web page which uses the HyperText Markup Language HTML and is displayed in a web \nbrowser such as Firefox Google Chrome etc An applets code is stored on a web server downloaded to the \nclient machine when the HTML page containing the reference to the applet is loaded by the browser and \nrun on the client machineChapter 1  programming Con Cepts\n13Java includes features that make it easy to develop distributed applications A distributed application \nconsists of programs running on different machines connected through a network Java has features that \nmake it easy to develop concurrent applications A concurrent application has multiple interacting threads \nof execution running in parallel a thread  is like an independent process within a program with its own \nvalues and processing independent of other threads\nRobustness of a program refers to its ability to handle unexpected situations reasonably The \nunexpected situation in a program is also known as an error Java provides robustness by providing many \nfeatures for error checking at different points during a programs lifetime The following are three different \ntypes of errors that may occur in a Java program\n\t Compiletime errors\n\t Runtime errors\n\t Logic errors\nCompiletime errors are also known as syntax errors They are caused by incorrect use of the Java \nlanguage syntax They are detected by the Java compiler A program with compiletime errors does not compile \ninto bytecode until the errors are corrected Missing a semicolon at the end of a statement assigning a decimal \nvalue such as 1023 to a variable of integer type etc are examples of compiletime errors\nRuntime errors occur when a Java program is run This kind of error is not detected by the compiler \nbecause a compiler does not have all of the runtime information available to it Java is a strongly typed \nlanguage and it has a robust type checking at compile time as well as runtime Java provides a neat \nexception handling mechanism to handle runtime errors When a runtime error occurs in a Java program \nthe JVM throws an exception which the program may catch and deal with For example dividing an integer \nby zero eg 170  generates a runtime error Java avoids critical runtime errors such as memory overrun \nand memory leaks by providing a builtin mechanism for automatic memory allocation and deallocation \nThe feature of automatic memory deallocation is known as garbage collection\nLogic errors are the most critical errors in a program and they are hard to find They are introduced \nby the programmer by implementing the functional requirements incorrectly This kind of error cannot \nbe detected by a Java compiler or at Java runtime They are detected by application testers or users \nwhen they compare the actual behavior of a program with its expected behavior Sometimes a few logic \nerrors can sneak into the production environment and they go unnoticed even after the application is \ndecommissioned\nAn error in a program is known as a bug  The process of finding and fixing bugs in a program is \nknown as debugging  All modern integrated development environments IDEs such as NetBeans Eclipse \nJDeveloper and IntelliJ IDEA provide programmers with a tool called a debugger  which lets them run the \nprogram stepbystep and inspect the programs state at every step to detect the bug Debugging is a reality \nof a programmers daily activities If you want to be a good programmer you must learn and be good at using \nthe debuggers that come with the development tools that you use to develop your Java programs\n The ObjectOriented Paradigm and\u00a0Java\nThe objectoriented paradigm supports four major principles abstraction  encapsulation  inheritance  \nand polymorphism  They are also known as four pillars of the objectoriented paradigm Abstraction is the \nprocess of exposing the essential details of an entity while ignoring the irrelevant details to reduce the \ncomplexity for the users Encapsulation is the process of bundling data and operations on the data together \nin an entity Inheritance is used to derive a new type from an existing type thereby establishing a parent\nchild relationship Polymorphism lets an entity take on different meanings in different contexts The four \nprinciples are discussed in detail in the sections to followChapter 1  programming Con Cepts\n14 Abstraction\nA program provides a solution to a realworld problem The size of the program may range from a few lines \nto a few million lines It may be written as a monolithic structure running from the first line to the millionth \nline in one place A monolithic program becomes harder to write understand and maintain if its size is \nover 2550 lines For easier maintenance a big monolithic program must be decomposed into smaller \nsubprograms The subprograms are then assembled together to solve the original problem Care must be \ntaken when a program is being decomposed All subprograms must be simple and small enough to be \nunderstood by themselves and when assembled they must solve the original problem Lets consider the \nfollowing requirement for a device\nDesign and develop a device that will let the users type text using all English letters digits \nand symbols\nOne way to design such a device is to provide a keyboard that has keys for all possible combinations \nof all letters digits and symbols This solution is not reasonable as the size of the device will be huge You \nmay realize that we are talking about designing a keyboard Look at your keyboard and see how it has been \ndesigned It has broken down the problem of typing text into typing a letter a digit or a symbol one at a time \nwhich represents the smaller part of the original problem If you can type all letters all digits and all symbols \none at a time you can type text of any length\nAnother decomposition of the original problem may include two keys one to type a horizontal line and \nanother to type a vertical line which a user can use to type in E T I F H and L because these letters consist \nof only horizontal and vertical lines With this solution a user can type six letters using the combination of \njust two keys However with your experience using keyboards you may realize that decomposing the keys so \nthat a key can be used to type in only part of a letter is not a reasonable solution although it is a solution\nWhy is providing two keys to type six letters not a reasonable solution Arent we saving space and \nnumber of keys on the keyboard The use of the term reasonable is relative in this context From a purist \npoint of view it may be a reasonable solution My reasoning behind calling it not reasonable is that it \nis not easily understood by users It exposes more details to the users than needed A user would have to \nremember that the horizontal line is placed at the top for T and at bottom for L When a user gets a separate \nkey for each letter they do not have to deal with these details It is important that the subprograms that \nprovide solutions to parts of the original problem must be simplified to have the same level of detail to work \ntogether seamlessly At the same time a subprogram should not expose details that are not necessary for \nsomeone to know in order to use it\nFinally all keys are mounted on a keyboard and they can be replaced separately If a key is broken \nit can be replaced without worrying about other keys Similarly when a program is decomposed into \nsubprograms a modification in a subprogram should not affect other subprograms Subprograms can \nalso be further decomposed by focusing on a different level of detail and ignoring other details A good \ndecomposition of a program aims at providing the following characteristics\n\t Simplicity\n\t Isolation\n\t Maintainability\nEach subprogram should be simple enough to be understood by itself Simplicity is achieved by \nfocusing on the relevant pieces of information and ignoring the irrelevant ones What pieces of information \nare relevant and what are irrelevant depend on the context\nEach subprogram should be isolated from other subprograms so that any changes in a subprogram \nshould have localized effects A change in one subprogram should not affect any other subprograms \nA subprogram defines an interface to interact with other subprograms The inner details about the \nsubprogram are hidden from the outside world As long as the interface for a subprogram remains \nunchanged the changes in its inner details should not affect the other subprograms that interact with itChapter 1  programming Con Cepts\n15Each subprogram should be small enough to be written understood and maintained easily\nAll of these characteristics are achieved during decomposition of a problem or program that solves a \nproblem using a process called abstraction Abstraction is a way to perform decomposition of a problem \nby focusing on relevant details and ignoring the irrelevant details about it in a particular context Note \nthat no details about a problem are irrelevant In other words every detail about a problem is relevant \nHowever some details may be relevant in one context and some in another It is important to note that it \nis the context that decides what details are relevant and what are irrelevant For example consider the \nproblem of designing and developing a keyboard For a users perspective a keyboard consists of keys that \ncan be pressed and released to type text Number type size and position of keys are the only details that \nare relevant to the users of a keyboard However keys are not the only details about a keyboard A keyboard \nhas an electronic circuit and it is connected to a computer A lot of things occur inside the keyboard and the \ncomputer when a user presses a key The internal workings of a keyboard are relevant to keyboard designers \nand manufacturers However they are irrelevant to the users of a keyboard You can say that different users \nhave different views of the same thing in different contexts What details about the thing are relevant and \nwhat are irrelevant depend on the user and the context\nAbstraction is about considering details that are necessary to view the problem in the way that is \nappropriate in a particular context and ignoring hiding or suppressing or forgetting the details that are \nunnecessary Terms like hiding and suppressing in the context of abstraction may be misleading These \nterms may mean hiding some details of a problem Abstraction is concerned with which details of a thing \nshould be considered and which should not for a particular purpose It does imply hiding of the details How \nthings are hidden is another concept called information hiding which is discussed in the following section\nThe term abstraction is used to mean one of the two things a process or an entity As a process it is \na technique to extract relevant details about a problem and ignore the irrelevant details As an entity it is a \nparticular view of a problem that considers some relevant details and ignores the irrelevant details\n Abstraction for\u00a0Hiding Complexities\nLets discuss the application of abstraction in realworld programming Suppose you want to write a program \nthat will compute the sum of all integers between two integers Suppose you want to compute the sum of all \nintegers between 10 and 20 You can write the program as follows Do not worry if you do not understand \nthe syntax used in programs in this section Just try to grasp the big picture of how abstraction is used to \ndecompose a program\nint sum  0\nint counter  10\nwhile counter  20 \n    sum  sum  counter\n    counter  counter  1\n\nSystemoutprintlnsum\nThis snippet of code will add 10  11  12    20  and print 165 Suppose you want to compute \nthe sum of all integers between 40 and 60 Here is the program to achieve just that\nint sum  0\nint counter  40\nwhile counter  60 \n    sum  sum  counter\n    counter  counter  1\n\nSystemoutprintlnsumChapter 1  programming Con Cepts\n16This snippet of code will perform the sum of all integers between 40 and 60 and it will print 1050  Note \nthe similarities and differences between the two snippets of code The logic is the same in both However the \nlower and upper limits of the range are different If you can ignore the differences that exist between the two \nsnippets of code you will be able to avoid the duplication of logic in two places Lets consider the following \nsnippet of code\nint sum  0\nint counter  lowerLimit\nwhile counter  upperLimit \n    sum  sum  counter\n    counter  counter  1\n\nSystemoutprintlnsum\nThis time you did not use any actual values for the lower and upper limits of any range Rather you \nused lowerLimit  and upperLimit  placeholders that are not known at the time the code is written By using \ntwo placeholders in your code you are hiding the identity of the lower and upper limits of the range In other \nwords you are ignoring their actual values when writing this piece of code You have applied the process of \nabstraction in the code by ignoring the actual values of the lower and upper limits of the range\nWhen this piece of code is executed the actual values must be substituted for lowerLimit  and \nupperLimit  placeholders This is achieved in a programming language by packaging the snippet of code \ninside a module subroutine or subprogram called a procedure  The placeholders are defined as formal \nparameters of that procedure Listing 12 has the code for such a procedure\nListing 12  A Pro cedure Named getRangeSum to Compute the Sum of All Integers Between Two Integers\nint getRangeSumint lowerLimit int upperLimit \n    int sum  0\n    int counter  lowerLimit\n    while counter  upperLimit \n        sum  sum  counter\n        counter  counter  1\n    \n    return sum\n\nA pr ocedure has a name which is getRangeSum  in this case A procedure has a return type which is \nspecified just before its name The return type indicates the type of value that it will return to its caller\nThe return type is int in this case which indicates that the result of the computation will be an integer\nA procedure has formal parameters possibly zero which are specified within parentheses following its \nname A formal parameter consists of a data type and a name In this case the formal parameters are named \nas lowerLimit  and upperLimit  and both are of the data type int It has a body which is placed within \nbraces The body of the procedure contains the logic\nWhen you want to execute the code for a procedure you must pass the actual values for its formal \nparameters You can compute and print the sum of all integers between 10 and 20 as follows\nint s1  getRangeSum10 20\nSystemoutprintlns1Chapter 1  programming Con Cepts\n17This snippet of code will print 165 To compute the sum all integers between 40 and 60 you can execute \nthe following snippet of code\nint s2  getRangeSum40 60\nSystemoutprintlns2\nThis snippet of code will print 1050  which is exactly the same result you achieved before\nThe abstraction method that you used in defining the getRangeSum  procedure is called abstraction by \nparameterization  The formal parameters in a procedure are used to hide the identity of the actual data on \nwhich the procedures body operates The two parameters in the getRangeSum  procedure hide the identity \nof the lower and upper limits of the range of integers Now you have seen the first concrete example of \nabstraction Abstraction is a vast topic I cover some more basics about abstraction in this section\nSuppose a programmer writes the code for the getRangeSum  procedure as shown in Listing 12 and \nanother programmer wants to use it The first programmer is the designer and writer of the procedure \nthe second one is the user of the procedure What pieces of information does the user of the getRangeSum  \nprocedure need to know in order to use it\nBefore you answer this question lets consider a realworld example of designing and using a DVD \nDigital Versatile Disc player A DVD player is designed and developed by electronic engineers How do you \nuse a DVD player Before you use a DVD player you do not open it to study all the details about its parts \nthat are based on electronic engineering theories When you buy it it comes with a manual on how to use it \nA DVD player is wrapped in a box The box hides the details of the player inside At the same time the box \nexposes some of the details about the player in the form of an interface to the outside world The interface \nfor a DVD player consists of the following items\n\t Input and output connection ports to connect to a power outlet a TV set etc\n\t A panel to insert a DVD\n\t A set of buttons to perform operations such as eject play pause fastforward etc\nThe manual that comes with the DVD player describes the usage of the players interface meant for its \nusers A DVD user need not worry about the details of how it works internally The manual also describes \nsome conditions to operate it For example you must plug the power cord to a power outlet and switch on \nthe power before you can use it\nA program is designed developed and used in the same way as a DVD player The user of the program \nshown in Listing 12 need not worry about the internal logic that is used to implement the program A user \nof the program needs to know only its usage which includes the interface to use it and conditions that \nmust be met before and after using it In other words you need to provide a manual for the getRangeSum  \nprocedure that will describe its usage The user of the getRangeSum  procedure will need to read its \nmanual to use it The manual for a program is known as its specification Sometimes it is also known as \ndocumentation or comments It provides another method of abstraction which is called abstraction by \nspecification It describes or exposes or focuses on the what part of the program and hides or ignores or \nsuppresses the how part of the program from its users\nListing 13 shows the same getRangeSum  procedure code with its specification\nListing 13  The g etRangeSum Procedure with Its Specification for the Javadoc Tool\n\n  Computes and returns the sum of all integers between two\n  integers specified by lowerLimit and upperLimit parameters\n \n  The lowerLimit parameter must be less than or equal to the\n  upperLimit parameter If the sum of all integers between theChapter 1  programming Con Cepts\n18  lowerLimit and the upperLimit exceeds the range of the int data\n  type then result is not defined\n \n  param lowerLimit The lower limit of the integer range\n  param upperLimit The upper limit of the integer range\n  return The sum of all integers between lowerLimit inclusive\n          and upperLimit inclusive\n \npublic static int getRangeSumint lowerLimit int upperLimit \n    int sum  0\n    int counter  lowerLimit\n    while counter  upperLimit \n        sum  sum  counter\n        counter  counter  1\n    \n    return sum\n\nJavadoc standards are used to write a specification for a Java program that can be processed by the \nJavadoc tool to generate HTML pages In Java the specification for a program element is placed between \n and  immediately before the element The specification is meant for the users of the getRangeSum  \nprocedure The Javadoc tool will generate the specification for the getRangeSum  procedure as shown in \nFigure\u00a0 14\nThis specification provides the description the what part of the getRangeSum procedure It also \nspecifies two conditions known as preconditions which must be true when the procedure is called The \nfirst precondition is that the lower limit must be less than or equal to the upper limit The second pre\ncondition is that the value for lower and upper limits must be small enough so that the sum of all integers \nbetween them fits in the size of the int data type It specifies another condition that is called a postcondition \nFigure 14  The s pecification for the getRangeSum procedureChapter 1  programming Con Cepts\n19which is specified in the Returns clause The postcondition holds as long as the preconditions hold The \npreconditions and postconditions are like a contract or an agreement between the program and its user \nIt states that as long as the user of the program makes sure that the precondition holds true the program \nguarantees that the postcondition will hold true Note that the specification never tells the user about how \nthe program fulfills implementation details the postcondition It only tells what it is going to do rather \nthan how it is going to do it The user of the getRangeSum  program who has the specification need not look \nat the body of the getRangeSum  procedure to figure out the logic that it uses In other words you have hidden \nthe details of the implementation of the getRangeSum  procedure from its users by providing this specification \nto them That is users of the getRangeSum  procedure can ignore its implementation details for the purpose \nof using it This is another concrete example of abstraction The method of hiding implementation details \nof a subprogram the how part and exposing its usage the what part by using specification is called \nabstraction by specification \nAbstraction by parameterization and abstraction by specification let the users of a program view the \nprogram as a black box where they are concerned only about the effects that program produces rather than \nhow the program produces those effects Figure\u00a0 15 depicts the users view of the getRangeSum  procedure \nNote that a user does not see and need not see the body of the procedure that has the details The details \nare relevant only to the writer of the program not its users\nWhat advantages did you achieve by applying the abstraction to define the getRangeSum  procedure \nOne of the most important advantages is isolation It is isolated from other programs If you modify the logic \ninside its body other programs including the ones that are using it need not be modified To print the sum \nof integers between 10 and 20 you use the following program\nint s1  getRangeSum10 20\nSystemoutprintlns1\nThe body of the procedure uses a while  loop which is executed as many times as the number of \nintegers between lower and upper limits The while  loop inside the getRangeSum  procedure executes n times \nwhere n is equal to upperLimit   lowerLimit  1  The number of instructions that need to be executed \ndepends on the input values There is a better way to compute the sum of all integers between two integers \nlowerLimit  and upperLimit  using the following formula\nn  upperLimit   lowerLimit  1\nsum  n  2  lowerLimit  n12\nIf you use this formula the number of instructions that are executed to compute the sum of all integers \nbetween two integers is always the same You can rewrite the body of the getRangeSum  procedure as shown \nin Listing 14 The specification of the getRangeSum  procedure is not shown here\nFigure 15  Users view of the getRangeSum procedure as a black box using abstractionChapter 1  programming Con Cepts\n20Listing 14  Another Ver sion of the getRangeSum Procedure with the Logic Changed Inside Its Body\npublic int getRangeSumint lowerLimit int upperLimit \n    int n  upperLimit   lowerLimit  1\n    int sum  n  2  lowerLimit  n12\n    return sum\n\nNote that the body implementation or the how part of the getRangeSum  procedure has changed \nbetween Listing 13 and Listing 14 However the users of the getRangeSum  procedure are not affected by \nthis change because the details of the implementation of this procedure are kept hidden from its users by \nusing abstraction If you want to compute the sum of all integers between 10 and 20 using the version of the \ngetRangeSum  procedure as shown in Listing 14 your old code is still valid\nint s1  getRangeSum10 20\nSystemoutprintlns1\nYou have just seen one of the greatest benefits of abstraction in which the implementation details of a \nprogram in this case a procedure can be changed without warranting any changes in the code that uses \nthe program This benefit also gives you a chance to rewrite your program logic to improve performance in \nthe future without affecting other parts of the application\nI consider two types of abstraction in this section\n\t Procedural abstraction\n\t Data abstraction\nProcedural abstraction lets you define a procedure for example getRangeSum  that you can use as an \naction or a task So far I have been discussing procedural abstraction Abstraction by parameterization and \nabstraction by specification are two methods to achieve procedural abstraction as well as data abstraction \nThe next section discusses data abstraction in detail\n Data Abstraction\nObjectoriented programming is based on data abstraction However I need to discuss data types briefly \nbefore I discuss data abstraction A data type or simply a type is defined in terms of three components\n\t A set of values or data objects\n\t A set of operations that can be applied to all values in the set\n\t A data representation which determines how the values are stored\nProgramming languages provide some predefined data types which are known as builtin data types \nThey also let programmers define their own data types which are known as userdefined data types A data \ntype that consists of an atomic and indivisible valueand that is defined without the help of any other data \ntypesis known as a primitive data type For example Java has builtin primitive data types such as int \nfloat  boolean  char  etc Three components that define the int primitive data type in Java are as follows\n\t An int data type consists of a set of all integers between 2147483648 and \n2147483647\n\t Operations such as addition subtraction multiplication division comparison and \nmany more are defined for the int data type\n\t A value of int data type is represented in 32bit memory in 2s complement formChapter 1  programming Con Cepts\n21All three components of the int data type are predefined by the Java language You cannot extend or \nredefine the definition of the int data type You can give a name to a value of the int data type as\nint n1\nThis statement says that n1 is a name technically called an identifier that can be associated with one \nvalue from the set of values that defines values for the int data type For example you can associate integer \n26 to the name n1 using an assignment statement as follows\nn1  26\nAt this stage you may be asking Where is the value 26 which is associated with the name n1 stored \nin memory You know from the definition of the int data type that n1 will take 32bit memory However \nyou do not know cannot know and do not need to know where in the memory that 32bit is allocated for \nn1 Do you see an example of abstraction here If you see an example of abstraction in this case you are \nright This is an example of abstraction which is built into the Java language In this instance the pieces \nof information about the data representation of the data value for the int data type are hidden from the \nusers programmers of the data type In other words a programmer ignores the memory location of n1 \nand focuses on its value and the operations that can be performed on it A programmer does not care if the \nmemory for n1 is allocated in a register RAM or the hard disk\nObjectoriented programming languages such as Java let you create new data types using an abstraction \nmechanism called data abstraction The new data types are known as abstract data types ADTs The data \nobjects in ADT may consist of a combination of primitive data types and other ADTs An ADT defines a set \nof operations that can be applied to all its data objects The data representation is always hidden in ADT\u00a0For \nusers of an ADT it consists of operations only Its data elements may only be accessed and manipulated \nusing its operations The advantage of using data abstraction is that its data representation can be changed \nwithout affecting any code that uses the ADT\n Tip Data abstraction lets programmers create a new data type called an abstract data type where the \nstora ge representation of the data objects is hidden from the users of the data type in other words  aDt is \ndefined solely in terms of opera tions that can be applied to the data objects of its type without knowing the \ninternal representation of the data the reason this kind of da ta type is called abstract is that users of aDt never \nsee the representa tion of the data values Users view the data objects of an aDt in an abstract way  by applying \noperations on them without knowing the details about representation of the data objects note tha t an aDt does \nnot mean absence of da ta representation Data representation is always present in an aDt\u00a0it only means hiding \nthe da ta representation from its users\nJava has constructs for example class interface annotation and enum  that let you define new ADTs \nWhen you use a class to define a new ADT you need to be careful to hide the data representation so your \nnew data type is really abstract If the data representation in a Java class is not hidden that class creates \na new data type but not an ADT\u00a0A class in Java gives you features that you can use to expose the data \nrepresentation or hide it In Java the set of values of a class data type are called objects  Operations on the \nobjects are called methods  Instance variables also known as fields of objects are the data representation \nfor the class type\nA class in Java lets you implement operations that operate on the data representation An interface in \nJava lets you create a pure ADT\u00a0An interface lets you provide only the specification for operations that can \nbe applied to the data objects of its type No implementation for operations or data representation can be \nmentioned in an interface Listing 11 shows the definition of the Person  class using Java language syntax Chapter 1  programming Con Cepts\n22By defining a class named Person  you have created a new ADT\u00a0Its internal data representation for name  \nand gender  uses the String  data type  String  is a builtin ADT provided by the Java class library Note that \nthe definition of the Person  class uses the private  keyword in the name  and gender  declarations to hide \nthem from the outside world Users of the Person  class cannot access the name  and gender  data elements It \nprovides four operations a constructor and three methods  getName  setName  and getGender \nA constructor operation is used to initialize a newly constructed data object of the Person  type The \ngetName  and setName  operations are used to access and modify the name  data element respectively The \ngetGender  operation is used to access the value of the gender  data element\nUsers of the Person  class must use only these four operations to work with data objects of the Person  \ntype Users of the Person  type are oblivious to the type of data storage being used to store name  and gender  \ndata elements I am using three terms type  class  and interface  interchangeably because they mean \nthe same thing in the context of a data type It gives the developer of the Person  type freedom to change the \ndata representation for the name  and gender  data elements without affecting any users of the Person  type \nSuppose one of the users of the Person  type has the following snippet of code\nPerson john  new PersonJohn Jacobs Male\nString intialName  johngetName\njohnsetNameWally Jacobs\nString changedName  johngetName\nThis snippet of code has been written only in terms of the operations provided by the Person  type It \ndoes not and could not refer to the name  and gender  instance variables directly Lets see how to change the \ndata representation of the Person  type without affecting the snippet of code Listing 15 shows the code for a \nnewer version for the Person  class\nListing 15  Another Ver sion of the Person Class That Uses a String Array of Two Elements to Store Name \nand Gender Values as Opposed to Two String Variables\npackage comjdojoconcepts\npublic class Person \n    private String data  new String2\n    public PersonString initialName String initialGender \n        data0  initialName\n        data1  initialGender\n    \n    public String getName \n        return data0\n    \n    public void setNameString newName \n        data0  newName\n    \n    public String getGender \n        return data1\n    \n\nCompare the code in Listing 11 and that in Listing 15 This time you have replaced the two instance \nvariables  name  and gender  which were the data representation for the Person  type in Listing 11 with a \nString  array of two elements Since operations or methods in a class operate on the data representation \nyou had to change the implementations for all four operations in the Person  type The client code in \nListing 15 was written in terms of the specifications of the four operations and not their implementation \nSince you have not changed the specification of any of the operations you do not need to change the Chapter 1  programming Con Cepts\n23snippet of code that uses the Person  class it is still valid with the newer definition of the Person  type as \nshown in Listing 15 Some methods in the Person  class use the abstraction by parameterization and \nall of them use the abstraction by specification I have not shown the specification for the methods here \nwhich would be Javadoc comments\nYou have seen two major benefits of data abstraction in this section\n\t It lets you extend the programming language by letting you define new data types \nThe new data types you create depend on the application domain For example for \na banking system Person  Currency  and Account  may be good choices for new data \ntypes whereas for an auto insurance application Person  Vehicle  and Claim  may \nbe good choices The operations included in a new data type depend on the need of \nthe application\n\t The data type created using data abstraction may change the representation of the \ndata without affecting the client code using the data type\n Encapsulation and\u00a0Information Hiding\nThe term encapsulation is used to mean two different things a process or an entity As a process it is an act \nof bundling one or more items into a container The container could be physical or logical As an entity it is a \ncontainer that holds one or more items\nProgramming languages support encapsulations in many ways A procedure is an encapsulation of \nsteps to perform a task an array is an encapsulation of several elements of the same type etc In object\noriented programming encapsulation is bundling of data and operations on the data into an entity called a \nclass Java supports encapsulation in various ways\n\t It lets you bundle data and methods that operate on the data in an entity  \ncalled a class \n\t It lets you bundle one or more logically related classes in an entity called a \npackage  A package in Java is a logical collection of one or more related classes \nA package creates a new naming scope in which all classes must have unique \nnames Two classes may have the same name in Java as long as they are bundled or \nencapsulated in two different packages\n\t It lets you bundle packages into a module  which was introduced in Java SE 9 A \nmodule can export its packages Types defined in exported packages are accessible \nto other modules whereas types in nonexported packages are inaccessible to other \nmodules\n\t It lets you bundle one or more related classes in an entity called a compilation unit  \nAll classes in a compilation unit can be compiled separately from other  \ncompilation units\nWhile discussing the concepts of objectoriented programming the two terms encapsulation  and \ninformation hiding are often used interchangeably However they are different concepts in objectoriented \nprogramming and they should not be used interchangeably as such Encapsulation is simply the bundling \nof items together into one entity Information hiding is the process of hiding implementation details that \nare likely to change Encapsulation is not concerned with whether the items that are bundled in an entity \nare hidden from other modules in the application or not What should be hidden or ignored and what \nshould not be hidden are the concern of abstraction Abstraction is only concerned about which item \nshould be hidden Abstraction is not concerned about how the item should be hidden Information hiding is \nconcerned with how an item is hiddenChapter 1  programming Con Cepts\n24Encapsulation abstraction and information hiding are three separate concepts They are very closely \nrelated though One concept facilitates the workings of the others It is important to understand the subtle \ndifferences in roles they play in objectoriented programming\n Tip in Ja va se you will often come across a statement like a module provides strong encapsulation \nhere the term encapsulation  is used in the sense of information hiding it means tha t types in nonexported \npackages in a module are hidden from or inaccessible to other modules\nIt is possible to use encapsulation with or without hiding any information For example the Person  \nclass in Listing 11 shows an example of encapsulation and information hiding The data elements  name  \nand gender  and methods  getName  setName  and getGender  are bundled together in a class called \nPerson  This is encapsulation In other words the Person  class is an encapsulation of the data elements \nname  and gender  plus the methods getName  setName  and getGender  The same Person  class uses \ninformation hiding by hiding the data elements from the outside world Note that name  and gender  data \nelements use the Java keyword private  which essentially hides them from the outside world Listing 16 \nshows the code for a Person2  class\nListing 16  The D efinition of the Person2 Class in Which Data Elements Are Not Hidden by Declaring \nThem Public\npackage comjdojoconcepts\npublic class Person2 \n    public String name     Not hidden from its users\n    public String gender  Not hidden from its users\n    public Person2String initialName String initialGender \n        name  initialName\n        gender  initialGender\n    \n    public String getName \n        return name\n    \n    public void setNameString newName \n        name  newName\n    \n    public String getGender \n        return gender\n    \n\nThe code in Listing 11 and that in Listing 16 are essentially the same except for two small differences \nThe Person2  class uses the keyword public  to declare the name  and gender  data elements The Person2  class \nuses encapsulation the same way the Person  class uses it However the name  and gender  data elements are \nnot hidden That is the Person2  class does not use data hiding data hiding is an example of information \nhiding If you look at the constructor and methods of Person  and Person2  classes their bodies use \ninformation hiding because the logic written inside their bodies is hidden from their users\n Tip enca psulation and information hiding are two distinct concepts of objectoriented programming the \nexistence of one does not imply the existence of the other Chapter 1  programming Con Cepts\n25 Inheritance\nInheritance is another important concept in objectoriented programming It lets you use abstraction in \na new way You have seen how a class represents an abstraction in previous sections The Person  class \nshown in Listing 11 represents an abstraction for a realworld person The inheritance mechanism lets you \ndefine a new abstraction by extending an existing abstraction The existing abstraction is called a supertype \na superclass a parent class or a base class The new abstraction is called a subtype a subclass a child \nclass or a derived class It is said that a subtype is derived or inherited from a supertype a supertype is a \ngeneralization of a subtype and a subtype is a specialization of a supertype The inheritance can be used \nto define new abstractions at more than one level A subtype can be used as a supertype to define another \nsubtype and so on Inheritance gives rise to a family of types arranged in a hierarchical form\nInheritance allows you to use varying degrees of abstraction at different levels of hierarchy In Figure\u00a0 16 \nthe Person  class is at the top highest level of the inheritance hierarchy Customer  and Employee  classes are at \nthe second level of the inheritance hierarchy As you move down the inheritance hierarchy you focus on more \nimportant pieces of information In other words at a higher level of inheritance you are concerned about the \nbigger picture and at lower levels of inheritance you are concerned about more and more details There is \nanother way to look at inheritance hierarchy from an abstraction point of view At the Person  level in Figure\u00a0 16 \nyou focus on the common characteristics of Customer  and Employee  ignoring the differences between them \nAt the Employee  level you focus on common characteristics of Clerk  Programmer  and Cashier  ignoring the \ndifferences between them\nIn inheritance hierarchy a supertype and its subtype represent an isa relationship That is an \nEmployee  is a Person  a Programmer  is an Employee  etc Since the lower level of inheritance means more \npieces of information a subtype always includes what its supertype has and maybe some more This \ncharacteristic of inheritance leads to another feature in objectoriented programming which is known \nas the principle of substitutivity  It means that a supertype can always be substituted with its subtype For \nexample you have considered only name  and gender  information for a person in your Person  abstraction \nIf you inherit Employee  from Person  Employee  includes name  and gender  information which it inherits \nFigure 16  Inher itance hierarchy for the Person classChapter 1  programming Con Cepts\n26from Person  Employee  may include some more pieces of information such as employee ID hire date \nsalary etc If a Person  is expected in a context it implies that only name  and gender  information is relevant \nin that context You can always replace a Person  in that context with an Employee  a Customer  a Clerk  or a \nProgrammer  because being a subtype direct or indirect of the Person  these abstractions guarantee that they \nhave the ability to deal with at least name  and gender  information\nAt the programming level inheritance provides a code reuse mechanism The code written in a \nsupertype may be reused by its subtype A subtype may extend the functionality of its supertype by adding \nmore functionalities or by redefining existing functionalities of its supertype\n Ti p i nheritance is also used as a technique to implement polymorphism which is discussed in the next \nsection inheritance lets you write polymorphic code the code is written in terms of the supertype and the \nsame code works for subtypes\nInheritance is a vast topic This book devotes a complete chapter on how to use inheritance in Java\n Polymorphism\nThe word polymorphism has its root in two Greek words poly means many and morphos \nmeans form In programming polymorphism is the ability of an entity eg variable class method \nobject code parameter etc to take on different meanings in different contexts The entity that takes on \ndifferent meanings is known as a polymorphic entity Various types of polymorphism exist Each type of \npolymorphism has a name that usually indicates how that type of polymorphism is achieved in practice The \nproper use of polymorphism results in generic and reusable code The purpose of polymorphism is writing \nreusable and maintainable code by writing code in terms of a generic type that works for many types or \nideally all types Polymorphism can be categorized in the following two categories\n\t Ad hoc polymorphism\n\t Universal polymorphism\nIf a piece of code works for a finite number of types and all those types must be known when the \ncode is written it is known as ad hoc polymorphism  Ad hoc polymorphism is also known as apparent \npolymorphism  because it is not polymorphism in a true sense Some computer science purists do not \nconsider ad hoc polymorphism to be polymorphism at all\nAd hoc polymorphism is further divided into two categories\n\t Overloading polymorphism\n\t Coercion polymorphism\nIf a piece of code is written in such a way that it works for an infinite number of types will also \nwork for new types not known at the time the code is written it is called universal polymorphism  In \nuniversal polymorphism the same code works on many types whereas in ad hoc polymorphism different \nimplementations of code are provided for different types giving an apparent impression of polymorphism\nUniversal polymorphism is further divided into two categories\n\t Inclusion polymorphism\n\t Parametric polymorphism\nIn the subsequent sections I describe these types of polymorphism in detail with examplesChapter 1  programming Con Cepts\n27 Overloading Polymorphism\nOverloading is an ad hoc polymorphism Overloading results when a method called a method in Java \nand a function in other languages or an operator has at least two definitions that work on different types \nIn such cases the same name for the method or operator is used for its different definitions That is the \nsame name exhibits many behaviors and hence the polymorphism Such methods and operators are called \noverloaded methods and overloaded operators Java lets you define overloaded methods Java has some \noverloaded operators but it does not let you overload an operator for an ADT\u00a0That is you cannot provide a \nnew definition for an operator in Java Listing 17 shows code for a class named MathUtil \nListing 17  An Exam ple of an Overloaded Method in Java\n MathUtiljava\npackage comjdojoconcepts\npublic class MathUtil \n    public static int maxint n1 int n2 \n         Code to determine the maximum of two integers goes here \n    \n    public static double maxdouble n1 double n2 \n         Code to determine the maximum of two floatingpoint numbers goes here \n    \n    public static int maxint num \n         Code to determine the maximum in an array of int goes here \n    \n\nThe max  method of the MathUtil  class is overloaded It has three definitions and each of its \ndefinitions performs the same task of computing a maximum but on different types The first definition \ncomputes a maximum of two numbers of int data type the second one computes a maximum of two \nfloatingpoint numbers of double  data type and the third one computes a maximum of an array of numbers \nof int data type The following snippet of code uses all three definitions of the overloaded max  method\nint max1  MathUtilmax10 23                   Uses maxint int\ndouble max2  MathUtilmax1034 289           Uses maxdouble double\nint max3  MathUtilmaxnew int1 89 8 3  Uses maxint\nNote that method overloading gives you only sharing of the method name It does not result in the \nsharing of the methods definitions In Listing 17 the method name max is shared by all three methods but \nthey all have their own definition of computing a maximum of different types In method overloading the \ndefinitions of methods do not have to be related They may perform entirely different things and share the \nsame name\nThe following snippet of code shows an example of operator overloading in Java The operator is  In \nthe following three statements it performs three different things\nint n1  10  20                Adds two integers\ndouble n2  1020  218        Adds two floatingpoint numbers\nString str  Hi   there    Concatenates two strings\nIn the first statement the  operator performs addition on two integers 10 and 20 and returns 30 In the \nsecond statement it performs addition on two floatingpoint numbers 1020  and 218  and returns 1238  \nIn the third statement it performs concatenation of two strings Hi  and there  and returns Hi there Chapter 1  programming Con Cepts\n28In overloading the types of the actual parameters of methods the types of operands in the case of \noperators are used to determine which definition of the code to use Method overloading provides only the \nreuse of the method name You can remove method overloading by simply supplying a unique name to all \nversions of an overloaded method For example you could rename the three versions of the max  method \nas max2Int  max2Double  and maxNInt  Note that all versions of an overloaded method or operator do \nnot have to perform related or similar tasks In Java the only requirement to overload a method name is that \nall versions of the method must differ in number andor type of their formal parameters\n Coercion Polymorphism\nCoercion is an ad hoc polymorphism Coercion occurs when a type is implicitly converted coerced to \nanother type automatically even if it was not intended explicitly Consider the following statements in Java\nint num  707\ndouble d1  doublenum  Explicit conversion of int to double\ndouble d2  num           Implicit conversion of int to double coercion\nIn the first statement the variable num has been declared to be of int data type and its assigned a \nvalue of 707 The second statement uses a cast double  to convert the int value stored in num to double  \nand it assigns the converted value to a variable named d1 This is the case of explicit conversion from \nint to double  In this case the programmer makes their intention explicit by using the cast The third \nstatement has exactly the same effect as the second one however it relies on implicit conversion called \nwidening conversion in Java provided by the Java language that converts an int to double  automatically \nwhen needed The third statement is an example of coercion A programming language including \nJava performs different types of coercion in different contexts assignment shown previously method \nparameters etc\nConsider the following snippet of code that shows a definition of a square  method which accepts a \nparameter of double  data type\ndouble squaredouble num \n    return num  num\n\nThe square  method can be called with an actual parameter of double  data type as follows\ndouble d1  2023\ndouble result  squared1\nThe same square  method may also be called with an actual parameter of int data type as follows\nint k  20\ndouble result  squarek\nYou have just seen that the square  method works on parameters of the double  as well as int data \ntype although you have defined it only once in terms of a formal parameter of double  data type This is \nexactly what polymorphism means In this case the square  method is called a polymorphic method \nwith respect to double  and int data types Thus the square  method is exhibiting polymorphic behavior Chapter 1  programming Con Cepts\n29even though the programmer who wrote the code did not intend it The square  method is polymorphic \nbecause of the implicit type conversion coercion from int to double  provided by the Java language Here is \na more formal definition of a polymorphic method\nSuppose m is a method that declares a formal parameter of type T\u00a0If S is a type that can be \nimplicitly converted to T the method m is said to be polymorphic with respect to S and T\n Inclusion Polymorphism\nInclusion is a universal polymorphism It is also known as subtype or subclass polymorphism  because it \nis achieved using subtyping or subclassing This is the most common type of polymorphism supported by \nobjectoriented programming languages Java supports it\nInclusion polymorphism occurs when a piece of code that is written using a type works for all its \nsubtypes This type of polymorphism is possible based on the subtyping rule that a value that belongs to a \nsubtype also belongs to the supertype Suppose T is a type and S1 S2 S3  are subtypes of T A value that \nbelongs to S1 S2 S3  also belongs to T This subtyping rule makes it possible to write code as follows\nT t\nS1 s1\nS2 s2\n\nt  s1  A value of type s1 can be assigned to a variable of type T\nt  s2  A value of type s2 can be assigned to a variable of type T\nJava supports inclusion polymorphism using inheritance which is a subclassing mechanism You \ncan define a method in Java using a formal parameter of a type for example Person  and that method can \nbe called on all its subtypes for example Employee  Student  Customer  etc Suppose you have a method \nprocessDetails  as follows\nvoid processDetailsPerson p \n    \nWrite code using the formal parameter p which is of type Person The same code will work if \nan object of any of the subclass of Person is passed to this method\n    \n\nThe processDetails  method declares a formal parameter of the Person  type You can define any \nnumber of classes that are subclasses of the Person  class This method will work for such subclasses Assume \nthat Employee  and Customer  are subclasses of the Person  class You can write code like this\nPerson p1  create a Person object\nEmployee e1  create an Employee object\nCustomer c1  create a Customer object\nprocessDetailsp1  Use the Person type\nprocessDetailse1  Use the Employee type which is a subclass of Person\nprocessDetailsc1  Use the Customer type which is a subclass of PersonChapter 1  programming Con Cepts\n30The effect of the subtyping rule is that the supertype includes hence the name inclusion all values \nthat belong to its subtypes A piece of code is called universally polymorphic only if it works on an infinite \nnumber of types In the case of inclusion polymorphism the number of types for which the code works is \nconstrained but infinite The constraint is that all types must be the subtype of the type in whose term the \ncode is written If there is no restriction on how many subtypes a type can have the number of subtypes is \ninfinite at least in theory Note that inclusion polymorphism not only lets you write reusable code it also \nlets you write extensible and flexible code The processDetails  method works on all subclasses of the \nPerson  class It will keep working for all subclasses of the Person  class which will be defined in the future \nwithout any modifications Java uses other mechanisms like method overriding and dynamic dispatch also \ncalled late binding along with subclassing rules to make the inclusion polymorphism more effective and \nuseful\n Parametric Polymorphism\nParametric is a universal polymorphism It is also called true polymorphism because it lets you write true \ngeneric code that works for any types related or unrelated Sometimes it is also referred to as generics  \nIn parametric polymorphism a piece of code is written in such a way that it works on any type Contrast \nparametric polymorphism with inclusion polymorphism In inclusion polymorphism code is written \nfor one type and it works for all of its subtypes It means all types for which the code works in inclusion \npolymorphism are related by a supertypesubtype relationship However in parametric polymorphism the \nsame code works for all types which are not necessarily related Parametric polymorphism is achieved by \nusing a type variable when writing the code rather than using any specific type The type variable assumes \na specific type for which the code needs to be executed Java supports parametric polymorphism since Java \n5 through generics Java supports polymorphic entities eg parameterized classes as well as polymorphic \nmethods parameterized methods that use parametric polymorphism\nIn Java parametric polymorphism is achieved in using generics All collection types in Java use \ngenerics You can write code using generics as follows\n Example 1 \n Create a List of String\nListString sList  new ArrayListString\n Add two Strings to the List\nsListaddstring 1\nsListaddstring 2\n Get the first String from the List\nString s1  sListget0\n Example 2 \n Create a List of Integer\nListInteger iList  new ArrayListInteger\n Add two Integers to the list\niListadd10\niListadd20\n Get the first Integer from the List\nint k1  iListget0\nThis code uses a List  object as a list of String  type and a List  object as a list of Integer  type Using \ngenerics you can treat a List  object as a list of any type in Java Note the use of Xxx  in these examples to \nspecify the type for which you want to instantiate the List  objectChapter 1  programming Con Cepts\n31 Summary\nWriting a set of instructions for a computer to accomplish a task is known as programming The set of \ninstructions is known as a program Different types of programming languages exist They differ in their \ncloseness to the instructions that the hardware can understand or the paradigm Machine language lets \nyou write programs using 0s and 1s and it is the lowestlevel programming language A program written \nin machine language is known as machine code An assembly language lets you write programs using \nmnemonics A program written using an assembly language is known as assembly code Later higherlevel \nprogramming languages were developed using an Englishlike language\nSeveral types of programming paradigms are in practice A programming paradigm is a thinking cap \nfor viewing and analyzing realworld problems in a particular way Imperative procedural functional and \nobjectoriented are some widely used paradigms in software development Java is a programming language \nthat supports procedural functional and objectoriented programming paradigms\nAbstraction encapsulation inheritance and polymorphism are the four pillars of the objectoriented \nparadigm Abstraction is the process of hiding details of a program that are irrelevant to the users of \nthat program Encapsulation is the process of bundling multiple items into one entity Inheritance is the \nprocess of arranging classes in a hierarchical manner to build supertypesubtype relationships Inheritance \npromotes reusability of code by allowing programmers to write the code in terms of a supertype that also \nworks for all of the subtypes Polymorphism is the way of writing a piece of code once that can operate on \nmultiple types Method overloading method overriding subtyping and generics are some of the ways to \nimplement polymorphism\nEXERCISES\nanswers to all of the following questions can be found in the different sections of this chapter\n 1 What is programming and what is a program\n 2 What is the difference between an assembler and a compiler\n 3 What is machine language and what does a program written in machine language \nconsist of\n 4 What is an assembly language and what does a program written in an assembly \nlanguage consist of\n 5 name three higherlevel programming languages\n 6 Based on the genera tion of a programming language 1 gL 2gL etc in what \ncategories do Java and sQL fall\n 7 What is a programming paradigm Describe procedural functional and  \nobjectoriented paradigms with examples\n 8 name the four pillars of objectoriented programming and describe each of them \nwith examples\n 9 What is true polymorphism and how does Java support it\n 10 What is an abstract data type how does Java support the abstract data type33\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730742CHAPTER 2\nSetting Up\u00a0the\u00a0Environment\nIn this chapter you will learn\n\t What software you need to write compile and run Java programs\n\t Where to download the required software from\n\t How to verify the installation of the Java Development Kit 17 JDK 17\n\t How to start the jshell  commandline tool that lets you run snippets of Java code\n\t From where to download install and configure the NetBeans IDE integrated \ndevelopment environment used to write compile package and run Java programs\n System Requirements\nYou need to have the following software installed on your computer to follow the examples in this book\n\t JDK 17\n\t A Java editor preferably NetBeans 125 or later\n Installing JDK 17\nYou will need a JDK to compile and run the Java programs You can download JDK 17 for your operating \nsystem from httpsjdkjavanet17  Follow the instructions on this web page to install the JDK on your \noperating system The web page at httpsdocsoraclecomenjavajavase17  contains a detailed \nexplanation of the JDK installation\nThroughout this book we assume that you have installed the JDK in the Cjava17  directory on \nWindows If you have installed it in a different directory or you are using a different operating system  \nyou need to use the path for the JDK installation on your system For example if you have installed it in the \nhomeksharanjdk17  directory on a UNIXlike operating system use homeksharanjdk17  whenever we \nuse Cjava17  in this book\nWhen you work with Java you will frequently hear three terms\n\tJDKHOME\n\tJREHOME\n\tJAVAHOMEChapter 2  Setting Up\u00a0the\u00a0 environment\n34JDKHOME  refers to the directory on your computer in which the JDK is installed If you have installed the \nJDK in Cjava17  JDKHOME  refers to the Cjava17  directory\nThere is a subset of the JDK which is called the JRE Java Runtime Environment If you have compiled \nJava code and just want to run it you need to install only the JRE\u00a0The JDK contains the JRE with several \ntools such as the Java compiler JREHOME  refers to the directory on your computer in which you have \ninstalled the JRE\u00a0You can always use the JDK installation directory as the value for the JREHOME  because \nJDK includes JRE\nTypically JAVAHOME  refers to the JREHOME  Depending on the context it may also refer to the JDKHOME \nI use the term JDKHOME  in this book to refer to the directory where JDK 17 is installed In the next two \nsections I explain the directory structure of the JDK and how to verify the JDK installation\n The JDK Directory Structure\nIn this section we explain the directory structure of the JDK installation There are a few significant changes \nin the way JDKs directories and their contents are organized in JDK 9 and above We also compare the JDK 8 \nand JDK 9 directory structures If you want to migrate your JDK 8 application to JDK 9 or above the new JDK \nstructure may break your application and you need to pay close attention to the changes described in this \nsection\nBefore JDK 9 the JDK build system used to produce two types of runtime imagesa Java Runtime \nEnvironment JRE and a Java Development Kit JDK The JRE was a complete implementation of the Java \nSE platform and the JDK had an embedded JRE and development tools and libraries You had a choice \nto install only JRE or a JDK which had an embedded JRE\u00a0Figure\u00a0 21 shows the main directories in JDK \ninstallation prior to Java SE 9 The JDKHOME  is the directory in which the JDK was installed If you installed \nJRE only you would have only directories under the jre directory\nFigure 21  JDK a nd JRE installation directory arrangements before Java SE 9\nThe installation directories in JDK 8 are arranged as follows\n\t The bin directory contains the commandline development and debugging tools \nsuch as javac  jar and javadoc  It also contains the java  command to launch Java \napplications\n\t The include  directory contains CC header files to be used while compiling the \nnative codeChapter 2  Setting Up\u00a0the\u00a0 environment\n35\t The lib directory contains several JARs and other types of files for the JDKs tools\nIt has a toolsjar  file which contains the Java classes for the javac  compiler\n\t The jrebin  directory contains essential commands such as the java  command  \nOn the Windows platform it contains the systems runtime dynamically linked \nlibraries DLLs\n\t The jrelib  directory contains usereditable configuration files such as \nproperties  and policy  files\n\t The jrelibendorsed  directory contains JARs that allow the Endorsed Standards \nOverride Mechanism which allows the later versions of classes and interfaces that \nimplement Endorsed Standards or Standalone Technologies which are created \noutside the Java Community Process to be incorporated into the Java platform \nThese JARs were prepended to the JVMs bootstrap class path thus overriding any \ndefinition of these classes and interfaces present in the Java runtime\n\t The jrelibext  directory contains JARs that allow the extension mechanism This \nmechanism loads all JARs in this directory by an extension class loader which is the \nchild of the bootstrap class loader and parent of the system class loader which loads \nall application classes By placing JARs in this directory you can extend the Java SE \nplatform The contents of these JARs are visible to all applications that compile with \nor run on this runtime image\n\t The jrelib  directory contains several JARs The rtjar  file contains the Java \nclasses and resource files for the runtime Many tools depend on the location of the \nrtjar  file\n\t The jrelib  directory contains dynamically linked native libraries for nonWindows \nplatforms\n\t The jrelib  directory contains several other subdirectories which contain runtime \nfiles such as fonts and images\nThe root directory of the JDK and of the JRE that is not embedded in a JDK used to contain several \nfiles such as COPYRIGHT  LICENSE  and README  A release  file in the root directory contains a keyvalue pair \ndescribing the runtime image such as the Java version OS version and architecture The following is a \nsample release  file from JDK 8 whose partial contents are shown\nJAVAVERSION18066\nOSNAMEWindows\nOSVERSION52\nOSARCHamd64\nBUILDTYPEcommercial\nThe Java SE 9 flattened the directory hierarchy for the JDK and removed the distinction between a JDK \nand a JRE\u00a0Figure\u00a0 22 shows the directories for a JDK installation in JDK 9 and above The JRE 8 installation \ndoes not contain the include  and jmods  directoriesChapter 2  Setting Up\u00a0the\u00a0 environment\n36The installation directories in JDK 9 are arranged as follows\n\t There is no subdirectory named jre\n\t The bin directory contains all commands On the Windows platform it continues to \ncontain the systems runtime dynamically linked libraries\n\t The conf  directory contains the usereditable configuration files such as \nproperties  and policy  files that used to be in the jrelib  directory\n\t The include  directory contains CC header files to be used while compiling the \nnative code as before It exists only in the JDK\n\t The jmods  directory contains the platform modules in JMOD format You need it \nwhen creating a custom runtime image It exists only in the JDK not in the JRE\n\t The legal  directory contains legal notices\n\t The lib directory contains the dynamically linked native libraries on the non\nWindows platform Its subdirectories and files are not supposed to be directly edited \nor used by developers It contains a file named modules  that contains the Java SE \nplatform modules in an internal format named JIMAGE\n Ti p  JDK 9 or above is much bigger than JDK 8 because it contains two copies of the pla tform modulesone \nin the jmods  directory in the J moD format and one in the libmodules  file in the JIMAGE  format\nThe root directory of the JDK continues to have files such as COPYRIGHT  LICENSE  and README  The \nrelease  file in the JDK contains a new entry with a MODULES  key whose value is a list of modules included in \nthe image Partial contents of a release  file in a JDK 17 image are as follows\nIMPLEMENTOROracle Corporation\nJAVAVERSION17\nJAVAVERSIONDATE20210914\nOSARCHamd64\nOSNAMEWindows\nMODULESjavabase javacompiler javadatatransfer\nWe have shown only three modules in the list In a full JDK install this list will include all platform \nmodules In a custom runtime image this list will contain only the modules that you included in the imageFigure 22  JDK directory arrangements in Java SE 9 and aboveChapter 2  Setting Up\u00a0the\u00a0 environment\n37 Ti p the libtoolsjar  in the JDK and the librtjar  in the J re were removed from Java S e in \nversion 9 Classes and resources that were available in these J ars are now stored in the lib directory in \ninternal format a new scheme called jrt may be used to retrieve those classes and resources from the \nruntime image applica tions dependent on the locations of these J ars will stop working\n Verifying the\u00a0JDK Installation\nThe JDKHOMEbin  directory contains a command named java  which is used to launch a Java application \nWhen the java  command is run with one of the following options it prints the JDK version information\n\tversion\n\tversion\n\tshowversion\n\tshowversion\nAll four options print the same JDK version information The options starting with one hyphen are \nUNIXstyle options whereas the options starting with two hyphens are GNUstyle options JDK 9 introduced \nGNUstyle options The UNIXstyle options print the JDK version on the standard error stream whereas the \nGNUstyle options print it on the standard output stream The version  and version  options exit after \nprinting the information whereas the showversion  and showversion  options continue to execute other \noptions after printing the information The following command shows how to print the JDK version\nCjava version\nopenjdk version 17ea 20210914\nOpenJDK Runtime Environment build 17ea10723\nOpenJDK 64Bit Server VM build 17ea10723 mixed mode sharing\nIf the first line of the output prints version 17  your JDK installation is fine You might get an output \nsimilar to the one shown\njava is not recognized as an internal or external command operable program or batch file\nThis output indicates that the JDKHOMEbin  directory is not included in the PATH  environment variable \non your computer In that case you can use the full path of the java  command to print its version and \neverywhere else you need it My JDKHOME  is Cjava17  on Windows The following commands show you \nhow to use the full path and how to set the PATH  environment variable on the command prompt\nCSET PATHCjava17binPATH\nCjava version\nYou can also set the PATH  environment variable permanently on Windows using the following\n  Control Panel  System and Security  System  Advanced system settings  Environment \nVariablesChapter 2  Setting Up\u00a0the\u00a0 environment\n38If you have more than one JDK installed on your computer it is easier to create a batch or a shell script \nto open a command prompt and set the PATH  environment variable in the script This way you can work \nwith multiple JDKs without setting the PATH  environment variable at the system level\n Starting the\u00a0JShell Tool\nJDK 9 and above include a jshell  tool in the JDKHOMEbin  directory The tool lets you execute a snippet \nof Java code instead of writing a full Java program This is very helpful for beginners Chapter 23 covers the \njshell  tool in detail The following commands show you how to start the jshell  tool execute a few Java \nsnippets of code and then exit the jshell  tool\nCjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell SystemoutprintlnHello JDK 17\nHello JDK 17\njshell 2  2\n2  4\njshell exit\n  Goodbye\nC\nWhile you are reading subsequent chapters you can start the jshell  tool on a command prompt and \nenter a snippet of code to see the results\n Installing NetBeans 12\nYou need a Java editor to write package compile and run your Java application and NetBeans is one \nsuch Java editor The source code for this book contains NetBeans projects However it is not necessary to \nuse NetBeans You can use another Java editor such as Eclipse IntelliJ IDEA or JDeveloper To follow the \nexamples in this book you need to copy the source code the java  files to the projects that you create \nusing another Java editor\nYou can download NetBeans 125 or above from httpsnetbeansorg  NetBeans 12 runs on JDK \nreleases 8 and 11 and the current JDK release When you install NetBeans it will ask you to select the JDK \nhome directory If you install NetBeans on JDK 11 you can select JDK 17 as the Java platform to use JDK 17 \ninside NetBeans If you install it on JDK 17 JDK 17 will be the default Java platform inside NetBeans In the \nnext section we will show you how to select a Java platform inside the NetBeans IDE\n Configuring NetBeans\nStart the NetBeans IDE\u00a0If you open the IDE for the first time it shows a pane titled Start Page as shown in \nFigure\u00a0 23 If you do not want this to show again you can uncheck the checkbox labeled Show On Startup \nwhich is in the upperright corner of the pane You can close the Start Page pane by clicking the X in the \npanes header If you want to show this page at any time you can use the Help  Start Page menu itemChapter 2  Setting Up\u00a0the\u00a0 environment\n39Select Tools  Java Platform to display the Java Platform Manager dialog box as shown in Figure\u00a0 24 \nIn this image NetBeans IDE is running on JDK 17 which is shown in the Platforms list If you are running it \non JDK 17 JDK 17 will be shown in the Platforms list and you do not need any further configuration\nFigure 23  The in itial NetBeans IDE screenChapter 2  Setting Up\u00a0the\u00a0 environment\n40If you see JDK 17\u00a0in the Platforms list your IDE has been configured to use JDK 17 and you can close \nthe dialog box by clicking the Close button If you do not see JDK 17\u00a0in the Platforms list click the Add \nPlatform button to open the Add Java Platform dialog box as shown in Figure\u00a0 25 Make sure that the Java \nStandard Edition radio button is selected Click the Next  button to display the Add Java Platform dialog \nbox as shown in Figure\u00a0 26\nFigure 24  The J ava Platform Manager dialog boxChapter 2  Setting Up\u00a0the\u00a0 environment\n41\nFigure 25  The Select platform type box\nFigure 26  The Add Java Platform dialog boxChapter 2  Setting Up\u00a0the\u00a0 environment\n42On the Add Java Platform dialog box select the directory in which JDK 17 is installed In this example \nwe installed JDK 17\u00a0in CUsersAdamjdk17 on Windows so we selected the CUsersAdamjdk17  \ndirectory on this dialog box Click the Next  button The Add Java Platform dialog box as shown in \nFigure\u00a0 27 is displayed The Platform Name and Platform Sources fields are prefilled\nClick the Finish button which will bring you back to the Java Platform Manager dialog box showing JDK \n17 as an item in the Platforms list as shown in Figure\u00a0 28 Click the Close button to close the dialog box You \nare done with configuring the NetBeans IDE to use JDK 17\nFigure 27  The A dd Java Platform Platform Name dialog boxChapter 2  Setting Up\u00a0the\u00a0 environment\n43 Summary\nTo work with Java programs you need to install a JDK such as OpenJDK 17 and a Java editor such as \nNetBeans The directory in which the JDK is installed is typically referred to as JDKHOME  JDK installation \ncopies many Java toolscommands in the JDKHOMEbin  directory such as the javac  command to compile a \nJava program the java  command to run a Java program and the jshell  tool to run snippets of Java code\nThe NetBeans IDE can be installed on top of JDK 8 11 or 17 When you install it on top of a JDK other \nthan 17 you need to configure the IDE to use JDK 17 if you want to use it as the Java platform\nFigure 28  After adding JDK 1745\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730743CHAPTER 3\nWriting Java Programs\nIn this chapter you will learn\n\t The structure of a Java program\n\t How to organize the source code of a Java program\n\t How to write compile and run a Java program using the Java Shell a command \nprompt and the NetBeans integrated development environment IDE\n\t What a module graph is\n\t What the modulepath and the classpath are and how to use them\n\t Briefly the Java platform and the Java virtual machine JVM\nThis chapter and the rest of the chapters in this book assume that you have installed JDK 17 and \nNetBeans IDE 125 or later as described in Chapter 2\n The Goal Statement\nThe main goal of this chapter is simplewrite a Java program to print the following message on the console\nWelcome to Java 17\nYou might think How hard would it be to print a message in Java In fact it is not hard to print a \nmessage in Java The following one line of code will print this message\nSystemoutprintlnWelcome to Java 17\nHowever you have to do a lot of plumbing work to print this message in a fullfledged Java program \nWe will show you how to print a message in Java using three methods\n\t Using the Java Shell which is also known as the JShell tool\n\t Using a command prompt or a terminal\n\t Using the NetBeans IDE\nUsing the JShell tool requires no plumbing work and is the easiest of all It will let you print a message \nwithout knowing anything else about the Java programming languageChapter 3  Writing Java programs\n46Using a command prompt requires the most plumbing work and makes you learn the basics of the Java \nprograms structure before you can print a message as the stated goal in this section\nUsing the NetBeans IDE requires a little plumbing work and provides the most help you would need \nas a developer After this chapter you will use only NetBeans to write all programs unless the other two \nmethods are required to show their special features The following sections show you how to achieve the \nstated goal using the three methods\n Using the\u00a0JShell Tool\nChapter 2 has a quick introduction to the JShell tool You need to enter the following line of code to print the \nmessage\nSystemoutprintlnWelcome to Java 17\nWe will explain each part of this code in an upcoming section The following JShell session shows you \nall the steps on a Windows command prompt\ncjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell SystemoutprintlnWelcome to Java 17\nWelcome to Java 17\njshell exit\n  Goodbye\nc\nYou have seen how to execute a Java statement using JShell You have not seen a full Java program yet \nJShell is a very powerful tool and you can use it to learn the Java language quickly For the next few chapters \nit will be a handy tool to experiment with code snippets used in examples We cover all its details in a chapter \nlater in this book\n What Is a\u00a0Java Program\nA Java program which is written using the rules and grammar of the Java programming language is a set of \ninstructions to be executed by a computer to perform a task In the next few sections we explain only the \nbasics involved in writing a Java program We cover a detailed explanation of all aspects of a Java program in \nsubsequent chapters Developing a Java application involves four steps\n\t Writing the source code\n\t Compiling the source code\n\t Packaging the compiled code\n\t Running the compiled code\nYou can write Java programs using a text editor of your choice such as Notepad on Windows and the vi \neditor on UNIX\u00a0The source code is compiled into object code also known as bytecode  using a Java compiler \nThe compiled code is packaged into a JAR  Java Archive file The packaged compiled code is run by a JVM\nWhen you are using an IDE such as NetBeans the IDE provides you with a builtin editor to write the \nsource code The IDE also provides you simple ways to compile package and run the applicationChapter 3  Writing Java programs\n47 Writing the\u00a0Source Code\nThis section covers the details of writing the source code We demonstrate this by using Notepad on \nWindows You can use a text editor of your choice that is available on your operating system\n Note  i  cover using the netBeans iDe later in this chapter i first want to cover using a text editor because \nthe process reveals a lot about Ja va programs that you need to know\nWhen you finish writing the source code you must save the file with the extension java  You are going \nto name your source code file Welcomejava  Note that any extension to the file other than java  is not \nacceptable For example the names like Welcometxt  and Welcomedoc  are not valid source code file names\nWhenever you use a language to write something in your case Java source code you need to follow \nthe grammar of that language and use a specific syntax depending on the thing you are writing Lets take \nan example of writing a letter to your friend The letter will have several parts a heading a greeting a body \nclosing statements and your signature In a letter it is not just important to put all five parts together rather \nthey should also be placed in a specific order For example the closing needs to follow the body Some parts \nin a letter may be optional and others mandatory For example it is fine to exclude the return address in a \nletter to your friend whereas it is mandatory in a business letter In the beginning you can think of writing a \nJava program similar to writing a letter\nA Java program consists of one or more modules A module contains zero or more packages A package \ncontains one or more types The term type  is a generic term that refers to a userdefined data type You can \nhave four types of userdefined data typesclasses interfaces enums and annotations Broadly speaking \nenums and annotations are specialized types of classes and interfaces respectively In the next several \nchapters you will be working with only classes Figure\u00a0 31 shows the arrangement of a module\n Note  m odules were introduced in JDK 9  Up to JDK 8 you had packages and types but no modules \nmodules are an optional way to organize code in addition to packa gesFigure 31  The s tructure of a Java programChapter 3  Writing Java programs\n48Pure Java programs are operating system agnostic You write the same Java code on all operating systems \nOperating systems use different syntax to refer to files and separate file paths While working with Java programs \nyou have to refer to files and directories and you will need to use the syntax for your operating system Windows \nuses a backslash   as a directory separator in a file path for example Cjavafunsrc  whereas UNIXlike \noperating systems use a forward slash   for example homeksharanjavafun  Windows uses a semicolon   \nas a path separator for example Cjava9binCbj9r  whereas UNIXlike operating systems use a colon   \nfor example homeksharanjava9binhomeksharanjavafun  I use Windows to work with examples in this \nbook I also explain the differences while using different operating systems whenever they exist\nWe use the following directory structure to work with the example in this section\n\tjavafun\n\tjavafunsrc\n\tjavafunmod\n\tjavafunlib\nWe named the toplevel directory javafun  which is short for Beginning Java  17 Fun damentals  \nYou can create this directory inside any other directory on your computer For example you can have  \nit as Cjavafun  on Windows and homeksharanjavafun  on UNIX\u00a0You will store the source code in the \njavafunsrc  directory the compiled code in the javafunmod  directory and the packaged code in the \njavafunlib  directory Go ahead and create these directories on your computer You need them in the sections \nthat follow\n Writing Comments\nComments are nonexecutable code that is used to document the code The Java compiler ignores them \nThey are included in source code to document the programs functionality and logic Java supports three \ntypes of comments\n\t Singleline comment\n\t Multiline comment\n\t Documentation comment or Javadoc comment\nA singleline comment starts with two forward slashes   followed by text for example\n This is a singleline comment\npackage comjdojointro  This is also a singleline comment\nA singleline comment may start at any position on a line The part of the line starting from two forward \nslashes to the end of the line is considered a comment As shown previously you can also mix Java source \ncode for example a package declaration and a comment on one line Note that this type of comment \ncannot be inserted in the middle of the Java code The following package declaration which is discussed \nshortly in detail is incorrect because the package name and the semicolon are also considered as part of the \ncomment\npackage  An incorrect singleline comment comjdojointro\nThe following line is a singleline comment It has a valid package declaration as the comments text\nIt will be treated as a comment not as a package declaration\n package comjdojointroChapter 3  Writing Java programs\n49The second type of comment is called a multiline comment A multiline comment may span multiple \nlines It starts with a forward slash immediately followed by an asterisk   and ends with an asterisk \nimmediately followed by a forward slash   An example of a multiline comment in a Java source code is as \nfollows\n\n    This is a multiline comment\n    It can span more than one line\n\nThis comment can also be written using two singleline comments as follows\n This is a multiline comment\n It can span more than one line\nThe style of comment that you use in the source code is your personal choice A multiline comment \nmay be inserted in the middle of Java code as shown here The compiler ignores all text starting from  \n to \npackage  A correct comment  comjdojointro\nThe third type of comment is called a documentation or Javadoc comment which is also a multiline \ncomment It is used to generate documentation for Java programs This kind of comment begins with a \nforward slash immediately followed by two asterisks   and ends with an asterisk that is immediately \nfollowed by a forward slash   The following is a simple example of a documentation comment\n\n   This is a documentation comment javadoc generates documentation from such comments\n\nWriting Javadoc comments is a vast topic It is covered in Appendix B in detail I start all source code \nin this book with a singleline comment that contains the name of the file that contains the source code for \nexample\n Welcomejava\n Declaring a\u00a0Module\nA module acts as a container for packages A module may contain packages that may be used internally \nwithin the module or by other modules A module controls the accessibility of its packages A module \nexports its packages for other modules to use them If a module needs to use packages from another module \nthe first module needs to declare dependency on the second module and the second module needs to \nexport the packages used by the first module The following is the simplified syntax to declare a module\nmodule modulename \n    modulestatement1\n    modulestatement2\nChapter 3  Writing Java programs\n50A modules declaration starts with a keyword module  which is followed with a module name Within \nbraces you place the body of the modules declaration which contains zero or more module statements \nListing 31 contains the complete code for a module named jdojointro \nListing 31  The D eclaration of a Module Named jdojointro\n moduleinfojava\nmodule jdojointro \n     An empty module body\n\nThe jdojointro  module contains no module statements That is it does not export any packages for \nother modules to use and does not depend on any other modules The JDK consists of several modules \none of those modules is named javabase  The javabase  module is known as the primordial module It \ndepends on no other modules and all other modulesbuiltin and userdefinedimplicitly depend on it\n Tip in Ja va three termsdepends on reads and requiresare used interchangeably to indicate \ndependency of one module on another module if module P depends on module Q you can also state it as \nmodule P reads module Q or  module P requires module Q\nThe dependency of a module is declared inside its body using a requires  statement Its simplest syntax \nis as follows\nrequires modulename\nYou have not declared any dependencies for the jdojointro  module However as every module in Java \nimplicitly depends on the javabase  module the compiler will add a dependency to the javabase  module in \nyour jdojointro  module The compilermodified declaration of the module is shown in Listing 32\nListing 32  The C ompilerModified Declaration of the jdojointro Module\n moduleinfojava\nmodule jdojointro \n    requires javabase\n\nIf you wish you can always include a requires javabase  statement in your module declaration\nIf you do not do so the compiler always adds it for you I do not include it in module declarations in this \nbook\nWhy does every module depend on the javabase  module The javabase  module contains several \nJava packages that are required to provide basic functionalities in all Java programs For example you want \nto print a message on the console and the printing functionality is contained in the javabase  module in a \npackage named javalang \nTypically a module declaration is saved in a moduleinfojava  file in the root directory of the source \nfor the module Create a subdirectory named jdojointro  inside the javafunsrc  directory in which you \nplace all source for the jdojointro  module Save the code shown in Listing 31 in a file called javafun\nsrcjdojointromoduleinfojava  This completes your module declarationChapter 3  Writing Java programs\n51Is it mandatory to save the module declaration in a root directory named the same as the module \nname No This is not mandatory You could have saved the moduleinfojava  file inside the javafunsrc  \ndirectory and everything would have worked Saving all source code of a module in a directory named after \nthe module name makes compiling the modules code easier The JDK also supports saving a modules code \nin different root directories\n Declaring Types\nA package is divided into several compilation units A compilation unit contains the source code for these \ntypes For the most part you can think of a compilation unit as a java  file that contains source code for \ntypes such as classes and interfaces When you compile a Java program you compile the compilation units \nthat program comprises Typically a compilation unit contains the declaration of one type For example \nyou are going to declare a class named Welcome  and you will place the source code for the Welcome  class in a \ncompilation unit or a file named Welcomejava  A compilation unit consists of three parts\n\t One package declaration\n\t Zero or more import  declarations\n\t Zero or more type declarations class interface enum or annotation declarations\nAll three parts if present must be specified in the mentioned order Figure\u00a0 32 shows the three parts \nof a compilation unit which contains one type declaration The type is a class named Welcome  Subsequent \nsections describe each part of a compilation unit in detail\n Package Declaration\nThe general syntax for a package declaration is as follows\npackage yourpackagenameFigure 32  Parts of a compilation unitChapter 3  Writing Java programs\n52A package declaration starts with the keyword package  followed with a usersupplied package name \nWhitespace spaces tabs new lines carriage returns and form feeds separates the keyword package  and \nthe package name A semicolon   ends the package declaration For example the following is the package \ndeclaration for a package named comjdojointro \npackage comjdojointro\nFigure 33 shows the parts of a package declaration\nYou supply the package name A package name may consist of one or more parts separated by a dot \n In this example the package name consists of three parts com jdojo  and intro  There is no limit to the \nnumber of parts in a package name You can have a maximum of one package declaration in a compilation \nunit All types declared in a compilation unit become a member of that package The following are some \nexamples of valid package declarations\npackage intro\npackage comjdojointrocommon\npackage comksharan\npackage comjdojointro\nHow do you choose a good package name It is important to keep your package names unique so \nthey do not conflict with other package names used in the same application It is recommended to use the \nreverse domain name notation for the leading part of a package such as comyahoo  for Yahoo comgoogle  \nfor Google etc Using the reverse domain name of the company as the leading part of the package name \nguarantees that a package name will not conflict with package names used by other companies provided \nthey follow the same guidelines If you do not own a domain name make up one that is likely to be unique \nThis is just a guideline There is nothing in practice that guarantees a unique package name for all Java \nprograms written in the world For example I own a domain named jdojocom  and I start all my package \nnames with comjdojo  to keep them unique In this book I start a package name with comjdojo  followed \nby the topic name\nWhy do we use a package declaration A package is a logical repository for types In other words it \nprovides a logical grouping for related types A package can be stored in a hostspecific file system or a \nnetwork location In a file system each part of a package name denotes a directory on the host system \nFor example the package name comjdojointro  indicates the existence of a directory named com which \ncontains a subdirectory named jdojo  which contains a subdirectory named intro  That is the package \nname comjdojointro  indicates the existence of a comjdojointro  directory on Windows and a com\njdojointro  directory on UNIXlike operating systems The intro  directory will contain the compiled \nJava code for all types in the comjdojointro  package A dot which is used to separate parts in a package \nname is treated as a file separator character on the host system Note that a backslash   is the file separator \ncharacter on Windows and a forward slash   is used on UNIXlike operating systemsFigure 33  Parts of a package declaration in a compilation unitChapter 3  Writing Java programs\n53The package name specifies only the partial directory structure in which the compiled Java program \nclass files must exist It does not specify the full path of the class files In this example the package \ndeclaration comjdojointro  does not specify where the com directory is placed It may be placed under the \nC directory or the Cmyprograms  directory or under any other directory in the file system Knowing just \nthe package name is not enough to locate a class file because it specifies only a partial path to the class file \nThe leading part of the class file path in the file system is obtained from the modulepath  which you need to \nspecify when you compile and run Java programs Before JDK 9 class files in a package were located using \nthe classpath which is still supported in JDK 917 for backward compatibility We discuss both approaches \nlater in this chapter\nJava source code is case sensitive The keyword package  has to be written as isin all lowercase The \nword Package  or packAge  cannot replace the keyword package  The package name is also case sensitive On \nsome operating systems the names of files and directories are case sensitive On those systems the package \nnames will be case sensitive as you have seen the package name is treated as a directory name on the host \nsystem The package names comjdojointro  and Comjdojointro  may not be the same depending on the \nhost system that you are working on It is recommended to use package names in all lowercase\nBefore JDK 9 the package declaration in a compilation unit was optional If a compilation unit does \nnot contain a package declaration the types declared in that compilation unit belong to a package called \nunnamed package  JDK 9 does not allow an unnamed package in a module If you are placing your types in \nmodules your compilation unit must contain a package declaration\n Import Declarations\nImport declarations in a compilation unit are optional You may develop a Java application without using \neven a single import declaration Why is an import declaration needed at all Using import declarations \nmakes your life easier It saves you some typing and makes your code cleaner and easier to read In an \nimport declaration you tell the Java compiler that you may use one or more types from a particular package \nWhenever a type is used in a compilation unit it must be referred to by its fully qualified name Using an \nimport declaration for a type lets you refer to a type using its simple name I will discuss simple and fully \nqualified names of a type shortly\nUnlike a package declaration there is no restriction on the number of import declarations in the source \ncode The following are two import declarations\nimport comjdojointroAccount\nimport comjdojoutil\nWe discuss import declarations in detail later in this book In this section we discuss only the meanings \nof all parts of an import declaration\nAn import declaration starts with the keyword import  The second part in an import declaration \nconsists of two parts\n\t A package name from which you want to use types in the current compilation unit\n\t A type name or an asterisk   to indicate that you may use one or more of the types \nstored in the packageChapter 3  Writing Java programs\n54Finally an import declaration ends with a semicolon The previous two import declarations state  \nthe following\n\t We may use a type named Account  by its simple name from the comjdojointro  \npackage\n\t We may use any types by their simple names from the comjdojoutil  package\nIf you want to use a class named Person  from the comjdojocommon  package you need to include one \nof the following two import declarations in your compilation unit\nimport comjdojocommonPerson\nor\nimport comjdojocommon\nThe following import declarations do not include classes in the package com or comjdojo \nimport comjdojointroAccount\nimport comjdojointro\nYou might think that an import declaration like this\nimport com\nwould let you use the simple names of all types whose first part of package declaration is com Java does \nnot support this type of wildcard use in an import declaration You are allowed only to name one type in \na package  comjdojointroAccount  or all types in a package  comjdojointro  any other syntax to \nimport types is invalid\nThe third part in a compilation unit contains type declarations which may contain zero or more \ndeclarations for types class interface enum and annotation According to the Java Language Specification  \ntype declaration is also optional However if you omit this part your Java program does not do anything\nTo make your Java program meaningful you must include at least one type declaration in a compilation \nunit\nI will defer the discussion of interfaces enums and annotations until later chapters in this book\nLets discuss how to declare a class in a compilation unit\n Class Declaration\nIn the simplest form a class declaration looks as follows\nclass Welcome \n     Code for the class body goes here\n\nFigure 34 shows parts of this class declarationChapter 3  Writing Java programs\n55A class is declared by using the keyword class  which is followed by the name of the class In this \nexample the name of the class is Welcome \nThe body of the class is placed between an opening brace and a closing brace The body may be empty \nHowever you must include the two braces to mark the beginning and the end of the body\nOptionally a class declaration may end with a semicolon This book will not use the optional semicolon \nto end a class declaration\nThe simplest class declaration in a Java program may look as follows\nclass Welcome  \nThis time I placed the whole class declaration on one line You can place the keyword class  the \nname of the class Welcome  and the two braces in any position you want except that you must include at \nleast one whitespace character space new line tab etc between the keyword class  and class name \nWelcome  Java allows you to write source code in a freeform text format All of the following three class \ndeclarations are the same\n Class Declaration 1\nclass\nWelcome  \n Class Declaration 2\nclass\n         Welcome \n\n Class Declaration 3\nclass Welcome \nFigure 34  Parts of a class declaration in a compilation unitChapter 3  Writing Java programs\n56This book uses the following class declaration format the opening brace is placed on the same line \nfollowing the class name and the closing brace is placed on a separate line and is aligned with the first \ncharacter of the first line of the class declaration like so\nclass Welcome \n\nThe body of a class consists of four parts All parts are optional may appear in any order and can be \nsplit into multiple sections\n\t Field declarations\n\t Initializers  Static initializers and instance initializers\n\t Constructors\n\t Method declarations\nJava does not impose any order in which the four parts of the body of a class may appear I start with \nmethod declarations and confine the discussion only to simple method declarations in this chapter We \ndiscuss advanced aspects of method declarations and other parts of class body declarations in a later \nchapter\nLets discuss how to declare a method in a class You might guess that the method declaration would \nbegin with a keyword method  as package and class declarations began with the keywords package  and \nclass  respectively However a method declaration does not begin with a keyword method  In fact method  \nis not a keyword in the Java language You begin a class declaration with the keyword class  indicating that \nyou are going to declare a class However in the case of a method declaration the first thing you specify \nis the type of value that a method will return to its caller If a method does not return anything to its caller \nyou must mention that fact at the beginning of the method declaration using the keyword void  The name \nof the method follows the return type of the method The method name is followed with a left and a right \nparenthesis Like a class a method has a body which is enclosed in braces The simplest method declaration \nin Java looks like the following\nmethodreturntype methodname argumentslist \n     Body of the method goes here\n\nThe following is an example of a method declaration\nvoid main \n     Empty body of the main method\n\nThis method declaration contains four things\n\t The method does not return anything as indicated by the keyword void \n\t The name of the method is main \n\t The method requires no arguments\n\t The method does not do anything as its body is emptyChapter 3  Writing Java programs\n57The return value of a method is something that the method returns to its caller The caller of the method \nmay also want to pass some values to the method If a method requires its caller to pass values to it this fact \nmust be indicated in the methods declaration The fact that you want to pass values to a method is specified \nwithin the parentheses that follow the method name You need to specify two things about the values you \nwant to pass to a method\n\t The type of the value you want to pass Suppose you want to pass an integer say 10 \nto the method You need to indicate this by using a keyword int which is used to \nindicate an integer value like 10\n\t The identifier which will hold the value you pass to the method An identifier is a \nuserdefined name It is called a parameter name\nIf you want the main  method to accept one integer value from its caller its declaration will change to the \nfollowing one\nvoid mainint num \n\nHere num is an identifier which will hold the value passed to this method Instead of num you may \nchoose to use another identifier for example num1  num2  num3  myNumber  etc The declaration of the main  \nmethod is read as follows\nThe main method accepts one parameter of the type int and it does not return any value \nto its caller\nIf you want to pass two integers to the main  method its declaration will change to the following\nvoid mainint num1 int num2 \n\nIt is clear from this declaration that you need to separate the parameters passed to a method by a \ncomma   What will you do if you want to pass 50 integers to this method You will end up with a method \ndeclaration like this\nvoid mainint num1 int num2  int num50 \n\nI have shown only three parameter declarations However when you write a Java program you will \nhave to type all 50 parameter declarations Lets look for a better way to pass 50 parameters to this method \nThere is one similarity among all 50 parametersthat they are all of the same type an integer No values \nwill contain fractions like 2011 or 4509 This similarity among all parameters allows you to use a magical \ncreature in the Java language called an array  What is required to use an array to pass 50 integer parameters \nto this method When you write\nint num\nit means that num is an identifier of the type int and it can hold one integer value If you place two magic \nbrackets   after int as in\nint numChapter 3  Writing Java programs\n58it means that num is an array of int and it can hold as many integer values as you want There is a limit to \nthe number of integers that num can hold However that limit is very high and we discuss that limit when we \ndiscuss arrays in detail The values stored in num can be accessed using subscripts num0  num1  num2  \netc Note that in declaring an array of the type int you have not mentioned the fact that you want num to \nrepresent 50 integers Your modified declaration for the main  method which can accept 50 integers would \nbe as follows\nvoid mainint num \n\nHow will you declare the main  method that will let you pass names of 50 persons Since int can only \nbe used for integers you must look for some other type that represents text in the Java language because the \nname of a person will be text not an integer There is a type String  note the uppercase S in String  that \nrepresents text in the Java language Therefore to pass 50 names to the method main  you can change its \ndeclaration as follows\nvoid mainString name \n\nIn this declaration you need not necessarily change the parameter name from num to name  You \nchanged it just to make the meaning of the parameter clear and intuitive Now lets add some Java code to \nthe body of the main  method which will print a message on the console\nSystemoutprintlnThe message you want to print\nThis is not the appropriate place to discuss what System  out and println  are all about For now just \ntype in System  note the uppercase S in System  a dot out a dot and println  followed by two parentheses \nthat contain the message you want to print within double quotes You want to print a message  Welcome to \nJava 17  so your main  method declaration will be as follows\nvoid mainString name \n    SystemoutprintlnWelcome to Java 17\n\nThis is a valid method declaration that will print a message on the console Your next step is to compile \nthe source code which contains the Welcome  class declaration and run the compiled code When you run a \nclass the Java runtime looks for a method named main  in that class and the declaration of the method must \nbe as follows though name  could be any identifier\npublic static void mainString name \n\nApart from two keywords public  and static  you should be able to understand this method declaration \nwhich states  main  is a method that accepts an array of String  as a parameter and returns nothing \nFor now you can think of public  and static  just as two keywords which must be present to declare \nthe main  method Note that the Java runtime also requires that the name of the method be main  This is the \nreason that I chose main  as the name of the method from the very beginning The final version of the source \ncode is shown in Listing 33 I made two changes\n\t I declared the Welcome  class as public\n\t I named the parameter to the main method as args Chapter 3  Writing Java programs\n59Save the source code in a file named Welcomejava  in the javafunsrcjdojointrocomjdojointro  \ndirectory\nListing 33  The S ource Code for the Welcome Class\n Welcomejava\npackage comjdojointro\npublic class Welcome \n    public static void mainString args \n        SystemoutprintlnWelcome to Java 17\n    \n\nThe Java compiler imposes a restriction on the file name of the source code If you have declared a \npublic type eg a class or interface in a compilation unit the file name of the compilation unit must be \nthe same as the name of the public type In this example you have declared the Welcome  class public which \nrequires you to name the file as Welcomejava  This also means that you cannot declare more than one \npublic type in a compilation unit You can have maximum one public type and any number of nonpublic \ntypes in a compilation\nAt this point the source directory and files for this example look as follows\n\tjavafunsrcjdojointromoduleinfojava\n\tjavafunsrcjdojointrocomjdojointroWelcomejava\n Types Have Two Names\nEvery class in fact every type in Java has two names\n\t A simple name\n\t A fully qualified name\nThe simple name of a class is the name that appears after the class  keyword in the class declaration In \nthis example Welcome  is the simple name of the class The fully qualified name of a class is its package name \nfollowed by a dot and its simple name In this example comjdojointroWelcome  is the fully qualified \nname of the class\nSimpleName  Name appearing in the type declaration\nFullyQualifiedName  package name    SimpleName\nThe next question that might arise in your mind is What is the fully qualified name of a class that \ndoes not have a package declaration The answer is simple In such a case the simple name and the fully \nqualified name of the class are the same If you remove the package declaration from the source code \nWelcome  will be both names for your class\n Compiling the\u00a0Source Code\nCompiling is the process of translating the source code into a special binary format called bytecode  This \nis accomplished using a program usually called a compiler called javac  which ships with the JDK\u00a0The \nprocess of compiling Java source code is shown in Figure\u00a0 35Chapter 3  Writing Java programs\n60You supply the source code in your case Welcomejava  and moduleinfojava  as input to the Java \ncompiler and it generates two files with the extension class  The file with the extension class  is called \na class file A class file is in a special format called bytecode Bytecode is a machine language for the Java \nvirtual machine JVM We discuss the JVM and bytecode later in this chapter\nNow I walk through the steps that are needed to compile the source code on Windows For other \nplatforms for example UNIX and Mac OS X you need to use the file path syntax specific to those platforms \nI assume that you have saved the two source files on Windows as follows\n\tCjavafunsrcjdojointromoduleinfojava\n\tCjavafunsrcjdojointrocomjdojointroWelcomejava\nOpen a command prompt and change the current directory to the Cjavafun  The prompt should look \nas follows\nCjavafun\nThe syntax to use the javac  command is as follows\njavac d outputdirectory sourcefile1 sourcefile2sourcefileN\nThe d option specifies the output directory where the compiled class files will be placed You can \nspecify one or more source code files If the d option is not specified the compiled class files are placed in \nthe same location as the source file\nYour output directory will be javafunmodjdojointro  because you want to place all class files in \nthis directory You will specify two source files which will be moduleinfojava  and Welcomejava  The \nfollowing command will compile your source code The command is entered on one line not on two as \nshown\nCjavafunjavac d modjdojointro srcjdojointromoduleinfojava srcjdojointrocom\njdojointroWelcomejava\nNote that the command uses relative paths such as mod and src which are relative to the current \ndirectory Cjavafun  If you wish you can use absolute paths such as Cjavafunmodjdojointro \nIf you do not get an error message it means your source files were compiled successfully and the \ncompiler generated two files named moduleinfoclass  and Welcomeclass  as follows\n\tCjavafunmodjdojointromoduleinfoclass\n\tCjavafunmodjdojointrocomjdojointroWelcomeclassFigure 35  The process of compiling Java source code into bytecodeChapter 3  Writing Java programs\n61Note that the compiler placed the Welcomeclass  file by creating a directory hierarchy that mirrored \nthe package declaration in the Welcomejava  file Recall that a package name mirrors a directory hierarchy \nFor example a package named comjdojointro  corresponds to a directory named comjdojointro  You \nhad placed the Welcomeclass  file by creating a directory hierarchy mirroring the package name The Java \ncompiler is smart enough to read the package name and create a directory hierarchy in the output directory \nto place the generated class files\nIf you get any error while compiling the source code there could be one of three reasons\n\t You have not saved the moduleinfojava  and Welcomejava  files in the directories \nas specified at the beginning of this section\n\t You may not have installed JDK 17 on your machine\n\t If you have already installed JDK 17 you have not added the JDKHOMEbin  directory \nto the PATH  environment variable where JDKHOME  refers to the directory where you \ninstalled JDK 17 on your machine If you installed JDK 17\u00a0in the directory Cjava17  \nyou need to add Cjava17bin  to the PATH  environment variable on your machine\nIf the discussion about setting the PATH  environment variable did not help you can use the following \ncommand This command assumes that you have installed the JDK in the directory Cjava17 \nCjavafun Cjava17binjavac d modjdojointro srcjdojointromoduleinfojava  \nsrcjdojointrocomjdojointroWelcomejava\nIf you get the following error message while compiling your source code it means you are using an \nolder version of the JDK for example JDK 8\nsrcjdojointromoduleinfojava1 error class interface or enum expected\nmodule jdojointro \nModules are supported starting in JDK 9 Compiling the moduleinfojava  source file on older JDKs \nwill cause this error The fix is to use the javac  command from JDK 17 to compile your source files\nThe name of the bytecode file the class  file is Welcomeclass  Why did the compiler choose to name \nthe class file Welcomeclass  You have used the word Welcome at three places when you wrote the source \ncode and compiled it\n\t First you declared a class named Welcome \n\t Second you saved the source code in a file named Welcomejava \n\t And third you passed the Welcomejava  file name to the compiler as an input\nWhich one of your three steps prompted the compiler to name the generated bytecode file as Welcome\nclass  As a first guess it appears to be the third step which is passing Welcomejava  as an input file name to \nthe Java compiler However the guess is wrong It is the first step which is declaring a class named Welcome  \nin the file Welcomejava  which prompted the compiler to name the output bytecode file Welcomeclass  \nYou can declare as many classes as you want in one compilation unit Suppose you declare two classes \nWelcome  and Bye in a compilation unit named Welcomejava  What file name will the compiler choose to \nname the output class file The compiler scans the whole compilation unit It creates one class file for each \nclass in fact for each type declared in the compilation unit If the Welcomejava  file had three classes\nWelcome  Thanks  and Byethe compiler would have generated three class files Welcomeclass  Thanks\nclass  and Byeclass Chapter 3  Writing Java programs\n62To run a Java program you can arrange class files\n\t In exploded directories as you have them at this point\n\t In one or more JAR files\n\t Or a combination of the twoexploded directories and JAR files\nYou can run your program now using the class files in the javafunmodjdojointro  directory I will \ndefer running it for now First we will show you how to package your compiled code into a JAR file in the \nnext section\n Packaging the\u00a0Compiled Code\nThe JDK ships with a tool named jar which is used to package Java compiled code in JAR files The JAR file \nformat uses the ZIP format A JAR file is simply a ZIP file with a jar  extension and a MANIFESTMF  file in its \nMETAINF  directory The MANIFESTMF  file is a text file that contains information about the JAR file and its \ncontents that is used by different Java tools The JDK also contains APIs to programmatically work with JAR \nfiles In this section we explain briefly how to use the jar tool to create a JAR file The syntax to use the jar \ncommand is as follows\njar options C dirtochange filelist\nThe create  option creates a new JAR file The file  option is used to specify the name of the JAR file \nto be created The C option is used to specify a directory which will be used as the current directory and \nall the files specified following this option will be included in the JAR file If you want to include files from \nseveral directories you can specify the C option multiple times\nThe following command creates a JAR file named comjdojointrojar  in the Cjavafunlib  \ndirectory Make sure that the Cjavafunlib  directory exists before you run the command\nCjavafunjar create file libcomjdojointrojar C modjdojointro \nHere\n\t The create  option specifies that you want to create a new JAR file\n\t The file libcomjdojointrojar  option specifies the path and the name \nof the new file Note that the file path starts with lib which is relative to the C\njavafun  directory You are free to use an absolute path such as Cjavafunlib\ncomjdjointrojar \n\t The C modjdojointro  option specifies that the jar command should change to \nthe modjdojointro  directory\n\t Note that the C option is followed by a space which in turn is followed with a dot \nor the command ends with a dot A dot means the current directory which is the \ndirectory specified with the C option It says to change to the modjdojointro  \ndirectory and include all files in that directory recursively\nThis command creates the following file\nCjavafunlibcomjdojointrojarChapter 3  Writing Java programs\n63You can use the list  option with the jar command to list the contents of a JAR file Use the following \ncommand to list the contents of the comjdojointrojar  file which was created by the previous command\nCjavafunjar list file libcomjdojointrojar\nMETAINF\nMETAINFMANIFESTMF\nmoduleinfoclass\ncom\ncomjdojo\ncomjdojointro\ncomjdojointroWelcomeclass\nThe output shows all directories and files in the JAR file You did not have a file named MANIFESTMF  \nin the input directory The jar command creates a MANIFESTMF  file for you You can also see that the root \ndirectory of the JAR file contains the moduleinfoclass  file and the Welcomeclass  file has been placed in \na directory mirroring the directory it was placed in the modjdojointro  directory which in turn mirrored \nthe directory hierarchy specified in its package name\nIf a JAR file contains a moduleinfoclass  file which is also known as a module descriptor the file is \ncalled a modular  JAR\u00a0Otherwise the file is simply known as a JAR\u00a0In this example the comjdojointro\njar file is a modular JAR\u00a0If you remove the moduleinfoclass  file from it it will become a JAR\n Ti p a  Jar file that contains a module descriptor  moduleinfoclass  in its root directory is known as a \nmodular J ar\u00a0there were no modules before JDK 9 and so there were no modular J ars\nYou can use the jar tool to describe a module using the describemodule  option and by specifying \nthe modular JAR using the file  option The following command describes the module packaged in the \ncomjdojointrojar  file\nCjavafunjar describemodule file libcomjdojointrojar\njdojointro jarfileCjavafunlibcomjdojointrojarmoduleinfoclass\nrequires javabase mandated\ncontains comjdojointro\nConsider the output of this command\n\t The first line starts with the module name which is jdojointro  The name is \nfollowed with the path to the module description The path uses a jar scheme and \npoints to the file system\n\t The second line mentions a requires  statement indicating that the jdojointro  \nmodule requires the javabase  module Recall that every module implicitly depends \non the javabase  module The compiler added this for you The last word mandated  \nindicates that the dependency on the javabase  module is mandated by the Java \nmodule systemChapter 3  Writing Java programs\n64\t The third line indicates that the jdojointro  module contains a package named \ncomjdojointro  The phrase contains  is used to indicate that the package is in \nthe module but it is not exported by the module so other modules cannot use this \npackage For every exported package this command will print the following\nexports packagename\nThe last line in the output needs a bit of explanation Figure\u00a0 31 shows that a module contains one \nor more packages The output shows that the jdojointro  module contains a comjdojointro  package \nHowever you never specified a link between the module and the packagenot when writing the source \ncode nor during the compilation or packaging So how do modules know the packages they contain The \nanswer is simple Placing the moduleinfoclass  file in the root directory makes the module contain all \npackages underneath In your case the comjdojointro  directory that mirrors the comjdojointro  \npackage for the Welcome  class is underneath the root directory in the module JAR\u00a0This is the reason that it \nbecame a part of the module\n Tip a modular J ar contains code for only one module  all packa ges under the root directory are part of \nthat module\n Running a\u00a0Java Program\nA Java program is run by a JVM\u00a0A JVM is invoked using a command called java  which is located in  \nthe JDKHOMEbin  directory The java  command is also known as a Java launcher The syntax to run it is \nas follows\njava options module modulenamemainclassname arguments\nHere\n\toptions  indicate zero or more options passed to the java  command\n\t The module  option specifies the module name and the main class name inside the \nmodule modulename  is the module name for example jdojointro  and main\nclassname  is the fully qualified name  of the main class for example comjdojo\nintroWelcome  When you package a module in a modular JAR you can specify \nthe main class name for the module which is stored in the module descriptorthe \nmoduleinfoclass  file You have not specified the main class name when you \ncreated the comjdojointrojar  modular JAR in the last section Passing the \nmainclassname  is optional If it is not specified the java  command will use \nthe main class name from the module descriptor The command calls the main  \nmethod of the mainclassname \n\targuments  is a spaceseparated list of arguments passed to the main  method \nof the main class Note that options  are passed to the java  command or JVM \nwhereas arguments  are passed to the main  method of the main class being run \narguments  must be specified after the module  optionChapter 3  Writing Java programs\n65Lets try to run the Welcome  class using the following command\nCjavafunjava module jdojointrocomjdojointroWelcome\nError occurred during initialization of boot layer\njavalangmoduleFindException Module jdojointro not found\nOops You got an error We used this command intentionally so you can understand the behindthe\nscene process that takes place when you run a Java program using modules There are two messages in the \noutput\n\t The first message states that an error occurred when the JVM was trying to initialize \nthe boot layer\n\t The second message states that the JVM was not able to find the jdojointro  \nmodule\nAt startup the JVM resolves modules dependencies If all required modules are not resolved at \nstartup the program fails to start This is a significant improvement of using modules in Java 9 where all \ndependencies are verified at startup Otherwise the runtime would attempt to resolve the dependencies the \ntypes as the program needed them not at startup which leads to many runtime surprises\nAll modules that are accessible to the module system in a phase compile time or runtime are called \nobservable modules  Module resolution starts with a set of initial modules called root modules  and follows \nthe dependency chain until the javabase  module is reached The set of resolved modules is called a \nmodule graph  In a module graph each module is represented as a node A directed edge from a module to \nanother module exists if the first module depends on the second module\nFigure 36 shows a module graph with two root modules named A and B Module A depends on module \nP which in turn depends on the javabase  module Module B depends on module Q which in turn depends \non the javabase  module The Java runtime will only use resolved modules That is the Java runtime knows \nonly about the modules in the module graphChapter 3  Writing Java programs\n66Typically you have only one root module How is the set of root modules determined When you run a \nJava program from a module the module containing the main class is the only default root module\n Tip if you need to resolve additional modules  which otherwise wont be resolved by default you can \nadd them to the default set of root modules using the addmodules  commandline option We will defer \ndiscussion of adding root modules to later chapters because it is an advanced topic\nLets get back to resolving our error The previous command tried to run the Welcome  class which is in \nthe jdojointro  module Therefore the jdojointro  module is the only root module If everything was fine \nthe JVM would have created a module graph as shown in Figure\u00a0 37\nFigure 36  A module g raphChapter 3  Writing Java programs\n67To construct this module graph the JVM needed to locate the root module jdojointro  The JVM will \nlook for a module only in the set of observable modules The second line in the error indicates that the JVM \ncould not find the root module jdojointro  To fix the error you need to include the jdojointro  module \nin the set of observable modules You know that the modules code exists at two locations\n\tjavafunmodjdojointro directory\n\tjavafunlibcomjdojointrojar file\nThere are two types of modules builtin modules that are shipped with the JDK and the userdefined \nmodules that you create The JVM knows about all builtin modules and includes them in the set of \nobservable modules You need to specify the locations of the userdefined modules using the modulepath  \noption Modules found on the modulepath will be included in the set of observable modules and they will \nbe resolved during the module resolution process The syntax to use this option is as follows\nmodulepath yourmodulepath\nModulepath  is a sequence of pathnames where a pathname may be a path to a directory a modular \nJAR or a JMOD file The path can be absolute or relative We discuss JMOD files later in this book \nPathnames are separated by a platformspecific path separator character which is a colon   on the UNIX\nlike platforms and a semicolon   on Windows The following are valid modulepaths on Windows\n\tCjavafunlib\n\tCjavafunlibCjavafunmodjdojocontactcomjdojocontactjar\n\tCjavafunlibCjavafunextlib\nThe first modulepath contains the path to a directory named Cjavafunlib  The second one contains \nthe path to a Cjavafunlib  directory and a modular JAR at Cjavafunmodjdojocontactcomjdojo\ncontactjar  The third one contains paths to two directories Cjavafunlib  and Cjavafunextlib  \nThe equivalent of these modulepaths on a UNIXlike platform will look similar to these\n\thomeksharanjavafunlib\n\thomeksharanjavafunlibhomeksharanjavafunmodjdojocontactcom\njdojocontactjar\n\thomeksharanjavafunlibhomeksharanjavafunextlib\nFigure 37  The module graph created at startup when the Welcome class is runChapter 3  Writing Java programs\n68How does the JVM find modules using the modulepath The JVM scans all modules present on the \nmodulepaths using the following rules\n\t If the pathname is a directory three places are scanned for moduleinfoclass  files \ncontaining modules the directory itself all immediate subdirectories and the root \ndirectories of all modular JARs in the directory If a moduleinfoclass  file is found \nin any of these places that module is included in the set of observable modules Note \nthat subdirectories are not scanned recursively\n\t If the pathname is a modular JAR or a JMOD file the modular JAR or the JMOD file is \nconsidered to contain a module which is included in the set of observable modules\nUsing the first rule if you place N modular JARs in a Cjavafunlib  directory specifying this directory \non the modulepath will include all N modules in the set of observable modules You can use the second \nform the path to a modular JAR or JMOD file if you have multiple modules in a directory but you want to \ninclude only a few of them in the set of observable modules\nYou have placed the modular JAR named comjdojointrojar  for this example into the Cjavafun\nlib directory Therefore specifying Cjavafunlib  as the modulepath will enable the JVM to find the \njdojointro  module Lets use the following command to run the Welcome  class\nCjavafunjava modulepath Cjavafunlib module jdojointrocomjdojointroWelcome\nWelcome to Java 17\nThis command assumes that Cjavafun  is the current directory You could have used a relative path \non the modulepath which would be lib instead of Cjavafunlib  as shown\nCjavafunjava modulepath lib module jdojointrocomjdojointroWelcome\nWelcome to Java 17\nThis time the JVM was able to find the jdojointro  module It found a modular JAR the comjdojo\nintrojar  file inside the Cjavafunlib  directory which contained the jdojointro  module\nYou saved the compiled classes for the module in the Cjavafunmodjdojointro  directory The \nmodule code exists in exploded directories inside this directory The root directory contains the module\ninfoclass  file You can also run a class inside a module whose code is saved inside an exploded directory \nstructure like the one in the Cjavafunmodjdojointro  directory The following command runs the \nWelcome  class inside the jdojointro  module whose code is in the Cjavafunmodjdojointro  directory\nCjavafunjava modulepath Cjavafunmodjdojointro module jdojointrocomjdojo\nintroWelcome\nWelcome to Java 17\nThis time the JVM scanned the Cjavafunmodjdojointro  directory and found a moduleinfo\nclass  file that contains the jdojointro  modules descriptorChapter 3  Writing Java programs\n69You can run the same command using the Cjavafunmod  directory as a part of the modulepath as \nfollows\nCjavafunjava modulepath Cjavafunmod module jdojointrocomjdojointroWelcome\nWelcome to Java 17\nHow did the JVM find the jdojointro  module this time Recall the rules for finding module \ndescriptors in a directory The JVM looked in the Cjavafunmod  directory for a moduleinfoclass  file \nwhich does not exist It looked for any modular JARs in the directory and found none Now it looked for \nimmediate subdirectories of the Cjavafunmod  directory It found one subdirectory named jdojointro  \nIt scanned the jdojointro  subdirectory for a moduleinfoclass  file and it found one having the module \ndescriptor for the jdojointro  module This is how the jdojointro  module was found\nMany GNUstyle options also have shorter names For example you can use the shorter names p and   \nm for the modulepath  and module  options respectively The previous command can also be written as \nfollows\nCjavafunjava p Cjavafunmod m jdojointrocomjdojointroWelcome\nResolving a module does not load all classes in that module It would be inefficient to load all classes \nin all modules at once Classes are loaded as and when they are referenced for the first time in the program \nThe JVM only locates the module and does some housekeeping to have more pieces of information about \nthe module For example it keeps track of all packages that the module contains How did the JVM load the \nWelcome  class The JVM used three pieces of information of a class the modulepath the module name and \nthe fully qualified name of the class You specified two pieces of information when you ran the Welcome  class\n\t The main module name which is jdojointro  This made the JVM locate this \nmodule and know that this module contains the comjdojointro  package Recall \nthat a package corresponds to a directory structure In this case the JVM knows that \ninside the module contents a modular JAR or a directory containing the module \ndescriptor there exists a package comjdojointro  which holds the contents in the \ncomjdojointro  package\n\t Along with the main module you specified the fully qualified name of the main \nclass which was comjdojointroWelcome  To locate the Welcome  class the JVM \nfirst finds the module that contains the comjdojointro  package It finds the jdojo\nintro  module to contain this package It converts the package name into a directory \nhierarchy appends a class  extension to the class name and tries to locate the class \nat comjdojointroWelcomeclass \nWith these two rules lets locate the Welcome  class file If you have specified the javafunlib  directory \nas the modulepath the comjdojointrojar  file contains the contents of the jdojointro  module and \nthis file also contains the comjdojointroWelcomeclass  file This is how the Welcome  class file will be \nlocated and then loaded If you specified the javafunmod  directory as the modulepath the javafunmod\njdojointro  directory contains the contents of the jdojointro  module and this directory also contains \nthe comjdojointroWelcomeclass  file Figure\u00a0 38 depicts the process of finding the Welcomeclass  \nfile when the Welcome  class needs to be loaded The figure uses the Cjavafunmodjdojointro  as the \nlocation of the module and Windows path separator which is a backslash The path separator will be a \nforward slash on UNIXlike operating systems JAR files also use a forward slash as a path separatorChapter 3  Writing Java programs\n70This example was simple It involved only two modules javabase  and jdojointro  If you followed \nthe discussion you know how these modules were resolved when you ran the Welcome  class There are \nseveral commandline options that help you understand what goes on behind the scenes when you use \nmodules The following section explores such commandline options\n Playing with\u00a0Module Options\nThere are commandline options that let you obtain more information about which modules are used and \nhow those modules are resolved These options are useful for debugging or reducing the number of resolved \nmodules In this section I show you a few examples of using a few of those options\n Listing Observable Modules\nUsing the listmodules  option with the java  command you can print a list of observable modules The \noption does not take any arguments The following command will print a list of all platform modules that \nare included in the set of observable modules The command prints approximately 100 modules A partial \noutput is shown\nCjavafunjava listmodules\njavaactivation17\njavabase17\njavadesktop17\njavase17\njavaseee17\nFigure 38  The process of finding a class file in a module using the modulepathChapter 3  Writing Java programs\n71In the output the module name is followed by a string 17  If a module descriptor contains a module \nversion the version is displayed after the  sign If you are using the final release of JDK 17 the version \nnumber will be 17 \nTo include your modules in the set of observable modules you need to specify the modulepath where \nyour modules are placed The following command will include the jdojointro  module in the set of \nobservable modules Partial output is shown\nCjavafunjava modulepath Cjavafunlib listmodules\njavaactivation17\njavabase17\njavadesktop17\njavase17\njavaseee17\n\njdojointro fileCjavafunlibcomjdojointrojar\nNote the last entry in the output\n\t It did not print a module version of the jdojointro  module This is because you \nhad not specified a module version when you created the modular JAR comjdojo\nintrojar  I will show you in the next section how to specify a version of your \nmodule\n\t It printed the path of the modular JAR in which the jdojointro  module was \nfound This is very helpful in debugging when your modules are not correctly being \nresolved\n Limiting the\u00a0Observable Modules\nYou can reduce the number of observable modules using limitmodules  It accepts a commaseparated \nlist of module names\nlimitmodules modulenamemodulename\nThe observable modules are limited to the list of the specified modules along with the modules they \ndepend on recursively plus the main module specified using the module  option plus any modules \nspecified using the addmodules  option This option is useful when you run a Java program in legacy \nmode by placing the JARs on the classpath in which case all platform modules are included in the set of root \nmodules\nLets see the effect of this option by using it while running the Welcome  class The Welcome  class uses \nonly the javabase  module To limit the observable modules to the javabase  and jdojointro  modules \nyou can specify javabase  as the value for the limitmodules  option as shown\nCjavafunjava modulepath Cjavafunlib limitmodules javabase module jdojointro\ncomjdojointroWelcome\nWelcome to Java 17Chapter 3  Writing Java programs\n72Note that even though you have specified only the javabase  module to the limitmodulus  option \nthe jdojointro  module is also included in the observable modules because it is the main module you are \nrunning\nYou can use the verbosemodule  option to print the loaded module The following command runs the \nWelcome  class with the limitmodule  option and loads only two modules\nCjavafunjava modulepath Cjavafunlib limitmodules javabase verbosemodule   \nmodule jdojointrocomjdojointroWelcome\n0079sinfomoduleload javabase location jrtjavabase\n0135sinfomoduleload jdojointro location fileCjavafunlibcomjdojointrojar\nWelcome to Java 17\nThe following command runs the Welcome  class without the limitmodule  option and loads about 40 \nmodules A partial output is shown\nCjavafunjava modulepath Cjavafunlib verbosemodule module jdojointrocom \njdojointroWelcome\n0082sinfomoduleload javabase location jrtjavabase\n0142sinfomoduleload jdknamingrmi location jrtjdknamingrmi\n0144sinfomoduleload jdkscripting location jrtjdkscripting\n0144sinfomoduleload javalogging location jrtjavalogging\n0144sinfomoduleload jdojointro location fileCjavafunlibcomjdojointrojar\n0156sinfomoduleload javamanagement location jrtjavamanagement\n\nWelcome to Java 17\n Describing a\u00a0Module\nYou can describe a module using the describemodule  option with the java  command Recall that you \ncan also use this option with the jar command see the Packaging the Compiled Code section for an \nexample to describe a module in a modular JAR\u00a0Make sure to specify the modulepath when you describe \nyour module To describe the platform modules you do not need to specify the modulepath The following \ncommands show a few examples\nCjavafunjava modulepath Cjavafunlib describemodule jdojointro\njdojointro fileCjavafunlibcomjdojointrojar\nrequires javabase mandated\ncontains comjdojointroChapter 3  Writing Java programs\n73Cjavafunjava describemodule javasql\njavasql17\nexports javasql\nexports javaxsql\nrequires javalogging transitive\nrequires javaxml transitive\nrequires javabase mandated\nrequires javatransactionxa transitive\nuses javasqlDriver\n Printing Module Resolution Details\nUsing the showmoduleresolution  option with the java  command you can print the details of the \nmodule resolution process that occurs at startup The following command uses this option when the \nWelcome  class is run A partial output is shown\nCjavafunjava modulepath Cjavafunlib showmoduleresolution module jdojo \nintrocomjdojointroWelcome\nroot jdojointro fileCjavafunlibcomjdojointrojar\njavabase binds jdkzipfs jrtjdkzipfs\njavabase binds jdkjdeps jrtjdkjdeps\njavabase binds javadesktop jrtjavadesktop\njavadesktop requires javaxml jrtjavaxml\njavadesktop requires javadatatransfer jrtjavadatatransfer\njavadesktop requires javaprefs jrtjavaprefs\n\nWelcome to Java 17\nThe first line in the output shows the root module that is resolved and the location of the root module \nThe javabase  module does not require any other modules However it uses many service providers if they \nare present The javabase binds   text in the output indicates that the service providers used by the \njavabase  module are present in the set of observable modules and they are resolved A service provider \nmodule may require other modules which will be resolved as well The resolution of the javadesktop  \nmodule is one such case The javadesktop  module is resolved because it provides a service used by the \njavabase  module which triggers resolving the javaxml  javadatatransfer  and javaprefs  modules \nbecause the javadesktop  module requires these three modules\n Ti p e ven though your program uses only the javabase  module which does not require any other \nmodules other platform modules will be resolved because they provide services used by the javabase  \nmodule the best way to limit the platform modules to the javabase  module is to use the limit\nmodules  option with javabase  as its valueChapter 3  Writing Java programs\n74 DryRunning Your Program\nYou can dryrun a class using the dryrun  option It creates the JVM and loads the main class but does \nnot execute the main  method of the main class This option is useful for verifying the module configuration \nand for debugging purposes The following command shows its use The output does not contain a welcome \nmessage because the main  method of the Welcome  class is not executed A partial output is shown\nCjavafunjava modulepath Cjavafunlib dryrun showmoduleresolution module \njdojointrocomjdojointroWelcome\nroot jdojointro fileCjavafunlibcomjdojointrojar\njavabase binds jdkzipfs jrtjdkzipfs\njavabase binds javalogging jrtjavalogging\njavabase binds jdklocaledata jrtjdklocaledata\n\n Enhancing a\u00a0Module Descriptor\nYou declare a module in a moduleinfojava  file A module declaration is compiled into a class file named \nmoduleinfoclass  The modules designer could have used XML or JSON format to declare a module Why \ndid they choose the class file format to store the module declaration There are several reasons for this\n\t The class file format was already well known to the Java community\n\t The class file format is extensible That is tools can augment the moduleinfoclass  \nfile after compilation\n\t The JDK already supported a similar file named packageinfojava  which is \ncompiled into a packageinfo class file to store package information\nThe jar tool contains a few options to augment a module descriptor two of which are module version \nand main class name You cannot specify the version of a module in its declaration The JDK 9 designer \nstayed away from dealing with a modules version in its declaration stating that managing a modules \nversion is the job of a build tool such as Maven or Gradle not of the module system provider Given the \nextensible nature of the module descriptor you can store a modules version in the moduleinfoclass  file \nas an attribute of the class file As a developer it is not easy to add class file attributes You can use the   \nmoduleversion  option of the jar tool to add a module version to the moduleinfoclass  file You have \nalready created a comjdojointrojar  file which contains the module descriptor for the jdojointro  \nmodule Lets rerun the command that describes the jdojointro  module in the existing comjdojointro\njar file as follows\nCjavafunjar describemodule file libcomjdojointrojar\njdojointro jarfileCjavafunlibcomjdojointrojarmoduleinfoclass\nrequires javabase mandated\ncontains comjdojointroChapter 3  Writing Java programs\n75There is no module version in the output The following command recreates the comjdojointrojar  \nfile by specifying the module version as 10\nCjavafunjar create moduleversion 10 file libcomjdojointrojar C modjdojointro\n Ti p t ypically  you should append the module version to the module J ar name in the previous example \nyou should name the file comjdojointro10jar  so its owner will know what version of the module is \nstored in this modular J ar\u00a0i chose the same name  comjdojointrojar  to keep things simple for this \nexample\nThe following command redescribes the module and the output shows the module name and its \nversion If a version is present a module name is printed in the form of modulenamemoduleversion \nCjavafunjar describemodule file libcomjdojointrojar\njdojointro10 jarfileCjavafunlibcomjdojointrojarmoduleinfoclass\nrequires javabase mandated\ncontains comjdojointro\nIn a typical application you will have one main module which is a module containing a main class \nYou can store the name of the main class in the module descriptor All you need to do is use the main\nclass  option with the jar tool when you create or update the modular JAR\u00a0The main class name is the fully \nqualified name of the class that contains the main  method that you want to use as an entry point for the \napplication The following command updates the existing modular JAR to add a main class name\nCjavafunjar update mainclass comjdojointroWelcome file libcomjdojointrojar\nThe following command recreates the modular JAR with a module version and a main class name\nCjavafunjar create moduleversion 10 mainclass comjdojointroWelcome  \nfile libcomjdojointrojar C modjdojointro \nWhat do you do with the module version and main class in the module descriptor The module version \nis meant to be used by build tools such as Maven and Gradle You need to include correct versions of a \nmodule in your application when multiple versions of the module exist If your module descriptor contains a \nmain class attribute you can use the name of the module to run the application The JVM will read the main \nclass name from the module descriptor Now your module descriptor for the jdojointro  module contains \nthe main class name The following command will run the Welcome  class\nCjavafunjava modulepath Cjavafunlib module jdojointro\nWelcome to Java 17Chapter 3  Writing Java programs\n76 Running Java Programs in\u00a0Legacy Mode\nThe module system was introduced in JDK 9 How were Java programs written compiled packaged and \nrun before Take the module system out and you will find that Java programs were almost written the same \nway before However the mechanism to run them was different The Welcome  class that you have written in \nthis chapter will also compile and run in JDK 8 Barring a few exceptions Java has always been backward \ncompatible Programs that you wrote in JDK 8 will also work in JDK 17\nBefore JDK 9 classes were always located using the classpath The classpath is a sequence of directories \nJAR files and ZIP files Each entry in the classpath is separated by a platformspecific path separator \ncharacter which is a semicolon   on Windows and a colon   on UNIXlike operating systems If you \ncompare the definition of the classpath and that of the modulepath they look the same The difference \nbetween them is that the classpath is used to locate classes more specifically types whereas the \nmodulepath is used to locate modules\n Ti p Y ou will encounter two terms loading classes and loading modules When a class is loaded its \nclass file is readeither from a modulepath or classpathand the class is represented as an object at runtime \nWhen a module is loaded the module descriptor the moduleinfoclass  file is read along with some other \nhousekeeping processing the module is represented as an object at runtime Loading a module does not mean \nloading all classes in that module which would be very inefficient Classes in a module are loaded when they \nare referenced in the program for the first time at runtime\nJDK 17 allows you to use only the modulepath only the classpath or a combination of both Using \nonly the modulepath means your program consists of only modules Using only the classpath means your \nprogram does not consist of modules Using a combination of both means some part of your program \nconsists of some modules and some part does not JDK 9 modularized the JDK code For example whether \nyou run a program from a module or not the javabase  module is always used Java supports three modes\n\t Module mode\n\t Legacy mode\n\t Mixed mode\nUsing only modules in your program is called module mode  and only the modulepath is used Using \nonly the classpath is called legacy mode  and only the classpath is used Using a combination of both is called \nmixed mode  JDK 9 supports these modes for backward compatibility For example you should be able to \nrun your JDK 8 programs as is in JDK 17 using the legacy mode in which you will place all your existing \nJARs on the classpath If you are developing a new Java application using modules but still have a few JARs \nfrom JDK 8 you can use the mixed mode by placing your modular JARs on the modulepath and the existing \nJARs on the classpath\nA class can be specified using three synonymous options classpath  classpath  and cp The first \noption was added in JDK 9 and the other two existed before The general syntax to run a Java program in \nlegacy mode is as follows\njava options mainclassname arguments\nHere options  and arguments  have the same meanings as discussed in the previous section \nRunning a Java Program  Since there are no userdefined modules in legacy mode you simply specify the \nfully qualified name of the main class that you want to run as mainclassname  As you must specify the \nmodulepath in module mode you must specify the classpath in legacy modeChapter 3  Writing Java programs\n77The following command runs the Welcome  class in legacy mode You do not need to recompile the Welcome  \nclass You can keep the moduleinfoclass  file or delete it because it will not be used in legacy mode\nCjavafunjava classpath Cjavafunmodjdojointro comjdojointroWelcome\nWelcome to Java 17\nThe JVM used the following steps to run the Welcome  class\n\t It detected that you were trying to run the comjdojointroWelcome  class\n\t It converted the main class name into a file path comjdojointroWelcomeclass \n\t It took the first entry in the classpath and looked for the existence of the path for the \nWelcomeclass  file computed in the previous step There was only one entry in the \nclasspath and it found the Welcomeclass  file using that entry The JVM tries to find \nthe class file using all entries in the classpath until it finds the class file If it does not \nfind the class file using all entries it throws a ClassNotFoundException \nThere are a few differences in how the classpath and the modulepath work The entries in the classpath \nare used as is  That is if you specify a directory path on the classpath that directory path is prepended to \nthe class file path to look for the class file Contrast this with the modulepath that contains a directory path \nwhere the directory itself all modular JARS in the directory and all immediate subdirectories are searched \nfor module descriptors Using this rule if you want to run the Welcome  class in legacy mode from a JAR file \nyou need to specify the full path of the JAR on the classpath\nThe following commands are not able to find the Welcome  class because the comjdojointro\nWelcomeclass  file is not found in the Cjavafunmod  or the Cjavafunlib  directory\nCjavafunjava classpath Cjavafunmod comjdojointroWelcome\nError Could not find or load main class comjdojointroWelcome\nCaused by javalangClassNotFoundException comjdojointroWelcome\nCjavafunjava classpath Cjavafunlib comjdojointroWelcome\nError Could not find or load main class comjdojointroWelcome\nCaused by javalangClassNotFoundException comjdojointroWelcome\nThe following command finds the Welcome  class because you specified the JAR path on the classpath\nCjavafunjava classpath Cjavafunlibcomjdojointrojar comjdojointroWelcome\nWelcome to Java 17\nIt is typical of a nontrivial Java application to have multiple JARs Adding the full path of all JARs to the \nclasspath is simply inconvenient To support this use case the classpath syntax supports an asterisk   in \nan entry as the last character which is expanded to all JAR and ZIP files in the directory represented by that \nentry Suppose you have a directory named cdir  that contains two JARs xjar  and yjar  To include these \ntwo JARs in the classpath you can use one of the following sequences of paths on Windows\n\tcdirxjarcdiryjar\n\tcdirChapter 3  Writing Java programs\n78The asterisk in the second case will be expanded to one entry per JARZIP file in the cdir  directory \nThis expansion happens before the JVM starts The following command shows how to use an asterisk in the \nclasspath\nCjavafunjava cp Cjavafunlib comjdojointroWelcome\nWelcome to Java 17\nYou must use an asterisk in a classpath entry in the end or by itself If you use an asterisk by itself \nthe asterisk will be expanded to include all JARZIP files in the current directory The following command \nuses the Cjavafunlib  directory as the current directory and an asterisk as the classpath to the run the \nWelcome  class\nCjavafunlibjava cp  comjdojointroWelcome\nWelcome to Java 17\nIn mixed mode you can use both the modulepath and the classpath like so\njava modulepath modulepath classpath classpath otherarguments\nThere may be a situation where you may have duplicate classesone copy on the modulepath and \nanother on the classpath In this case the version on the modulepath is used effectively ignoring the \nclasspath copy If duplicate classes exist on the classpath the class found first on the classpath is used \nDuplicate packages and hence duplicate classes are not allowed between modules That is if you have \na package named comjdojointro  all classes in this package must be available through one module \nOtherwise your application wont compilerun\nIf Java works only with modules how are nonmodular types loaded from the classpath used Types \nare loaded by class loaders Every class loader has a module called unnamed  module All types loaded from \nthe classpath become members of the unnamed module of their class loader All modules loaded from the \nmodulepath are members of the module in which they are declared We will revisit unnamed modules in \nlater chapters\n Duplicate Modules on\u00a0a\u00a0Module Path\nSometimes you may have multiple versions of the same modules on the modulepath How does the module \nsystem choose which module copy to use from the modulepath It is always a mistake to have two modules \nwith the same name on the modulepath The module system safeguards you against such mistakes in a \nlimited way\nLets start with an example to understand the rule in resolving the duplicate modules You have two \nversions of the jdojointro  moduleone in the comjdojointrojar  file inside the Cjavafunlib  \ndirectory and another in the Cjavafunmodjdojointro  directory Run the Welcome  class and include \nboth directories in the modulepath\nCjavafunjava modulepath CjavafunlibCjavafunmodjdojointro module jdojo\nintrocomjdojointroWelcome\nWelcome to Java 17Chapter 3  Writing Java programs\n79You might have expected this command to fail because it does not make sense to run a program having \ntwo versions of the same module accessible to the runtime system Which copy of the module was used by \nthis command It is hard to tell by looking at the output because both copies of the module contain the \nsame code You can use the showmoduleresolution  option to see the location from where the module \nwas loaded The following command does this A partial output is shown\nCjavafunjava modulepath CjavafunlibCjavafunmodjdojointro showmodule\nresolution module jdojointrocomjdojointroWelcome\nroot jdojointro fileCjavafunlibcomjdojointrojar\n\nWelcome to Java 17\nThe output indicates that the jdojointro  module which is a root module in this case was loaded from \nthe modular JAR comjdojointrojar  from the Cjavafunlib  directory Lets switch the order of entries \nin the modulepath and rerun the command\nCjavafunjava modulepath CjavafunmodjdojointroCjavafunlib showmodule\nresolution module jdojointrocomjdojointroWelcome\nroot jdojointro fileCjavafunmodjdojointro\n\nWelcome to Java 17\nThis time the output indicates that the jdojointro  module was loaded from the Cjavafunmod\njdojointro  directory Here is the rule\nIf there are multiple copies of a module with the same name accessible through different \nentries in the modulepath the modules copy that is found first on the modulepath is used\nUsing this rule when you had the lib directory listed first in the modulepath the jdojointro  module \nwas used from the lib directory and the modules copy in the modjdojointro  directory was ignored \nWhen you reversed the order of these entries in the modulepath the module in the modjdojointro  \ndirectory was used\nNotice the accessible through different entries in the modulepath  phrase in the rule This rule applies \nas long as multiple copies of a module exist in different modulepath entries If however multiple copies of a \nmodule are accessible through the same entry in the modulepath an error occurs How can you get into this \nsituation Here are a few possibilities\n\t Multiple modular JARs with different file names but having the code for a module \nwith the same name may exist in the same directory If such a directory is an entry \nin the modulepath multiple copies of a module are accessible through this single \nmodulepath entry\n\t When a directory is used as a modulepath entry all modular JARs in that directory \nand all immediate subdirectories containing a module descriptor locate modules \nthrough that modulepath entry This opens up the possibility of having multiple \nmodules with the same name accessible through a single modulepath entryChapter 3  Writing Java programs\n80In our example the two copies of the jdojointro  module are not accessible through a single \nmodulepath entry Lets simulate the error using the following steps\n\t Create a directory called Cjavafuntemp \n\t Copy the Clibcomjdojointrojar  file to the Cjavafuntemp  directory\n\t Copy the Cmodjdojointro  directory to the Cjavafuntemp  directory\nAt this point you have the following files\n\tCjavafuntempcomjdojointrojar\n\tCjavafuntempjdojointromoduleinfoclass\n\tCjavafuntempjdojointrocomjdojointroWelcomeclass\nIf you include the Cjavafuntemp  directory in the modulepath two copies of the jdojointro  \nmodule are accessibleone in the module JAR and one in the subdirectory The following command fails \nwith a clear message indicating the problem\nCjavafunjava modulepath ClibCjavafuntemp module jdojointrocomjdojointro\nWelcome\nError occurred during initialization of boot layer\njavalangmoduleFindException Error reading module Clibcomjdojointro10jar\nCaused by javalangmoduleInvalidModuleDescriptorException thisclass should be moduleinfo\nThe following command includes the Cjavafunlib  directory as the first entry in the modulepath \nwhere only one copy of the module will be found It includes the Cjavafuntemp  directory as the second \nentry in the modulepath You still get the same error\nCjavafunjava modulepath CjavafunlibCjavafuntemp module jdojointrocomjdojo\nintroWelcome\nError occurred during initialization of boot layer\njavalangmoduleFindException Two versions of module jdojointro found in Cjavafun\ntemp jdojointro and comjdojointrojar\n Syntax for\u00a0CommandLine Options\nJDK 17 supports two styles for specifying commandline options\n\t UNIX style\n\t GNU style\nA UNIXstyle option starts with a hyphen   followed by the option name as one word for example p \nm and cp A GNUstyle option starts with two hyphens   followed by the option name where each word \nin the option name is hyphenated for example modulepath  module  and classpath \nJDK designers were running out of short names for options that were also meaningful to developers \nTherefore JDK version 9 started using GNUstyle options Most options are available in both styles You are \nencouraged to use the GNUstyle options if available because they are easier to remember and intuitive to readersChapter 3  Writing Java programs\n81 Tip to print a list of all standard options supported by a JDK tool run the tool with the help  or h \noption and for all nonstandard options run the tool with the helpextra  or X option For example the \njava help  and java helpextra  commands print a list of standard and nonstandard options for \nthe java  command respectively\nAn option may take a value as its argument The value for an option follows the option name The \noption name and the value must be separated by one or more spaces The following examples show you how \nto specify the modulepath with the java  command using both options\n Using the UNIXstyle option\nCjavafunjava p CapplibCextlib otherargsgohere\n Using the GNUstyle option\nCjavafunjava modulepath CapplibClib otherargsgohere\nWhen you use the GNUstyle option you can specify the value for the option in one of two forms\n\tname value\n\tnamevalue\nThe previous command can also be written as follows\n Using the GNUstyle option\nCjava modulepath CapplibClib otherargsgohere\nWhen using spaces as the namevalue  separator you need to use at least one space When using a  as a \nnamevalue  separator you must not include any spaces around it This option\n  modulepathCapplib\nis valid whereas this option\n  modulepath Capplib\nis invalid because  Capplib  will be interpreted as a modulepath which is an invalid path\n Writing Java Programs Using the\u00a0NetBeans IDE\nYou can use the NetBeans IDE to write compile and run Java programs In this section we walk you through \nthe steps of working with NetBeans First you will learn how to create a new Java project write a simple Java \nprogram compile it and run it At the end you will learn how to open the NetBeans project for this book and \nuse the source code supplied with this book Refer to Chapter 2 on how to download install and configure \nthe NetBeans IDE\n Note  a t the time of this writing  netBeans iDe 125 has not been released  it will be released with JDK 17  \nBy the time you read this chapter the final release version 125 should be available in this section  we use the \nnightly build of netBeans 125 beta versionChapter 3  Writing Java programs\n82 Creating a\u00a0Java Project\nWhen you start the NetBeans IDE the startup page is displayed as shown in Figure\u00a0 39 The startup page \ncontains useful links for developers such as links for tutorials for Java JavaFX C etc If you dont want the \nstartup page to display every time you start the IDE you need to uncheck the Show On Startup checkbox in \nthe upperright corner of the startup page You can close the startup page by clicking the X icon displayed in \nthe Start Page tab Use Help  Start Page to open the Start Page at any time\nTo create a new Java project follow these steps\n 1 Sele ct File  New Project or press CtrlShiftN\u00a0The New Project dialog is \ndisplayed as shown in Figure\u00a0 310 \nFigure 39  The N etBeans IDE with the startup pageChapter 3  Writing Java programs\n83 2 In the N ew Project dialog select Java with Ant in the Categories list In the \nProjects list you can select Java Application Java Class Library or Java Modular \nProject When you select a category its description is displayed at the bottom \nIn the first two categories you can have only one Java module whereas the third \none lets you have multiple Java modules Select the Java Modular Project option \nand click the Next  button The New Java Modular Application dialog as shown \nin Figure\u00a0 311  is displayed\nFigure 310  A New Pr oject dialogChapter 3  Writing Java programs\n84 3 In the N ew Java Modular Application dialog enter Java17Fundamentals  as \nthe project name In the Project Location field enter or browse to a location \nwhere you want to save the project files I entered C as the project location \nNetBeans will create a CJava17Fundamentals  directory where all files for the \nJava17Fundamentals  project will be stored Select JDK 17 as the Java platform \nfrom the Platform dropdown If JDK 17 is not available for selection click the \nManage Platforms button and create a new Java platform Creating a new Java \nplatform is simply adding a location where a JDK is stored in the file system and \ngiving that location a name Click the Finish button when you are done The new \nJava17Fundamentals  project is displayed in the IDE as shown in Figure\u00a0 312 \nFigure 311  The N ew Java Modular Application dialog\nFigure 312  The N etBeans IDE with the Java17Fundamentals Java ProjectChapter 3  Writing Java programs\n85At the top left you see three tabs Projects Files and Services The Projects tab shows you all the \nprojectrelated files The Files tab lets you view all system files on your computer The Services tab lets you \nwork with services such as databases and web servers If you close these tabs you can reopen them using the \nsubmenus with the same name as these tabs under the Window menu\nAt this point you have created a modular Java application project that contains no modules You need \nto add modules to your project To create a new module select the project name Java17Fundamentals  \nin the Projects tab and rightclick to select New  Module as shown Figure\u00a0 313  A New Module dialog is \ndisplayed as shown in Figure\u00a0 314  Enter jdojointro  as the module name and click the Finish button\nFigure 313  Sele cting the Module menu item to create a menu moduleChapter 3  Writing Java programs\n86Figure 315  shows the editor with the moduleinfojava  file open I have removed the comments \nadded by the NetBeans IDE and added a comment at the top You might have to expand the file tree in the \nProjects tab to see all files Creating a jdojointro  module created a moduleinfojava  file with a module \ndeclaration for the jdojointro  module When a moduleinfojava  file is open in the editor the NetBeans \nIDE displays three tabsSource History and Graph Selecting the Graph tab displays the module graph as \nshown in Figure\u00a0 316  Rightclick the empty area in the module graph to see options to customize the graph \nUsing the Layouts options you can arrange the nodes in the graph in different ways I prefer viewing the \ngraph by arranging nodes hierarchically Use the Export as image rightclick option to export the image as a \nPNG image Selecting a node highlights all edges coming to and going out of the selected node which easily \nlets you visualize a modules roles in a graph Select the Source tab under the moduleinfojava  tab to see \nthe source code for the module\nFigure 314  The N ew Module dialogChapter 3  Writing Java programs\n87\nFigure 315  The jdojointro module with its moduleinfojava file open in the editor\nFigure 316  The module graph created by the NetBeans IDEChapter 3  Writing Java programs\n88Now you are ready to add the Welcome  class to the jdojointro  module Select the jdojointro  module \nnode in the Projects tab and rightclick Then choose New  Java Class which displays the New Java Class \ndialog shown in Figure\u00a0 317  Enter Welcome  as the class name and comjdojointro  as the package name \nThen click the Finish button\nFigure 318  shows the source code that was created for the Welcome  class I have cleaned up the \ncomments that are added by NetBeans when you create a new class You need to add a main  method \nto the Welcome  class as shown in Listing 33 Figure\u00a0 319  shows the Welcome  class with a main  method \nYou can save all your changes by pressing CtrlShiftS or you can save the changes in the active file using \nCtrlS\u00a0Alternatively you can use the File  Save All and File  Save menus or the toolbar buttons\nFigure 317  Entering the class details in the New Java Class dialogChapter 3  Writing Java programs\n89\nFigure 318  The Welcome class created by NetBeans\nFigure 319  The Welcome class code with a main methodChapter 3  Writing Java programs\n90You do not need to compile the code when you use NetBeans By default NetBeans compiles your code \nwhen you save it Now you are ready to run the Welcome  class NetBeans lets you run a project or a single \nJava class You can run a Java file if it contains a main class To run the Welcome  class you will need to run the \nWelcomejava  file in NetBeans You can run the Welcome  class in one of the following ways\n\t Open the Welcomejava  file in the editor and press ShiftF6 Alternatively you can \nrightclick in the editor while the Welcomejava  file is open and select Run File\n\t Select the Welcomejava  file in the Projects tab and press ShiftF6 Alternatively \nselect the Welcomejava  file in the Projects tab and select Run File\n\t Select the Welcomejava  file in the Projects tab and choose Run  Run File\nWhen you run the Welcome class the output appears in an Output tab as shown in Figure\u00a0 320 \n Creating Modular JARs in\u00a0NetBeans\nYou can build a modular JAR from inside the NetBeans IDE\u00a0Press F11 to build the project which will create \na modular JAR for each module you have added to your NetBeans project You can press ShiftF11 to clean \nand build which deletes all existing compiled class files and modular JARs and recompiles all classes before \ncreating new modular JARs Alternatively you can select the Run  Build Project Your Project Name \nmenu item to build your project\nWhere are the modular JARs created when you build a project NetBeans creates a dist  directory \nunder the project directory Recall that you have saved your NetBeans project in CJava17Fundamentals  \nso NetBeans will create a CJava17Fundamentalsdist  directory when you build the project in the \nIDE\u00a0Suppose you have two modules in your project jdojointro  and jdojotest  Building the project \nwill create the following two modular JARs\n\tCJava17Fundamentalsdistjdojointrojar\n\tCJava17Fundamentalsdistjdojotestjar\nFigure 320  The o utput when the Welcome class is runChapter 3  Writing Java programs\n91 NetBeans Project Directory Structure\nNetBeans uses a default directory structure to store the source code compiled code and packaged code The \nfollowing directories are created under the NetBeans project directory\n\tsrcmodulenameclasses\n\tbuildmodulesmodulename\n\tdist\nHere modulename  is your module name such as jdojointro  The srcmodulenameclasses  \ndirectory stores the source code for a specific module The moduleinfojava  file for the module is stored in \nthe classes  subdirectory The classes  subdirectory may have several subdirectories mirroring the directory \nstructure required by the package of types stored in the module\nThe buildmodulesmodulename  directory stores the compiled code for a module For example \nthe moduleinfoclass  file for the jdojointro  module will be stored at buildmodulesjdojointro\nmoduleinfoclass  The buildmodulesmodulename  directory mirrors the package of types stored in \nthe module For example the Welcomeclass  file in our example will be stored at buildmodulesjdojo\nintrocomjdojointroWelcomeclass  When you clean a project rightclick and choose Clean or clean \nand build a project the entire build  directory is deleted and recreated\nThe dist  directory stores a modular JAR for each module in the project The Clean  or CleanBuild  \naction on the project deletes all modular JARs and recreates them\nThis book will refer to this NetBeans directory structure in subsequent chapters to show you examples \nusing the same modules on the command line You can use NetBeans to write the modules code and build a \nmodular JAR for the module You can add the dist  directory of your NetBeans project to the modulepath to \nuse the modular JARs on the command line\n Adding Classes to\u00a0a\u00a0Module\nTypically you have several classes in a module To add a new class to your module rightclick the module in \nthe Projects tab and select New  Java Class Fill out the class name and the package name in the New Java \nClass dialog\n Customizing NetBeans Project Properties\nNetBeans lets you customize several properties for your Java project using the Project Properties dialog To \nopen the Project Properties dialog rightclick the project name in the Projects tab and select Properties The \nProject Properties dialog for the Java17Fundamentals  project is shown in Figure\u00a0 321 Chapter 3  Writing Java programs\n92On the left side of the dialog is the list of categories of properties When you select a property category \nthe details are displayed on the right side The following are brief descriptions of each property category\n\t Sources  It is used to set source coderelated properties for example source folder \nformat JDK encoding etc When you select a JDK from the SourceBinary Format \ndropdown the NetBeans IDE will restrict you from using an API outside of that JDK \nversion The IncludesExcludes button lets you include and exclude fields in and \nfrom the project Use this button when you want to keep some files in the project but \ndo not want to compile them for example the files may not be compiled as they are \nnot complete\n\t Libraries  Among several properties it lets you set three important properties the \nJava platform the modulepath and the classpath Clicking the Manage Platforms \nbutton opens the Java Platform Manager dialog where you can select an existing \nplatform or add a new platform Use the  sign on the right of the Modulepath  and \nClasspath  to use the Add Project Add Library and Add JARFolder buttons to \nadd projects predefined sets of JAR files and JARfolder to the modulepath and \nclasspath The modulepath and classpath set here are used to compile and run your \nJava project Note that all the modules you add to your project are automatically \nadded to your modulepath If you have modular JARs outside the current NetBeans \nproject you can add them to the modulepath using this dialog\nFigure 321  The Project Properties dialog for the Java17Fundamentals projectChapter 3  Writing Java programs\n93\t Build  It lets you set properties for several subcategories Under the Compiling \nsubcategory you can set compilerrelated options You can choose to compile the \nsource code when it is saved or you can choose to compile the source code yourself \nusing the menu options in the IDE\u00a0Under the Packaging subcategory you can set \noptions for packaging your modules The Documenting subcategory lets you set \noptions for generating Java documentation for the project\n\t Run  This category lets you set properties that are used to run the project You can set \nthe Java platform and JVM arguments Using the category you can set a main class \nfor your project Typically when you are learning you run a Java file as you did in the \nprevious sections not a modular Java project\n Opening an\u00a0Existing NetBeans Project\nIt is assumed you have downloaded the source code for this book The source code contains a NetBeans \nproject To open the project follow these steps\n 1 Pres s CtrlShiftO or select File  Open Project The Open Project dialog is \ndisplayed\n 2 Navigate to the folder that contains the unzipped downloaded source code The \nproject Java17Fundamentals  is displayed as shown in Figure\u00a0 322 \n 3 Sele ct the project and click the Open Project button NetBeans opens the project \nin the IDE\u00a0Use the Projects or Files tab on the left to browse the source code for \nall chapters in this book Refer to the previous sections on how to compile build \nand run classes in the source code\nFigure 322  Open ing the NetBeans Java project for the source code for this bookChapter 3  Writing Java programs\n94 Behind the\u00a0Scenes\nThis section answers some general questions related to compiling and running Java programs For example \nwhy do we compile Java source code to bytecode format before running it What is the Java platform What \nis a JVM and how does it work The detailed discussion of these topics is beyond the scope of this book \nRefer to the JVM specification for detailed discussions on any topic related to the JVM functionality The JVM \nspecification is available online at httpdocsoraclecomjavasespecs \nLets look at a simple daily life example Suppose there is a Frenchman who can understand and \nspeak only French and he has to communicate with three other personsan American a German and a \nRussianand these three only know one language English German and Russian respectively How will \nthe Frenchman communicate with the other three There are many ways to solve this problem\n\t The Frenchman may learn all three languages\n\t The Frenchman may hire a translator who knows all four languages\n\t The Frenchman may hire three translators who know FrenchEnglish  \nFrenchGerman and FrenchRussian\nThere are numerous other possible solutions to this problem Lets consider the similar problem in \nthe context of running a Java program The Java source code is compiled into bytecode The same bytecode \nneeds to be run without any modification on all operating systems Designers of the Java language chose the \nthird option which is to have a translator for each operating system The job of the translator is to translate \nthe bytecode into machine code which is native to the operating system running the translated code The \ntranslator is called a Java virtual machine JVM You need to have a JVM for each operating system Figure\u00a0 323  \nis a pictorial view of how the JVM acts as a translator between the bytecode class file and different operating \nsystems\nFigure 323  A JVM as a tra nslator between bytecode and an operating systemChapter 3  Writing Java programs\n95A Java program compiled into bytecode format has two advantages\n\t You do not need to recompile your source code if you want to run it on another \nmachine with a different operating system It is also called platform independence in \nJava It is also known as write once run anywhere for Java code\n\t If you are running a Java program over a network the program runs faster because of \nthe compact size of the bytecode format which results in less loading time over the \nnetwork\nIn order to run a Java program over the network the size of the Java code must be compact enough to be \ntransported over the network faster The class file which is generated by a Java compiler in bytecode format \nis very compact This is one of the advantages of compiling the Java source code in bytecode format\nThe second important advantage of using bytecode format is that it is architectureneutral By bytecode \nformat being architectureneutral it means if you compile the Java source code on a specific host system \nsay Windows the generated class file does not have any mention or effects that it was generated on \nWindows If you compile the same Java source code on two different host systems for example Windows \nand UNIX both class files will be the same\nThe class file in bytecode format cannot be directly executed on a host system because it does not have \nany host systemspecific direct instructions In other words we can say that bytecode is not a machine \nlanguage for any specific host system Now the question is who understands the bytecode and who \ntranslates it into underlying host systemspecific machine code The JVM performs this job The bytecode is \nthe machine language for the JVM\u00a0If you compile Java source code to generate a class file on Windows you \ncan run the same class file on UNIX if you have a Java platform JVM and Java API collectively are known as \nthe Java platform available on the machine running on UNIX\u00a0You do not need to recompile your source \ncode to generate a new class file for UNIX because the JVM running on UNIX can understand the bytecode \nyou generated on Windows This is how the concept of write once run anywhere is implemented for a Java \nprogram\nThe Java platform also called Java runtime system consists of two things\n\t The Java virtual machine JVM\n\t The Java application programming interface Java API\nThe term JVM is used in three contexts\n\t The JVM specification  It is the specification or standard of an abstract machine for \nwhich a Java compiler can generate bytecode\n\t The concrete realization of the JVM specification  If you want to run your Java \nprogram you need to have a real JVM which is developed using the abstract \nspecification for a JVM\u00a0To run the Java program in the previous section you used \nthe java  command which is a concrete implementation of the abstract JVM \nspecification The java  command or the JVM has been implemented completely \nin software However a JVM can be implemented in software or hardware or a \ncombination of both\n\t A running JVM instance  You have a running JVM instance when you invoke the java  \ncommand\nThis book uses the term JVM for all three cases Its actual meaning should be understood by the context \nof its use\nOne of the jobs a JVM performs is to execute the bytecode and generate a machinespecific instruction \nset for the host system A JVM has class loaders and an execution engine A class loader reads the content \nof a class file when required and loads it into memory The job of the execution engine is to execute the \nbytecodeChapter 3  Writing Java programs\n96A JVM is also called a Java Interpreter Often the term Java Interpreter is misleading particularly to \nthose who have just started learning the Java language By the term Java Interpreter  they conclude that the \nexecution engine of a JVM interprets the bytecodes one at a time and so Java must be very slow The name \nJava Interpreter for a JVM has nothing to do with the technique the execution engine uses to execute the \nbytecode The actual technique which the execution engine may opt for to execute the bytecode depends \non the specific implementation of the JVM\u00a0Some execution engine types are interpreter justintime \ncompiler and adaptive optimizer In its simplest kind which is interpreter the execution engine interprets \nthe bytecodes one at a time and therefore it is slower In its second kind which is the justintime compiler \nit compiles the whole code for a method in the underlying host machine language for the first time that \nmethod is called Then it reuses the compiled code the next time the same method is called This kind of \nexecution engine is faster compared with the first kind but requires more memory to cache the compiled \ncode In the adaptive optimizer technique it does not compile and cache the whole bytecode rather it does \nso only for the most heavily used part of the bytecode\nWhat is an API application programming interface An API is a specific set of methods made available \nby an operating system or by an application to the programmers for direct use In the previous sections \nyou created the Welcome  class in the comjdojointro  package which declared a method main  which \naccepts an array of String  as an argument and returns nothing indicated by keyword void  If you expose \nall these pieces of information about the created package class and method and make them available to \nother programmers for use your method main  in the Welcome  class is a typical though trivial example of an \nAPI\u00a0Generally when we use the term  API  we mean a set of methods that are available to the programmer \nfor use Now it is easy to understand what the Java API means The Java API is the set of all classes and other \ncomponents that are available to programmers for use while writing Java source code In your Welcome  class \nexample you have already used one Java API\u00a0You used it inside the body of the main  method to print the \nmessage on the console The code which used the Java API is\nSystemoutprintlnWelcome to Java 17\nYou did not declare any method named println  in your code This method was made available to the \nJVM at runtime through the Java API which is a part of the Java platform Broadly speaking the Java API can \nbe classified in two categories Core API and Extension API\u00a0Every JDK must support the Core API\u00a0Examples \nof Core Java APIs are Java runtimes eg applets AWT IO etc JFC JDBC etc Java Extension APIs are \nJavaMail JNDI Java Naming and Directory Interface etc Java includes JavaFX API as an Extension API\u00a0The \nprocess of compiling and running a Java program is depicted in Figure\u00a0 324 Chapter 3  Writing Java programs\n97 Summary\nJava programs are written in plain text format using a text editor or IDE\u00a0The Java source code is also known \nas a compilation unit and it is stored in a file with a java  extension Several integrated development \nenvironments IDEs for Java such as NetBeans are freely available on the market Using an IDE to develop \nJava applications reduces the time and effort involved in developing a Java application\nJDK 9 introduced the module system to the Java platform A module contains packages which in turn \nconsist of types A type could be a class an interface an enum or an annotation A module is declared in \na source file named moduleinfojava  and it is compiled into a class file named moduleinfoclass  A \ncompilation unit contains the source code for one or more types When a compilation unit is compiled a \nclass file is generated for each type declared in the compilation unit\nJava source code is compiled into class files using a Java compiler The class files contain bytecode The \nJava compiler that ships with the JDK is called javac  The compiled code is packaged into JAR files using \na tool called jar When a JAR file contains a moduleinfoclass  file which is a module descriptor at its \nroot directory the JAR file is called a modular JAR\u00a0The compiled code is run by a JVM\u00a0The JDK installs a \nJVM that can be run as a java  command Both javac  and java  commands are located in the JDKHOMEbin  \ndirectory where JDKHOME  is the installation directory for the JDK\nA module may contain packages for internal and external use If a module exports a package the public \ntypes contained in that package may be used by other modules If a module wants to use packages exported \nby another module the first module must declare a dependency on the second module JDK 9 consists of \nseveral modules known as platform modules The javabase  module is a primordial module and all other \nmodules implicitly depend on it\nFigure 324  Components involved in compiling and running a Java programChapter 3  Writing Java programs\n98The modulepath is a sequence of pathnames where a pathname may be a path to a directory a modular \nJAR or a JMOD file Each entry in the modulepath is separated by a platformspecific path separator \ncharacter which is a semicolon   on Windows and a colon  on UNIXlike operating systems User\ndefined modules are located by the module system using the modulepath The modulepath is set using the   \nmodulepath  or the shorter version p commandline option\nClasses can be located using the classpath The classpath is a sequence of directories JAR files and \nZIP files Each entry in the classpath is separated by a platformspecific path separator character which is \na semicolon   on Windows and a colon   on UNIXlike operating systems You can specify the classpath \nusing the classpath  or cp or classpath  commandline option\nValues for the classpath and the modulepath may look the same but they are used for different \npurposes The classpath is used to locate classes more specifically types whereas the modulepath is used \nto locate modules You can print the description of a module using the describemodule  or the shorter \nversion d option with the jar and java  commands If you have a modular JAR use the jar command If \nyou have a module in a modular JAR or exploded directory on the modulepath use the java  command\nAll modules accessible to the module system in any phase compile time or runtime are known as \nobservable modules You can print the list of observable modules using the listmodules  commandline \noption The module system creates a module graph by reclusively resolving the dependencies of a set of \nmodules known as root modules  with respect to the set of observable modules At compile time all modules \nbeing compiled make up the set of root modules The main module whose main class is run makes up the \nset of root modules at runtime If the main class is on the classpath all system modules are root modules \nYou can add modules to the set of root modules using the addmodules  commandline option You can \nlimit the number of observable modules using the limitmodules  commandline option\nJDK 9 works with only modules where your code is inside a module or not Each class loader has an \nunnamed module If a class loader loads a type from the modulepath the type is a member of a named \nmodule If a class loader loads a type from the classpath the type becomes a member of the unnamed \nmodule of that class loader\nJava code is compiled to bytecode and is run by the JVM Java virtual machine This allows the same \ncode to be run on many different operating systems\nEXERCISES\n 1 What is the extension of the file that contains the source code for a Java program\n 2 What is a compilation unit\n 3 how many types can you declare in a compilation unit\n 4 how many public types can you declare in a compilation unit\n 5 What is the restriction on naming a compilation unit if it contains a public type \nWhat would be the name of the compilation unit if it contains the declaration of a \npublic class named HelloWorld \n 6 in what order are the following constructs specified in a compilation unit type \ndeclaration packages and import statements\n 7 how many package statements can you have in one compilation unit\n 8 What is the extension of a file that contains Java compiled code\n 9 What are the names of files that contain the source code and the compiled code for \na Java module\n 10 What keyword do you use to declare a moduleChapter 3  Writing Java programs\n99 11 how many modules can you declare in one moduleinfojava  file\n 12 What is an unnamed module how many unnamed modules can a class loader \nhave When does a type eg a class become a member of an unnamed module\n 13 What is a J ar What is the difference between a J ar file and a Z ip file\n 14 What is a modular J ar and how does it differ from a J ar Can you use a modular \nJar as a J ar and vice versa\nHint a modular J ar is also a J ar and it can be used as such a Jar placed on \nthe modulepath acts as a modular J ar and in that case the module definition \nis automatically derived by the module system such a module is known as an \nautomatic  module\n 15 What command do you use to start the J shell tool and where is the  \ncommand located\n 16 What command do you use to compile Java source code\n 17 What command do you use to package Java compiled code into a J ar or a  \nmodular J ar\n 18 Where is the module descriptor  moduleinfoclass  file placed in a  \nmodular J ar\n 19 You have a modular J ar saved at Clibcomjdojotestjar  it contains a \nmodule named jdojotest  and a main class named comjdojotestTest  \nWrite the commands to run this class in module mode and in legacy mode\n 20 You have a modular J ar saved at Clibcomjdojotestjar  Write the \ncommand using the jar command to describe the module packaged in this \nmodular J ar\n 21 What is a module descriptor Can you specify the version for a module when you \ndeclare the module how do you specify a module version\n 22 What are observable modules What are root modules and how are they used in \nconstructing a module graph\n 23 Write the name of a commandline option tha t is used to add modules to the set of \nroot modules\n 24 What commandline option do you use to print the list of observable modules\n 25 What commandline option do you use to limit the set of observable modules\n 26 the gnUstyle option name for specifying the modulepath is modulepath  \nWhat is its equivalent U niXstyle option101\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730744CHAPTER 4\nData Types\nIn this chapter you will learn\n\t What identifiers are and the detailed rules to declare them\n\t What data types are\n\t The difference between primitive and reference data types\n\t Local variable type inference using var\n\t How to declare variables of a data type\n\t How to assign a value to a variable\n\t Detailed descriptions of all primitive data types in Java\n\t What literals of a data type are\n\t What casting is and when it is needed\n\t Binary representation of integers and floatingpoint numbers\n\t Different rounding modes for floatingpoint numbers\n\t How Java implements IEEE floatingpoint standards\nWe use a lot of snippets of code in this chapter The quickest way to evaluate those snippets and see the \nresults is to use the JShell tool Refer to Chapter 2 on how to start the JShell tool on a command prompt\n What Is a\u00a0Data Type\nA data type or simply a type is defined in terms of three components\n\t A set of values or data objects\n\t A set of operations that can be applied to all values in the set\n\t A data representation which determines how the values are stored\nA programming language provides some predefined data types which are known as builtin  \ndata types A programming language may also let programmers define their own data types which are \nknown as userdefined data typesChapter 4  Data types\n102A data type that consists of an atomic indivisible valueand that is defined without the help of \nany other data typesis known as a primitive  data type Userdefined data types are defined in terms of \nprimitive data types and other userdefined data types Typically a programming language does not let the \nprogrammers extend or redefine primitive data types\nJava provides many builtin primitive data types such as int float  boolean  char  etc For example \nthe three components that define the int primitive data type in Java are as follows\n\t An int data type consists of a set of all integers between 2147483648 and \n2147483647\n\t Operations such as addition subtraction multiplication division comparison and \nmany more are defined for the int data type\n\t A value of the int data type is represented in 32bit memory in 2s complement form\nAll three components of the int data type are predefined by the Java language Developers cannot \nextend or redefine the int data type You can give a name to a value of the int data type as follows\nint employeeId\nThis statement states that employeeId  is a name technically called an identifier that can be associated \nwith one value from the set of values that defines values for the int data type For example you can associate \ninteger 1969  to the name employeeId  using an assignment statement like this\nemployeeId  1969\n What Is an\u00a0Identifier\nAn identifier  in Java is a sequence of characters of unlimited length The sequence of characters includes all \nJava letters and Java digits the first of which must be a Java letter Java uses the Unicode character set\nA Java letter is a letter from any language that is represented by the Unicode character set For example \nAZ az  underscore and  are considered Java letters from the ASCII character set range of Unicode \nJava digits include 09 ASCII digits and any Unicode character that denotes a digit in a language Spaces are \nnot allowed in an identifier\n Ti p a n identifier in Java is a sequence of one or more Unicode letters and digits and it must start with a \nletter\nIdentifier is a technical term for name  Therefore an identifier is simply the name given to an entity \nin a Java program such as a module a package a class a method a variable etc In the previous chapter \nyou declared a module named jdojointro  a package named comjdojointro  a class named Welcome  a \nmethod named main  and an argument to the main  method named args  All these names are identifiers\nYou have seen names in two forms a name that consists of only one part such as Welcome  and a name \nthat consists of multiple parts separated by dots such as jdojointro  and comjdojointro  Names that \nconsist of only one part without using any dots are known as simple names  names that can consist of parts \nseparated by dots are known as qualified  names  There are rules regarding what kind of entities in Java can \nhave simple names and qualified names For example modules and packages can have qualified names Chapter 4  Data types\n103whereas classes methods and variables can have only simple names An entity that can have a qualified \nname does not mean that the name of such an entity must consist of at least two parts such as xy it simply \nmeans that such an entitys name may consist of parts separated by dots For example the module name \nComJdojoIntro  is as valid as the module name comjdojointro  or jdojointro \nWhy do we have two types of namessimple and qualified To understand the reason behind it \nconsider the following two questions\n\t John and his friend Anna live in the United Kingdom John tells Anna that he will go \nto Birmingham  tomorrow\n\t Thomas and his friend Wanda live in the United States Thomas tells Wanda that he \nwill go to Birmingham  tomorrow\nAre John and Thomas talking about the same Birmingham City The answer is no Both the United \nKingdom and the United States have a city named Birmingham John is talking about the city in the \nUnited Kingdom and Thomas is talking about the city in the United States When you use a name in a \ndaily conversation or a Java program the name has a space an area a region or a scope in which it is \nvalid and must be unique Such a space is called a namespace In our example UK and USA are serving as \nnamespaces in which the Birmingham city name is unique A qualified name lets you use namespaces for \nthe name For example John and Thomas might have used UKBirmingham  and USABirmingham  as city \nnames which would be qualified names in Java terminology\nWhen Java entities can occur as a standalone for example modules and packages qualified names for \nsuch entities are allowed to prevent name collision Suppose we have a module named jdojointro  and \nsomeone else also creates a module named jdojointro  These modules cannot be used or referred to in \nthe same Java application because of their name collision However these names are fine if these modules \nwill be used standalone A class always occurs or is declared inside a package therefore a class name must \nbe a simple name as long as that simple name is unique within the package\nA simple rule of thumb in naming your reusable and published modules and packages is to use the \nInternet reverse domain naming convention If you own jdojocom  use comjdojo  as a prefix to the names \nof all your modules and packages We use only jdojo  as a prefix for all module names in this book because \nthese modules are not for public use they are only used in examples of this book and they are only for \nlearning purposes a shorter module name is also easy for me and you to type and read\nThe Java programming language is case sensitive All characters used in an identifier are important \nas is their case The names welcome  Welcome  and WELCOME  are three different identifiers It helps the \nreaders of your code if you use intuitive names in your Java programs that convey the purpose of the entity \nSuppose you need to store an employees ID in a variable You can name the variable n1 and id and Java \nwont complain However if you name it employeeId  or empId  your code becomes more readable Anybody \nreading your code will get the right context and the purpose for that variable Table\u00a0 41 contains examples of \na few valid and invalid identifiers in JavaChapter 4  Data types\n104 Keywords\nKeywords are words that have predefined meanings in the Java programming language They can only \nbe used in contexts defined by the Java programming language Keywords cannot be used as identifiers \nTable\u00a0 42 contains a complete list of keywords in JavaTable 41  Examples of Valid and Invalid Identifiers in Java\nIdentifier Valid Description\nWelcome Yes Consists of all letters\nnum1 Yes Consists of three letters and a digit\nmyId Yes Can start with an underscore\nsumoftwonumbers Yes Can have letters and underscores\nOuterInner Yes Can have letters and a \nvar Yes Can start with a \n Yes Can be only a \n No Starting JDK 9 an underscore cannot be used as an identifier by itself \nHowever an underscore can be a part of a multicharacter identifier name\n2num No An identifier cannot start with a digit\nmy name No An identifier cannot contain spaces\nnum1num2 No An identifier cannot contain symbols like      etc\nTable 42  List of Keywords and Reserved Words in Java\nabstract continue for New switch\nassert default If Package synchronized\nboolean do goto Private this\nbreak double implements Protected throw\nbyte else import Public throws\ncase enum instanceof Return transient\ncatch extends int short try\nchar final interface static void\nclass finally long strictfp volatile\nconst float native super while\n underscoreChapter 4  Data types\n105The two keywords const  and goto  are not currently used in Java They are reserved keywords and they \ncannot be used as identifiers Java SE 10 introduced var as a reserved type so although it appears to be a \nkeyword it is not\nWith the introduction of the module system Java SE 9 introduced ten new restricted keywords which \ncannot be used as identifiers Those restricted keywords are open  module  requires  transitive  exports  \nopens  to uses  provides  and with  They are restricted keywords because they are treated as keywords only \nin the context of module declaration everywhere else in a program they can be used as identifiers They \nwere not keywords in Java SE 8 If they were declared keywords in Java SE 9 many programs written in Java \nSE that used them as identifiers would have broken\n Ti p y ou will encounter three words true  false  and null in Java programs they appear to be \nkeywords but they are not rather true  and false  are Boolean literals and null  is a null literal you cannot \nuse true  false  and null  as identifiers in Java even though they are not keywords\n Data Types in\u00a0Java\nBefore we start discussing all data types available in Java lets look at a simple example of adding two numbers \nSuppose your friend asks you to add two numbers The procedure to add two numbers goes as follows\n 1 Your friend tells you the first number you listen to them and your brain records \nthe number at a particular location in your memory Of course you do not know \nwhere the number is exactly stored in your brains memory\n 2 Your friend tells you the second number you listen to them and again your \nbrain records it at a particular location in your memory\n 3 Now your friend asks you to add the two numbers Your brain comes into action \nagain It recalls or reads the two numbers and adds them and you tell your \nfriend the sum of the two numbers\nNow if your friend wants you to tell them the difference between the same two numbers they do not \nneed to tell you those two numbers again This is because these two numbers are stored in your memory \nand your brain can recall and use them again However whether your brain can perform addition of those \ntwo numbers depends on many factors for example how big those two numbers are whether your brain \ncan memorize or store those big numbers whether your brain is trained to do addition etc The process \nof adding two numbers also depends on the type of these two numbers Your brain will use different logic \nto add them depending on whether the two numbers are whole numbers eg 10 and 20 real numbers \neg 124 and 191 or the mix of whole and real numbers eg 10 and 699 The entire process takes place \nin your brain without you noticing it maybe because you are so accustomed to doing these additions \nHowever when you want to do any kind of manipulation on numbers or any other types of values in a Java \nprogram you need to specify the details about the values you want to manipulate and the procedure for \nmanipulating those values\nLets discuss the same example of adding two numbers in a Java program The first thing you need to \ntell Java is the type of the two numbers you want to add Lets assume that you want to add two integers 50 \nand 70 When you added two numbers by yourself your brain gave each number a name maybe as the first \nnumber and the second number You did not notice the naming of those numbers by your brain However Chapter 4  Data types\n106in a Java program you have to explicitly give names also known as identifiers to both numbers Lets name \nthe two numbers as num1  and num2  respectively The following two lines in a Java program indicate the fact \nthat there are two integers num1  and num2 \nint num1\nint num2\nThe int keyword is used to indicate that the name that follows represents an integer value for example \n10 15 70 1000 etc When these two lines of code are executed Java allocates two memory locations and \nassociates the name num1  with the first memory location and the name num2  with the second memory \nlocation The memory state at this point is depicted in Figure\u00a0 41\nThese memory locations are called variables that have been named num1  and num2  Strictly speaking \nnum1  and num2  are two names associated with two memory locations However roughly speaking you say\n\tnum1  and num2  are two variables\n\tnum1  and num2  are two variables of the int data type\n\tnum1  and num2  are two int variables\nBecause you have declared num1  and num2  variables of the int data type you cannot store a real number \nsuch as 1051 at these memory locations The following piece of code stores 50\u00a0in num1  and 70\u00a0in num2 \nnum1  50\nnum2  70\nThe memory state after these two lines of code are executed is depicted in Figure\u00a0 42Figure 41  Memor y state when two int type variables are declaredChapter 4  Data types\n107Now you want to add the two numbers Before you add them you must allocate another memory \nlocation which will hold the result You name this memory location as num3  and the following piece of code \nperforms these tasks\nint num3              Allocates the memory location num3\nnum3  num1  num2    Computes sum and store the result in num3\nThe memory state after these two lines of code are executed is depicted in Figure\u00a0 43\nThe two previous lines can be combined into one\nint num3  num1  num2\nA variable has three properties\n\t A memory location to hold the value\n\t The type of the data stored at the memory location\n\t A name also called an identifier  to refer to the memory locationFigure 42  Memor y state after two int type variables are assigned a value\nFigure 43  Memor y state in the process of adding two numbersChapter 4  Data types\n108The data type of the variable also determines the range of the values that the memory location can hold \nTherefore the amount of memory allocated for a variable depends on its data type For example 32 bits of \nmemory is allocated for a variable of the int data type In this example each variable  num1  num2  and num3  \nuses 32 bits of memory\nJava supports two kinds of data types\n\t Primitive data type\n\t Reference data type\nA variable of the primitive data type holds a value whereas a variable of the reference data type holds \nthe reference to an object in memory We discuss one of the reference data types available in Java String  in \nthis section String  is a class defined in the Java library and you can use it to manipulate text sequence of \ncharacters You declare a reference variable named str of String  type as follows\nString str\nBefore you assign the reference of an object to a reference variable you need to create an object You \ncreate an object using the new operator You can create an object of the String  class with Hello  as its \ncontents as follows\n Creates a String object and assigns the reference of the object to str\nstr  new StringHello\nWhat happens when this code is executed First memory is allocated and the name of the variable \nstr is associated with that memory location as shown in Figure\u00a0 44 This process is the same as declaring \na primitive data type variable The second piece of code creates a String  object in memory with the text \nHello  and stores the reference or memory address of the String  object into the variable str This fact \nis shown in the second half of Figure\u00a0 44 by using an arrow pointing from the variable str to the object in \nmemory\nFigure 44  Memor y states using reference variablesChapter 4  Data types\n109You can also assign the reference of an object stored in one reference variable to another reference \nvariable In such cases both reference variables refer to the same object in memory This can be achieved as \nfollows\n Declares String reference variable str1 and str2\nString str1\nString str2\n Assigns the reference of a String object Hello to str1\nstr1  new StringHello\n Assigns the reference stored in str1 to str2\nstr2  str1\nThere is a reference constant also known as a reference literal null  which can be assigned to any \nreference variable If null  is assigned to a reference variable it means that the reference variable is not \nreferring to any object in memory The null  reference literal can be assigned to str2 \nstr2  null\nMemory states after execution of all of these statements are depicted in Figure\u00a0 45\nA String  object is created using the new operator However strings are used so often that there is a \nshortcut to create a String object All string literals a sequence of characters enclosed in double quotes are \ntreated as String  objects Therefore instead of using the new operator to create a String  object you can use \nstring literals like so\n Assigns the reference of a String object with text Hello to str1\nString str1  Hello\n Assigns the reference of a String object with text Hello to str1\nString str1  new String Hello\nThere is a subtle difference between these two statements which assign a String  object to str1  with the \nsame text Hello  This book discusses the difference in a separate Chapter 15 that covers the String  classFigure 45  Memor y states using null in the reference variable assignmentsChapter 4  Data types\n110 Local Variable Type Inference\nJava 10 introduced the local variable type inference feature which allows you to use var in place of the type \nfor local variables inside a method if the compiler can determine the type it should use It has the same \nmeaning as if you did strictly define the type but is a much more concise syntax It can avoid repetition of the \ntype in many cases\nFor example using the previous code as an example and using var would result in code like the \nfollowing without any change in meaning\n Assigns the reference of a String object with text Hello to str1\nvar str1  Hello\n Assigns the reference of a String object with text Hello to str1\nvar str1  new String Hello\nIts not a keyword and can still be used as a variable name although this is not recommended We will \ncover var more in depth in later chapters such as every scenario where it can and cannot be used\n Primitive Data Types in\u00a0Java\nJava has eight primitive data types Table\u00a0 43 lists their names their sizes whether they are signed or \nunsigned their range and a few examples The following sections describe them in detail\nThe eight primitive data types are divided into two categories\n\tboolean  data type\n\t Numeric data type\nThe numeric data type can be further subdivided into integral and floatingpoint types All primitive \ndata types and their categories are shown in Figure\u00a0 46 The subsequent sections describe all primitive data \ntypes in detailTable 43  List of Primitive Data Types Their Size Range and Examples\nData Type Size in Bits SignedUnsigned Range Example\nbyte 8 Signed 27 to 27  1 2 8 10\nshort 16 Signed 215 to 215  1 2 8 10\nint 32 Signed 231 to 231  1 1990 90 23\nlong 64 Signed 263 to 263  1 1990L 90L 23L\nchar 16 Unsigned 0 to 65535 A 8 u0000\nfloat 32 Signed 34 x 1038 to 34 x 10381289F 8978F\ndouble 64 Signed 17 x 10308 to 17 x 103081278 7889\nboolean Unspecified NA true  and false true falseChapter 4  Data types\n111 Alert  W e have received several emails from readers of the first edition of this book that it is an error to \nlist the char  data type under the numeric data type category however that is not true the char  data type \nis a numeric data type by all means you can assign an integer to a char  variable and you can also perform \narithmetic operations such as addition and subtraction on char  variables the Java Language Specification  also \ncategorizes char  as a numeric data type Many Java books either list char  as a separate data type or describe \nit as a nonnumeric data type both are wrong\nYou will come across the term literal several times while reading this book and while working with \nJava A literal of type X means a value of type X that can be directly represented in the source code without \nrequiring any computations For example 10 is an int literal which means whenever you need a value 10 \nof int type in a Java program you can simply type 10 Java defines literals for all primitive types and for two \nreference types the String  type and null type\n Integral Data Types\nAn integral data type is a numeric data type whose values are whole numbers ie integers Java offers five \nintegral data types byte  short  int long  and char  All integral data types are described in detail in the \nsections to follow\nFigure 46  List of primitive data types divided by their categories in JavaChapter 4  Data types\n112 The int Data Type\nThe int data type is a 32bit signed Java primitive data type A variable of the int data type takes 32 bits of \nmemory Its valid range is 2147483648 to 2147483647 231 to 231\u00a0 1 All whole numbers in this range \nare known as integer literals or integer constants For example 10 200 0 30 19 etc are integer literals of \nint type An integer literal can be assigned to an int variable say num1  like so\nint num1  21\nInteger literals can be expressed in the following formats\n\t Decimal number format\n\t Octal number format\n\t Hexadecimal number format\n\t Binary number format\nWhen an integer literal starts with a zero and has at least two digits it is considered to be in the octal \nnumber format The following line of code assigns a decimal value of 17 021\u00a0in octal to num1 \n 021 is in octal number format not in decimal\nint num1  021\nThe following two lines of code have the same effect of assigning a value of 17 to the variable num1 \n No leading zero   decimal number format\nint num1  17\n Leading zero   octal number format 021  in octal is the same as 17  in decimal\nint num1  021\nBe careful when using int literals with a leading zero because Java will treat these literals as in the octal \nnumber format Note that an int literal in octal format must have at least two digits and must start with a \nzero to be treated as an octal number The number 0 is treated as zero in the decimal number format and 00 \nis treated as zero in the octal number format\n Assigns zero to num1 0 is in the decimal number format\nint num1  0\n Assigns zero to num1 00 is in the octal number format\nint num1  00\nNote that 0 and 00 represent the same value zero Both lines of code have the same effect of assigning a \nvalue of zero to the variable num1 \nAll int literals in the hexadecimal number format start with 0x or 0Xthat is zero immediately followed \nby an uppercase or lowercase Xand they must contain at least one hexadecimal digit The hexadecimal \nnumber format uses 16 digits 09 and AF or af The case of the letters AF does not matter The following \nare examples of using int literals in hexadecimal format\nint num1  0x123\nint num2  0xdecafe\nint num3  0x1A2B\nint num4  0X0123Chapter 4  Data types\n113An int literal can also be represented using the binary number format All int literals in the binary \nnumber format start with 0b or 0B that is zero immediately followed by an uppercase or lowercase B The \nfollowing are examples of using int literals in the binary number format\nint num1  0b10101\nint num2  0b00011\nint num3  0b10\nint num4  0b00000010\nThe following assignments assign the same decimal number 51966 to an int variable named num1  in all \nfour different formats\nnum1  51966                  Decimal format\nnum1  0145376                Octal format starts with a zero\nnum1  0xCAFE                 Hexadecimal format starts with 0x\nnum1  0b1100101011111110     Binary format starts with 0b\nJava has a class named Integer  note the uppercase I in Integer  that defines two constants to represent \nmaximum and minimum values for the int data type IntegerMAXVALUE  and IntegerMINVALUE \nFor example\nint max  IntegerMAXVALUE  Assigns maximum int value to max\nint min  IntegerMINVALUE  Assigns minimum int value to min\n The long Data Type\nThe long  data type is a 64bit signed Java primitive data type It is used when the result of calculations \non whole numbers may exceed the range of the int data type Its range is 9223372036854775808 to \n9223372036854775807 263 to 263\u00a0 1 All whole numbers in the range of long  are called integer literals of \nlong  type\n51 is an integer literal What is its data type int or long  An integer literal of type long  always ends \nwith L or lowercase l This book uses L to mark the end of an integer literal of the long  type because l \nlowercase L is often confused with 1 digit one in print The following are examples of using an integer \nliteral of long  type\nlong num1  0L\nlong num2  401L\nlong mum3  3556L\nlong num4  89898L\nlong num5  105L\n Ti p 25L is an integer literal of long  type whereas 25 is an integer literal of int typeChapter 4  Data types\n114Integer literals of long  type can also be expressed in octal hexadecimal and binary formats for \nexample\nlong num1\nnum1  25L        Decimal format\nnum1  031L       Octal format\nnum1  0X19L      Hexadecimal format\nnum1  0b11001L  Binary format\nWhen a long  literal is assigned to a variable of type long  the Java compiler checks the value being \nassigned and makes sure that it is in the range of the long  data type otherwise it generates a compiletime \nerror for example\n One more than maximum positive value for long This will generate a compiletime error\nlong num1  9223372036854775808L\nBecause the int data type has a lower range than the long  data type the value stored in an int variable \ncan always be assigned to a long  variable\nint num1  10\nlong num2  20    OK to assign int literal 20 to a long variable num2\nnum2  num1       OK to assign an int to a long\n Ti p When you assign a value of a smaller type to a variable of bigger type eg  int to long  Java \nperforms an automatic widening conversion to fill the higher order bits in the destination with zero preserving \nthe sign bit of the source For example when assigning an int literal to a long  variable Java performs the \nwidening conversion\nThe assignment from int to long  is valid because all values that can be stored in an int variable can \nalso be stored in a long  variable However the reverse is not true You cannot simply assign the value stored \nin a long  variable to an int variable There is a possibility of value overflow or loss of value Consider the \nfollowing two variables\nint num1  10\nlong num2  2147483655L\nIf you assign the value of num2  to num1  as\nnum1  num2\nthe value stored in num2  cannot be stored in num1  because the data type of num1  is int and the value of num2  \nfalls outside the range that the int data type can handle To guard against inadvertently making such errors \nJava does not allow you to write code like this\n A compiletime error long to int assignment is not allowed in Java\nnum1  num2Chapter 4  Data types\n115Even if the value stored in a long  variable is well within the range of the int data type the assignment \nfrom long  to int is not allowed as shown in the following example\nint num1  5\nlong num2  25L\n A compiletime error Even if num2s value 25 which is within the range of int\nnum1  num2\nIf you want to assign the value of a long  variable to an int variable you have to explicitly mention this \nfact in your code so that Java makes sure you are aware that there may be loss of value You do this using \ncast in Java by putting the target type in parentheses before the value like so\nnum1  intnum2  Now it is fine because of the int cast\nBy writing intnum2  you are instructing Java to treat the value stored in num2  as an int At runtime Java \nwill use only the 32 least significant bits LSBs of num2  and assign the value stored in those 32 bits to num1  If \nnum2  has a value that is outside the range of the int data type you would not get the same value in num1 \nJava has a class Long  note the uppercase L in Long  that defines two constants to represent maximum \nand minimum values of the long  data type LongMAXVALUE  and LongMINVALUE \nlong max  LongMAXVALUE\nlong min  LongMINVALUE\n The byte Data Type\nThe byte  data type is an 8bit signed Java primitive integer data type Its range is 128 to 127 27 to 27\u00a0 1 \nThis is the smallest integer data type available in Java Generally byte  variables are used when a program \nuses a large number of variables whose values fall in the range 128 to 127 or when dealing with binary data \nin a file or over the network Unlike int and long  literals there are no byte  literals However you can assign \nany int literal that falls in the range of byte  to a byte  variable for example\nbyte b1  125\nbyte b2  11\nJava generates a compiler error if you assign a value outside the range 128 to 127 to a byte  variable The \nfollowing assignment produces a compiletime error\n An error 150 is an int literal outside 128 to 127\nbyte b3  150\nNote that you can only assign an int literal between 128 and 127 to a byte  variable However this does \nnot imply that you can also assign the value stored in an int variable which is in the range of 128 to 127 to \na byte  variable The following piece of code will generate a compiletime error because it assigns the value \nof an int variable num1  to a byte  variable b1\nint num1  15\n OK Assignment of int literal 128 to 127 to byte\nbyte b1  15\n A compiletime error Even though num1 has a value of 15 which is in the range 128 and 127\nb1  num1Chapter 4  Data types\n116Why did the compiler complain when num1  was assigned to b1 The compiler does not try to read the \nvalue stored in num1  because num1  is a variable and its value is known only at runtime It sees num1  as an int \ntype which is 32bit big whereas it sees b1 as byte  type which is 8bit big Based on their size the compiler \nsees that you are assigning a bigger variable to a smaller variable and there is a potential of loss of data \nWhen you assign 15 to b1 15 is an int literal and its value is known at compile time the compiler can make \nsure that 15 is within the range of a byte  128 to 127 If you declare num1  as a compiletime constant in \nthe previous snippet of code the compiler will not generate an error A compiletime constant is a variable \ndeclared using the final keyword and whose value is known at compile time The following snippet of code \ndoes this\n Using final makes the num1 variable a compiletime constant\nfinal int num1  15\n OK Assignment of int literal 128 to 127 to byte\nbyte b1  15\n Now the compiler knows the value of num1 as 15 and it is fine\nb1  num1\nYou can also fix this error by using a cast as you did in the case of the long toint assignment The \nassignment of num1  to b1 can be rewritten as follows\nint num1  15\nbyte b1  15\nb1  bytenum1  Ok Using a cast\nAfter this cast from int to byte  the Java compiler would not complain about the inttobyte  \nassignment If num1  holds a value that cannot be correctly represented in the 8bit byte  variable b1 the \nhigher order bits 9th to 32nd of num1  are ignored and the value represented in the lower 8 bits is assigned \nto b1 In such a case of inttobyte  assignment the value assigned to the destination byte  variable may not \nbe the same as the value of the source int variable if the value of the source variable falls outside the range \nof the byte  data type\nHowever irrespective of the value in the source int variable the destination byte  variable will always \nhave a value between 128 and 127 Like int since long  is also a bigger data type than byte  you need to use \nexplicit cast if you want to assign the value of a long  variable to a byte  variable For example\nbyte b4  10\nlong num3  19L\nb4  bytenum3    OK because of cast\nb4  19L           Error Cannot assign long literal to byte\nb4  byte19L     OK because of cast\nIt is true that both 19 and 19L represent the same number However to the Java compiler they are \ndifferent 19 is an int literal that is its data type is int whereas 19L is a long  literal that is its data type is long \nJava has a class named Byte  note the uppercase B in Byte  that defines two constants to represent \nmaximum and minimum values of the byte  data type ByteMAXVALUE  and ByteMINVALUE \nbyte max  ByteMAXVALUE  Same as byte max  127\nbyte min  ByteMINVALUE  Same as byte min  128Chapter 4  Data types\n117 The short Data Type\nThe short  data type is a 16bit signed Java primitive integer data type Its range is 32768 to 32767 or 215 to \n215\u00a0 1 Generally short  variables are used when a program uses a large number of variables whose values \nfall in the range of the short  data type or when dealing with data in a file which can be easily handled using \nthe short  data type Unlike int and long  literals there are no short  literals However you can assign any int \nliteral that falls in the range of short  32768 to 32767 to a short  variable for example\nshort s1  12905     ok\nshort s2  11890    ok\nThe value of a byte  variable can always be assigned to a short  variable because the range of the byte  \ndata type falls within the range of the short  data type All other rules for assignment of a value from an int \nor long  variable to a short  variable are the same as that for the byte  variable The following snippet of code \nillustrates the assignment of byte  int and long  values to short  variables\nshort s1  15      OK\nbyte b1  10       OK\ns1  b1            OK\nint num1  10      OK\ns1  num1          A compiletime error\ns1  shortnum1  OK because of cast from int to short\ns1  35000         A compiletime error of an int literal outside the short range\nlong num2  555L  OK\ns1  num2          A compiletime error\ns1  shortnum2  OK because of the cast from long to short\ns1  555L          A compiletime error\ns  short555L    OK because of the cast from long to short\nJava has a class called Short  note the uppercase S in Short  that defines two constants to represent \nmaximum and minimum values of the short  data type ShortMAXVALUE  and ShortMINVALUE \nshort max  ShortMAXVALUE\nshort min  ShortMINVALUE\n The char Data Type\nThe char  data type is a 16bit unsigned  Java primitive data type Its value represents a Unicode character \nNote that char  is an unsigned data type Therefore a char  variable cannot have a negative value The range \nof the char  data type is 065535 which is the same as the range of the Unicode character set A character \nliteral represents a value of the char  data type A character literal can be expressed in the following formats\n\t As a character enclosed in single quotes\n\t As a character escape sequence\n\t As a Unicode escape sequence\n\t As an octal escape sequenceChapter 4  Data types\n118Character Literals in\u00a0Single Quotes\nA character literal can be expressed by enclosing it in single quotes The following are a few examples\nchar c1  A\nchar c2  L\nchar c3  5\nchar c4  \nRecall that a sequence of characters enclosed in double quotes is a String  literal A String  literal \ncannot be assigned to a char  variable even if the String  literal consists of only one character This \nrestriction is because Java does not allow you to mix values of primitive and reference data types String  is a \nreference data type whereas char  is a primitive data type The following are a few examples\nchar c1  A       OK\nString s1  A     An error Cannot assign a char A to a String s1\nString s2  A     OK A is a String literal assigned to a String variable\nString s3  ABC  OK ABC is a String literal\nchar c2  A       An error Cannot assign a String A to char c2\nchar c4  AB      An error A character literal must contain only one character\nCharacter Escape Sequence\nA character literal can also be expressed as a character escape sequence A character escape sequence starts \nwith a backslash immediately followed by a character and both are enclosed in single quotes There are \neight predefined character escape sequences as listed in Table\u00a0 44 You cannot define your own character \nescape sequence in Java\nTable 44  List of Character Escape Sequences\nCharacter Escape Sequence Description\nn A line feed\nr A carriage return\nf A form feed\nb A backspace\nt A tab\n A backslash\n A double quote\n A single quoteChapter 4  Data types\n119A character literal expressed in the form of a character escape sequence consists of two charactersa \nbackslash and a character following the backslash However they represent only one character The \nfollowing are a few examples of using character sequences\nchar c1  n  Assigns a linefeed to c1\nchar c2    Assigns double quote to c2\nchar c3  a  A compiletime error Invalid character escape sequence\nUnicode Character Escape Sequence\nA character literal can also be expressed as a Unicode escape sequence in the form uxxxx  Here u a \nbackslash immediately followed by a lowercase u denotes the start of the Unicode escape sequence and \nxxxx  represents exactly four hexadecimal digits The value represented by xxxx  is the Unicode value for the \ncharacter The character A has the Unicode value of 65 The value 65\u00a0in decimal can be represented in \nhexadecimal as 41 So the character A can be expressed in a Unicode escape sequence as u0041  The \nfollowing snippet of code assigns the same character A to the char  variables c1 and c2\nchar c1  A\nchar c2  u0041    Same as c2  A\nOctal Character Escape Sequence\nA character literal can also be expressed as an octal escape sequence in the form nnn  Here n is an octal \ndigit 07 The range for the octal escape sequence is 000  to 377  The octal number 377 is the same \nas the decimal number 255 Therefore using an octal escape sequence you can represent characters whose \nUnicode code ranges from 0 to 255 decimal integers\nA Unicode character set code range 065535 can be represented as a Unicode escape sequence  \nuxxxx  Why does Java have another octal escape sequence which is a subset of the Unicode escape \nsequence The octal escape sequences exist to represent characters for compatibility with other languages \nthat use 8bit unsigned chars to represent a character Unlike a Unicode escape sequence where you are \nalways required to use four hexadecimal digits in an octal escape sequence you can use one two or three \noctal digits Therefore an octal escape sequence may take on the form n  nn  or nnn  where n is one \nof the octal digits 0 1 2 3 4 5 6 and 7 Some examples of octal escape sequences are as follows\nchar c1  52\nchar c2  141\nchar c3  400  A compiletime error Octal 400 is out of range\nchar c4  42\nchar c5  10    Same as n\nYou can also assign an int literal to a char  variable if the int literal falls in the range 065535 When \nyou assign an int literal to a char  variable the char  variable represents the character whose Unicode code \nis equal to the value represented by that int literal The Unicode code for the character a lowercase A \nis 97 The decimal value 97 is represented as 141\u00a0in octal and 61\u00a0in hexadecimal You can represent the \nUnicode character a in different forms in Java a141  and u0061  You can also use int literal 97 to \nrepresent the Unicode character a The following four assignments have the same meanings in Java\nchar c1  97            Assign a to c1\nchar c2  a           Assign a to c2\nchar c3  141        Assign a to c3\nchar c4  u0061      Assign a to c4Chapter 4  Data types\n120A byte  variable takes 8 bits and a char  variable takes 16 bits Even if the byte  data type has a smaller \nrange than the char  data type you cannot assign a value stored in a byte  variable to a char  variable The \nreason is that byte  is a signed data type whereas char  is an unsigned data type If the byte  variable has \na negative value say 15 it cannot be stored in a char  variable without losing the precision For such an \nassignment to succeed you need to use an explicit cast The following snippet of code illustrates possible \ncases of assignments from char  to other integral data types and vice versa\nbyte b1  10\nshort s1  15\nint num1  150\nlong num2  20L\nchar c1  A\n byte and char\nb1  c1            An error\nb1  bytec1      OK\nc1  b1            An error\nc1  charb1      OK\n short and char\ns1  c1            An error\ns1  shortc1     OK\nc1  s1            An error\nc1  chars1      OK\n int and char\nnum1  c1          OK\nnum1  intc1     OK But cast is not required Use num1  c1\nc1  num1          An error\nc1  charnum1    OK\nc1  255           OK 255 is in the range of 065535\nc1  70000         An error 70000 is out of range 065535\nc1  char70000  OK  But will lose the original value\n long and char\nnum2  c1          OK\nnum2  longc1    OK But cast is not required Use num2  c1\nc1  num2          An Error\nc1  charnum2    OK\nc1  255L          An error 255L is a long literal\nc1  char255L    OK But use c1  255 instead\n The boolean Data Type\nThe boolean  data type has only two valid values true  and false  These two values are called boolean  \nliterals You can use boolean  literals as follows\n Declares a boolean variable named done\nboolean done\n Assigns true to done\ndone  trueChapter 4  Data types\n121 Ti p In Ja va 1 and 0 are not treated as boolean  values true  and false  respectively this is a change for \nyou if you are coming from a CC background Java defines only two boolean  values known as boolean  \nliterals which are true  and false  you cannot assign an y other values to a boolean  variable other than true  \nand false \nOne important point to note is that a boolean  variable cannot be cast to any other data type and vice \nversa Java does not specify the size of the boolean  data type Its size is left up to the JVM implementation \nTypically a value of a boolean  data type is mapped by the compiler to int and boolean  arrays are encoded \nas byte  arrays\n FloatingPoint Data Types\nA number that contains a fractional part is known as a real number for example 325 049 919 190 etc A \ncomputer stores every number real or integral in binary format which consists of only 0s and 1s Therefore \nit is necessary to convert a real number to its binary representation before it can be stored It must be \nconverted back to a real number after its binary representation is read When a real number is converted to \nits binary representation the computer must also store the position of the decimal point within the number \nThere are two strategies to store a real number in computer memory\n\t Store only the binary representation of the number assuming that there is always \na fixed number of digits before and after the point A point is called a decimal \npoint in the decimal representation of a number and a binary point in the binary \nrepresentation The type of representation in which the position of the point is \nalways fixed in a number is known as a fixedpoint number format \n\t Store the binary representation of the real number and the position of the point in \nthe real number Since the number of digits before and after the point can vary in this \nkind of representation of the real number we say that the point can float This kind of \nrepresentation is called a floatingpoint format \nFloatingpoint representations are slower and less accurate compared to fixedpoint representations \nHowever floatingpoint representations can handle a larger range of numbers with the same amount of \nmemory as compared with fixedpoint representations\nJava supports the floatingpoint number format It is important to note that not all real numbers have \nexact binary representations and therefore they are represented as floatingpoint approximations Java uses \nthe IEEE 754 floatingpoint standard to store real numbers IEEE is an initialism for the Institute of Electrical \nand Electronics Engineers Java has two floatingpoint numeric data types\n\tfloat\n\tdouble\n The float Data Type\nThe float  data type uses 32 bits to store a floatingpoint number in the IEEE 754 standard format A floating\npoint number represented in 32 bits according to the IEEE 754 standard is also known as a singleprecision \nfloatingpoint number It can represent a real number as small as 14 x 1045 and as big as 34 x 1038 \napprox in magnitude The range includes only the magnitude It could be positive or negative Here  \n14 x 1045 is the smallest positive number greater than zero that can be stored in a float  variableChapter 4  Data types\n122All real numbers that end with f or F are called float  literals A float  literal can be expressed in the \nfollowing two formats\n\t Decimal number format\n\t Scientific notation\nA few examples of float  literals in the decimal number format are as follows\nfloat f1  8F\nfloat f2  8F\nfloat f3  80F\nfloat f4  351F\nfloat f5  00F\nfloat f6  1678f\nThe real number 325  is also written using exponential forms such as 325 x 101 and 0325 x 101\nIn Java such real numbers can be represented as float  literals using scientific notation In scientific \nnotation the number 325 x 101 is written as 325E1  As a float  literal it can be written as 325E1F  or \n325E1f  All of the following float  literals denote the same real number 325 \n\t325F\n\t325E1F\n\t0325E1F\n\t0325E1F\n\t00325E2F\n\t00325e2F\n\t325E0F\nThe float  data type defines two zeros 00F  or 00F  and 00F  However for the comparison \npurposes 00F  and 00F  are considered equal\nThe float  data type defines two infinities positive infinity and negative infinity For example the result \nof dividing 25F  by 00F  is a float  positive infinity whereas the result of dividing 25F  by 00F  is a float  \nnegative infinity\nResults of some operations on float  are not defined For example dividing 00F  by 00F  is \nindeterminate Indeterminate results are represented by a special value of the float  data type called NaN \nNotaNumber Java has a Float  class note the uppercase F in Float  that defines three constants that \nrepresent positive infinity negative infinity and NaN of the float  data type Table\u00a0 45 lists these float  \nconstants and their meanings The table also lists two constants which represent the maximum and \nminimum greater than zero float  values that can be stored in a float  variableChapter 4  Data types\n123The value of all integral types  int long  byte  short  and char  can be assigned to a variable of the \nfloat  data type without using an explicit cast The following are a few examples\nint num1  15000\nfloat salary  num1              OK int variable to float\nsalary  12455                   OK int literal to float\nfloat bigNum  FloatMAXVALUE  Assigns maximum float value\nbigNum  1226L                   OK a long literal to float\nfloat justAChar  A            OK Assigns 650F to justAChar\n OK Assigns positive infinity to the fInf variable\nfloat fInf  FloatPOSITIVEINFINITY\n OK Assigns NotaNumber to fNan variable\nfloat fNan  FloatNaN\n A compiletime error Cannot assign a float literal to a float variable\n greater than the maximum value of float34E38F approx\nfloat fTooBig  35E38F\n A compiletime error Cannot assign a float literal to a float variable less\n than the minimum value greater than zero of float 14E45F\nfloat fTooSmall  14E46F\nA float  value must be cast before it is assigned to a variable of any integral data type int long  byte  \nshort  or char  The reason behind this rule is that an integral data type cannot store the fraction part stored \nin a float  value so Java warns you of a loss of precision when you convert a float  value to an integer Here \nare a few examples\nint num1  10\nfloat salary  106F\nnum1  salary         A a compiletime error Cannot assign float to int\nnum1  intsalary    OK num1 will store 10\nMost floatingpoint numbers are approximations of their corresponding real numbers The assignment \nof int and long  to float  may result in loss of precision Consider the following piece of code\nint num1  1029989998  Stores an integer in num1\nfloat num2  num1       Assigns the value stored in num1 to num2\nint num3  intnum2    Assigns the value stored in num2 to num3Table 45  Constants Defined in the Float Class\nFloat Constants Meaning\nFloatPOSITIVEINFINITY Positive infinity of type float\nFloatNEGATIVEINFINITY Negative infinity of type float\nFloatNaN NotaNumber of type float\nFloatMAXVALUE The largest positive value that can be represented in a float variable \nThis is equal to 34 x 1038 approx\nFloatMINVALUE The smallest positive value greater than zero that can be represented in \na float variable This is equal to 14 x 1045Chapter 4  Data types\n124You expect that the value stored in num1  and num3  should be the same However they are not because \nthe value stored in num1  cannot be stored exactly in a floatingpoint format in the float  variable num2  Not all \nfloatingpoint numbers have an exact representation in binary format This is the reason that num1  and num3  \nare not equal Refer to the section Binary Representation of FloatingPoint Numbers described later in this \nchapter for more details The following JShell session shows you that num3  is 18 more than num1 \njshell int num1  1029989998\nnum1  1029989998\njshell float num2  num1\nnum2  102999002E9\njshell int num3  intnum2\nnum3  1029990016\njshell num1   num3\n4  18\n Ti p a ssigning an int to a float  may result in loss of precision however such assignments do not result \nin errors in Java\n The double Data Type\nThe double  data type uses 64 bits to store a floatingpoint number in the IEEE 754 standard format A \nfloatingpoint number represented in 64 bits according to the IEEE 754 standard is also known as a double\nprecision floatingpoint number It can represent a number as small as 49 x 10324 and as big as 17 x 10308 \napprox in magnitude The range includes only magnitude It could be positive or negative Here 49 x 10324 \nis the smallest positive number greater than zero that can be stored in a double  variable\nAll real numbers are called double  literals A double  literal may optionally end with d or D for example \n1927d That is both 1927 and 1927d represent the same double  literal This book uses double  literals \nwithout the suffix d or D A double  literal can be expressed in the following two formats\n\t Decimal number format\n\t Scientific notation\nA few examples of double  literals in the decimal number format are as follows\ndouble d1  8D\ndouble d2  8\ndouble d3  80\ndouble d4  8D\ndouble d5  789867\ndouble d6  450\n Ti p 8 is an int literal whereas 8D 8 and 80 are double  literalsChapter 4  Data types\n125Like a float  literal you can also use scientific notation to express double  literals like so\ndouble d1  325E1\ndouble d2  0325E1\ndouble d3  0325E1\ndouble d4  00325E2\ndouble d5  00325e2\ndouble d6  325E1D\ndouble d7  0325E1d\ndouble d8  0325E1d\ndouble d9  00325E2d\nLike the float  data type the double  data type defines two zeros two infinities and a NaN They are \nrepresented by constants in the Double  class Table\u00a0 46 lists these constants and their meanings Table\u00a0 46 \nalso lists two constants which represent the maximum and minimum greater than zero double  values that \ncan be represented in a double  variable\nThe value of all integral types  int long  byte  short  char  and float  can be assigned to a variable of \nthe double  data type without using a cast\nint num1  15000\ndouble salary  num1               OK An int to double assignment\nsalary  12455                     OK An int literal to double\ndouble bigNum  DoubleMAXVALUE  Assigns the maximum double value to bigNum\nbigNum  1226L                     OK A long literal to double\ndouble justAChar  A             OK Assigns 650 to justAChar\n Assigns positive infinity to dInf variable\ndouble dInf  DoublePOSITIVEINFINITY\n Assigns NotaNumber to dNan variable\ndouble dNan  DoubleNaN\n A compiletime error Cannot assign a double literal to a double variable\n greater than the maximum value of double 17E308 approx\ndouble dTooBig  18E308\n A compiletime error Cannot assign a double literal to a double variable\n less than the minimum value greater than zero of double 49E324\ndouble dTooSmall  49E325Table 46  Con stants in the Double Class\nDouble Constants Meaning\nDoublePOSITIVEINFINITY Positive infinity of type double\nDoubleNEGATIVEINFINITY Negative infinity of type double\nDoubleNaN NotaNumber of type double\nDoubleMAXVALUE The largest positive value that can be represented in a double variable \nThis is equal to 17 x 10308 approx\nDoubleMINVALUE The smallest positive value greater than zero that can be represented in \na double variable This is equal to 49 x 10324Chapter 4  Data types\n126A double  value must be cast to the integral type before it is assigned to a variable of any integral data \ntype int long  byte  short  or char \nint num1  10\ndouble salary  100\nnum1  salary         A compiletime Error Cannot assign double to int\nnum1  int salary  Now Ok\n Underscores in\u00a0Numeric Literals\nBeginning with Java 7 you can use any number of underscores between two digits in numeric literals \nFor example an int literal 1969  can be written as 1969  1969  1969  1969  or any other forms using \nunderscores between two digits The use of underscores is also allowed in octal hexadecimal and binary \nformats Big numbers are harder to read without any punctuation marks eg a comma as a thousand \nseparator Use of underscores in big numbers makes them easier to read The following examples show the \nvalid uses of underscores in numeric literals\nint x1  1969              Underscore in decimal format\nint x2  1969            Multiple consecutive underscores\nint x3  03661            Underscore in octal literal\nint x4  0b011110110001  Underscores in binary literal\nint x5  0x7B1            Underscores in hexadecimal literal\nbyte b1  127             Underscores in decimal format\ndouble d1    19690919    Underscores in double literal\nUnderscores are allowed in numeric literals only between digits This means that you cannot use \nunderscores in the beginning or end of a numeric literal You cannot use underscores with prefixes such as \n0x for hexadecimal format and 0b for binary format and suffixes such as L for long  literals and F for float  \nliterals The following examples show the invalid uses of underscores in numeric literals\nint y1  1969           An error Underscore in the beginning\nint y2  1969           An error Underscore in the end\nint y3  0x7B1          An error Underscore after prefix 0x\nint y4  0x7B1          An error Underscore inside prefix 0x\nlong z1  1969L         An error Underscore with suffix L\ndouble d1  19690919  An error Underscore before decimal\ndouble d1  19690919  An error Underscore after decimal\n Ti p y ou can write the int literal 1969  in octal format as 03661  the zero at the beginning of an int literal \nin octal format is considered a digit not a prefix It is allowed to use underscores after the first zero in an int \nliteral in octal format you can write 03661  as 03661 Chapter 4  Data types\n127 Java Compiler and\u00a0Unicode Escape Sequence\nRecall that any Unicode character in a Java program can be expressed in the form of a Unicode escape \nsequence For example the character A can be replaced with u0041  The Java compiler first converts \nevery occurrence of a Unicode escape sequence to a Unicode character A Unicode escape sequence starts \nwith u followed by four hexadecimal digits u0041  is not a Unicode escape sequence To make uxxxx  \na valid part of a Unicode escape sequence it must be preceded by an odd number of backslashes because \ntwo contiguous backslashes   represent one backslash character Therefore u0041  represents a \nsixcharacter string composed of  u 0 0 4  and 1 However u0041  represents a two\ncharacter string A \nSometimes inappropriate use of Unicode escape sequences in Java source code may result in a \ncompiletime error Consider the following declaration of a char  variable\nchar c  u000A  Incorrect\nThe programmer intends to initialize the variable c with a line feed character whose Unicode escape \nsequence is u000A  When this piece of code is compiled the compiler will convert u000A  into an actual \nUnicode character and this piece of code will be split into two lines as follows\n After the actual linefeed is inserted\nchar c  \n         \nSince a character literal cannot continue in two lines this piece of code generates a compiletime error \nThe correct way to initialize the variable c is to use the character escape sequence n as shown\nchar c  n  Correct\nIn character literals and string literals line feed and carriage return should always be written as n and \nr respectively not as u000A  and u000D  Even a line of comment may generate a compiletime error if \nyou do not use the line feed and carriage return characters correctly Suppose you commented the wrong \ndeclaration of the char  variable as shown\n char c  u000A\nEven if this line is a comment line it will generate a compiletime error The comment will be split into \ntwo lines before compilation like so\n char c  \n\nThe second line which contains  causes the error The multiline comment syntax would not generate \na compiler error in such a case\n char c  u000A \nwould be converted to\n char c  \n \nwhich is still a valid multiline commentChapter 4  Data types\n128 A Short Break\nWe have finished discussing all primitive data types in Java In the following section we discuss the general \nconcepts of binary numbers and their use in representing different types of values in Java If you have a \ncomputer science background you may skip the following section\nClasses in this chapter are members of the jdojodatatype  module declared in Listing 41 The \nprogram in Listing 42 shows how to declare variables of different data types and use different types of \nliterals It also prints the values for some constants in the Double  class Java 8 has added the DoubleBYTES  \nconstant which contains the number of bytes used by a double  variable\nListing 41  The D eclaration of a Module Named jdojodatatype\n moduleinfojava\nmodule jdojodatatype \n     No module statement needed at this time\n\nListing 42  Using Primitive Data Types\n NumberTestjava\npackage comjdojodatatype\npublic class NumberTest \n    public static void mainString args \n        int anInt  100\n        long aLong  200L\n        byte aByte  65\n        short aShort  902\n        char aChar  A\n        float aFloat  1098F\n        double aDouble  89989\n         Print values of the variables\n        SystemoutprintlnanInt    anInt\n        SystemoutprintlnaLong    aLong\n        SystemoutprintlnaByte    aByte\n        SystemoutprintlnaShort    aShort\n        SystemoutprintlnaChar    aChar\n        SystemoutprintlnaFloat    aFloat\n        SystemoutprintlnaDouble    aDouble\n         Print some double constants\n        SystemoutprintlnMax double    DoubleMAXVALUE\n        SystemoutprintlnMin double    DoubleMINVALUE\n        SystemoutprintlnDoublePOSITIVEINFINITY    DoublePOSITIVEINFINITY\n        SystemoutprintlnDoubleNEGATIVEINFINITY    DoubleNEGATIVEINFINITY\n        SystemoutprintlnNotaNumber for double    DoubleNaN\n        SystemoutprintlnDouble takes   DoubleBYTES   bytes\n    \nChapter 4  Data types\n129anInt  100\naLong  200\naByte  65\naShort  902\naChar  A\naFloat  1098\naDouble  89989\nMax double  17976931348623157E308\nMin double  49E324\nDoublePOSITIVEINFINITY  Infinity\nDoubleNEGATIVEINFINITY  Infinity\nNotaNumber for double  NaN\nDouble takes 8 bytes\n Binary Representation of\u00a0Integers\nComputers use the binary number system to work with data All data in a binary system is stored using 1s \nand 0s Characters 1 and 0 are called bits short for binary digits They are the smallest units of information \na computer can work with A group of 8 bits is called a byte or octet Half a byte ie a group of 4 bits is \ncalled a nibble A computer uses a data bus a pathway to send data from one part of the computer system \nto another How much information can be moved from one part to another at one time depends on the bit \nwidth of the data bus The bit width of the data bus on a particular computer is also known as word size and \ninformation contained in one word size is simply referred to as a word Therefore a word may refer to 16bit \nor 32bit or another bit width depending on the computers architecture The long  and double  data types in \nJava take 64 bits On a computer with a word size of 32 bits these two data types are not treated atomically \nFor example to write a value in a long  variable two write actions are performedone for each 32bit half\nA decimal number can be converted to binary format using the following steps\n 1 Divide the decim al number successively by 2\n 2 After e ach division record the remainder This will be 1 or 0\n 3 Con tinue steps 1 and 2 until the result of the division is 0\n 4 The bin ary number is formed by writing digits in the remainder column from \nbottom to top\nFor example the binary representation of decimal number 13 can be computed as shown in Table\u00a0 47\nTable 47  DecimaltoBinary Conversion\nNumber Divided by 2 Result Remainder\n13 132 6 1\n6 62 3 0\n3 32 1 1\n1  0 1Chapter 4  Data types\n130The binary representation of decimal number 13 is 1101 A byte variable in Java occupies 1 byte \nThe value 13\u00a0in a byte variable is stored as 00001101 Note that four zeros are added in front of the binary \nrepresentation 1101 because a byte variable always occupies 8 bits irrespective of the value that it contains \nThe rightmost bit in a byte or a word is known as the least significant bit LSB and the leftmost bit as the \nmost significant bit MSB The MSB and LSB for the binary representation of 13 are shown in Figure\u00a0 47\nEach bit in a binary number is assigned a weight which is a power of 2 A binary number can be \nconverted to its decimal equivalent by multiplying each bit in the binary number by its weight and adding \nthem For example 1101\u00a0in binary can be converted to its decimal equivalent as follows\n11012    1 x 20  0 x 21  1 x 22  1 x 23\n           1  0  4  8\n           1310\nJava stores the negative integral numbers in 2s complement form Lets discuss the complement of a \nnumber in a given number system Every number system has a base also known as radix For example 10 is \nthe radix for the decimal number system 2 for the binary number system and 8 for the octal number system \nWe will use the symbol R for radix Every number system defines two types of complements\n\t Diminished radix complement which is also known as the R1s complement\n\t Radix complement which is also known as the Rs complement\nTherefore for the decimal number system we have 9s complement and 10s complement for the octal \nnumber system we have 7s and 8s complements and for the binary number system we have 1s and 2s \ncomplements\n Diminished Radix Complement\nLet N be a number in a number system with radix R and n the total number of digits in N\u00a0The diminished \nradix complement or R1s complement of the number N is defined as\nRn1  N\nIn the de cimal number system the 9s complement of the number N is\n 10n 1  N\nSince 10n consists of a 1 followed by n zeros 10n\u00a0 1 consists of n 9s Therefore 9s complement of \na number can be computed simply by subtracting each digit in the number from 9 For example the 9s \ncomplement of 5678 is 4321 and the 9s complement of 894542 is 105457\nIn the binary number system the 1s complement of a binary number is\n 2n1  NFigure 47  MSB a nd LSB in a binary numberChapter 4  Data types\n131Since 2n in the binary number system consists of a 1 followed by n zeros 2n\u00a0 1 consists of n 1s For \nexample the 1s complement of 10110 here n is 5 can be computed as 25\u00a0 1\u00a0 10110 which is 11111\n10110 25\u00a0 1 is 31 which is 11111\u00a0in binary\nThe 1s complement of a binary number can be computed simply by subtracting each digit in the \nnumber from 1 A binary number consists of 0s and 1s When you subtract 1 from 1 you get 0 and when \nyou subtract 0 from 1 you get 1 Therefore the 1s complement of a binary number can be computed just by \ninverting the bits of the number that is by changing 1 to 0 and 0 to 1 For example the 1s complement of \n10110 is 01001 and the 1s complement of 0110001 is 1001110\nIn a number system the R1s complement of a number is computed by subtracting each digit of \nthe number from the maximum digit value of that number system For example the maximum digit value \nin an octal number system is 7 and therefore the 7s complement of an octal number is computed by \nsubtracting each digit of that number from 7 For a hexadecimal number system the maximum digit value \nis 15 represented by F \u00a0For example the 7s complement of an octal number 56072 is 21705 and the 15s \ncomplement of a hexadecimal number 6A910F is 956EF0\n Radix Complement\nLet N be a number in a number system of radix R and n the total number of digits in the number N\u00a0The radix \ncomplement or the Rs complement of the number N is defined as follows\nRn  N\nFor N  0 the R s complement is defined as zero It is evident from the definition of the Rs and R1s \ncomplements that the Rs complement of a number is computed by adding 1 to the R1s complement \nof that number Therefore the 10s complement of a decimal number is obtained by adding 1 to its 9s \ncomplement and the 2s complement of a binary number is obtained by adding 1 to its 1s complement For \nexample the 2s complement of 10110 is 01001  1 which is 01010 By carefully looking at the procedure to \ncompute the 2s complement of a binary number you can observe that it can be computed just by looking \nat the binary number The simple procedure to compute the 2s complement of a binary number can be \ndescribed as follows\n 1 Star t from the right end of the binary number\n 2 Writ e down all digits unchanged up to the first 1 bit\n 3 Subs equently invert the bits to get the 2s complement of the binary number\nFor example lets compute the 2s complement of 10011000 Start from the right end and write down all \nthe digits unchanged up to the first 1 bit Since the fourth digit from the right is 1 you will write the first four \ndigits unchanged which is 1000 Now invert the bits starting from the fifth bit from the right which will give \nyou 01101000 This procedure is illustrated in Figure\u00a0 48\nFigure 48  Com puting 2s complement of a binary numberChapter 4  Data types\n132All negative integers  byte  short  int and long  are stored as their 2s complements in memory Lets \nconsider two byte  variables in Java\nbyte bPos  13\nbyte bNeg  13\nThe bPos  is stored in memory as 00001101 The 2s complement of 00001101 is computed as 11110011 \nTherefore bNeg  which is 13 is stored as 11110011 as shown in Figure\u00a0 49\n Binary Representation of\u00a0FloatingPoint Numbers\nA binary floatingpoint system can represent only a finite number of floatingpoint values in exact form All \nother values must be approximated by the closest representable value The IEEE 7541985 is the most widely \naccepted floatingpoint standard in the computer industry and it specifies the format and the method to \nrepresent binary floatingpoint numbers The goal of the IEEE standard which is designed for engineering \ncalculations is to maximize accuracy to get as close as possible to the actual number Precision refers \nto the number of digits that you can represent The IEEE standard attempts to balance the number of bits \ndedicated to the exponent with the number of bits used for the fractional part of the number to keep both \naccuracy and precision within acceptable limits This section describes the IEEE 7541985 standard for \nbinary floatingpoint format in general and points out how Java supports this standard A floatingpoint \nnumber has four parts\n\t Sign\n\t Significand also known as a mantissa\n\t Base also known as a radix\n\t Exponent\nThe floatingpoint number 1925 can be represented with all its four parts as\n1925 x 100\nHere the sign is  positive the significand is 1925 the base is 10 and the exponent is 0Figure 49  Storing the number 13\u00a0in 2s complement formsChapter 4  Data types\n133The number 1925 can also be represented in many other forms as shown here We omit the positive \nsign of the number by writing 1925 as 1925\n\t1925 x 100\n\t1925 x 101\n\t01925 x 102\n\t1925 x 101\n\t1925 x 102\nA floatingpoint number can be represented in an infinite number of ways A floatingpoint number \nrepresented in base 10 is said to be in normalized form if its significand satisfies the following rule\n01  significand  1\nAccording to this rule the representation 01925 x 102 is the normalized form of 1925 The floating\npoint number 1925 base 10 can be written as 1001101\u00a0in binary form base 2 The floatingpoint number \n1925 can be rewritten in many different binary forms Some of the alternate binary representations of \ndecimal 1925 are as follows\n\t1001101 x 20\n\t1001101 x 21\n\t1001101 x 22\n\t1001101 x 24\n\t1001101 x 21\n\t1001101 x 22\nNote that in binary form the base is 2 When the binary point is shifted to the left by one digit the \nexponent is incremented by one When the binary point is shifted to the right by one digit the exponent is \ndecremented by one A floatingpoint number in a binary form is normalized if its significand satisfies the \nfollowing condition\n1  significand  2\nIf the significand of a binary floatingpoint number is of the form 1bbbbbbb  where b is a bit 0 or 1 \nthe binary floatingpoint number is said to be in normalized form Therefore 1001101 x 24 is the normalized \nform of binary floatingpoint number 1001101 In other words a normalized binary floatingpoint number \nstarts with a bit 1 immediately followed by a binary point\nThe floatingpoint numbers which are not normalized are called denormalized floatingpoint \nnumbers A denormalized floatingpoint number is also called denormal or subnormal All floatingpoint \nnumbers cannot be represented in a normalized form There could be two reasons for this\n\t The number does not contain any bit as 1 An example of this is 00 Since 00 does \nnot have any bit set as 1 it cannot be represented in the normalized form\n\t Computers use a fixed number of bits to store the sign significand and exponent of \na binary floatingpoint number If the exponent of a binary floatingpoint number is \nthe minimum exponent allowed by the computer storage format and the significand \nis less than 1 such a binary floatingpoint number cannot be normalized For \nexample suppose that 126  is the minimum exponent value that can be stored in a Chapter 4  Data types\n134given storage format for a binary floatingpoint number If the binary floatingpoint \nnumber is 001101 x 2126 this number cannot be normalized The normalized \nform of this number will be 1101 x 2128 However the given storage format allows \na minimum exponent as 126  I have assumed number 126 for this example \nTherefore the exponent 128  128  126  cannot be stored in the given storage \nformat and that is why 001101 x 2126 cannot be stored in the normalized form\nWhy do we need to normalize a binary floatingpoint number before storing it in memory The \nfollowing are the advantages of doing this\n\t The normalized representation is unique\n\t Because the binary point in a binary floatingpoint number can be placed anywhere \nin the number you must store the position of the binary point along with the \nnumber By normalizing the number you always place the binary point after the first \n1 bit and therefore you need not store the position of the binary point This saves \nmemory and time to store one extra piece of information\n\t Two normalized binary floatingpoint numbers can be compared easily by \ncomparing their signs significands and exponents\n\t In a normalized form the significand can use all its storage bits to store significant \ndigits bits For example if you allocate only 5 bits to store the significand for \nthe number 00010110  210 only the 000101 part of the significand will be stored \nHowever if you normalize this number as 10110 x 27 the significand can be stored \nfully in 5 bits\n\t In a normalized form the significand always starts with a 1 bit which can be omitted \nwhile storing the significand When reading back you can add the leading 1 bit This \nomitted bit is called the hidden bit  and it provides one extra bit of precision\nThe IEEE 7541985 standard defines the four floatingpoint formats as follows\n\t 32bit singleprecision floatingpoint format\n\t 64bit doubleprecision floatingpoint format\n\t Singleextended floatingpoint format\n\t Doubleextended floatingpoint format\nJava uses IEEE 32bit singleprecision floatingpoint format to store the values of the float  data type It \nuses 64bit doubleprecision floatingpoint format to store the values of the double data type\nI discuss only IEEE 32bit singleprecision floatingpoint format The difference between single\nprecision floatingpoint format and other formats is the total number of bits used to store the binary floating\npoint numbers and the distribution of the number of bits among sign exponent and significand The \ndifference among different IEEE formats is shown at the end of the discussion\n 32Bit SinglePrecision FloatingPoint Format\nThe 32bit singleprecision floatingpoint format uses 32 bits to store a binary floatingpoint number A \nbinary floatingpoint number is of the following form\nSign  Significand  2ExponentChapter 4  Data types\n135Since the base is always 2 this format does not store the value of the base The 32 bits are distributed as \nfollows\n\t 1 bit to store the sign\n\t 8 bits to store the exponent\n\t 23 bits to store the significand\nThe layout for the singleprecision floatingpoint format is shown in Table\u00a0 48\n Sign\nIEEE singleprecision floatingpoint format uses 1 bit to store the sign of the number A 0 sign bit indicates a \npositive number and a 1 sign bit indicates a negative number\n Exponent\nThe exponent takes 8 bits The exponent can be positive or negative The range of the exponent value that \ncan be stored in 8 bits is 127 to 128 There must be a mechanism to represent the sign of the exponent Note \nthat the 1bit sign field in the layout shown in Table\u00a0 48 stores the sign of the floatingpoint number not the \nsign of the exponent To store the sign of the exponent you can use the signmagnitude method where 1 \nbit is used to store the sign and the remaining 7 bits store the magnitude of the exponent You can also use \nthe 2s complement method to store the negative exponent as is used to store integers However IEEE does \nnot use either of these two methods for storing the exponent IEEE uses the biased representation of the \nexponent to store the exponent value\nWhat is a bias and a biased exponent A bias is a constant value which is 127 for IEEE 32bit single\nprecision format The bias value is added to the exponent before storing it in memory This new exponent \nafter adding a bias is called a biased exponent The biased exponent is computed as follows\nBiased Exponent  Exponent  Bias\nFor example 1925 can be written in normalized binary floatingpoint format as 1001101 x 24 Here the \nexponent value is 4 However the exponent value stored in memory will be a biased exponent which will be \ncomputed as follows\nBiased Exponent  Exponent  Bias\n                 4  127 Singleprecision format\n                 131\nFor 1001101 x 24 131 will be stored as the exponent When reading back the exponent of a binary \nfloatingpoint number you must subtract the bias value for that format to get the actual exponent value\nWhy does IEEE use a biased exponent The advantage of using a biased exponent is that positive \nfloatingpoint numbers can be treated as integers for comparison purposesTable 48  IEEE Sin glePrecision Format Layout\n1Bit Sign 8Bit Exponent 23Bit Significand\ns Eeeeeeee fffffffffffffffffffffffChapter 4  Data types\n136Suppose E is the number of bits used to store the exponent value in a given floatingpoint format The \nvalue of the bias for that format can be computed as follows\nBias  2E  1  1\nThe exp onent ranges from 127 to 128 for the singleprecision format Therefore the biased exponent \nranges from 0 to 255 Two extreme exponent values 127 and 128 for unbiased and 0 and 255 for biased are \nused to represent special floatingpoint numbers such as zero infinities NaNs and denormalized numbers \nThe exponent range of 126 to 127 biased 1 to 254 is used to represent normalized binary floatingpoint \nnumbers\n Significand\nIEEE singleprecision floatingpoint format uses 23 bits to store the significand The number of bits used to \nstore the significand is called the precision of that floatingpoint format Therefore you might have guessed \nthat the precision of floatingpoint numbers stored in the singleprecision format is 23 However this is not \ntrue But first we need to discuss the format in which the significand is stored before we conclude about the \nprecision of this format\nThe significand of a floatingpoint number is normalized before it is stored in memory The normalized \nsignificand is always of the form 1fffffffffffffffffffffff  Here an f denotes a bit 0 or 1 for the \nfractional part of the significand Because the leading 1 bit is always present in the normalized form of the \nsignificand you need not store the leading 1 bit Therefore while storing the normalized significand you \ncan use all 23 bits to store the fractional part of the significand In fact not storing the leading 1 bit of a \nnormalized significand gives you one extra bit of precision This way you represent 24 digits 1 leading bit  \n23 fraction bits in just 23 bits Thus for a normalized significand the precision of a floatingpoint number in \nIEEE singleprecision format is 24\nActual Significand 1fffffffffffffffffffffff 24 digits\nStored Significand    fffffffffffffffffffffff 23 digits\nIf you always represent the significand of a binary floatingpoint number in normalized form there is a \ngap around zero on the number line The minimum number in magnitude that can be represented in IEEE \nsingleprecision format can be computed as follows\n\t Sign  It can be 0 or 1 denoting a positive or negative number For this example lets \nassume the sign bit is 0 to indicate a positive number\n\t Exponent  The minimum exponent value is 126 Recall that the exponent  \nvalues 127 and 128 are reserved to represent special floatingpoint numbers  \nThe minimum biased exponent will be 126  127  1 The binary representation of \nthe biased exponent 1\u00a0in 8bit is 00000001\n\t Significand  The minimum value of a significand in the normalized form will consist \nof the leading 1 bit and all 23 fraction bits set to 0 as 100000000000000000000000\nIf you combine the binary representation of a normalized floatingpoint number with the minimum \npossible values for the exponent and significand the actual number stored in the computer will look like the \none shown in Table\u00a0 49Chapter 4  Data types\n137The value of the minimum floatingpoint number in decimal is 10 x 2126 Therefore 10 x 2126 is the first \nrepresentable normalized number after zero leaving a gap around zero on the number line\nIf you store only normalized floatingpoint numbers using IEEE singleprecision format all numbers \nless than 10 x 2126 in magnitude must be rounded to zero This will cause a serious problem when dealing \nwith tiny numbers in a program In order to store numbers smaller than 10 x 2126 the numbers must be \ndenormalized\n Special FloatingPoint Numbers\nThis section describes special floatingpoint numbers and their representations in the IEEE singleprecision \nformat\n Signed Zeros\nThe IEEE floatingpoint format allows for two zeros 00 or 00 and 00 Zero is represented by the \nminimum exponent value 127 for the singleprecision format The significand is 00 for zero Since the \nsign bit can be 0 or 1 there are two zeros 00 and 00 The binary representations of zeros in the single\nprecision format are shown in Table\u00a0 410 \nFor comparison purposes 00 and 00 are considered equal Therefore the expression 00  00  \nalways returns true \nWhy does IEEE define two zeros if they are considered equal The sign of zero is used to determine the \nresult of an arithmetic expression involving multiplication and division The result of 30  00 is a positive \nzero 00 whereas the result of 30  00 is a negative zero 00 For a floatingpoint number num with the \nvalues Infinity the relation 11num  num  holds true only because of two signed zeros\n Signed Infinities\nThe IEEE floatingpoint format allows for two infinities positive infinity and negative infinity The sign bit \nrepresents the sign of infinity The maximum exponent value 128 the biased exponent 255 for the single\nprecision format and zero significand represents infinity The maximum biased value 255 can be represented \nin 8bit with all bits set to 1 as 11111111 The binary representations of infinities in singleprecision format \nare shown in Table\u00a0 411 Table 410  Binary Representations of Positive and Negative Zeros in the SinglePrecision Format\nNumber Sign Exponent Significand\n00 0 00000000 00000000000000000000000\n00 1 00000000 00000000000000000000000Table 49  Min imum Possible Normalized Number\nSign Exponent Significand\n0 00000001 00000000000000000000000\n1bit 8bit 23bitChapter 4  Data types\n138 NaN\nNaN stands for NotaNumber  NaN is the value used for arithmetic operations that do not have meaningful \nresults such as dividing zero by zero the square root of a negative number adding Infinity to Infinity etc\nNaN is represented by a maximum exponent value 128 for singleprecision format and a nonzero \nsignificand The sign bit is not interpreted for NaN What happens when NaN is one of the operands in an \narithmetic expression For example what is the result of NaN  100  Should the execution of an arithmetic \nexpression involving NaNs be stopped or continued There are two types of NaNs\n\t Quiet NaN\n\t Signaling NaN\nA quiet NaN when encountered as an operand in an arithmetic expression quietly ie without raising \nany trap or exception produces another quiet NaN as the result In the case of a quiet NaN the expression NaN \n 100  will result in another quiet NaN The most significant bit in the significand is set to 1 for a quiet NaN \nTable\u00a0 412  shows a binary representation of a quiet NaN In the table s and b indicate a 0 or 1 bit\nWhen a signaling NaN is encountered as an operand in an arithmetic expression an invalid operation \nexception is signaled and a quiet NaN is delivered as the result Signaling NaNs are generally used to initialize \nthe uninitialized variables in a program so when variables are not initialized before they are used errors \ncan be signaled The most significant bit of the significand is set to 0 for a signaling NaN Table\u00a0 413  shows a \nbinary representation of a signaling NaN In the table s and b indicate a 0 or 1 bit\n Tip Ieee defines 224\u00a0 2 distinct NaNs for the singleprecision format and 253\u00a0 2 distinct NaNs for the \ndoubleprecision format however Java has only one NaN for the float  data type and one NaN for the double  \ndata type Java always uses a quiet NaNTable 411  Binary Representations of Positive and Negative Infinities in the SinglePrecision Format\nNumber Sign Exponent Significand\nInfinity 0 11111111 00000000000000000000000\nInfinity 1 11111111 00000000000000000000000\nTable 412  A Bin ary Representation of a Quiet NaN\nNumber Sign Exponent Significand\nQuiet NaN s 11111111 1bbbbbbbbbbbbbbbbbbbbbb\nTable 413  A Bin ary Representation of a Signaling NaN\nNumber Sign Exponent Significand\nSignaling NaN s 11111111 0bbbbbbbbbbbbbbbbbbbbbbChapter 4  Data types\n139 Denormals\nWhen the biased exponent is 0 and the significand is nonzero it denotes a denormalized number Table\u00a0 414  \nshows the bit pattern to represent denormalized numbers in the singleprecision format\nIn Table\u00a0 414  s denotes a sign bit which can be 0 for a positive number and 1 for a negative number \nThe exponent bits are all zeros At least one of the bits in the significand is denoted 1 The decimal value of \nthe denormalized number is computed as shown\n1s  0fffffffffffffffffffffff  2126\nSuppose you want to store a number 025 x 2128 in the singleprecision format If you write this number \nin normalized form after converting 025\u00a0in binary it will be 10 x 2130 However the minimum exponent \nallowed for singleprecision format is 126 Therefore this number cannot be stored in normalized form in \nsingleprecision format The exponent is kept as 126 and the binary point is shifted to the left resulting in \ndenormalized form as 00001 x 2126 The number is stored as shown in Table\u00a0 415 \nIt seems that for the number 00001 x 2126 the biased exponent should be computed as 126  127  1 and \nthe exponent bits should be 00000001 However this is not true For denormalized numbers the exponent \nis stored as all 0 bits when reading it back it is interpreted as 126 This is because you need to distinguish \nbetween normalized and denormalized numbers when reading back floatingpoint numbers and for all \ndenormalized numbers there is no leading 1 bit in their significands The denormalized numbers fill the gap \naround zero on the number line which would have been there if you had stored only normalized numbers\n Rounding Modes\nNot all real numbers can be exactly represented in binary floatingpoint format in a finite number of bits \nTherefore real numbers that cannot be exactly represented in a binary floatingpoint format must be \nrounded There are four rounding modes\n\t Round toward zero\n\t Round toward positive infinity\n\t Round toward negative infinity\n\t Round toward nearestTable 414  The B it Pattern for a Denormalized SinglePrecision FloatingPoint Number\nSign Exponent Significand\nS 000000000 fffffffffffffffffffffff\nTable 415  Bit P attern for a Denormalized Number 10  2130\nNumber Sign Exponent Significand\n00001 x 2126 0 00000000 00010000000000000000000Chapter 4  Data types\n140 Rounding Toward Zero\nThis rounding mode is also called truncation or chop mode In this rounding mode the total number of \nbits or digits retained from the original number is the same as the number of bits available to store the \nfloatingpoint number in the given format The rest of the bits are ignored This rounding mode is called \nrounding toward zero because it has the effect of making the rounded result closer to zero Some examples \nof rounding toward zero are shown in Table\u00a0 416 \n Rounding Toward Positive Infinity\nIn this rounding mode numbers are rounded to a value closer to the positive infinity Some examples of \nrounding toward positive infinity are shown in Table\u00a0 417 \n Rounding Toward Negative Infinity\nIn this rounding mode numbers are rounded to a value closer to the negative infinity Some examples of \nrounding toward negative infinity are shown in Table\u00a0 418 Table 416  Examples of Rounding Toward Zero\nOriginal Number Available Number of Binary Points Rounded Number\n11101 2 111\n01011 2 010\n01010 2 010\n00011 2 000\nTable 417  Examples of Rounding Toward Positive Infinity\nOriginal Number Available Number of Binary Points Rounded Number\n11101 2 1000\n01011 2 010\n01010 2 011\n00011 2 001\nTable 418  Examples of Rounding Toward Negative Infinity\nOriginal Number Available Number of Binary Points Rounded Number\n11101 2 111\n01011 2 011\n01010 2 010\n00011 2 000Chapter 4  Data types\n141 Rounding Toward Nearest\nIn this rounding mode the rounded result is the nearest representable floatingpoint number In case of a tie \nthat is if there are two representable floatingpoint numbers that are equally near to the original number the \nresult is the one that has its least significant bit as zero In other words in case of a tie the rounded result is \nthe even number The system which implements IEEE floatingpoint standards has this mode as the default \nrounding mode The IEEE standard states that the system should also allow users to select one of the other \nthree rounding modes Java uses this mode as the default rounding mode for floatingpoint numbers Java \ndoes not allow users ie programmers to select any other rounding modes Some examples of rounding \ntoward nearest are shown in Table\u00a0 419 \n IEEE FloatingPoint Exceptions\nThe IEEE floatingpoint standard defines several exceptions that occur when the result of a floatingpoint \noperation is unacceptable Exceptions can be ignored in which case some default action is taken such as \nreturning a special value When trapping is enabled for an exception an error is signaled whenever that \nexception occurs Floatingpoint operations can lead to any of the following five types of floatingpoint \nexceptions\n\t Division by zero exception\n\t Invalid operation exception\n\t Overflow exception\n\t Underflow exception\n\t Inexact exception\n Division by Zero Exception\nA division by zero exception occurs when a nonzero number is divided by a floatingpoint zero If no trap \nhandler is installed infinity of the appropriate sign is delivered as the result\n Invalid Operation Exception\nAn invalid operation exception occurs when the operand is invalid for an operation being performed If no \ntrap handler is installed a quiet NaN is delivered as the result The following are some of the operations that \nraise an invalid exception\n\t Square root of a negative number\n\t Division of zero by zero or of infinity by infinityTable 419  Examples of Rounding Toward Nearest\nOriginal Number Available Number of Binary Points Rounded Number\n11101 2 111\n01011 2 011\n01010 2 010\n00011 2 001Chapter 4  Data types\n142\t Multiplication of zero and infinity\n\t Any operation on a signaling NaN\n\t Subtracting infinity from infinity\n\t When a quiet NaN is compared with the  or  relational operator\n Overflow Exception\nAn overflow exception occurs when the result of a floatingpoint operation is too large in magnitude to fit in \nthe intended destination format For example this will occur when you multiply FloatMAXVALUE  by 2 and \ntry to store the result in a float  variable If no trap handler is installed the result to be delivered depends on \nthe rounding mode and the sign of the intermediate result\n\t If the rounding mode is rounding toward zero the result of overflow is the largest \nfinite number that can be represented in that format The sign of the result is the \nsame as the sign of the intermediate result\n\t If the rounding mode is rounding toward positive infinity the negative overflow \nresults in the most negative finite number for that format and the positive overflow \nresults in the most positive finite number for that format\n\t If the rounding mode is rounding toward negative infinity the negative overflow \nresults in negative infinity and the positive overflow results in the most positive \nfinite number for that format\n\t If the rounding mode is rounding toward nearest the overflow results in infinity The \nsign of the result is the same as the sign of the intermediate result\nHowever if a trap handler is installed the result delivered to the trap handler in case of an overflow is \ndetermined as follows the infinitely precise result is divided by 2t and rounded before delivering it to the \ntrap handler The value of t is 192 for singleprecision format 1536 for doubleprecision format and 3 x 2n1 \nfor extended format where n is the number of bits used to represent the exponent\n Underflow Exception\nThe underflow exception occurs when the result of an operation is too small to be represented as a \nnormalized float  in its format If trapping is enabled the floatingpoint underflow exception is signaled \nOtherwise the operation results in a denormalized float  or zero Underflow can be abrupt or gradual If \nthe result of an operation is less than the minimum value that can be represented in normalized form in \nthe format the result could be delivered as zero or a denormalized number In case of an abrupt underflow \nthe result is zero In case of a gradual underflow the result is a denormalized number The IEEE default is \ngradual underflow denormalized numbers Java supports gradual underflow\n Inexact Exception\nThe inexact exception is signaled if the rounded result of an operation is not identical to the infinitely precise \nresult Inexact exceptions are quite common 1030 is an inexact operation Inexact exceptions also occur \nwhen the operation overflows without an overflow trapChapter 4  Data types\n143 Java and\u00a0IEEE FloatingPoint Standards\nJava follows a subset of the IEEE 754 standard The following are some of the differences between the IEEE \nfloatingpoint standard and its Java implementations\n\t Java does not signal the IEEE exceptions\n\t Java has no signaling NaN\n\t Java uses the rounding toward nearest mode to round the inexact results However \nJava rounds toward zero when converting a floating value to an integer Java does not \nprovide the userselectable rounding modes for floatingpoint computations up \ndown or toward zero\n\t IEEE defines 224\u00a0 2 NaNs for singleprecision format and 253\u00a0 2 NaNs for double\nprecision format However Java defines only one NaN for each of these two formats\nTable 420  lists the parameters for different IEEE formats\n LittleEndian and\u00a0BigEndian\nThese two terms are related to the direction of bytes in a word within the CPU architecture Computer \nmemory is referenced by addresses that are positive integers It is natural to store numbers with the least \nsignificant byte coming before the most significant byte in the computer memory Sometimes computer \ndesigners prefer to use a reverseorder version of this representation The natural order where the less \nsignificant byte comes before the more significant byte in memory is called littleendian Many vendors like \nIBM Cray and Sun prefer the reverse order that of course is called bigendian For example the 32bit hex \nvalue 0x45679812 would be stored in memory as follows\nAddress         00  01  02  03\n\nLittleendian    12  98  67  45\nBigendian       45  67  98  12\nDiffer ence in endianness can be a problem when transferring data between two machines Table\u00a0 421  \nlists some vendors their float  types and the endianness on their machinesTable 420  Parameters for the IEEE Formats\nWidth in\nBitsExponent\nWidth in BitsPrecision Maximum\nExponentMinimum\nExponentExponent Bias\nSingleprecision 32 8 24 127 126 127\nDoubleprecision 64 11 53 1023 1022 1023\nSingleextended  43  11  32  1023  1022 Unspecified\nDoubleextended  79  15  64  16383  16382 UnspecifiedChapter 4  Data types\n144Everything in Java binary format files is stored in bigendian order This is sometimes called network \norder This means that if you use only Java all files are done the same way on all platforms Mac PC UNIX \netc You can freely exchange binary data electronically without any concerns about endianness The \nproblem comes when you must exchange data files with some program not written in Java that uses little\nendian order most commonly a program written in C\u00a0Some platforms use bigendian order internally Mac \nIBM 390 some use littleendian order Intel Java hides that internal endianness from you\n Summary\nEverything in a program such as values and entities that needs to be referred to is given a name A name in \nJava is called an identifier An identifier in Java is a sequence of characters of unlimited length The sequence \nof characters includes all Java letters and Java digits the first of which must be a Java letter Java uses the \nUnicode character set A Java letter is a letter from any language that is represented by a Unicode character \nset For example AZ az  underscore and  are considered Java letters from the ASCII character set \nrange of Unicode Java digits include 09 ASCII digits and any Unicode character that denotes a digit in a \nlanguage Spaces are not allowed in an identifier\nKeywords are words that have predefined meanings in the Java programming language The Java \nprogramming language defines several keywords Beginning Java SE 9 underscore   is a keyword A \nfew examples of keywords in Java are class  if do while  int long  and for Keywords cannot be used \nas identifiers Reserved keywords are keywords that have been reserved for future use for example goto  \nand const  A restricted keyword is a keyword that has special meaning when used in specific places and \nin other places is not treated as a keyword Examples of restricted keywords are module  exports  open  \nopens  requires  etc Starting in Java 10 var is not a keyword but can be used as an inferred type for local \nvariables\nEvery value in Java has a data type Java supports two kinds of data types primitive data types and \nreference data types Primitive data types represent atomic indivisible values Java has eight primitive data \ntypes byte  short  int long  float  double  char  and boolean  Literals of primitive data types are constants \nthat can be represented directly in source code Reference data types represent references of objects in \nmemory Java is a statically typed programming language That is it checks the data types of all values at \ncompile time\nThe byte  data type is an 8bit signed Java primitive integer data type Its range is 128 to 127 27 to 27\u00a0 1 \nThis is the smallest integer data type available in Java\nThe short  data type is a 16bit signed Java primitive integer data type Its range is 32768 to 32767 or 215 \nto 215\u00a0 1Table 421  Vendors Float Types and EndianNess\nVendor Float Type Endianness\nAlpha DECIEEE Littleendian\nIBM IBM Bigendian\nMac IEEE Bigendian\nSun IEEE Bigendian\nVAX DEC Littleendian\nPC IEEE LittleendianChapter 4  Data types\n145The int data type is a 32bit signed Java primitive data type A variable of the int data type takes 32 bits \nof memory Its valid range is 2147483648 to 2147483647 231 to 231\u00a0 1 All whole numbers in this range \nare known as integer literals or integer constants For example 10 200 0 30 19 etc are integer literals of \nint type\nThe long  data type is a 64bit signed Java primitive data type It is used when the result of calculations \non whole numbers may exceed the range of the int data type Its range is 9223372036854775808 to \n9223372036854775807 263 to 263\u00a0 1 All whole numbers in the range of long  are called integer literals of \nlong  type An integer literal of long  type must end with L or l for example 10L and 897L\nThe char  data type is a 16bit unsigned  Java primitive data type Its value represents a Unicode \ncharacter The range of the char  data type is 065535 which is the same as the range of the Unicode \ncharacter set A character literal represents a value of the char  data type and it can be represented in \nfour formats a character enclosed in single quotes as an escape sequence enclosed in single quotes as \na Unicode escape sequence and as an octal escape sequence A X and 8 are examples of char  literals\nThe float  data type uses 32 bits to store a floatingpoint number in the IEEE 754 standard format\nA floatingpoint number represented in 32 bits according to the IEEE 754 standard is also known as a \nsingleprecision floatingpoint number It can represent a real number as small as 14 x 1045 and as big as 34 \nx 1038 approx in magnitude The range includes only the magnitude It could be positive or negative Here \n14 x 1045 is the smallest positive number greater than zero that can be stored in a float  variable\nA float  literal must end with an F or f A few examples of float  literals are 20f 56F  and 078F \nThe double  data type uses 64 bits to store a floatingpoint number in the IEEE 754 standard format \nA floatingpoint number represented in 64 bits according to the IEEE 754 standard is also known as a \ndoubleprecision floatingpoint number It can represent a number as small as 49 x 10324 and as big as 17 \nx 10308 approx in magnitude The range includes only magnitude It could be positive or negative All real \nnumbers are called double  literals A double  literal may optionally end with d or D for example 1927d That \nis both 1927 and 1927d represent the same double  literal\nThe boolean  data type has only two valid values true  and false  These two values are called boolean  \nliterals\nTo make big numeric values expressed as numeric literals more readable Java allows you to use any \nnumber of underscores between two digits in numeric literals For example an int literal 1969  can be \nwritten as 1969  1969  1969  1969  or any other forms using underscores between two digits The use \nof underscores is also allowed in octal hexadecimal and binary formats\nEXERCISES\n 1 What is an identifier in Java What can an identifier consist of List five valid and \nfive invalid identifiers in Java\n 2 What are keywords reserved keywords and restricted keywords in Java Is an \nunderscore a keyword in Java\n 3 What is a data type What is the difference between a primitive data type and a \nreference data type\n 4 List the names of all eight primitive da ta types supported by the Java programming \nlanguage List their size in bytes\n 5 What are literals List two literals of each primitive type in Java\n 6 What is the shortest numeric primitive type in Java What is the range  \nof its valuesChapter 4  Data types\n146 7 Consider the follo wing two variable declarations\nbyte small  10\nint big  99\nhow will you assign the value in the big variable to the small  variable\n 8 Why do you need to use a cast when you assign a variable of a bigger size to a \nvariable of smaller size  for example assigning an int variable to a byte  variable\n 9 Name two primitive da ta types in Java whose values can be floatingpoint \nnumbers\n 10 If you dec lare a variable of the boolean  type what are the two possible values it \ncan have\n 11 Can you cast a boolean  value to an int type as shown in the following \nstatement\nboolean done  true\nint x  int done\nWhat happens when you compile this snippet of code\n 12 are the boolean  literals true  and false  the same as integers 1 and 0\n 13 Name an unsigned numeric da ta type in Java\n 14 Name the four different forma ts of writing the literals of char  data types Give two \nexamples of each\n 15 how do you represent a backslash   and a double quote   as char  literals \nin Java Write code to declare two char  variables named c1 and c2 assign a \nbackslash character to c1 and a double quote character to c2\n 16 What are 1s and 2s complements of binary numbers Compute the 1s and 2s \ncomplements of the binary number 10111011\n 17 Why does the follo wing line of comment in a Java program not compile  u000A  is \na Unicode code value for line feed\nchar c  u000A\n 18 how many zeros are supported by float  and double  data types\n 19 What is NaN how many NaNs are supported by float  and double  types in Java \nDifferentiate between a quiet NaN and a signaling NaN What types of NaNs are \nsupported by Javaquiet NaNs signaling NaNs or both\n 20 What are denormals or denormalized floatingpoint numbers\n 21 What are the different rounding modes for floatingpoint numbers What rounding \nmodes are supported by Java\n 22 What are littleendian order and bigendian order What endian order does Java \nuse to encode the multibyte binary data in class files147\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730745CHAPTER 5\nOperators\nIn this chapter you will learn\n\t What operators are\n\t The different types of operators available in Java\n\t Operator precedence which determines the order in which operators are evaluated \nwhen multiple operators are used in the same expression\nWe use a lot of snippets of code in this chapter The quickest way to evaluate those snippets and see the \nresults is to use the JShell tool Refer to Chapter 2 on how to start the JShell tool on a command prompt\nAll classes in this chapter are members of a module named jdojooperator  whose declaration is \nshown in Listing 51\nListing 51  Declaration of a Module Named jdojooperator\n moduleinfojava\nmodule jdojooperator \n     No module statements\n\n What Is an\u00a0Operator\nAn operator  is a symbol that performs a specific kind of operation on one two or three operands and \nproduces a result The type of the operator and its operands determine the kind of operation performed and \nthe type of the result produced Operators in Java can be categorized based on two criteria\n\t The number of operands they operate on\n\t The type of operation they perform on the operands\nThere are three types of operators based on the number of operands\n\t Unary operator\n\t Binary operator\n\t Ternary operatorChapter 5  Operat Ors\n148If an operator takes one operand its called a unary operator if it takes two operands its called a binary \noperator if it takes three operands its called a ternary operator\nA unary operator can use postfix or prefix notation In the postfix notation the operator appears after \nits operand\noperand postfixunaryoperator\nThe following is an example of using a postfix unary operator\n num is an operand and  is a Java unary operator\nnum\nIn a prefix notation the unary operator appears before its operand\nprefixunaryoperator operand\nThe following is an example of using a prefix unary operator Note that the  operator in Java can be \nused as a prefix as well as postfix operator\n  is a Java unary operator and num is an operand\nnum\nA binary operator uses infix notation The operator appears in between the two operands The syntax to \nuse an infix binary operator is as follows\nfirstoperand infixbinaryoperator secondoperand\nThe following is an example of using  as an infix binary operator\n 10 is the first operand  is a binary operator and 15 is the second operand\n10  15\nLike a binary operator a ternary operator uses infix notation The syntax to use an infix ternary operator \nis as follows\nfirstoperand operator1 secondoperand operator2 thirdoperand\nHere both operator1  and operator2  make a ternary operator\nThe following is an example of using a ternary operator in Java\n isSunday is the first operand  is the first part of ternary operator\n holiday is the second operand is the second part of ternary operator noHoliday is the\n third operand\nisSunday  holiday  noHoliday\nDepending on the type of operation an operator performs you can categorize them in the following \ncategories\n\t Arithmetic operators\n\t Relational operatorsChapter 5  Operat Ors\n149\t Logical operators\n\t Bitwise operators\nJava has a big list of operators This chapter discusses most of the Java operators We discuss a few of \nthem in later chapters when the context is appropriate Enjoy the long journey of learning operators in Java \nin subsequent sections\n Assignment Operator\nAn assignment operator   is used to assign a value to a variable It is a binary operator It takes two \noperands The value of the righthand operand is assigned to the lefthand operand The lefthand operand \nmust be a variable for example\nint num\nnum  25\nHere num  25  uses the assignment operator  In this example 25 is the righthand operand and num \nis the lefthand operand which is a variable\nJava ensures that the value of the righthand operand of the assignment operator is assignment \ncompatible to the data type of the lefthand operand otherwise a compiletime error occurs In the case \nof reference variables you may be able to compile the source code and get a runtime error if the object \nrepresented by the righthand operand is not assignment compatible to the reference variable specified as \nthe lefthand operand For example the values of type byte  short  and char  are assignment compatible to \nthe int data type and hence the following snippet of code is valid\nbyte b  5\nchar c  a\nshort s  200\nint i  10\ni  b  OK byte b is assignment compatible to int i\ni  c  OK char c is assignment compatible to int i\ni  s  OK short s is assignment compatible to int i\nHowever long toint and float toint assignments are not compatible and hence the following \nsnippet of code generates compiletime errors\nlong big  524L\nfloat f  119F\nint i  15\ni  big  A compiletime error long to int assignment incompatible\ni  f    A compiletime error float to int assignment incompatible\nIn cases where the righthand operands value is not assignment compatible with the lefthand \nvariables data type the value of the righthand operand must be cast to the appropriate type The previous \npiece of code which uses assignment operators can be rewritten with a cast as follows\ni  intbig  OK\ni  intf     OKChapter 5  Operat Ors\n150An expression  is a series of variables operators and method calls constructed according to the syntax of \nthe Java programming language that evaluates to a single value For example num  25  is an expression The \nexpression which uses the assignment operator also has a value The value of the expression is equal to the \nvalue of the righthand operand Consider the following piece of code assuming that num is an int variable\nnum  25\nHere num  25  is called an expression and num  25  is called a statement The expression num  25  \ndoes two things\n\t Assigns the value 25 to the variable num\n\t Produces a value 25 which is equal to the value of the righthand operand of the \nassignment operator\nThe second effect producing a value of using the assignment operator in an expression may seem \nstrange at this point You may wonder what happens to the value 25 produced by the expression num  25  \nDo we ever use the value returned by an expression The answer is yes We do use the value returned by an \nexpression Consider the following expression which uses chained assignment operators assuming that \nnum1  and num2  are int variables\nnum1  num2  25\nWhat happens when this code is executed First the part of the expression num2  25  is executed\nAs mentioned earlier there will be two effects of this execution\n\t It will assign a value of 25 to num2 \n\t It will produce a value of 25 In other words you can say that after assigning the value \n25 to num2  the expression num2  25  is replaced by a value 25 which changes the \nmain expression num1  num2  25  to num1  25 \nNow the expression num1  25  is executed and the value 25 is assigned to num1  and the value \nproduced which is 25 is ignored This way you can assign the same value to more than one variable in a \nsingle expression There can be any number of variables used in such a chained assignment expression\nFor example\nnum1  num2  num3  num4  num5  num6  219\nSuppose that there are two int variables num1  and num2  The following assignment num1  num2  \nassigns the value 200 stored in num2  to num1 \nint num1  100  num1 is 100\nint num2  200  num2 is 200\nnum1  num2     num1 is 200 num2 is 200\nnum2  500       num2 is 500 num1 is still 200\nWhen you say num1  num2  the value stored in num2  is copied to num1  and both num1  and num2  maintain \ntheir own copy of the same value 200 Later on when num2  500  is executed the value of only num2  \nchanges to 500 But the value of num1  remains the same 200 Now suppose there are two reference variables \nref1  and ref2  which refer to two different objects of the same class Suppose we write\nref1  ref2Chapter 5  Operat Ors\n151The effect of the expression ref1  ref2  is that both reference variables ref1  and ref2  now refer \nto the same object in memorythe object that is being referred to by ref2  After this assignment both \nreference variables ref1  and ref2  are equally capable of manipulating the object The changes made to the \nobject in memory by reference variable ref1  will be observed by ref2  also and vice versa Chapter 7 covers \nmore on reference variable assignments\n Declaration Initialization and\u00a0Assignment\nBefore a variable of any type is used in a Java program it must be declared and have a value assigned to it \nSuppose you want to use an int variable named num1  First you must declare it as follows\n Declaration of a variable num1\nint num1\nA value can be assigned to a variable after it is declared or at the time of declaration itself When a value \nis assigned to a variable after it has been declared it is known as assignment The following piece of code \ndeclares an int variable num2  and assigns 50 to it\nint num2     Declaration of a variable num2\nnum2  50    Assignment\nWhen a value is assigned to a variable at the time of declaration itself it is known as initialization\nThe following code declares an int variable num3  and initializes it to a value 100\n Declaration of variable num3 and its initialization\nint num3  100\nYou can declare more than one variable of the same type in one declaration by separating each \nvariables name by a comma\n Declaration of three variables num1 num2 and num3 of type int\nint num1 num2 num3\nYou can also declare more than one variable in one declaration and initialize some or all\n Declaration of variables num1 num2 and num3 Initialization of only num1 and num3\nint num1  10 num2 num3  200\n Declaration and initialization of variables num1 num2 and num3\nint num1  10 num2  20 num3  30\nJava will not let you use a variable unless it has been assigned a value either through the process of \ninitialization or assignment Java implicitly initializes variables declared in a few contexts Variables declared \nin other contexts must be initialized or assigned a value before they are used if Java does not initialize \nthem implicitly We discuss the implicit initialization of a variable by Java in Chapter 7 It is good practice to \ninitialize a variable at the time of its declarationChapter 5  Operat Ors\n152 Arithmetic Operators\nAn arithmetic operator is an operator that takes numeric values as its operands and performs an arithmetic \noperation for example addition and subtraction to compute another numeric value Table\u00a0 51 lists all \narithmetic operators in Java All operators listed in Table\u00a0 51 can only be used with numerictype operands \nThat is both operands to arithmetic operators must be one of types byte  short  char  int long  float  and \ndouble  These operators cannot have operands of boolean  primitive type and reference type The following \nsections describe arithmetic operators in detail\nTable 51   List of Arithmetic Operators in Java\nOperators Description Type Usage Result\n Addition Binary 2  5 7\n Subtraction Binary 5  2 3\n Unary plus Unary 5 Positive of five Same as 5\n Unary minus Unary 5 Negative of five\n Multiplication Binary 5  3 15\n Division Binary 5  2 2\n6  2 3\n50  20 25\n60  20 30\n Modulus Binary 5  3 2\n Increment Unary num Evaluates to the value of num \nIncrement num by 1\n Decrement Unary num Evaluates to the value of num \nDecrement num by 1\n Arithmetic compound \nassignmentBinary num  5 Adds 5 to the value of num and assigns \nthe result to num If num is 10 the new \nvalue of num will be 15\n Arithmetic compound \nassignmentBinary num  3 Subtracts 3 from the value of num and \nassigns the result to num If num is 10 the \nnew value of num will be 7\n Arithmetic compound \nassignmentBinary num  15 Multiplies 15 by the value of num and \nassigns the result to num If num is 10 the \nnew value of num will be 150\n Arithmetic compound \nassignmentBinary num  5 Divides the value of num by 5 and assigns \nthe result to num If num is 10 the new \nvalue of num will be 2\n Arithmetic compound \nassignmentBinary num  5 Calculates the remainder of num divided \nby 5 and assigns the result to num If num \nis 12 the new value of num will be 2Chapter 5  Operat Ors\n153 Addition Operator \nThe addition operator   is an arithmetic operator and it is used in the following form\noperand1  operand2\nThe addition operator is used to add two numeric values represented by the two operands for example \n5  3 results in 8 The operands may be any numeric literals numeric variables numeric expressions or \nmethod calls Every expression involving the addition operator   has a data type The data type of the \nexpression is determined according to one of four rules\n\t If one of the operands is double  the other operand is converted to double  and the \nwhole expression is of type double \n\t If one of the operands is float  the other operand is converted to float  and the \nwhole expression is of type float\n\t If one of the operands is of long  the other operand is converted to long  and the \nwhole expression is of type long \n\t If none of the previous three rules applies all operands are converted to int \nprovided they are not already of int type and the whole expression is of type int\nThese rules have some important implications Consider a byte  variable b1 which is assigned a value of \n5 as shown in the following piece of code\nbyte b1\nb1  5\nYou get a compiletime error when you try to assign the same value 5 to a byte  variable b1 as shown in \nthe following snippet of code\nbyte b1\nbyte b2  2\nbyte b3  3\nb1  b2  b3  A compiletime error Trying to assign 5 to b1\nWhy does this snippet of code result in a compiletime error Do the expressions b1  5  and b1  b2 \n b3  not have the same effect of assigning 5 to the variable b1 Yes the effect would be the same However \nthe rules that govern the assignment operation are different in two cases In the expression b1  5  the \nassignment is governed by the rule that any int literal between 128 and 127 can be assigned to a byte  \nvariable Because 5 is between 128 and 127 the assignment b1  5  is valid The second assignment  \nb1  b2  b3  is governed by the fourth rule for the determination of the data type of an arithmetic \nexpression which uses the addition operator   Because both operands in the expression b2  b3  are of \nthe byte  type the operands b2 and b3 are first converted to int and then the expression b2  b3  becomes \nof the int type Because the data type of b1 is byte  which is smaller than the int data type of the expression \nb2  b3  the assignment b1  b2  b3  that is int to byte  is not compatible and that is the reason it \ngenerates an error In such a case you need to cast the result of the righthand expression to the data type of \nthe lefthand operand\nb1  byteb2  b3  OK nowChapter 5  Operat Ors\n154Beginners may try to write this statement of code as follows\nb1  byte b2  b3  A compiletime error again\nThe two expressions byteb2  b3  and byteb2  b3  are not the same In the expression byte \nb2  b3  first b2 and b3 are promoted to int and then an addition is performed which results in a value \n5 of the int type Then the int value 5 is cast to byte  and assigned to b1\nIn the expression byteb2  b3  first b2 is cast to byte  Note that this cast is redundant since b2 is \nalready of type byte  both b2 and b3 are promoted to int the whole expression byteb2  b3  is of type int \nSince inttobyte  assignment is not permitted the expression would not compile\nThe error produced by the second expression byteb2  b3  raises an interesting question Why did \nJava not first compute b2  b3  in byteb2  b3  and then apply  byte  to the result Because there were \ntwo operations to be done one being the cast to byte  and another being the addition of b2 and b3 Java did \ncast on b2 first and the addition second The decision to perform the cast first followed by the addition was \nnot arbitrary Each operator in Java has a precedence order The operator that has higher precedence is \nevaluated first before the operators having lower precedence The cast operator has higher precedence than \nthe addition operator This is the reason that byteb2  was evaluated first in byteb2  b3  You can always \noverride the precedence of operators using parentheses We overrode the precedence of the cast operator by \nusing parentheses in the expression byteb2  b3  Consider another example\nbyte b1\nb1  3  2  Will this line of code compile\nWill the expression b1  3  2  compile If we apply the fourth rule for determining the data type \nof this expression it should not compile because 3 and 2 are int literals The expression 3  2  is of type \nint Because int is not assignment compatible to byte  the expression b1  3  2  should give an error \nHowever our assumption is wrong and the expression b1  3  2  will compile fine In this case the \nassignment proceeds as follows\nThe operands 3 and 2 are constants so their values are known at compile time Therefore the compiler \ncomputes the result of the expression 3  2  at the time of compilation and replaces 3  2  by its result 5 \nThe expression b1  3  2  is replaced by b1  5  by the compiler Now you can see why Java didnt give any \nerrors for this expression Because the int literal 5 is in the range 128  to 127 b1  5  is a valid assignment \naccording to the rule of assignment of an int literal to a byte  variable However if you try to write an \nexpression as b1  127  10  certainly it would not compile because the result of 127  10  which is 137 is \nout of range for a byte  data type Here are the final words on the data type conversion of the operands and \nthe determination of the type of the expression involving the addition operator\nvar  operand1  operand2\nIf operand1  and operand2  are compiletime constants the result of operand1  operand2  determines \nwhether this assignment is valid If the result of operand1  operand2  is in the range for the data type of \nthe variable var the expression will compile Otherwise a compiler error is generated If either operand1  or \noperand2  is a variable ie the value of either operand1  or operand2  cannot be ascertained at compile time \nthe data type of the expression is determined according to one of the four rules discussed at the beginning \nof this section The following are examples of correct and incorrect uses of the addition operator The \ncomments along with the code indicate whether the use is correct\nbyte b1  2\nbyte b2  3\nshort s1  100\nint i  10Chapter 5  Operat Ors\n155int j  12\nfloat f1  25F\ndouble d1  200\n OK 125 is in the range 128 and 127\nb1  15  110\n An error Data type of i  5 is int and int to byte assignment is not permitted\nb1  i  5\nb1  bytei  5  OK\n An error s1 is promoted to int and s1  2 is of the data type int\n int to byte assignment is not permitted\nb1  s1  2\n An error b2 is promoted to float and f1  b2 is of the data type float\n float to byte assignment is not permitted\nb1  f1  b2\n An error f1 is promoted to double and f1  d1 is of the data type double\nb1  f1  d1\n OK i is promoted to float and i  f1 is of the data type float\nf1  i  f1\n An error i is promoted to double and i  d1 is of data type double\n double to float assignment is not permitted\nf1  i  d1\nf1  floati  d1  OK\n An error 20 and 30 are of the type double The result of 20  32 is 52\n which is also of the type double double to float assignment is not permitted\nf1  20  32\n OK 20F and 32F are of the type float The result of 20F  32F\n which is 52F is of the type float\nf1  20F  32F\n OK j is promoted to float and f1  j is of the data type float\n float to double assignment is permitted\nd1  f1  j\n Subtraction Operator \nThe subtraction operator   is an arithmetic operator and it is used in the following form\noperand1   operand2\nThe subtraction operator is used to compute the difference of two numbers for example 5  3 results \nin 2 All rules that we discussed about the numeric data conversion of the operands and the determination of \nthe data type of the expression involving the addition operator are also applicable to an expression involving \nthe subtraction operator The following are a few examples of using the subtraction operator\nbyte b1  5\nint i  100\nfloat f1  25F\ndouble d1  1545\n OK 200   173 will be replaced by 27\n b1  27 is OK because 27 is in the range 128 and 127\nb1  200   173Chapter 5  Operat Ors\n156 An error   i  27 is of the type int int to byte assignment is not allowed\nb1  i  27\nb1  bytei   27   OK Assigns 73 to b1\nd1  f1  i           OK Assigns 975 to d1\n Multiplication Operator \nThe multiplication operator   is an arithmetic operator and it is used in the following form\noperand1  operand2\nThe multiplication operator   is used to compute the product of two numbers for example 7  3  \nresults in 21 All rules that we discussed about the numeric data conversion of the operands and the \ndetermination of the data type of the expression involving the addition operator are also applicable \nto an expression involving the multiplication operator The following are some examples of using the \nmultiplication operator\nbyte b1  5\nint i  10\nfloat f1  25F\ndouble d1  1545\n OK 20  6 will be replaced by 120\n b1  120 is OK because 120 is in the range 128 and 127\nb1  20  6\n An error i  12 is of the type int int to byte assignment is not allowed\nb1  i  12\nb1  bytei  12  OK  Assigns 120 to b1\n OK i  b1 is of the type int int to float assignment is allowed\nf1  i  b1\n An error d1  i is of type double double to float assignment is not allowed\nf1  d1  i\nf1  floatd1  i  OK  Assigns 1545 to f1\n Division Operator \nThe division operator   is an arithmetic operator and it is used in the following form\noperand1  operand2\nThe division operator   is used to compute the quotient of two numbers for example 5020  results \nin 25 All rules we discussed about the numeric data conversion of the operands and the determination of \nthe data type of the expression involving the addition operator   are also valid for expressions involving the \ndivision operator There are two types of division\n\t Integer division\n\t Floatingpoint divisionChapter 5  Operat Ors\n157If both the operands of the division operator are integers that is byte  short  char  int or long  the \nusual division operation is carried out and the result is truncated toward zero to represent an integer For \nexample if you write an expression 52 the division yields 25 the fractional part 05 is ignored the result is \n2 The following examples illustrate the integer division\nint num\nnum  52  Assigns 2 to num\nnum  53  Assigns 1 to num\nnum  54  Assigns 1 to num\nnum  55  Assigns 1 to num\nnum  56  Assigns 0 to num\nnum  57  Assigns 0 to num\nIn all these examples the value assigned to the variable num is an integer The result is an integer in all \ncases not because the data type of variable num is int The result is an integer because both the operands of \nthe division operator are integers Because the data types of both operands are int the whole expression \n53 is of type int Because the fractional portion eg 05 0034 cannot be stored in an int the fractional \nportion is ignored and the result is always an integer Using the JShell tool is a great way to experiment with \nthese operators The following jshell  session shows you the results of these expressions\njshell int num\nnum  0\njshell num  52\nnum  2\njshell num  53\nnum  1\njshell num  54\nnum  1\njshell num  55\nnum  1\njshell num  56\nnum  0\njshell num  57\nnum  0\nIf either or both operands of the division operator are float  or double  a floatingpoint division is \nperformed and the result is not truncated Here are a few examples\nfloat f1\n 150F and 40F are of float type So the expression 150F40F is of the type float\n The result 375F is assigned to f1\nf1  150F40F\n 15 is of type int and 40F is of type float The expression 1540F is of type float\n The result 375F is assigned to f1\nf1  1540F\n An error 150 is of the type double and 40F is of the type float The expression\n 15040F is of type double The result 375 is of the type double and cannot be\n assigned to f1 because double to float assignment is not allowed\nf1  15040F\n OK 375F is assigned to f1\nf1  float15040FChapter 5  Operat Ors\n158 15 and 4 are of type int The expression 154 is of type int An integer division\n is performed The result 3 is assigned to f1 because int to float assignment is allowed\nf1  154\nWhat happens when you try to divide a number integer or floating point by zero The result of dividing \na number by zero depends on the type of division If an integer division is performed on the number \ndividing by zero results in a runtime error If you write an expression 30 in a Java program it compiles fine \nbut it gives an error when this expression is executed at runtime for example\nint i  2\nint j  5\nint k  0\ni  jk    A runtime error Divide by zero\ni  00    A runtime error Divide by zero\nIf either operand of the division operator is a floatingpoint number a floatingpoint division is \nperformed and the result of dividing the number by zero is not an error If the dividend in 72 7 is the \ndividend and 2 is the divisor is a nonzero number in a floatingpoint dividebyzero operation the result is \na positive infinity or a negative infinity If the dividend is a floatingpoint zero eg 00 or 00F the result is a \nNaN for example\nfloat f1  25F\ndouble d1  56\nf1  50F00F      FloatPOSITIVEINFINITY is assigned to f1\nf1  50F00F     FloatNEGATIVEINFINITY is assigned to f1\nf1  50F00F    FloatPOSITIVEINFINITY is assigned to f1\nf1  50F00F     FloatNEGATIVEINFINITY is assigned to f1\nd1  5000        DoublePOSITIVEINFINITY is assigned to d1\nd1  5000       DoubleNEGATIVEINFINITY is assigned to d1\nd1  5000      DoublePOSITIVEINFINITY is assigned to d1\nd1  5000       DoubleNEGATIVEINFINITY is assigned to d1\n 50F is of the type float and 0 is of the type int 50F0 is of type float\n FloatPOSITIVEINFINITY is assigned to f1\nf1  50F0\n A compiletime error 50F is of the type float and 00 is of the type double\n 50F00 is of the type double double to float assignment is not allowed\nf1  50F00\nf1  float50F00  f1 is assigned FloatPOSITIVEINFINITY\nf1  00F00F           Assigns FloatNaN to f1\nd1  0000             Assigns DoubleNaN to d1\nd1  0000            Assigns DoubleNaN to d1\n Modulus Operator \nThe modulus operator   is an arithmetic operator and it is used in the following form\noperand1  operand2Chapter 5  Operat Ors\n159The modulus operator   is also known as the remainder operator The modulus operator performs \na division on the lefthand operand by its righthand operand and returns the remainder of the division \nfor example 75 evaluates to 2 All rules about the numeric data conversion of the operands and the \ndetermination of the data type of the expression involving the addition operator   are also applicable to \nexpressions involving the modulus operator Because the use of the modulus operator involves a division \noperation there are a few special rules to determine the result of a modulus operation\nIf both operands of the modulus operator are integers the following rules are applied to compute \nthe result\n Rule 1\nIt is a runtime error if the righthand operand is zero for example\nint num\nnum  15  0  A runtime error\n Rule 2\nIf the righthand operand is not zero the sign of the result is the same as the sign of the lefthand operand \nfor example\nint num\nnum  15  6     Assigns 3 to num\nnum  15  6    Assigns 3 to num\nnum  15  6    Assigns 3 to num\nnum  15  6  Assigns 3 to num because lefthand operand is 15 which is negative\nnum  5  7      Assigns 5 to num\nnum  0  7      Assigns 0 to num\nIf either operand of the modulus operator is a floatingpoint number the following rules are applied to \ncompute the result\n Rule 1\nThe operation never results in an error even if the righthand operand is a floatingpoint zero\n Rule 2\nThe result is NaN if either operand is NaN for example\nfloat f1\ndouble d1\nf1  FloatNaN  105F       Assigns FloatNaN to f1\nf1  200F  FloatNaN       Assigns FloatNaN to f1\nf1  FloatNaN  FloatNaN  Assigns FloatNaN to f1\n A compiletime error The expression is of the type double\n double to float assignment is not allowed\nf1  FloatNaN  DoubleNaN\nd1  FloatNaN  DoubleNaN  Assigns DoubleNaN to d1Chapter 5  Operat Ors\n160 Rule 3\nIf the righthand operand is zero the result is NaN for example\nfloat f1\nf1  150F  00F  Assigns FloatNaN to f1\n Rule 4\nIf the lefthand operand is infinity the result is NaN for example\nfloat f1\nf1  FloatPOSITIVEINFINITY  21F  Assigns FloatNaN to f1\n Rule 5\nIf none of the previous rules apply the modulus operator returns the remainder of the division of the left\nhand operand and the righthand operand The sign of the result is the same as the sign of the lefthand \noperand for example\nfloat f1\ndouble d1\nf1  155F  65F                      Assigns 25F to f1\nd1  55  1565                        Assigns 55 to d1\nd1  00  378                         Assigns 00 to d1\nd1  850  DoublePOSITIVEINFINITY    Assigns 850 to d1\nd1  850  DoublePOSITIVEINFINITY  Assigns 850 to d1\nd1  850  DoubleNEGATIVEINFINITY    Assigns 850 to d1\nd1  850  DoubleNEGATIVEINFINITY  Assigns 850 to d1\n Unary Plus Operator \nThe unary plus operator   is an arithmetic operator and it is used in the following form\noperand\nThe operand  must be a primitive numeric type If the operand  is a byte  short  or char  the unary plus \noperator promotes it to an int Otherwise there is no effect of using this operator For example if there is an \nint variable num that has a value of 5 num  still has the same value 5 The following examples illustrate the \nuse of this operator\nbyte b1  10\nbyte b2  5\nb1  b2    OK byte to byte assignment\n A compiletime error b2 is of the type byte But use of the unary plus operator on\n b2 promoted its type to int Therefore b2 is of the type int\n int b2 to byte b1 assignment is not allowed\nb1  b2\nb1  byte b2  OKChapter 5  Operat Ors\n161 Unary Minus Operator \nThe unary minus operator   is an arithmetic operator and it is used in the following form\noperand\nThe unary minus operator arithmetically negates the value of its operand The operand  must be a \nprimitive numeric type If the operand  is a byte  short  or char  it is promoted to an int The following \nexamples illustrate its use\nbyte b1  10\nbyte b2  5\nb1  b2    OK byte to byte assignment\n A compiletime error b2 is of the type byte But use of unary minus operator  on\n b2 promoted its type to int Therefore b2 is of type int\n int b2 to byte b1 assignment is not allowed\nb1  b2\nb1  byte b2  OK\n Compound Arithmetic Assignment Operators\nEach of the five basic arithmetic operators      and  has a corresponding compound arithmetic \nassignment operator These operators can be explained better with an example Suppose you have two \nvariables num1  and num2 \nint num1  100\nbyte num2  15\nIf you want to add the value of num1  to num2  you would write the code as follows\nnum2  bytenum2  num1\nYou need to cast the result of num2  num1  to byte  because the data type of the expression is int The \nsame effect can be rewritten using a compound arithmetic operator   as follows\nnum2  num1  Adds the value of num1 to num2\nA compound arithmetic assignment operator is used in the following form\noperand1 op operand2\nHere op is one of the arithmetic operators     and  operand1  and operand2  are of primitive \nnumeric data types where operand1  must be a variable The previous expression is equivalent to the \nfollowing expression\noperand1  Type of operand1 operand1 op operand2\nFor example\nint i  100\ni  55       Assigns 105 to iChapter 5  Operat Ors\n162is equivalent to\ni  inti  55  Assigns 105 to i\nThere are two advantages of using the compound arithmetic assignment operators\n\t The operand1  is evaluated only once For example in i  55  the variable i is \nevaluated only once whereas in i  int i  55  the variable i is evaluated \ntwice\n\t The result is automatically cast to the type of operand1  before assignment The cast \nmay result in a narrowing conversion or an identity conversion In the previous \nexample the cast is a narrowing conversion The expression i  55  is of the type \ndouble  and the result of this expression is cast to int So the result double 1055  \nis converted to int 105  If you write an expression like i  5  the equivalent \nexpression will be i  inti  5  Because the type of the expression i  5  is \nalready int casting the result to int again is an identity conversion\nThe compound assignment operator  can also be applied to String  variables In such cases operand1  \nmust be of type String  and operand2  may be of any type including boolean  For example\nString str1  Hello\nstr1  str1  100      Assigns Hello100 to str1\ncan be rewritten as\nstr1  100  Assigns Hello100 to str1\n Ti p Only the  operator can be used with a String  lefthand operand\nThe following are examples of using the compound assignment operators In the examples each use of \na compound assignment operator is independent of the effects of its previous uses In all cases it has been \nassumed that the values of the variables remain the same as the values assigned to them at the time of their \ndeclarations\nint i  110\nfloat f  1202F\nbyte b  5\nString str  Hello\nboolean b1  true\ni  10    Assigns 120 to i\n           A compiletime error boolean type cannot be used with \n           unless lefthand operand here i is a String variable\ni  b1\ni  15    Assigns 95 to i Assuming i was 110\ni  2    Assigns 220 to i Assuming i was 110\ni  2    Assigns 55 to i Assuming i was 110\ni  0    Runtime error Divide by zero error\nf  00  Assigns FloatPOSITIVEINFINITY to f\ni  3    Assigns 2 to i Assuming i is 110Chapter 5  Operat Ors\n163str   How are you  Assigns Hello How are you to str\nstr  f    Assigns Hello1202 to str Assuming   str was Hello\nb  f     Assigns 125 to b Assuming b was 5 f was 1202\nstr  b1  Assigns Hellotrue to str Assuming str was Hello\n Increment  and\u00a0Decrement  Operators\nThe increment operator   is used with a variable of a numeric data type to increment the variables \nvalue by 1 whereas the decrement operator  is used to decrement the value by 1 In this section we \ndiscuss only the increment operator The same discussion applies to the decrement operator with the only \ndifference being that it will decrement the value by 1 instead of increment it by 1 Suppose there is an int \nvariable i declared as follows\nint i  100\nTo increment the value of i by 1 you can use one of the three following expressions\ni  i  1  Assigns 101 to i\ni  1     Assigns 101 to i\ni        Assigns 101 to i\nThe increment operator  can also be used in a more complex expression such as\nint i  100\nint j  50\nj  i  15    Assigns 115 to j and i becomes 101\nThe expression i  15  is evaluated as follows\n\t The value of i is evaluated and the righthand expression becomes 100  15 \n\t The value of i in memory is incremented by 1 So at this stage the value of the \nvariable i in memory is 101\n\t The expression 100  15  is evaluated and the result 115 is assigned to j\nThere are two kinds of increment operator\n\t Postfix increment operator for example i\n\t Prefix increment operator for example i\nWhen  appears after its operand it is called a postfix increment operator When  appears before its \noperand it is called a prefix increment operator The only difference between postfix and prefix increment \noperators is the order in which they use the current value of their operand and the increment in their \noperands value The postfix increment uses the current value of its operand first and then increments the \noperands value as you saw in the expression j  i  15  Because i uses a postfix increment operator \nfirst the current value of i is used to compute the value of expression i  15  eg 100  15  The value \nassigned to j is 115 And then the value of i is incremented by 1 The result would be different if this \nexpression is rewritten using a prefix increment operator\nint i  100\nint j  50\nj  i  15     Assigns 116 to j and i becomes 101Chapter 5  Operat Ors\n164In this case the expression i  15  is evaluated as follows\n\t Because i uses a prefix increment operator first the value of i is incremented in \nmemory by 1 Therefore the value of i is 101\n\t The current value of i which is 101 is used in the expression and the expression \nbecomes 101  15 \n\t The expression 101  15  is evaluated and the result 116 is assigned to j\nNote that after evaluation of both expressions i  15  and i  15  the value of i is the same \nwhich is 101 However the values assigned to j differ If you are using the increment operator  in a simple \nexpression as in i or i you cannot observe any difference in using a postfix or prefix operator\nThere is a puzzle for Java beginners The puzzle includes the use of the increment operator as follows\nint i  15\ni  i  What will be the value of i after this assignment\nGuess what the value of i will be after i  i  is executed If your guess is 16 you are wrong Here is the \nexplanation of how the expression is evaluated\n\ti is evaluated Because i uses a postfix increment operator the current  \nvalue of i is used in the expression The current value of i is 15 The expression \nbecomes i  15 \n\t The value of i is incremented by 1 in memory as the second effect of i At this \npoint the value of i is 16\u00a0in memory\n\t The expression i  15  is evaluated and the value 15 is assigned to i The value of \nthe variable i in memory is 15 and that is the final value In fact variable i observed \na value 16\u00a0in the previous step but this step overwrote that value with 15 Therefore \nthe final value of the variable i after i  i  is executed will be 15 not 16\nIn this example the order of operations is important It is important to note that in the case of i the \nvalue of the variable i is incremented as soon as the current value of i is used in the expression To make this \npoint clearer consider the following example\nint i  10\ni  i  i     Assigns 21 to i\ni  10\ni  i  i  Assigns 22 to i\nThere are also postfix and prefix decrement operators for example i i  The following are a few \nexamples of using postfix and prefix decrement operators\nint i  15\nint j  16\ni\ni\ni  10\ni  i         Assigns 10 to i\ni  10\nj  i  10    Assigns 20 to j and 9 to i\ni  10\nj  i  10    Assigns 19 to j and 9 to iChapter 5  Operat Ors\n165There are two important points to remember about the use of increment and decrement operators\n\t The operand of the increment and decrement operators must be a variable For \nexample the expression 5 is incorrect because  is being used with a constant\n\t The result of the expression using the  or  operator is a value not a variable \nFor example i evaluates to a value so we cannot use i as the left hand of an \nassignment operator or where a variable is required\n String Concatenation Operator \nThe  operator is overloaded in Java An operator is said to be overloaded if it is used to perform more than \none function So far you have seen its use as an arithmetic addition operator to add two numbers It can \nalso be used to concatenate two strings Two strings for example abc  and xyz  can be concatenated \nusing the  operator as abc  xyz  to produce a new string abcxyz  Another example of a string \nconcatenation is as follows\nString str1  Hello\nString str2   Alekhya\nString str3  str1  str2  Assigns Hello Alekhya to str3\nThe string concatenation operator can also be used to concatenate a primitive and a reference data \ntype value to a string We discuss only concatenation of string and primitive data types in this section When \neither operand of the  operator is a string it performs a string concatenation When both operands of  are \nnumeric it performs a number addition Consider the following snippet of code\nint num  26\nString str1  Alphabets\nString str2  num  str1  Assigns 26Alphabets to str2\nWhen the expression num  str1  is executed the  operator acts as a string concatenation operator \nbecause its righthand operand str1  is a String  Before num and str1  are concatenated num is replaced \nby its string representation which is 26  Now the expression becomes 26  str1  which results in \n26Alphabets  Table\u00a0 52 lists the string representation of the values of the primitive data types\nTable 52  String Representations of the Values of Primitive Data Types\nData Type Value String Representation\nint short byte long 1678 1678\n0 0\nchar A A\nu0041\nUnicode escape sequenceA\nboolean True true\nFalse false\ncontinued Chapter 5  Operat Ors\n166If a String  variable contains the null  reference the concatenation operator uses a string null  The \nfollowing examples illustrate the use of string representations of the values of primitive data types in string \nconcatenation\nboolean b1  true\nboolean b2  false\nint num  365\ndouble d  00\nchar c  A\nString str1\nString str2  null\nstr1  b1   friends      Assigns true friends to str1\nstr1  b2   identity     Assigns false identity to str1\n Assigns null and void to str1 Because str2 is null it is replaced\n by a string null by the string concatenation operator\nstr1  str2   and void\nstr1  num   days       Assigns 365 days to str1\nstr1  d   zero          Assigns 00 zero to str1\nstr1  DoubleNaN   is absurd  Assigns NaN is absurd to str1\nstr1  c   is a letter  Assigns A is a letter to str1\nstr1  This is   b1      Assigns This is true to str1\n Assigns Beyond Infinity to str1\nstr1  Beyond   FloatPOSITIVEINFINITY\nIt may sometimes be confusing to determine the result of an expression that uses more than one  \noperator and strings What will be the result of the following expression\n 12  15   menData Type Value String Representation\nfloat 25 25\n00F 00\n00F 00\nFloatPOSITIVEINFINITY Infinity\nFloatNEGATIVEINFINITY Infinity\nFloatNaN NaN\ndouble 8912 8912\n00 00\n00 00\nDoublePOSITIVEINFINITY Infinity\nDoubleNEGATIVEINFINITY Infinity\nDoubleNaN NaNTable 52  continued Chapter 5  Operat Ors\n167Will the result be 1215 men  or 27 men  The key to finding the correct answer is to find which  is an \narithmetic operator and which  is a string concatenation operator\nIf both the operands are numeric the  operator performs addition If either operand is a string the  \noperator performs string concatenation The execution of an expression proceeds from left to right unless \noverridden by using parentheses In the expression 12  15   men  the first  from the left performs \naddition on 12 and 15 which results in 27 After that the expression reduces to 27   men  Now the  \noperator performs a string concatenation because the righthand operand  men  is a string and it results \nin 27 men  Consider the following piece of code\nint num1  12\nint num2  15\nString str1   men\nString str2\nWe want to create a string 1215 men  using the three variables num1  num2  and str1  and the  operator \nWe want to assign the result to str2  Here is the first attempt\nstr2  num1  num2  str1\nThis statement will assign 27 men  to str2  Another solution is to place num2  str1  in parentheses\nstr2  num1  num2  str1  Assigns 1215 men to str2\nThe expression in parentheses is evaluated first The expression num2  str1  is evaluated first to \nreduce the expression to num1   15 men  which in turn will evaluate to 1215 men  Another option is to \nplace an empty string at the beginning of the expression\nstr2    num1  num2  str1  Assigns 1215 men to str1\nIn this case   num1  is evaluated first and it results in 12  which reduces the expression to 12 \n num2  str1  Now 12  num2  is evaluated which results in 1215  Now the expression is reduced to \n1215   men  which results in a string 1215 men  You may also place an empty string between num1  \nand num2  in the expression to get the same result\nstr2  num1    num2  str1  Assigns 1215 men to str2\nSometimes the string concatenation is trickier than you think Consider the following piece of code\nboolean b  false\nint num  15\nString str1  faces\nString str2  b  num  str1  A compiletime error\nThe last statement generates a compiletime error What is wrong with this statement You were \nexpecting a string  false15faces  to be assigned to str2  Werent you Lets analyze the expression b  \nnum  str1  Is the first  operator from the left an arithmetic operator or a string concatenation operator \nFor a  operator to be a string concatenation operator it is necessary that at least one of its operands is a \nstring Since neither b nor num is a string the first  operator from the left in b  num  str1  is not a string \nconcatenation operatorChapter 5  Operat Ors\n168Is it an arithmetic addition operator Its operands are of type boolean  b and int num You have \nalready learned that an arithmetic addition operator   cannot have a boolean  operand The presence of a \nboolean  operand in the expression b  num  caused the compiletime error A boolean  cannot be added to a \nnumber However the  operator works on a boolean  as a string concatenation operator if another operand \nis a string To correct this error you can rewrite the expression in a number of ways as follows\nstr2  b  num  str1       OK Assigns false15faces to str2\nstr2    b  num  str1    OK Assigns false15faces to str2\nstr2  b    num  str1    OK Assigns false15faces to str2\nYou use the println  or print  method to print a message on the standard output as follows\nSystemoutprintlnPrints a new line at the end of text\nSystemoutprintDoes not print a new line at the end of text\nIf you use the Systemoutprintln  method to print text on the console after printing the text it also \nprints a new line character at the end of the text The only difference between using println  and print  \nis that the former prints a new line at the end of the text whereas the latter does not The println  and \nprint  methods are overloaded Until now you have seen their use only with string arguments You can \npass any Java data type argument to these two methods The following snippet of code illustrates how to pass \nJava primitive types as arguments to these methods\nint num  156\n Prints 156 on the console\nSystemoutprintlnnum\n Prints Value of num  156 on the console\nSystemoutprintlnValue of num    num\n Prints a new line character on the console\nSystemoutprintln\nListing 52 contains a complete program to demonstrate the use of arithmetic operators and the string \nconcatenation operator\nListing 52  An Exam ple of Using Java Operators\n ArithOperatorjava\npackage comjdojooperator\nclass ArithOperator \n    public static void mainString args \n        int num  120\n        double realNum  255F\n        double veryBigNum  258  00\n        double garbage  00  00\n        boolean test  true\n         Print the value of num\n        Systemoutprintlnnum    num\n         Print the value of realNum\n        SystemoutprintlnrealNum    realNum\n         Print the value of veryBigNum\n        SystemoutprintlnveryBigNum    veryBigNum\n         Print the value of garbage\n        Systemoutprintlngarbage    garbageChapter 5  Operat Ors\n169         Print the value of test\n        Systemoutprintlntest    test\n         Print the maximum value of int type\n        SystemoutprintlnMaximum int    IntegerMAXVALUE\n         Print the maximum value of double type\n        SystemoutprintlnMaximum double    DoubleMAXVALUE\n         Print the sum of two numbers\n        Systemoutprintln125  100    125  100\n         Print the difference of two numbers\n        Systemoutprintln125   100    125   100\n         Print the multiplication of two numbers\n        Systemoutprintln125  100    125  100\n         Print the result of division\n        Systemoutprintln125  100    125  100\n         Print the result of modulus\n        Systemoutprintln125  100    125  100\n         Print the result of string concatenation\n        Systemoutprintlnabc  xyz      abc  xyz  \n    \n\nnum  120\nrealNum  255\nveryBigNum  Infinity\ngarbage  NaN\ntest  true\nMaximum int  2147483647\nMaximum double  17976931348623157E308\n125  100  1125\n125  100  875\n125  100  12500\n125  100  0125\n125  100  125\nabc  xyz  abcxyz\n Relational Operators\nA relational operator compares values of its operands A few examples of such comparisons are comparison \nfor equality inequality greater than less than etc Java supports seven relational operators six of which are \nlisted in Table\u00a0 53 The seventh one is the instanceof  operator which we discuss later in this bookChapter 5  Operat Ors\n170All relational operators are binary operators That is they take two operands The result produced by a \nrelational operator is always a boolean  value true  or false \n Equality Operator \nThe equality operator   is used in this form\noperand1  operand2\nThe equality operator is used to test two operands for equality It uses the following rules\n\t Both operands must be either primitive type or reference type Mixed operand types \nare not allowed\n\t For primitive operands it returns true  if both operands represent the same value \notherwise it returns false  Operands must be either both numeric or both boolean  \nA mix of numeric and boolean  types is not allowed\n\t For reference operands it returns true  if both operands refer to the same object in \nmemory otherwise it returns false \nSuppose there is an int variable named i declared as follows\nint i  10\nNow i  10  will test whether i is equal to 10 or not Because i is equal to 10 the expression i  10  \nwill evaluate to true  Consider another example\nint i\nint j\nint k\nboolean b\ni  j  k  15      Assign 15 to i j and k\nb  i  j  k  A compiletime errorTable 53  List of Relational Operators in Java\nOperators Meaning Type Usage Result\n Equal to Binary 3  2 false\n Not equal to Binary 3  2 true\n Greater than Binary 3  2 true\n Greater than or equal to Binary 3  2 true\n Less than Binary 3  2 false\n Less than or equal to Binary 3  2 falseChapter 5  Operat Ors\n171In this example you tried to test whether the three variables i j and k had the same value and the \nexpression i  j  k  resulted in an error Why did you get the error The expression i  j  k  is \nevaluated as follows\n\t First i  j  is evaluated in expression i  j  k  Since both i and j have the \nsame value which is 15 the expression i  j  returns true \n\t The first step reduced the expression i  j  k  to true  k  This is an error \nbecause the operands of the  operator are of boolean  and int types You cannot \nmix boolean  and numerictype operands with the equality operator\nThe following rules apply when the operands of the equality operator are floatingpoint types\n Rule 1\nBoth negative zero 00 and positive zero 00 are considered equal Recall that 00 and 00 are stored \ndifferently in memory\ndouble d1  00\ndouble d2  00\nboolean b  d1  d2  Assigns true to b\n Rule 2\nPositive and negative infinities are considered unequal\ndouble d1  DoublePOSITIVEINFINITY\ndouble d2  DoubleNEGATIVEINFINITY\nboolean b  d1  d2  Assigns false to b\n Rule 3\nIf either operand is NaN the equality test returns false \ndouble d1  DoubleNaN\ndouble d2  55\nboolean b  d1  d2  Assigns false to b\nNote that even if both operands are NaN the equality operator will return false \nd1  DoubleNaN\nd2  DoubleNaN\nb  d1  d2  Assigns false to b\nHow do you test whether the value stored in a float  or double  variable is NaN If you write the following \npiece of code to test for the value of a double  variable d1 being NaN it will always return false \ndouble d1  DoubleNaN\nboolean b  d1  DoubleNaN  Assigns false to b Incorrect way of testingChapter 5  Operat Ors\n172Float  and Double  classes have an isNaN  method which accepts a float  and a double  argument \nrespectively It returns true  if the argument is NaN otherwise it returns false  For example to test if d1 is \nNaN the previous expression can be rewritten as follows\ndouble d1  DoubleNaN\n Assigns true to b Correct way to test for a NaN value\nb  DoubleisNaNd1\nYou should not use the  operator to test two strings for equality for example\nString str1  new StringHello\nString str2  new StringHello\nboolean b\nb  str1  str2  Assigns false to b\nThe new operator in Java always creates a new object in memory Therefore str1  and str2  refer to \ntwo different objects in memory and this is the reason that str1  str2  evaluates to false  It is true that \nboth String  objects in memory have the same contents Whenever the  operator is used with reference \nvariables it always compares the references of the objects its operands are referring to To compare the text \nrepresented by two String  variables str1  and str2  you should use the equals  method of the String  \nclass as shown\n Assigns true to b because str1 and str2 have the same text Hello\nb  str1equalsstr2\n Assigns true to b because str1 and str2 have the same text Hello\nb  str2equalsstr1\nWe discuss more about string comparison in Chapter 15 covering strings\n Inequality Operator \nThe inequality operator   is used in the following form\noperand1  operand2\nThe inequality operator returns true  if operand1  and operand2  are not equal Otherwise it returns \nfalse  The rules for the data types of the operands of the inequality   operator are the same as those of \nthe equality operator   Here are a few examples of using the inequality operator\nint i  15\nint j  10\nint k  15\nboolean b\nb  i  j          Assigns true to b\nb  i  k          Assigns false to b\nb  true  true    Assigns false to b\nb  true  false  Assigns true to bChapter 5  Operat Ors\n173If either operand is NaN float  or double  the inequality operator returns true  If d1 is a floatingpoint \nvariable  double  or float  d1  d1  returns false  and d1  d1  returns true  if and only if d1 is NaN\n Greater Than Operator \nThe greater than operator  is used in the following form\noperand1  operand2\nThe greater than operator returns true  if the value of operand1  is greater than the value of operand2  \nOtherwise it returns false  The greater than operator can be used only with primitive numeric data types \nIf either of the operands is NaN float  or double  it returns false  The following are a few examples of using \nthis operator\nint i  10\nint j  15\ndouble d1  DoubleNaN\nboolean b\nb  i  j  Assigns false to b\nb  j  i  Assigns true to b\n A compiletime error  cannot be used with boolean operands\nb  true  false\nb  d1  DoubleNaN  Assigns false to b\nString str1  Hello\nString str2  How is Java\n A compiletime error  cannot be used with reference type operands str1 and str2\nb  str1  str2\nIf you want to test if the number of characters in String str1  is greater than that of str2  you should \nuse the length  method of the String  class The length  method of the String  class returns the number \nof characters in the string for example\ni  str1length  Assigns 5 to i Hello has 5 characters\nb  str1length  str2length  Assigns false to b\nb  str2length  str1length  Assigns true to b\n Greater Than or Equal to\u00a0Operator \nThe greater than or equal to operator   is used in this form\noperand1  operand2\nThe greater than or equal to operator returns true  if the value of operand1  is greater than or equal to \nthe value of operand2  Otherwise it returns false  The greater than or equal to operator can be used only \nwith primitive numeric data types If either of the operands is NaN float  or double  the greater than or \nequal to operator returns false  The following are a few examples of using this operator\nint i  10\nint j  10\nboolean bChapter 5  Operat Ors\n174b  i  j    Assigns true to b\nb  j  i    Assigns true to b\n Less Than Operator \nThe less than operator   is used in this form\noperand1  operand2\nThe less than operator returns true  if operand1  is less than operand2  Otherwise it returns false  The \noperator can be used only with primitive numeric data types If either operand is NaN float  or double  the \nless than operator returns false  The following are a few examples of using this operator\nint i  10\nint j  15\ndouble d1  DoubleNaN\nboolean b\nb  i  j             Assigns true to b\nb  j  i             Assigns false to b\n A compiletime error  cannot be used with boolean operands\nb  true  false\nb  d1  DoubleNaN  Assigns false to b\n Less Than or Equal to\u00a0Operator \nThe less than or equal to operator   is used in this form\noperand1  operand2\nThe less than or equal to operator returns true  if the value of operand1  is less than or equal to the \nvalue of operand2  Otherwise it returns false  The operator can be used only with primitive numeric data \ntypes If either of the operands is NaN float  or double  the less than or equal to operator returns false  The \nfollowing are a few examples of using this operator\nint i  10\nint j  10\nint k  15\nboolean b\nb  i  j    Assigns true to b\nb  j  i    Assigns true to b\nb  j  k    Assigns true to b\nb  k  j    Assigns false to b\n Boolean Logical Operators\nA Boolean logical operator takes boolean  operands applies a Boolean logic to them and produces a boolean  \nvalue Table\u00a0 54 lists boolean  logical operators available in Java All boolean  logical operators can be used \nonly with boolean  operands Subsequent sections explain the use of these operators in detailChapter 5  Operat Ors\n175 Logical NOT Operator \nThe logical NOT operator   is used in this form\noperand\nThe operator returns true  if operand  is false  and false  if operand  is true \nboolean b\nb  true      Assigns false to b\nb  false     Assigns true to b\nint i  10\nint j  15\nboolean b1  true\nb  b1        Assigns false to b\nb  i  j  Assigns true to b because i  j returns false\nSuppose you want to change the value of a boolean  variable b to true  if its current value is false  and to \nfalse  if its current value is true  This can be achieved as follows\nb  b  Assigns true to b if it was false and false if it was true\n Logical ShortCircuit AND\u00a0Operator \nThe logical shortcircuit AND operator   is used in this form\noperand1  operand2Table 54  List of Boolean Logical Operators\nOperators Meaning Type Usage Result\n Logical NOT Unary true false\n Shortcircuit AND Binary true  true true\n Logical AND Binary true  true true\n Shortcircuit OR Binary true  false true\n Logical OR Binary true  false true\n Logical XOR Exclusive OR Binary true  true false\n AND assignment Binary test  true\n OR assignment Binary test  true\n XOR assignment Binary test  trueChapter 5  Operat Ors\n176The  operator returns true  if both operands are true  If either operand is false  it returns false  It is \ncalled a shortcircuit AND operator because if operand1  the lefthand operand evaluates to false  it returns \nfalse  without evaluating operand2  the righthand operand\nint i  10\nint j  15\nboolean b  i  5  j  10    Assigns true to b\nIn this expression i  5  is evaluated first and it returns true  Because the lefthand operand evaluated \nto true  the righthand operand was also evaluated The righthand operand j  10  is evaluated which also \nreturns true  Now the expression is reduced to true  true  Because both operands are true  the final \nresult is true  Consider another example\nint i  10\nint j  15\nboolean b  i  20  j  10    Assigns false to b\nThe expression i  20  returns false  The expression reduces to false  j  10  Because the left\nhand operand is false  the righthand operand j  10  is not evaluated and  returns false  However \nthere is no way to prove in this example that the righthand operand which is j  10  was not evaluated \nConsider another example to prove this point We have already discussed the assignment operator   If num \nis a variable of type int num  10  returns a value 10\nint num  10\nboolean b  num  50  5  Assigns true to b\nNote the use of parentheses in this example In the expression num  50  5  the num  50  \nexpression is evaluated first It assigns 50 to num and returns 50 reducing the expression to 50  5  which \nin turn returns true  If you use the value of num after the num  50  expression is executed its value will be 50 \nKeeping this point in mind consider the following snippet of code\nint i  10\nint j  10\nboolean b  i  5  j  20  15\nSystemoutprintlnb    b\nSystemoutprintlni    i\nSystemoutprintlnj    j\nb  true\ni  10\nj  20\nSince the lefthand operand which is i  5  evaluated to true  the righthand operand j  20 \n 15  was evaluated and the variable j was assigned a value 20 If we change this code so the lefthand \noperand evaluates to false  the righthand operand would not be evaluated and the value of j will remain \n10 The changed piece of code is as follows\nint i  10\nint j  10\n j  20  5 is not evaluated because i  25 returns falseChapter 5  Operat Ors\n177boolean b  i  25  j  20  15\nSystemoutprintln b    b\nSystemoutprintln i    i\nSystemoutprintln j    j  Will print j  10\nb  false\ni  10\nj  10\n Logical AND\u00a0Operator \nThe logical AND operator   is used in this form\noperand1  operand2\nThe logical AND operator returns true  if both operands are true  If either operand is false  it returns \nfalse  The logical AND operator   works the same way as the logical shortcircuit AND operator   except \nfor one differencethe logical AND operator   evaluates its righthand operand even if its lefthand operand \nevaluates to false \nint i  10\nint j  15\nboolean b\nb  i  5  j  10              Assigns true to b\nb  i  25  j  20  15    j  20  5 is evaluated even if i  25 returns false\nSystemoutprintln b    b\nSystemoutprintln i    i\nSystemoutprintln j    j  Will print j  20\nb  false\ni  10\nj  20\n Logical ShortCircuit OR Operator \nThe logical shortcircuit OR operator   is used in this form\noperand1  operand2\nThe logical shortcircuit OR operator returns true  if either operand is true  If both operands are false  \nit returns false  It is called a shortcircuit OR operator because if operand1  evaluates to true  it returns true  \nwithout evaluating operand2 \nint i  10\nint j  15\nboolean b  i  5  j  10  Assigns true to bChapter 5  Operat Ors\n178In this expression i  5  is evaluated first and it returns true  Because the lefthand operand evaluated \nto true  the righthand operand is not evaluated and the expression  i  5  j  10  returns true  \nConsider another example\nint i  10\nint j  15\nboolean b  i  20  j  10  Assigns true to b\nThe expression i  20  returns false  The expression reduces to false  j  10  Because the left\nhand operand to  is false  the righthand operand j  10  is evaluated which returns true  and the entire \nexpression returns true \n Logical OR Operator \nThe logical OR operator   is used in this form\noperand1  operand2\nThe logical OR operator returns true  if either operand is true  If both operands are false  it returns \nfalse  The logical OR operator works the same way as the logical shortcircuit OR operator except for one \ndifferencethe logical OR operator evaluates its righthand operand even if its lefthand operand evaluates \nto true \nint i  10\nint j  15\nboolean b  i  5  j  10  Assigns true to b\nIn this expression i  5  is evaluated first and it returns true  Even if the lefthand operand i  5  evaluates \nto true  the righthand operand j  15  is still evaluated and the whole expression i  5  j  10   \nreturns true \n Logical XOR Operator \nThe logical XOR operator   is used in this form\noperand1  operand2\nThe logical XOR operator returns true  if operand1  and operand2  are different That is it returns true  if \none of the operands is true  but not both If both operands are the same it returns false \nint i  10\nboolean b\nb  true  true        Assigns false to b\nb  true  false       Assigns true to b\nb  false  true       Assigns true to b\nb  false  false      Assigns false to b\nb  i  5  i  15  Assigns false to bChapter 5  Operat Ors\n179 Compound Boolean Logical Assignment Operators\nThere are three compound boolean  logical assignment operators Note that Java does not have any operators \nlike  and  These operators are used in this form\noperand1 op operand2\noperand1  must be a boolean  variable and op may be   or  This form is equivalent to writing\noperand1  operand1 op operand2\nTable 55 shows the compound logical assignment operators and their equivalents\nIf both operands evaluate to true   returns true  Otherwise it returns false \nboolean b  true\nb  true    Assigns true to b\nb  false  Assigns false to b\nIf either op erand evaluates to true   returns true  Otherwise it returns false \nboolean b  false\nb  true    Assigns true to b\nb  false  Assigns false to b\nIf both operands evaluate to different values that is one of the operands is true  but not both  returns \ntrue  Otherwise it returns false \nboolean b  true\nb  true    Assigns false to b\nb  false  Assigns true to b\n Ternary Operator  \nJava has one conditional operator It is called a ternary operator It takes three operands It is used in \nthis form\nbooleanexpression  trueexpression  falseexpressionTable 55  Com pound Logical Assignment Operators and Their Equivalents\nExpression Is Equivalent To\noperand1  operand2 operand1  operand1  operand2\noperand1  operand2 operand1  operand1  operand2\noperand1  operand2 operand1  operand1  operand2Chapter 5  Operat Ors\n180Two symbols  and  make the ternary operator If the booleanexpression  evaluates to true  it \nevaluates the trueexpression  otherwise it evaluates falseexpression \nSuppose you have three integer variables num1  num2  and minNum  You want to assign minNum  the \nminimum of num1  and num2  You can use the ternary operator to accomplish this\nint num1  50\nint num2  25\n Assigns num2 to minNum because num2 is less than num1\nint minNum  num1  num2  num1  num2\n Bitwise Operators\nA bitwise operator is an operator that performs an action on its integer operands using their bit patterns \nBitwise operators in Java are listed in Table\u00a0 56\nAll bitwise operators work with only integers The bitwise AND  operator operates on corresponding \nbits of its two operands and returns 1 if both bits are 1 and 0 otherwise Note that the bitwise AND  operates \non each bit of the respective operands not on the operands as a whole The following is the result of all bit \ncombinations using the bitwise AND  operator\n1  1  1\n1  0  0\n0  1  0\n0  0  0\nConsider the following piece of code in Java\nint i  13  3Table 56  List of Bitwise Operators\nOperators Meaning Type Usage Result\n Bitwise AND Binary 25  24 24\n Bitwise OR Binary 25  2 27\n Bitwise XOR Binary 25  2 27\n Bitwise NOT 1s complement Unary 25 26\n Left shift Binary 25  2 100\n Signed right shift Binary 25  2 6\n Unsigned right shift Binary 25  2 6\n      Compound assignment bitwise operators BinaryChapter 5  Operat Ors\n181The value of 13  3  is computed as follows The 32 bits have been shown in 8bit chunks for clarity In \nmemory all 32 bits are contiguous\n13         00000000 00000000 00000000 00001101\n 3         00000000 00000000 00000000 00000011\n\n13  3     00000000 00000000 00000000 00000001 Equal to decimal 1\nTherefore 13  3  is 1 which is assigned to i in the previous piece of code\nThe bitwise OR  operates on corresponding bits of its operands and returns 1 if either bit is 1 and 0 \notherwise The following is the result of all bit combinations using the bitwise OR  operator\n1  1  1\n1  0  1\n0  1  1\n0  0  0\nThe value of 13  3  can be computed as follows The result of 13  3  is 15\n13       00000000 00000000 00000000 00001101\n 3       00000000 00000000 00000000 00000011\n\n13  3   00000000 00000000 00000000 00001111 Equal to decimal 15\nThe bitwise XOR  operates on corresponding bits of its operands and returns 1 if only one of the \nbits is 1 Otherwise it returns 0 The following is the result of all bit combinations using the bitwise XOR  \noperator\n1  1  0\n1  0  1\n0  1  1\n0  0  0\nThe value of 13  3  can be computed as follows The result of 13  3  is 14\n13      00000000 00000000 00000000 00001101\n 3      00000000 00000000 00000000 00000011\n\n13  3  00000000 00000000 00000000 00001110 Equal to decimal 14\nThe bitwise NOT  operates on each bit of its operand It inverts the bits that is 1 is changed to 0 and 0 \nis changed to 1 It is also called a bitwise  complement operator  It computes 1s complement of its operand \nThe following is the result of all bit combinations using the bitwise NOT  operator\n1  0\n0  1\nThe value of 13 can be computed as follows The result of 13 is 14\n13     00000000 00000000 00000000 00001101\n\n13    11111111 11111111 11111111 11110010   Equal to decimal 14Chapter 5  Operat Ors\n182The bitwise left shift operator   shifts all the bits to the left by the number of bits specified as its \nrighthand operand It inserts zeros at the lower order bits The effect of shifting 1 bit to the right is the \nsame as multiplying the number by 2 Therefore 9  1  will produce 18 whereas 9  2  produces 36 The \nprocedure to compute 13  4  is shown in Figure\u00a0 51\nWhat is the result of 13  35  You might have guessed zero However this is not true In fact only 32 \nbits are used to represent 13 because 13 is considered as int literal and int occupies 32 bits You can shift \nall bits to the left only by 31 bits in an int If the lefthand operand of the bitwise left shift operator  is \nint only the 5 lower order bits value of the righthand operand is used as the number of bits to shift For \nexample in 13  35  the righthand operand  35 can be represented in binary as follows\n00000000000000000000000000100011\nThe 5 lower order bits in 35 is 00011 which is equal to 3 Therefore when you write 13  35  it is \nequivalent to writing 13  3  For all positive righthand operands of the bitwise left shift operator you can \ntake modulus of the righthand operand with 32 which would be the final number of bits to shift Therefore \n13  35  can be considered as 13  35  32  which is the same as 13  3  If the lefthand operand is \nlong  the first 6 lower order bits value of the righthand operand is used as the number of bits to shift\nlong  val  13\nlong result\nresult  val  35\nSince val is a long  6 lower order bits of 35 which is 100011 will be used as the number to shift \nFigure\u00a0 52 shows the steps used to compute 13  4  and 13  4 Figure 51  Com puting 13  4Chapter 5  Operat Ors\n183The bitwise signed right shift operator   shifts all the bits to the right by the number specified as \nits righthand operand If the most significant digit of the lefthand operand is 1 for negative numbers \nall higher order bits are filled with 1s after the shift operation If the most significant bit is 0 for positive \nnumbers all higher order bits are filled with 0s Because the sign bit after the right shift operation   \nremains the same it is called the signed right shift operator For example 13  4  results in zero as depicted \nin Figure\u00a0 52 Also note that in the case of 13  4  all 4 higher order bits are filled with 1s because in 13 \nthe most significant digit is 1 The result of 13  4  is 1\nThe unsigned right shift operator   works the same way as the signed right shift operator   \nexcept for one differenceit always fills the higher order bits with zero The result of 13  4  is zero \nwhereas the result of 13  4  is 268435455  as shown There is no unsigned left shift operator\n13         00000000 00000000 00000000   00001101\n13  4    00000000 00000000 00000000   00000000 1101\n13        11111111 11111111 11111111   11110011\n13  4   00001111 11111111 11111111   11111111 0011\nA com pound bitwise assignment operator is used in the following form\noperand1 op operand2\nHere op is one of the bitwise operators      and  operand1  and operand2  are of \nprimitive integral data type where operand1  must be a variable The previous expression is equivalent to \nthe following one\noperand1  Type of operand1 operand1 op operand2\nAssuming that there are two int variables i and j Table\u00a0 57 lists the equivalent expressions for \ncompound bitwise assignment operatorsFigure 52  Com puting 13  4 and 13  4Chapter 5  Operat Ors\n184 Operator Precedence\nConsider the following piece of code\nint result\n What will be the value assigned to result\nresult  10  8  2\nWhat will be the value assigned to the variable result  after the last statement is executed Will it be 9 or \n14 It depends on the operation that is done first It will be 9 if the addition 10  8  is performed first It will be \n14 if the division 82 is performed first All expressions in Java are evaluated according to operator precedence \nhierarchy which establishes the rules that govern the order in which expressions are evaluated Operators \nwith higher precedence are evaluated before the operators with lower precedence If operators have the same \nprecedence the expression is evaluated from left to right Multiplication division and remainder operators \nhave higher precedence than addition and subtraction operators Therefore in the previous expression 82 is \nevaluated first which reduces the expression to 10  4  which in turn results in 14\nConsider another expression\nresult  10  5  2\nThe expression 10  5  2  uses two operators a multiplication operator and a division operator Both \noperators have the same precedence The expression is evaluated from left to right First the expression 10 \n 5 is evaluated and then the expression 50  2  is evaluated The whole expression evaluates to 25 If you \nwant to perform division first you must use parentheses Parentheses have the highest precedence and \ntherefore the expression within parentheses is evaluated first You can rewrite the previous piece of code \nusing parentheses\nresult  10  5  2  Assigns 20 to result Why\nYou can also use nested parentheses In nested parentheses the innermost parentheses expression is \nevaluated first Table\u00a0 58 lists Java operators in their precedence order Operators in the same level have the \nsame precedence Table\u00a0 58 lists some of the operators we have not discussed yet We discuss them later in \nother chapters In the table a lower value in the Level column indicates a higher precedenceTable 57  List of Compound Bitwise Assignment Operators\nExpression Is Equivalent To\ni  j i  i  j\ni  j i  i  j\ni  j i  i  j\ni  j i  i  j\ni  j i  i  j\ni  j i  i  jChapter 5  Operat Ors\n185Table 58  Java Operators and Their Precedence\nLevel Operator Symbol Action Performed\n1  Pre or postincrement\n Pre or postdecrement\n  Unary plus unary minus\n Bitwise complement\n Logical NOT\ntype Cast\n2    Multiplication division\nremainder\n3   Addition subtraction\n String concatenation\n4  Left shift\n Signed right shift\n Unsigned right shift\n5  Less than\n Less than or equal\n Greater than\n Greater than or equal\ninstanceof Type comparison\n6  Equal in value\n Not equal to\n7  Bitwise AND\n Logical AND\n8  Bitwise XOR\n Logical XOR\n9  Bitwise OR\n Logical OR\n10  Logical shortcircuit AND\n11  Logical shortcircuit OR\n12   Ternary operator\n13  Assignment\n    \n   \n  Compound assignmentChapter 5  Operat Ors\n186 Summary\nAn operator is a symbol that is used to perform some type of computation on its operands Java contains \na rich set of operators Operators are categorized as unary binary or ternary based on the number of \noperands they take They are categorized as arithmetic relational logical or bitwise based on the operand \ntypes and the operation they perform on their operands\nAn arithmetic operator is an operator that takes numeric values as its operands and performs an \narithmetic operation for example addition and subtraction to compute another numeric value A few \nexamples of arithmetic operators in Java are    and \nIn Java the  operator is overloaded When one of its operands is a String  it performs a string \nconcatenation For example an expression 50   States  produces another string 50 States \nA relational operator compares values of its operands returning a boolean  valuetrue  or false  A few \nexamples of relational operators are      and \nA Boolean logical operator takes boolean  operands applies a Boolean logic to them and produces a \nboolean  value A few examples of Boolean logical operators in Java are   and \nJava supports a ternary operator    which takes three operands It is also known as a conditional \noperator If the first operand evaluates to true  the second operand is evaluated and returned otherwise the \nthird operand is evaluated and returned\nA bitwise operator is an operator that performs an action on its integer operands using their bit \npatterns Two examples of bitwise operators in Java are  and \nAn operator is called overloaded if it can be used in multiple contexts to perform different types of \ncomputations Java contains a  operator that is overloaded It is used as an arithmetic addition operator as \nwell as a string concatenation operator Unlike C Java does not let developers overload operators\nEvery operator in Java has a precedence order with respect to other operators If multiple operators \nappear in a single expression the operands of operators with higher precedence are evaluated before the \noperands of operators with lower precedence\nEXERCISES\n 1 What is an operator What are unary binary and ternary operators Give an \nexample of each type of operator in Java\n 2 What is the difference between prefix postfix and infix operators Give an example \nof such operators in Java\n 3 What are arithmetic operators what types of operands do they take and what type \nof results do they produce\n 4 Name two opera tors in Java that take only Boolean  operands and produce a \nBoolean value\n 5 What is the difference between the two operators  and \n 6 Consider the follo wing snippet of code\nboolean done\n Some code goes here \nyourcodegoeshere\nUsing a Boolean  logical operator invert the current value stored in the done  \nvariable that is write a statement that will assign true  to the done  variable if its \ncurrent value is false  and false  if its current value is true Chapter 5  Operat Ors\n187 7 Consider the follo wing snippet of code\nint x  23\nint y  x  3\nWhat will be the value of y after this snippet of code is executed\n 8 Consider the follo wing snippet of code\nint x  23\nx  x  x\nWhat will be the value of x after this snippet of code is executed explain your \nanswer with steps performed explaining how the value of x changes during the \nexecution of the second statement\n 9 explain why the following snippet of code does not compile\nint x  10\nboolean yes  x  20\n 10 What will be the value assigned to the variable named yes when the following \nsnippet of code is executed\nint x  10\nboolean yes  x  20\n 11 What will be the value of y when the following snippet of code is executed\nint x  19\nint y  x  10  69  68\n 12 You have a short variable named x which is declared and initialized as follows\nshort x  19\nYou want to assign 19 to x using the following statements both of which do not compile\nx  x\nx  1  x\nhow will you rewrite these two statements to make them compile What is wrong with the \nfollowing statement that attempts to fix the compiletime error in these statements but fails to \nassign 19 to x\nx  x\n 13 What will be the output when the following snippet of code is executed\nboolean b  true\nString str  b  is not   b\nSystemoutprintlnstrChapter 5  Operat Ors\n188 14 What will be the output when the following snippet of code is executed\nboolean b  true\nString str  b  b   is   b\nSystemoutprintlnstr\n 15 What will be the output when you execute the following snippet of code\nint x  10\nint y  x\nint z  x\nSystemoutprintlnx    x   y    y   z    z\n 16 Complete the second sta tement using the ternary operator    and the bitwise \naND operator   that will make a message x is odd  Your code must contain \nthe following tokens in any order x    odd  and even  You may use \nadditional tokens as needed\nint x  19\nString msg  yourcodegoeshere \nSystemoutprintlnx is   msg\n 17 Which of the follo wing assignments will fail to compile and why\nint i1  100\nint i2  106\nbyte b1  90\nbyte b2  3L\nshort s1  90\nfloat f1  1267\nfloat f2  000f\ndouble d1  1256\ndouble d2  1278d\nboolean bn1  true\nboolean bn2  0\nchar c1  A\nchar c2  A\nchar c3  0\nchar c4  u0000\n 18 Write do wn the value assigned to the declared variable in each of the following \nstatements If a statement generates a compiletime error explain the reason \nbehind the error and if possible provide a solution to fix the error\nint i1  104\nint i2  10040\nint i3  00\nlong l1  104\nlong l2  10040\nfloat f1  104\nfloat f2  10040\ndouble d1  104Chapter 5  Operat Ors\n189double d2  10040\ndouble d3  00\ndouble d4  000\ndouble d5  2900\n 19 Complete the follo wing snippet of code that will assign a 2s complement of x to y \nYou must use the bitwise operator\nint x  19\nint y  yourcodegoeshere\n 20 What will be the output of the following snippet of code\nint x  19\nint y  x  1  x\nSystemoutprintlny191\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730746CHAPTER 6\nStatements\nIn this chapter you will learn\n\t What statements are\n\t What expressions in Java are and how to convert them into expression statements\n\t What a block statement is and what the scope of variables declared inside a block is\n\t What control flow statements are and how to use ifelse  forloop while loop and \ndowhile  loop statements\n\t How to use the break  statement to exit a loop or a block\n\t How to use the continue  statement to ignore the rest of the body of a loop statement \nand continue the next iteration\n\t What an empty statement is and where to use it\n\t What a switch expression is and how to use it\nAll examples in this chapter are in the jdojostatement  module whose declaration is shown in \nListing 61\nListing 61  The D eclaration of a Module Named jdojostatement\n moduleinfojava\nmodule jdojostatememnt \n     No module statements\n\n What Is a\u00a0Statement\nA statement specifies an action in a Java program such as assigning the sum of x and y to z printing \na message to the standard output writing data to a file looping through a list of values conditionally \nexecuting a piece of code etc Statements are written using keywords operators and expressionsChapter 6  Statement S\n192 Types of\u00a0Statements\nDepending on the action performed by a statement statements in Java can be broadly classified into three \ncategories\n\t Declaration statements\n\t Expression statements\n\t Control flow statements\nSubsequent sections describe all statement types in detail\n Declaration Statement\nA declaration statement is used to declare a variable You have already been using this type of statement The \nfollowing are a few examples of declaration statements in Java\nint num\nint num2  100\nString str\n Expression Statement\nExpressions in Java consist of literals variables operators and method invocation and they are the building \nblocks of a Java program An expression is evaluated and the evaluation may produce a variable a value or \nnothing An expression always has a type which may be void  if it is a method invocation to a method whose \nreturn type is void  The following are a few examples of expressions in Java\n\t19  69\n\tnum  2\n\tnum\n\tSystemoutprintlnHello\n\tnew StringHello\nAn expression with a semicolon at the end is called an expression statement  However not all Java \nexpressions can be converted to expression statements by appending a semicolon to them Assuming x and \ny as two int variables the following is an arithmetic expression that evaluates to an int value\nx  y\nHowever the following is not a valid expression statement in Java\nx  y\nAllowing a statement like this does not make sense It adds the values of x and y and does nothing \nwith the value Only the following four kinds of expressions can be converted to expression statements by \nappending a semicolon to them\n\t Increment and decrement expressions\n\t Assignment expressionsChapter 6  Statement S\n193\t Object creation expressions\n\t Method invocation expressions\nA few examples of increment and decrement expression statements are as follows\nnum\nnum\nnum\nnum\nA few examples of assignment expression statements are as follows\nnum  100\nnum  10\nAn example of an object creation expression statement is as follows\nnew StringThis is a text\nNote that this statement creates a new object of the String  class However the new objects reference \nis not stored in any reference variable Therefore this statement is not very useful In some cases however \nyou can use such an object creation statement in a useful way for example JDBC drivers register themselves \nwith the driver manager when the driver class is loaded and one way to load the driver class is to create its \nobject and discard the created object\nYou invoke the method println  to print a message on the console When you use the println  method \nwithout a semicolon at the end it is an expression When you add a semicolon to the end of the method call it \nbecomes a statement The following is an example of a method invocation expression statement\nSystemoutprintlnThis is a statement\n Control Flow Statement\nBy default all statements in a Java program are executed in the order they appear in the program However \nyou can change the order of execution using control flow statements Sometimes you may want to execute \na statement or a set of statements only if a particular condition is true Sometimes you may want to execute \na set of statements repeatedly for a number of times or as long as a particular condition is true All of these \nare possible in Java using control flow statements the if and for statements are examples of control flow \nstatements We will discuss control flow statements shortly\n A Block Statement\nA block statement is a sequence of zero or more statements enclosed in braces A block statement is \ngenerally used to group together several statements so they can be used in a situation that requires you to \nuse a single statement In some situations you can use only one statement If you want to use more than one \nstatement in those situations you can create a block statement by placing all your statements inside braces \nwhich would be treated as a single statement You can think of a block statement as a compound statement \nthat is treated as one statement The following are examples of block statements\n  Start of a block statement A block statement starts with  \n    int num1  20\n    num1Chapter 6  Statement S\n194  End of the block statement A block statement ends with  \n\n   Another valid block statement with no statements inside\n\nAll the variables declared in a block statement can only be used within that block In other words you \ncan say that all variables declared in a block have local scope Consider the following snippet of code\n Declare a variable num1\nint num1\n    Start of a block statement\n     Declares a variable num2 which is a local variable for this block\n    int num2\n     num2 is local to this block so it can be used here\n    num2  200\n     We can use num1 here because it is declared outside and before this block\n    num1  100\n    End of the block statement\n     A compiletime error num2 has been declared inside a block and\n     so it cannot be used outside that block\nnum2  50\nYou can also nest a block statement inside another block statement All the variables declared in the \nenclosing blocks outer blocks are available to the enclosed blocks inner blocks However the variables \ndeclared in the enclosed inner blocks are not available in the enclosing outer blocks for example\n Start of the outer block\n\n    int num1  10\n     Start of the inner block\n    \n         num1 is available here because we are in an inner block\n        num1  100\n        int num2  200  Declared inside the inner block\n        num2  678       OK num2 is local to inner block\n    \n     End of the inner block\n     A compiletime error num2 is local to the inner block\n     So it cannot be used outside the inner block\n    num2  200\n\n End of the outer block\nOne important point to remember about nested block statements is that you cannot define a variable \ninside an inner block if a variable with the same name has already been defined in the outer block This \nis because the variables declared in the outer block can always be used inside the inner block and if you \ndeclare a variable with the same name inside the inner block there is no way for Java to differentiate \nbetween these two variables inside the inner block The following snippet of code wont compile\nint num1  10Chapter 6  Statement S\n195\n     A Compiletime error num1 is already in scope Cannot redeclare num1\n    float num1  105F\n    float num2  1298F  OK\n    \n         A compiletime error num2 is already in scope\n         You can use num2 already defined in the outer\n         block but cannot redeclare it\n        float num2\n    \n\n The ifelse Statement\nThe format of an ifelse  statement is as follows\nif condition\n    statement1\nelse\n    statement2\nThe condition  must be a boolean  expression That is it must evaluate to true  or false  If the \ncondition  evaluates to true  statement1  is executed Otherwise statement2  is executed The flow diagram \nfor an ifelse  statement is shown in Figure\u00a0 61\nFigure 61  The flo w diagram for an ifelse statementChapter 6  Statement S\n196The else  part in an ifelse  statement is optional If the else  part is missing the statement sometimes \nis simply called an if statement You may write an if statement as follows\nif condition\n    statement\nThe flow diagram for an if statement is shown in Figure\u00a0 62\nSuppose there are two int variables named num1  and num2  Suppose you want to add 10 to num2  if num1  \nis greater than 50 Otherwise you want to subtract 10 from num2  You can write this logic using an ifelse  \nstatement\nif num1  50\n    num2  num2  10\nelse\n    num2  num2   10\nSuppose you have three int variables named num1  num2  and num3  You want to add 10 to num2  and num3  \nif num1  is greater than 50 Otherwise you want to subtract 10 from num2  and num3  You may try the following \nsnippet of code which is incorrect\nif num1  50\n    num2  num2  10\n    num3  num3  10\nelse\n    num2  num2   10\n    num3  num3   10Figure 62  The flo w diagram for an if statementChapter 6  Statement S\n197This code generates a compiletime error What is wrong with this code You can place only one \nstatement between if and else  in an ifelse  statement This is the reason that the statement num3  num3 \n 10  caused a compiletime error In fact you can always associate only one statement with the if part \nin an ifelse  statement or in a simple if statement This is also true for the else  part In this example \nonly num2  num2   10  is associated with the else  part the last statement num3  num3   10  is not \nassociated with the else  part You want to execute two statements when num1  is greater than 50 or not In \nthis case you need to bundle two statements into one block statement like so\nif num1  50 \n    num2  num2  10\n    num3  num3  10\n else \n    num2  num2   10\n    num3  num3   10\n\nThe ifelse  statement can be nested as shown\nif num1  50 \n    if num2  30 \n        num3  num3  130\n     else \n        num3  num3   130\n    \n else \n    num3  num3  200\n\nSometimes it is confusing to determine which else  goes with which if in nested ifelse  statements \nConsider the following piece of code\nint i  10\nint j  15\nif i  15\nif j  15\n    SystemoutprintlnThanks\nelse\n    SystemoutprintlnSorry\nWhat will be the output of this snippet of code Will it print Thanks  or Sorry  or does it print \nanything at all If you guessed that it would not print anything you already understand ifelse  association\nYou can apply a simple rule to figure out which else  goes with which if in an ifelse  statement Start \nwith the else  and move up If you do not find any other else  statements the first if you find goes with the \nelse  you started with If you find one else  in moving up before you find any if the second if goes with the \nelse  you started with and so on In this example starting with else  the first if you find is if j  15  \nand so the else  goes with this if The previous piece of code can be rewritten using indentation and block \nstatements as follows\nint i  10\nint j  15\nif i  15 Chapter 6  Statement S\n198    if j  15 \n        SystemoutprintlnThanks\n     else \n        SystemoutprintlnSorry\n    \n\nBecause i is equal to 10 the expression i  15  will return false  and hence the control would not enter \nthe if statement at all Therefore there would not be any output\nNote that the condition  expression in an if statement must be of the boolean  type Therefore if you \nwant to compare two int variables i and j for equality your if statement must look like the following\nif i  j\n    statement\nYou cannot write an if statement like this\nif i  5  A compiletime error \n    statement\nThis if statement will not compile because i  5  is an assignment expression and it evaluates to an \nint value 5 The condition expression must return a boolean  value true  or false  Therefore an assignment \nexpression cannot be used as a condition expression in an if statement except when you are assigning a \nboolean  value to a boolean  variable like so\nboolean b\nif b  true  Always returns true \n    statement\nHere the assignment expression b  true  always returns true  after assigning true  to b In this case \nthe use of the assignment expression in the if statement is allowed because the data type of expression b  \ntrue  is boolean \nYou can use the ternary operator in place of a simple ifelse  statement Suppose if a person is male \nyou want to set the title to Mr and if not to Ms You can accomplish this using an ifelse  statement and \nalso using a ternary operator like so\nString title\nboolean isMale  true\n Using an ifelse statement\nif isMale\n    title  Mr\nelse\n    title  Ms\n Using a ternary operator\ntitle  isMale  Mr  Ms\nYou can see the difference in using the ifelse  statement and the ternary operator The code is \ncompact using the ternary operator However you cannot use a ternary operator to replace all ifelse  \nstatements You can use the ternary operator in place of the ifelse  statement only when the if and else  \nparts in the ifelse  statement contain only one statement and both statements return the same type of \nvalues Because the ternary operator is an operator it can be used in expressions Suppose you want to \nassign the minimum of i and j to k You can do this in the following declaration statement of the variable kChapter 6  Statement S\n199int i  10\nint j  20\nint k  i  j  i  j  Using a ternary operator in initialization\nThe same can be achieved using an ifelse  statement as shown\nint i  10\nint j  20\nint k\nif i  j\n    k  i\nelse\n    k  j\nAnother difference in using a ternary operator and an ifelse  statement is that you can use an \nexpression that uses a ternary operator as an argument to a method However you cannot use an ifelse  \nstatement as an argument to a method Suppose you have a calc  method that accepts an int as an \nargument You have two integers num1  and num2  If you want to pass the minimum of the two integers to the \ncalc  method you would write the code as shown\n Use an ifelse statement\nif num1  num2\n    calcnum1\nelse\n    calcnum2\n Use a ternary operator\ncalcnum1  num2  num1  num2\nSuppose you want to print the message k is 15  if the value of an int variable k is equal to 15 \nOtherwise you want to print the message k is not 15  You can print the message using a ternary \noperator and writing one line of code as follows\nSystemoutprintlnk  15  k is 15  k is not 15\n The switch Statement\nThe general form of a switch  statement is the following\nswitch switchvalue \n    case label1\n        statements\n    case label2\n        statements\n    case label3\n        statements\n    default\n        statements\nChapter 6  Statement S\n200The switchvalue  must evaluate to a type byte  short  char  int enum  or String  Refer to Chapter 22  \non enums for details on how to use an enum  type in a switch  statement Refer to Chapter 15 on strings for \ndetails on how to use strings in a switch  statement The label1  label2  etc are compiletime constant \nexpressions whose values must be in the range of the type of the switchvalue  A switch  statement is \nevaluated as follows\n\tThe switchvalue  is evaluated\n\t If the value of the switchvalue  matches a case  label the execution starts from \nthe matched case  label and executes all statements until the end of the switch  \nstatement\n\t If the value of the switchvalue  does not match a case  label execution starts at the \nstatement following the optional default  label and continues until the end of the \nswitch  statement\nThe following snippet of code is an example of using a switch  statement\nint i  10\nswitch i \n    case 10  Found the match\n        SystemoutprintlnTen        Execution starts here\n    case 20\n        SystemoutprintlnTwenty     Also executes this statement\n    default\n        Systemoutprintln Nomatch  Also executes this statement\n\nTen\nTwenty\nNomatch\nThe value of i is 10 The execution starts at the first statement following case 10  and falls through case \n20 and default  labels executing the statements under these labels If you change the value of i to 50 there \nwould not be any match in case  labels and the execution would start at the first statement after the default  \nlabel which will print Nomatch  The following example illustrates this logic\nint i  50\nswitch i \n    case 10\n        SystemoutprintlnTen\n    case 20\n        SystemoutprintlnTwenty\n    default\n        SystemoutprintlnNomatch  Execution starts here\n\nNomatchChapter 6  Statement S\n201The default  label does not have to be the last label to appear in a switch  statement and is optional The \nfollowing is an example of a default  label that is not the last label\nint i  50\nswitch i \n    case 10\n        SystemoutprintlnTen\n    default\n        SystemoutprintlnNomatch  Execution starts here\n    case 20\n        SystemoutprintlnTwenty\n\nNomatch\nTwenty\nBecause the value of i is 50 which does not match any of the case  labels the execution starts at the first \nstatement after the default  label The control falls through the subsequent label case 20  and executes \nthe statement following this case label which prints Twenty  Generally you want to print Ten if the value of \ni is 10 and Twenty  if the value of i is 20 If the value of i is not 10 nor 20 you want to print Nomatch  This is \npossible using the break  keyword\nWhen a break  statement is executed inside a switch  statement the control is transferred outside the \nswitch  statement The following is an example of using break  statements inside a switch  statement\nint i  10\nswitch i \n    case 10\n        SystemoutprintlnTen\n        break  Transfers control outside the switch statement\n    case 20\n        SystemoutprintlnTwenty\n        break  Transfers control outside the switch statement\n    default\n        SystemoutprintlnNomatch\n        break  Transfers control outside the switch statement It is not necessary\n\nTen\nNote the use of the break  statement in the previous snippet of code In fact the execution of a break  \nstatement inside a switch  statement stops the execution of the switch  statement and transfers control \nto the first statement if any following the switch  statement In the previous snippet of code the use of \na break  statement inside the default  label is not necessary because the default  label is the last label in \nthe switch  statement and the execution of the switch  statement will stop after that anyway However \nI recommend using a break  statement even inside the last label to avoid errors if additional labels are \nadded laterChapter 6  Statement S\n202The value of the constant expressions used as the case  labels must be in the range of the data type of \nswitchvalue  Keeping in mind that the range of the byte  data type in Java is 128 to 127 the following code \nwould not compile because the second case  label is 150 which is outside the range of the byte  data type\nbyte b  10\nswitch b \n    case 5\n        b\n    case 150  A compiletime error 150 is outside the range 128 to 127\n        b\n    default\n        b  0\n\nTwo case labels in a switch  statement cannot be the same The following piece of code would not \ncompile because the case  label 10 is repeated\nint num  10\nswitch num \n    case 10\n        num\n    case 10  A compiletime error Duplicate label 10\n        num\n    default\n        num  100\n\nIt is important to note that the label for each case  in a switch  statement must be a compiletime \nconstant That is the value of the labels must be known at compile time Otherwise a compiletime error \noccurs For example the following code would not compile\nint num1  10\nint num2  10\nswitch num1 \n    case 20\n        Systemoutprintlnnum1 is 20\n    case num2  A Compiletime error num2 is a variable and cannot be used as a label\n        Systemoutprintlnnum1 is 10\n\nYou might say that you know the value of num2  is 10 when the switch  statement will be executed \nHowever all variables are evaluated at runtime The values of variables are not known at compile time \nTherefore the case num2  causes the compiler error This is necessary because Java makes sure at compile \ntime itself that all case  labels are within the range of the data type of the switchvalue  If they are not the \nstatements following those case labels will never get executed at runtime\n Ti p the default  label is optional there can be at most one default  label in a switch  statementChapter 6  Statement S\n203A switch  statement is a clearer way of writing an ifelse  statement when the condition expression in \nan ifelse  statement compares the value of the same variable for equality For example the following if\nelse  and switch  statements accomplish the same thing\n Using an ifelse statement\nif i  10\n    Systemoutprintlni is 10\nelse if i  20\n    Systemoutprintlni is 20\nelse\n    Systemoutprintlni is neither 10 nor 20\n Using a switch statement\nswitch i \n    case 10\n        Systemoutprintlni is 10\n        break\n    case 20\n        Systemoutprintlni is 20\n        break\n    default\n        Systemoutprintlni is neither 10 nor 20\n\n The switch Expression\nSwitch expressions were introduced as a preview feature in Java 12 and a core feature in Java 14 A switch \nexpression results in a single value and uses single expressions throw statements or code blocks instead of \nrelying on the break  keyword This results in a cleaner and less errorprone syntax\nFor example converting the previous switch statement to a switch expression it would look like the \nfollowing\nswitch i \n    case 10  Systemoutprintlni is 10\n    case 20  Systemoutprintlni is 20\n    default  Systemoutprintlni is neither 10 nor 20\n\nUnlike a switch statement a switch expression results in a single value so the preceding example could \nbe rewritten as follows\nString message  switch i \n    case 10  i is 10\n    case 20  i is 20\n    default  i is neither 10 nor 20\n\nSystemoutprintlnmessageChapter 6  Statement S\n204Switch expressions use the case label followed by  followed by one of the following\n\t An expression including but not limited to a constant value\n\t A throw statement\n\t A code block using opening and closing curly brackets\nIn addition each case label can support multiple values separated by commas For example the \nfollowing switch expression uses one of each type\nString message  switch i \n    case 10 15  i is ten or fifteen\n    case 20  \n        String str  i is\n        yield str   twenty\n    \n    default  throw new RuntimeExceptioni is not 10 15 or 20\n\nThe first case statement would match 10 or 15\nThe yield statement is used from within a switch expression to specify the value returned by the switch \nexpression\nAn exception can be thrown since it breaks out of the current method being executed or execution \ncontext We will cover exceptions fully in Chapter 13\nA switch expression also supports oldstyle case labels case L using the yield statement but you \ncannot mix case label types within the same switch expression In other words you must use all oldstyle \ncase labels or none of them\n The for\u00a0Statement\nA for statement is an iteration statement which is used to loop through a statement a number of times \nbased on some conditions It is also called a forloop statement or simply a for loop The general form of a \nforloop statement is\nfor initialization conditionexpression expressionlist\n    statement\nThe initialization  conditionexpression  and expressionlist  are separated by semicolons A \nforloop statement consists of four parts\n\t Initialization\n\t Condition expression\n\t Statement\n\t Expression list\nFirst the initialization part is executed then the condition expression is evaluated If the condition \nexpression evaluates to true  the statement associated with the forloop statement is executed After \nthat all expressions in the expression list are evaluated The condition expression is evaluated again \nand if it evaluates to true  the statement associated with the forloop statement is executed and then the \nexpression list and so on This loop of execution is repeated until the condition expression evaluates to \nfalse  Figure\u00a0 63 shows the flow diagram for a forloop statementChapter 6  Statement S\n205For example the following forloop statement will print all integers between 1 and 10 inclusive\nforint num  1 num  10 num\n    Systemoutprintlnnum\nFirst int num  1  is executed which declares an int variable named num and initializes it to 1 It \nis important to note that variables declared in the initialization part of the forloop statement can only \nbe used within that forloop statement Then condition expression num  10  is evaluated which is 1 \n 10  it evaluates to true  for the first time Now the statement associated with the forloop statement \nis executed which prints the current value of num Finally the expression in the expression list num  is \nevaluated which increments the value of num by 1 At this point the value of num becomes 2 The condition \nexpression 2  10  is evaluated which returns true  and the current value of num is printed This process \ncontinues until the value of num becomes 10 and it is printed After that num  sets the value of num to \n11 and the condition expression 11  10  returns false  which stops the execution of the forloop \nstatementFigure 63  The flow diagram for a forloop statementChapter 6  Statement S\n206All three parts initialization condition expression and expression list in a forloop statement are \noptional Note that the fourth part the statement is not optional Therefore if you do not have a statement \nto execute in a forloop statement you must use an empty block statement or a semicolon in place of a \nstatement A semicolon that is treated as a statement is called an empty statement  or a null statement  An \ninfinite loop using a forloop statement can be written as follows\nfor    \n     An infinite loop\n\nThe previous forloop statement can be rewritten using an empty statement which is a semicolon as \nfollows\n An infinite loop Note a semicolon as a statement\nfor   \nA detailed discussion of each part of a forloop statement follows\n Initialization\nThe initialization part of a forloop statement can have a variable declaration statement which may declare \none or more variables of the same type or it can have a list of expression statements separated by a comma \nNote that the statements used in the initialization part do not end with a semicolon The following snippet of \ncode shows the initialization part in a forloop statement\n Declares two variables i and j of the same type int\nforint i  10 j  20  \n Declares one double variable salary\nfordouble salary  345578F  \n Attempts to declare two variables of different types\nforint i  10 double d1  205    A compiletime error \n Uses an expression i\nint i  100\nfori    OK\n Uses an expression to print a message on the console\nforSystemoutprintlnHello      OK\n Uses two expressions to print a message and to increment num\nint num  100\nforSystemoutprintlnHello num  \n Ti p t he initialization part of a for loop is executed only once when the for loop is executed\nYou can declare a new variable in the initialization part of a forloop statement However you cannot \nredeclare a variable that is already in scope\nint i  10\nfor int i  0    An error Cannot redeclare iChapter 6  Statement S\n207You can reinitialize the variable i in the forloop statement as shown\nint i  10        Initialize i to 10\ni  500           Value of i changes here to 500\n Other statements go here \nfor i  0    Reinitialize i to zero inside the forloop loop\n Condition Expression\nThe condition expression must evaluate to a boolean  value of true  or false  Otherwise a compiletime \nerror occurs The condition expression is optional If it is omitted a boolean  value of true  is assumed as a \ncondition expression which results in an infinite loop unless a break  statement is used to stop the loop The \nfollowing two forloop statements result in infinite loops and they are the same\n An infinite loop   Implicitly conditionexpression is true\nfor   \n An infinite loop   An explicit true is used as the conditionexpression\nfor  true \nA break  statement is used to stop the execution of a forloop statement When a break  statement \nis executed the control is transferred to the next statement if any after the forloop statement You can \nrewrite the forloop statement to print all integers between 1 and 10 using a break  statement\n A forloop with no conditionexpression\nforint num  1    num \n    Systemoutprintlnnum  Print the number\n    if num  10 \n        break                Break out of loop when i is 10\n    \n\nThis forloop statement prints the same integers as the previous forloop statement did However \nthe latter is not recommended because you are using a break  statement instead of using the condition \nexpression to break out of the loop It is good programming practice to use a condition expression to break \nout of a for loop whenever possible\n Expression List\nThe expression list part is optional It may contain one or more expressions separated by a comma You can \nuse only expressions that can be converted to a statement by appending a semicolon at the end Refer to the \ndiscussion on the expression statement at the beginning of this chapter for more details You can rewrite the \nsame example of printing all integers between 1 and 10 as follows\nforint num  1 num  10 Systemoutprintlnnum num\nNote that this forloop statement uses two expressions in the expression list which are separated by a \ncomma A forloop statement gives you more power to write compact codeChapter 6  Statement S\n208You can rewrite the previous forloop statement as follows to make it more compact and accomplish \nthe same task\nforint num  1 num  10 Systemoutprintlnnum\nNote that you combined the two expressions in the expression list into one You used num  as the \nargument to the println  method so it prints the value of num first and then increments its value by 1 Can \nyou predict the output of the previous forloop statement if you replace num  with num \nYou can also use nested forloop statements that is forloop statements inside another forloop \nstatement Suppose you want to print a 3  3 read as three by three matrix as follows\n11      12      13\n21      22      23\n31      32      33\nThe code to print the 3  3 matrix can be written as follows\n Outer forloop statement\nforint i  1 i  3 i \n     Inner forloop statement\n    forint j  1 j  3 j \n        Systemoutprinti    j\n         Prints a tab after each column value\n        Systemoutprintt\n    \n    Systemoutprintln  Prints a new line\n\nThe previous piece of code can be explained using the following steps\n 1 The execution starts in the initialization part  int i  1  of the outer forloop \nstatement where i is initialized to 1\n 2 The condition expression for the outer forloop statement  i  3  is evaluated \nfor i equal to 1 which is true\n 3 The statement part of the outer for loop starts with an inner forloop statement\n 4 Now j is initialized to 1\n 5 The condition expression for the inner forloop statement  j  3  is evaluated \nfor j equal to 1 which is true\n 6 The block statement associated with the inner forloop statement is executed \nwhich prints 11 and a tab\n 7 The expression list of the inner forloop statement  j is executed which \nincrements the value of j to 2\n 8 The condition expression for the inner forloop statement  j  3  is evaluated \nfor j equal to 2 which is true\n 9 The block statement associated with the inner forloop statement is executed \nwhich prints 12 and a tab At this stage the printed text looks like this\n11  12Chapter 6  Statement S\n209 10 The expr ession list of the inner forloop statement  j is executed which \nincrements the value of j to 3\n 11 The condition expr ession for the inner forloop statement  j  3  is evaluated \nfor j equal to 3 which is true\n 12 The blo ck statement associated with the inner forloop statement is executed \nwhich prints 13 and a tab At this stage the printed text looks like this\n11  12  13\n 13 The expr ession list of the inner forloop statement  j is executed which \nincrements the value of j to 4\n 14 The condition expr ession for the inner forloop statement  j  3  is evaluated \nfor j equal to 4 which is false At this point the inner for loop is finished\n 15 The l ast statement of the block statement for the outer forloop statement \nwhich is Systemoutprintln  is executed It prints a systemdependent line \nseparator\n 16 The expr ession list of the outer forloop statement  i is executed which \nincrements the value of i to 2\n 17 Now the inner forloop statement is started afresh with the value of i equal to 2 \nThis sequence of steps is also executed for i equal to 3 When i becomes 4  \nthe outer forloop statement exits and at this point the printed matrix will look \nlike this\n11   12   13\n21   22   23\n31   32   33\nNote that this snippet of code also prints a tab character at the end of every row and a new line after the \nlast row which are not necessary One important point to note is that the variable j is created every time the \ninner forloop statement is started and it is destroyed when the inner forloop statement exits Therefore \nthe variable j is created and destroyed three times You cannot use the variable j outside the inner forloop \nstatement because it has been declared inside the inner forloop statement and its scope is local to that \ninner forloop statement Listing 62 contains the complete code for the discussion in this section The \nprogram makes sure not to print extra tabs and new line characters\nListing 62  Using a for Loop to Print a 3  3 Matrix\n PrintMatrixjava\npackage comjdojostatement\npublic class PrintMatrix \n    public static void mainString args \n        for int i  1 i  3 i \n            for int j  1 j  3 j \n                Systemoutprinti    j\n                 Print a tab except for the last number in a row\n                if j  3 \n                    Systemoutprintt\n                Chapter 6  Statement S\n210            \n             Print a new line except after the last line\n            if i  3 \n                Systemoutprintln\n            \n        \n    \n\n11    12      13\n21    22      23\n31    32      33\n The foreach Statement\nJava 5 introduced an enhanced for loop which is called a foreach  loop It is used for iterating over \nelements of arrays and collections Refer to the chapter on arrays and collections Chapter 19 for a detailed \nexplanation of the foreach  loop as well as additional ways to loop through elements of a collection The \ngeneral syntax for a foreach  loop is as follows\nforType element  acollectionoranarray \n     This code will be executed once for each element in\n     the collectionarray\n     Each time this code is executed the element\n     variable holds the reference\n     of the current element in the collectionarray\n\nThe following snippet of code prints all elements of an int array numList \n Create an array with 4 elements\nint numList  10 20 30 40\n Print each element of the array in a separate line\nforint num  numList \n    Systemoutprintlnnum\n\n10\n20\n30\n40Chapter 6  Statement S\n211 The while Statement\nA while  statement is another iteration or loop statement which is used to execute a statement repeatedly \nas long as a condition is true A while  statement is also known as a while loop statement The general form \nof a while loop statement is\nwhile conditionexpression\n    statement\nThe condition expression must be a boolean  expression and the statement can be a simple statement \nor a block statement The condition expression is evaluated first If it returns true  the statement is \nexecuted Again the condition expression is evaluated If it returns true  the statement is executed This \nloop continues until the condition expression returns false  Figure\u00a0 64 shows the flow diagram for a while  \nstatement\nUnlike the forloop statement the condition expression in a while loop statement is not optional \nFor example to make a while  statement an infinite loop you need to use the boolean  literal true  as the \ncondition expression\nwhile true\n    Systemoutprintln This is an infinite loopFigure 64  The flo w diagram for a while statementChapter 6  Statement S\n212In general a forloop statement can be converted to a while loop statement However not all forloop \nstatements can be converted to while loop statements The conversion between a forloop and a while loop \nstatement is shown here\n A forloop statement\nfor initialization conditionexpression expressionlist\n    statement\n Equivalent whileloop Statements\ninitialization\nwhile conditionexpression \n    statement\n    expressionlist\n\nYou can print all integers between 1 and 10 using a while  loop as shown\nint i  1\nwhile i  10 \n    Systemoutprintlni\n    i\n\nThis while loop  can be rewritten in three different ways as follows\n 1\nint i  0\nwhile i  10 \n    Systemoutprintlni\n\n 2\nint i  1\nwhile i  10 \n    Systemoutprintlni\n\n 3\nint i  1\nwhile i  10 \n    Systemoutprintlni\n    i\n\nA break  statement is used to exit the loop in a while loop statement You can rewrite the previous \nexample using a break  statement as follows Note that the following piece of code is written only to illustrate \nthe use of a break  statement in a while  loop it is not a good example of using a break  statement\nint i  1\nwhile true   Cannot exit the loop from here because it is true \n    if i  10 \n        Systemoutprintlni\n        iChapter 6  Statement S\n213     else \n        break  Exit the loop\n    \n\n The dowhile Statement\nThe dowhile  statement is another loop statement It is similar to the while loop statement with one \ndifference The statement associated with a while loop statement may not be executed even once if the \ncondition expression evaluates to false  for the first time However the statement associated with a do\nwhile  statement is executed at least once The general form of a dowhile  statement is\ndo\n    statement\nwhile conditionexpression\nNote that the dowhile  statement ends with a semicolon The condition expression must be a \nboolean  expression The statement can be a simple statement or a block statement The statement is \nexecuted first Then the condition expression is evaluated If it evaluates to true  the statement is executed \nagain This loop continues until the condition expression evaluates to false  Figure\u00a0 65 shows the flow \ndiagram for a dowhile  statement\nFigure 65  The flo w diagram for a dowhile statementChapter 6  Statement S\n214Like in a for loop and a while  loop a break  statement may be used to exit a dowhile  loop A dowhile  \nloop can compute the sum of integers between 1 and 10 as shown\nint i  1\nint sum  0\ndo \n    sum  sum  i  Better to use sum  i\n    i\n\nwhile i  10\n Print the result\nSystemoutprintlnSum    sum\nSum  55\nWhen do you use a dowhile  statement instead of a while  statement You can rewrite every dowhile  \nstatement as a while  statement and vice versa However using the dowhile  statement in some use cases \nmakes your code more readable Consider the following snippet of code\nString filePath  Ckishoripoemtxt\nBufferedReader reader  new BufferedReadernew FileReaderfilePath\nString line\nwhileline  readerreadLine  null \n    Systemoutprintlnline\n\nThe code reads the contents of a file one line at a time and prints it on the standard output I have left \nout the details of error checking and import statements for this snippet of code It uses a while  loop The \nfollowing snippet of code uses a dowhile  statement to do the same\nString filePath  Ckishoripoemtxt\nBufferedReader reader  new BufferedReadernew FileReaderfilePath\nString line\ndo \n    line  readerreadLine\n    if line  null \n        Systemoutprintlnline\n    \n  while line  null\nYou can see that the logic did not flow smoothly when you used the dowhile  statement Before \nprinting you had to use an additional if statement to check if a line was read before In this case using a \nwhile  statement is a better choice\nWhen the condition expression for the loop depends on values computed inside the loop you need \nto use the dowhile  statement Suppose you need to ask the user to enter a value for a month that must be \nbetween 1 and 12 The program keeps asking the user until a valid value is entered A dowhile  statement is \nmore suitable in this scenario Listing 63 contains the complete program I have left out error checks such as \nwhen the user enters text instead of an integerChapter 6  Statement S\n215Listing 63  Using a dowhile Statement to Accept a Valid User Input\n UserInputjava\npackage comjdojostatement\nimport javautilScanner\npublic class UserInput \n    public static void mainString args \n        Scanner input  new ScannerSystemin\n        int month\n        do \n            SystemoutprintEnter a month112 \n             Read an input from the user\n            month  inputnextInt\n         while month  1  month  12\n        SystemoutprintlnYou entered   month\n    \n\nEnter a month112 20\nEnter a month112 1\nEnter a month112 0\nEnter a month112 9\nYou entered 9\nThe Scanner  class is used to read inputs from the standard input In this case the keyboard is the \nstandard input The nextInt  method of the Scanner  class reads the next integer from the keyboard The \nprogram runs in a loop until users enter an integer between 1 and 12 If users enter a noninteger value the \nprogram is aborted with an error\n The break Statement\nA break  statement is used to exit from a block There are two forms of the break  statement\n\t Unlabeled break  statement\n\t Labeled break  statement\nAn example of an unlabeled break  statement is\nbreak\nAn example of a labeled break  statement is\nbreak labelChapter 6  Statement S\n216You have already seen the use of the unlabeled break  statement inside switch  forloop while loop \nand dowhile  statements It transfers control out of the switch  forloop while loop or dowhile  statement \nin which it appears In the case of nested statements of these four kinds if an unlabeled break  statement \nis used inside the inner statement it transfers control only out of the inner statement not out of the outer \nstatement Suppose you want to print the lower half of the 3  3 matrix as shown\n11\n21      22\n31      32      33\nTo print only the lower half of the 3  3 matrix you can write the following snippet of code\nforint i  1 i  3 i \n    forint j  1 j  3 j \n        Systemoutprint  i    j\n        if i  j \n            break  Exit the inner for loop\n        \n        Systemoutprintt\n    \n    Systemoutprintln\n\n11\n21    22\n31    32      33\nThe break  statement has been used inside the inner forloop statement When the value of the outer \nloop counter  i becomes equal to the value of the inner loop counter  j the break  statement is executed \nand the inner loop exits If you want to exit from the outer forloop statement from inside the inner forloop \nstatement you have to use a labeled break  statement A label in Java is any valid Java identifier followed by a \ncolon The following are some valid labels in Java\n\tlabel1\n\talabel\n\tOuter\n\tHello\n\tIamALabel\nNow use a labeled break  statement in the previous example and see the result\nouter   Defines a label named outer\nforint i  1 i  3 i  \n    forint j  1 j  3 j  \n        Systemoutprinti    j\n        if i  j \n            break outer    Exit the outer for loop\n        Chapter 6  Statement S\n217        Systemoutprintt\n    \n    Systemoutprintln\n   The outer label ends here\nThe output of the previous snippet of code will be as follows\n11\nWhy did it print only one element of the 3  3 matrix This time you have used a labeled break  \nstatement inside the inner forloop statement When i  j  evaluates to true  for the first time the labeled \nbreak  statement is executed It transfers control out of the block that has been labeled as outer  Note that \nthe outer  label appears just before the outer forloop statement Therefore the block associated with the \nlabel outer  is the outer forloop statement A labeled statement can be used not only inside switch  for\nloop while loop and dowhile  statements rather it can be used with any type of a block statement The \nfollowing is a trivial example of a labeled break  statement\nblockLabel\n\n    int i  10\n    if i  5 \n        break blockLabel  Exits the block\n    \n    if i  10 \n        Systemoutprintlni is not five\n    \n\nAn important point to remember about a labeled break  statement is that the label used with the break  \nstatement must be the label for the block in which that labeled break  statement is used The following \nsnippet of code illustrates an incorrect use of a labeled break  statement\nlab1\n\n    int i  10\n    if i  10\n        break lab1  Ok lab1 can be used here\n\nlab2\n\n    int i  10\n    if i  10\n         A compiletime error lab1 cannot be used here\n         because this block is not associated with\n         lab1 label We can use only lab2  in this block\n        break lab1\nChapter 6  Statement S\n218 The continue Statement\nA continue  statement can only be used inside the forloop while loop and dowhile  statements There are \ntwo forms of continue  statements\n\t Unlabeled continue  statement\n\t Labeled continue  statement\nAn example of an unlabeled continue  statement is\ncontinue\nAn example of a labeled continue  statement is\ncontinue label\nWhen a continue  statement is executed inside a for loop the rest of the statements in the body of the \nloop are skipped and the expressions in the expression list are executed You can print all odd integers \nbetween 1 and 10 using a forloop statement as shown\nfor int i  1 i  10 i  2 \n    Systemoutprintlni\n\nIn this forloop statement you increment the value of i by 2\u00a0in the expression list You can rewrite the \nprevious forloop statement using a continue  statement as shown in Figure\u00a0 66\nThe expression i  2  returns 0 for the values of i that are multiples of 2 and the expression i  2 \n 0  returns true  In such cases the continue  statement is executed and the last statement Systemout\nprintlni  is skipped The increment statement i is executed after the continue  statement is executed \nThe previous snippet of code is certainly not the best example of using a continue  statement however it \nserves the purpose of illustrating its use\nWhen an unlabeled continue  statement is executed inside a while  loop or dowhile  loop the \nremaining statements in the loop are skipped and the condition expression is evaluated for the next \niteration For example the snippet of code in Figure\u00a0 67 will print all odd integers between 1 and 10 using a \ncontinue  statement inside a while  loopFigure 66  Using a continue statement inside a forloop statementChapter 6  Statement S\n219The main difference in using a continue  statement inside a for loop and a while  loop is the place \nwhere the control is transferred Inside a for loop control is transferred to the expression list and in a while  \nloop the control is transferred to the condition expression This is why a forloop statement cannot always \nbe converted to a while loop statement without modifying some logic\nAn unlabeled continue  statement always continues the innermost for loop while  loop and dowhile  \nloop If you are using nested loop statements you need to use a labeled continue  statement to continue in \nthe outer loop For example you can rewrite the snippet of code that prints the lower half of the 3  3 matrix \nusing a continue  statement as shown\nouter  The label outer starts here\nforint i  1 i  3 i \n    forint j  1 j  3 j \n        Systemoutprinti    j\n        Systemoutprintt\n        if i  j \n            Systemoutprintln  Print a new line\n            continue outer         Continue the outer loop\n        \n    \n   The label outer ends here\n An Empty Statement\nAn empty statement is a semicolon by itself An empty statement does nothing If an empty statement does \nnot do anything why do we have it Sometimes a statement is necessary as part of the syntax of a construct \nHowever you may not need to do anything meaningful In such cases an empty statement is used A for \nloop must have a statement associated with it However to print all integers between 1 and 10 you can \nonly use the initialization condition expression and expression list parts of a forloop statement In this \ncase you do not have a statement to associate with the forloop statement Therefore you use an empty \nstatement in this case as shown\nforint i  1 i  10 Systemoutprintlni\n   This semicolon is an empty statement for the for loopFigure 67  Using a continue statement inside a whileloop statementChapter 6  Statement S\n220Sometimes an empty statement is used to avoid doublenegative logic in the code Suppose \nnoDataFound  is a boolean  variable You may write a snippet of code as shown\nif noDataFound\n      An empty statement\nelse \n       Do some processing\n\nThe previous ifelse  statement can be written without using an empty statement like so\nif noDataFound \n     Do some processing\n\nIt is a personal choice which code to use Finally note that if you type two or more semicolons where \nonly one is required it will not cause any errors because each extra semicolon is considered as an empty \nstatement for example\ni   Ok Here semicolon is part of statement\ni  Still Ok The second semicolon is considered an empty statement\nYou cannot use an empty statement where a statement is not allowed For example when only one \nstatement is allowed adding an extra empty statement will cause an error as shown in the following snippet \nof code It associates two statements i  and an empty statement   to an if statement where only one \nstatement is allowed\nif i  10\n    i  A compiletime error Cannot use two statements before an else statement\nelse\n    i\n Summary\nA statement in a Java program specifies an action Statements in Java can be broadly classified in three \ncategories declaration statements expression statements and control flow statements A declaration \nstatement is used to declare variables An expression statement is used to evaluate an expression A control \nflow statement controls the order in which other statements are executed Control flow statements include \nif ifelse  and looping statements A looping statement executes a block of statements repeatedly until \nsome condition becomes false Java provides four looping statements the for loop foreach  loop while  \nloop and dowhile  loop A break  statement is used to transfer control outside of a block statement or a loop \nA continue  statement is used to ignore executing the remaining code for a loop and continue with the next \niteration Java has an empty statement too which is simply a semicolon by itselfChapter 6  Statement S\n221EXERCISES\n 1 What is a statement\n 2 What is an expression how do you convert an expression into an expression \nstatement in Java Can you convert all types of expressions in Java into expression \nstatements\n 3 What are control statements and why do you use them\n 4 What is a block statement and how do you create a block statement\n 5 What is an empty statement\n 6 What is the difference between while loop and dowhile  statements\n 7 a switch  statement contains a switchvalue  List all the types that a switch\nvalue  must evaluate to\n 8 When can you use a switch  statement in place of an ifelse  statement\n 9 Consider the follo wing snippet of code the valid value of the count  variable must \nbe in the range 11 inclusive to 20 inclusive Write the condition for the ifelse  \nstatement so a correct message is printed\nint count  20\nifyourcodegoeshere\n    SystemoutprintlnCount is valid\nelse\n    SystemoutprintlnCount is invalid\n 10 Fix the compiletime errors in the following snippet of code make sure the fixed \ncode prints the value of y\nint x  10\nint y  20\nif x  10\n    y\n    Systemoutprintlny    y\nelse\n    y\n    Systemoutprintlny    yChapter 6  Statement S\n222 11 rewrite the following snippet of code using an ifelse  statement make sure \nthat the switch  and ifelse  statements both have the same output when you \ninitialize the variable x to another value  hint this is a tricky question because \nthere are no break  statements in any case  labels\nint x  50\nswitch x \n    case 10\n        SystemoutprintlnTen\n    default\n        SystemoutprintlnNomatch\n    case 20\n        SystemoutprintlnTwenty\n\n 12 the following snippet of code is a modified version of the previous one rewrite it \nusing an ifelse statement make sure that the switch and ifelse statements both \nhave the same output when you initialize the variable x to another value\nint x  50\nswitch x \n    case 10\n        SystemoutprintlnTen\n        break\n    default\n        SystemoutprintlnNomatch\n        break\n    case 20\n        SystemoutprintlnTwenty\n        break\n\n 13 a programmer was learning about the switch  statement and they tried to use \nit everywhere they could the following snippet of code is an example of such a \nforced use where it is not needed rewrite the following snippet of code using no \ncontrol flow statements that is you need to get rid of the switch  statement and \nleave the program logic intact\nint x  10\n Some logic goes here\nswitchx \n    default\n    x\nChapter 6  Statement S\n223 14 how do you write an infinite loop using the for while  and dowhile  \nstatements Give an example of each\n 15 the intent of the following for statement is to print integers from 1 to 10\u00a0in reverse \norder the code does not print the numbers as intended Identify the logical error \nand fix the code so it prints 10 9 8 1\nforbyte b  10 b  1 b\n    Systemoutprintlnb\n 16 Write a for statement that prints all odd numbers from 13 to 1\u00a0in reverse order \nthe body of the for statement must be an empty statement that is you can use \nonly the initialization condition expression and expression list of the for statement \nto write all your logic the template of your for statement is as follows\nforyourcode yourcode yourcode\n 17 Write a snippet of code using a for statement that calculates the sum of all \nintegers from 1 to 10 and prints it on the standard output the template for your \ncode is as follows\nint sum  0\nforyourcode yourcode yourcode\nSystemoutprintlnSum    sum\n 18 Use a nested for statement to print the following pyramid\n    \n   \n  \n \n 19 Write a nested for statement that will print the following\n     1\n    22\n   333\n  4444\n 55555\n666666\n 20 Complete the follo wing snippet of code It is supposed to print a commaseparated \nlist of all integers from lower  to upper  For example if lower  is 1 and upper  \nis 4 it should print 1 2 3 4  hint Use Systemoutprint  to print a \nmessage without a new line\nint lower  1\nint upper  4\nforyourcodegoeshere \n    yourcodegoeshere225\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730747CHAPTER 7\nClasses\nIn this chapter you will learn\n\t What classes are in Java\n\t How to define classes in Java\n\t How to declare class members such as fields\n\t How to create objects of a class\n\t How to declare import statements in a compilation unit\n\t How to define a Record in Java\n What Is a\u00a0Class\nClasses are the basic units of programming in the objectoriented paradigm In Chapter 3 you looked at \nsome elementary aspects of a class in Java for example using the class  keyword to declare a class declaring \nthe main  method to run a class etc This chapter explains how to declare and use a class in detail\nLets start with a simple example of a class in the real world to build the technical concept of a class \nin Java When you look around you see a number of objects such as books computers keyboards tables \nchairs humans etc Each object that you see belongs to a class Ask yourself a simple question Who am \nI Your obvious answer would be I am a human What do you mean by saying that you are a human You \nmean that a human class exists in the world and you are one of the instances being of that class You also \nunderstand that other humans other instances of the human class also exist who are similar but not the \nsame to you Both you and your friend being instances of the same human class have the same properties \nsuch as name gender height weight and behaviors such as the ability to think talk walk etc However the \nproperties and behaviors differ for you and your friend in value quality or both For example both have a \nname and the ability to talk However your name may be Richard and your friends name may be Greg You \nmay talk slowly whereas your friend may talk fast If you want to prepare a model for you and your friend to \nexamine your behaviors there are two choices\n\t You can list all properties and behaviors for you and your friend separately and \nexamine them separately as if there was no connection between you and your friend\n\t You can list the properties and behaviors for you and your friend that are in common \nand then examine them as properties and behaviors for an entity without naming \nyou and your friend This model assumes that all listed properties and behaviors \nwill be present in an entity without naming it though they may vary from entity \nto entity You may want to list all properties and behaviors for you and your friend Chapter 7  Classes\n226as properties and behaviors of a class say human and treat you and your friend as \ntwo different instances of that human class Essentially you have grouped together \nentities eg you and your friend with similar properties and behaviors and called \nthat group a class Then you will treat all objects again you and your friend as \ninstances of that class\nThe first approach treats each object as a separate entity In the second approach objects are classified \nbased on similarity of properties and behaviors where an object always belongs to a class the class becomes \nthe essential part of programming To determine any property or behavior of an object you need to look \nup its class definition For example you are an object of the human class Can you fly This question can \nbe answered by going through a series of steps First you need to answer the question What class do \nyou belong to The answer is that you belong to the human class Does the human class define a flying \nbehavior The answer is no Because you are an instance of the human class that does not define the flying \nbehavior you cannot fly If you look carefully at the way you arrived at the answer you would find that the \nquestion was asked on an object you but the answer was provided by the class human to which the \nobject belongs\nClasses are essential and they are basic parts of programs in objectoriented programming They are \nused as templates to create objects How do you define a class in Java A class in Java may consist of five \ncomponents\n\t Fields\n\t Methods\n\t Constructors\n\t Static initializers\n\t Instance initializers\nFields and methods are also known as members of the class Classes and interfaces can also be \nmembers of a class This chapter focuses only on fields A class can have zero or more class members A class \nmember of a class is also known as a nested class \nSimilar to giving the initial characteristics of a human like a name a gender height and weight when \na baby is born properties of a newly created object are initialized at the time when the object is created In \nJava giving initial values to the properties of an object is called initializing  an object Constructors are used \nto initialize objects of a class You must have at least one constructor for a class\nInitializers are used to initialize fields of a class You can have zero or more initializers of static or \ninstance type Initializers perform the same task as constructors Initializers can also be used to initialize \nclasslevel fields whereas constructors can initialize only objectlevel fields\nThe rest of this chapter discusses how to declare and use the fields of a class\n Declaring a\u00a0Class\nThe general syntax for declaring a class in Java is as follows\nmodifiers class classname \n     Body of the class goes here\nChapter 7  Classes\n227Here\n\tmodifiers  are optional they are keywords that associate special meanings to the \nclass declaration A class declaration may have zero or more modifiers\n\t The keyword class  is used to declare a class\n\t The classname  is a userdefined name of the class which should be a valid Java \nidentifier\n\t Each class has a body which is specified inside a pair of braces   The body of a \nclass contains its different components for example fields methods etc\nThe following snippet of code defines a class named Human  with an empty body Note that the Human  \nclass does not use any modifiers\n Humanjava\nclass Human \n     An empty body for now\n\nThe following snippet of code defines a public class named Human  with an empty body Note that this \ndeclaration uses a public  modifier\n Humanjava\npublic class Human \n     An empty body for now\n\nI explain the differences between a public and other types of classes in detail later in this chapter\n Declaring Fields in\u00a0a\u00a0Class\nFields of a class represent properties also called attributes of objects of that class Suppose every object of \na Human  class has two properties a name and a gender The Human  class should include declarations of two \nfields one to represent the name and one to represent the gender\nThe fields are declared inside the body of the class The general syntax to declare a field in a class is\nmodifiers class classname \n     A field declaration\n    modifiers datatype fieldname  initialvalue\n\nA field declaration can use zero or more modifiers  The data type of the field precedes its name \nOptionally you can also initialize each field with a value If you do not want to initialize a field its \ndeclaration should end with a semicolon after its name\nWith two fields name  and gender  the declaration of the Human  class will look as shown\n Humanjava\nclass Human \n    String name\n    String gender\nChapter 7  Classes\n228 Tip It is a convention not a rule or a requirement in Java to start a c lass name with an uppercase letter \nand capitalize the subsequent words for example Human  Table  ColorMonitor  etc the names of fields \nand methods should start with a lo wercase letter and the subsequent words should be capitalized for example \nname  firstName  maxDebitAmount  etc\nThe Human  class declares two fields name  and gender  Both fields are of the String  type Every instance \nor object of the Human  class will have a copy of these two fields\nSometimes a property belongs to the class itself not to any particular instance of that class For \nexample the count of all humans is not a property of any specific human Rather it belongs to the human \nclass itself The existence of the count of humans is not tied to any specific instance of the human class even \nthough each instance of the human class contributes to the value of the count property Only one copy of \nthe class property exists irrespective of the number of instances that exist for the class However a separate \ncopy of the instance property exists for each instance of a class For example a separate copy of the name  \nand gender  properties exists for each instance of the Human  class You always specify name and gender of a \nhuman However even if there is no instance of the Human  class you can say that the count of the Human  class \ninstances is zero\nJava lets you declare two types of fields for a class\n\t Class fields\n\t Instance fields\nClass fields are also known as class variables  Instance fields are also known as instance variables  In the \nprevious snippet of code name  and gender  are two instance variables of the Human  class Java has a different \nway to declare class variables All class variables must be declared using the static  keyword as a modifier \nThe declaration of the Human  class in Listing 71 adds a count  class variable\nListing 71  Declaration of a Human Class with One Class Variable and Two Instance Variables\n Humanjava\npackage comjdojocls\nclass Human \n    String name          An instance variable\n    String gender        An instance variable\n    static long count    A class variable because of the static modifier\n\n Tip a c lass variable is also known as a static variable  an instance variable is also kno wn as a  \nnonstatic variable \n Creating Instances of\u00a0a\u00a0Class\nThe following is the general syntax to create an instance of a class\nnew CalltoClassConstructorChapter 7  Classes\n229The new operator is followed by a call to the constructor of the class whose instance is being created \nThe new operator creates an instance of a class by allocating the memory on heap The following statement \ncreates an instance of the Human  class\nnew Human\nHere Human  is a call to the constructor of the Human  class Did you add any constructor to your Human  \nclass No You have not added any constructor to your Human  class You have added only three fields to it \nHow can you use a constructor for a class that you have not added When you do not add a constructor to \na class the Java compiler adds one for you The constructor that is added by the Java compiler is called a \ndefault constructor The default constructor accepts no arguments The name of the constructor of a class is \nthe same as the class name We discuss constructors in detail in Chapter 9\nWhat happens when an instance of a class is created The new operator allocates memory for each \ninstance field of the class Recall that class variables are not allocated memory when an instance of the class \nis created Figure\u00a0 71 depicts an instance of the Human  class in memory\nFigure 71 shows that memory is allocated for the instance variables name  and gender  You can create \nas many instances of the Human  class as you want Each time you create an instance of the Human  class the \nJava runtime allocates memory for the name  and gender  instance variables How much memory is allocated \nfor an instance of the Human  class The simple answer is that you do not know exactly how much memory \nis used by an instance of a class and in fact you do not need to know this The Java runtime takes care of \nmemory allocation as well as deallocation automatically for you\nNow you want to move a step forward and assign values to the name  and gender  instance variables \nfor the newly created instance of the Human  class Can you assign values to the name  and gender  instance \nvariables of the newly created instance of the Human  class The answer is no You cannot access the name  and \ngender  instance variables even though they exist in memory To access instance variables of an instance \nof a class you must have its reference or handle The expression new Human  creates a new instance of \nthe Human  class in memory The newly created instance is like a balloon filled with helium gas left in the air \nWhen you release a heliumfilled balloon in the air you lose control of the balloon If you attach a string to \nthe balloon before releasing it in the air you can control the balloon using the string Similarly if you want \nto have control of or access to an instance of a class you must store the reference of that instance in a \nreference variable You control a balloon with a string you control a television with a remote control The \ntype of controlling device depends on the type of the object that you want to control Similarly you need \nto use different types of reference variables to refer to or to handle or to work with instances of different \nclasses\nThe name of a class defines a new reference type in Java A variable of a specific reference type can store \nthe reference of an instance of the same reference type in memory Suppose you want to declare a reference \nvariable which will store a reference of an instance of the Human  class You will declare the variable as shown\nHuman jackFigure 71  An in stance of the Human class in memory created by the new Human instance creation \nexpressionChapter 7  Classes\n230Here Human  is the class name which is also a reference type and jack  is a variable of that type In other \nwords jack  is a reference variable of Human  type The jack  variable can be used to store a reference of an \ninstance of the Human  class\nThe new operator allocates the memory for a new instance of a class and returns the reference or the \nindirect pointer to that instance You need to store the reference returned by the new operator in a reference \nvariable\njack  new Human\nNote that jack  itself is a variable and it will be allocated memory separately The memory location \nfor the jack  variable will store the reference of the memory location of the newly created instance of the \nHuman  class Figure\u00a0 72 depicts the memory state when the reference variable jack  is declared and when an \ninstance of the Human  class is created and its reference is assigned to the jack  variable\nYou can think of the jack  variable as a remote controller for a Human  instance in memory You can refer \nto the Human  instance in memory using the jack  variable We discuss how to use a reference variable in the \nnext section You can also combine the two statements into one\nHuman jack  new Human\n The null Reference Type\nEvery class in Java defines a new reference type Java has a special reference type called a null type It has no \nname Therefore you cannot define a variable of the null reference type The null reference type has only \none value defined by Java which is the null  literal It is simply null  The null reference type is assignment\ncompatible with all the other reference types That is you can assign null  to a variable of any reference type \nPractically null  stored in a reference variable means that the reference variable is referring to no object You \ncan think of storing null  in a reference variable as a string with no balloon attached to it where the balloon \nis a valid object and the string is a reference variable For example you can write code like the following\n Assign null to john\nHuman john  null    john is not referring to any object\njohn  new Human  Now john is referring to a valid Human objectFigure 72  Memor y states when a reference variable is declared and when a reference variable is assigned the \nreference of an instance of a classChapter 7  Classes\n231You can use null  with comparison operators to check for equality and inequality\nif john  null \n     john is referring to null Cannot use john for anything\n else \n     Do something with john\n\nIf you perform an operation on a null  reference a NullPointerException  is thrown\nHuman john  null\n The following statement throws a NullPointerException because john is null and you\n cannot use any operation on a null reference variable\nString name  johnname\nNote that null  is a literal of the null type Java does not let you mix reference types and primitive types \nYou cannot assign null  to a primitivetype variable The following assignment statement will generate a \ncompiletime error\n A compiletime error A reference type value null cannot be assigned to\n a primitive type variable num\nint num  null\nBecause null  or any referencetype value cannot be assigned to a primitivetype variable the Java \ncompiler does not allow you to compare a primitive value to a null  value The following comparison will \ngenerate a compiletime error In other words you can compare a reference type with other reference types \nand a primitive type with other primitive types\nint num  0\n A compiletime error Cannot compare a primitive type to a reference type\nif num  null \n\n Ti p Ja va has a special reference type that is called null type the null type does not have a name the null \ntype has a literal value which is represented by null  the null type is assignmentcompatible with all the other \nreference types You can assign any referencetype variable a null  value You can cast a null  value to any \nreference type It is to be emphasized that null  is a literal value of null reference type not a keyword\n Using Dot Notation to\u00a0Access Fields of\u00a0a\u00a0Class\nDot notation is used to refer to instance variables The general form of the dot notation syntax is as follows\nreferencevariablenameinstancevariablenameChapter 7  Classes\n232For example you use jackname  to refer to the name  instance variable of the instance to which the jack  \nreference variable is referring If you want to assign a value to the name  instance variable you can use the \nfollowing\njackname  Jack Parker\nThe following statement assigns the value of the name  instance variable to a String  variable aName \nString aName  jackname\nHow do you refer to class variables You have two ways to refer to a class variable using dot notation\n\t Using the name of the class\n\t Using a reference of an instance of the class\nYou can refer to a class variable using the name of the class\nclassnameclassvariablename\nFor example you can use Humancount  to refer to the count  class variable of the Human  class To assign a \nnew value say 101 to the count  class variable you can write this\nHumancount  101\nTo read the value of the count  class variable into a variable called population  you can use this\nlong population  Humancount\nYou can also use a reference variable to refer to the class variable of a class For example you can use \njackcount  to refer to the count  class variable of the Human  class You can use the following statement to \nassign a value say 101 to the count  class variable\njackcount  101\nThe following statement reads the value of the count  class variable into a variable called population \nlong population  jackcount\nBoth of these statements assume that jack  is a reference variable of Human  type and that it refers to a \nvalid Human  instance\n Ti p Y ou can use the class name or a reference variable of the class type to refer to a class variable since \nthe class variable belongs to the class and it is shared by all instances of the class it is logical to refer to it \nusing the class name however you must always use a reference variable of a class type to refer to the instance \nvariablesChapter 7  Classes\n233It is time to see fields in the Human  class in action Most classes in this chapter are part of the jdojocls  \nmodule as declared in Listing 72 The cls in the module name is short for class You cannot use jdojo\nclass  as a module name because class  is a keyword The module exports a comjdojocls  package You \nhave not learned about the exports  statement in a module declaration yet I explain it in this chapter\nListing 72  Declaration of the jdojocls Module\n moduleinfoclass\nmodule jdojocls \n    exports comjdojocls\n\nListing 73 has a complete program that demonstrates how to access class variables and instance \nvariables of a class\nListing 73  Using Fields in a Class Declaration\n FieldAccessTestjava\npackage comjdojocls\nclass FieldAccessTest \n    public static void mainString args \n         Create an instance of the Human class\n        Human jack  new Human\n         Increase count by one\n        Humancount\n         Assign values to name and gender\n        jackname  Jack Parker\n        jackgender  Male\n         Read and print the values of name gender and count\n        String jackName  jackname\n        String jackGender  jackgender\n        long population  Humancount\n        SystemoutprintlnName   jackName\n        SystemoutprintlnGender   jackGender\n        SystemoutprintlnPopulation   population\n         Change the name\n        jackname  Jackie Parker\n         Read and print the changed name\n        String changedName  jackname\n        SystemoutprintlnChanged Name   changedName\n    \n\nName Jack Parker\nGender Male\nPopulation 1\nChanged Name Jackie ParkerChapter 7  Classes\n234The following statement in this program needs some explanation\n Increase count by one\nHumancount\nIt uses the increment operator   on the count  class variable After the count  class variable is \nincremented by 1 you read and print its value The output shows that after incrementing its value by 1 \nits value becomes 1 It means that its value was zero before the Humancount  statement was executed \nHowever you have never set its value to zero Its declaration was as follows\nstatic long count\nWhen the count  class variable was declared as shown previously it was initialized to zero by default All \nfields of a class class variables and instance variables are initialized to a default value if you do not assign \nan initial value to them The next section describes the rules used to initialize fields of a class\n Default Initialization of\u00a0Fields\nAll fields of a class static as well as nonstatic are initialized to a default value The default value of a field \ndepends on its data type\n\t A numeric field  byte  short  char  int long  float  and double  is  \ninitialized to zero\n\t A boolean  field is initialized to false \n\t A referencetype field is initialized to null \nAccording to these rules the fields of the Human  class will be initialized as follows\n\t The count  class variable is initialized to zero because it is of numeric type This is the \nreason that Humancount  evaluated to 1 0  1  1  as shown in the output of \nListing 73\n\t The name  and gender  instance variables are of String  type String  is a reference \ntype They are initialized to null  Recall that a copy of the name  and gender  fields \nexists for every object of the Human  class and each copy of name  and gender  is \ninitialized to null \nIf you consider the default initialization of the fields of the Human  class it behaves as if you had declared \nthe Human  class as follows This declaration of the Human  class and the one shown in Listing 71 are the same\nclass Human \n    String name  null\n    String gender  null\n    static long count  0\n\nListing 74 demonstrates the default initialization of fields The DefaultInit  class includes only \ninstance variables The class fields are initialized with the same default value as the instance fields If you \ndeclare all fields of the DefaultInit  class as static  the output will be the same The class includes two \nreferencetype instance variables str and jack  which are of String  and Human  types Note that both String  \nand Human  are reference types and null  is assigned to their references by defaultChapter 7  Classes\n235Listing 74  Defa ult Initialization of Class Fields\n DefaultInitjava\npackage comjdojocls\nclass DefaultInit \n    byte b\n    short s\n    int i\n    long l\n    float f\n    double d\n    boolean bool\n    String str\n    Human jack\n    public static void mainString args \n         Create an object of DefaultInit class\n        DefaultInit obj  new DefaultInit\n         Print the default values for all instance variables\n        Systemoutprintlnbyte is initialized to   objb\n        Systemoutprintlnshort is initialized to   objs\n        Systemoutprintlnint is initialized to   obji\n        Systemoutprintlnlong is initialized to   objl\n        Systemoutprintlnfloat is initialized to   objf\n        Systemoutprintlndouble is initialized to   objd\n        Systemoutprintlnboolean is initialized to   objbool\n        SystemoutprintlnString is initialized to   objstr\n        SystemoutprintlnHuman is initialized to   objjack\n    \n\nbyte is initialized to 0\nshort is initialized to 0\nint is initialized to 0\nlong is initialized to 0\nfloat is initialized to 00\ndouble is initialized to 00\nboolean is initialized to false\nString is initialized to null\nHuman is initialized to null\n Access Level Modifiers for\u00a0a\u00a0Class\nIn Listing 71 you created the Human  class in the comjdojocls  package You used the Human  class in Listing \n73 to create its object in the FieldAccessTest  class which is in the same module and the same package as \nthe Human  class You had no problem compiling and running the following statement in Listing 73\nHuman jack  new HumanChapter 7  Classes\n236Lets create a class called ClassAccessTest  in the comjdojocommon  package in the jdojocls  module \nNote that the ClassAccessTest  and Human  classes are in different packages The ClassAccessTest  class \ndeclaration is as follows\n ClassAccessTestjava\npackage comjdojocommon\npublic class ClassAccessTest \n    public static void mainString args \n        Human jack\n    \n\nThe code for the ClassAccessTest  class is very simple It does only one thingdeclares a reference \nvariable of the Human  type in its main  method Compile the ClassAccessTest  class Oops You got a \ncompiletime error\nClassAccessTestjava6 error cannot find symbol\n     Human jack\n        \n  symbol   class Human\n  location class ClassAccessTest\n1 error\nIf you read the error carefully the compiler is complaining about the type Human  in the following \nvariable declaration\nHuman jack\nThe compiler is stating that it could not find the definition of the term Human  What is wrong in the \nClassAccessTest  class with the jack  variable declaration When you refer to a class by its simple name the \ncompiler looks for that class declaration in the same package where the referring class is In your case the \nreferring class ClassAccessTest  is in the comjdojocommon  package and it uses the simple name Human  to \nrefer to the Human  class Therefore the compiler looks for the Human  class in the comjdojocommon  package \nThe compiler is looking for a comjdojocommonHuman  class which does not exist This is the reason you \nreceived the error\nBy using the simple name Human  in ClassAccessTest  you meant to refer to the Human  class in the com\njdojocls  package not in the comjdojocommon  package If you had the Human  class in the comjdojo\ncommon  package your code for ClassAccessTest  would have compiled Lets assume that you do not have a \ncomjdojocommonHuman  class and you want to fix this error You can fix it by using the fully qualified name \nof the Human  class like so\n ClassAccessTestjava\npackage comjdojocommon\npublic class ClassAccessTest \n    public static void mainString args \n        comjdojoclsHuman jack\n    \nChapter 7  Classes\n237Now compile the ClassAccessTest  class Oops You got a compilationtime error again However this \ntime the error is different\nClassAccessTestjava6 error Human is not public in comjdojocls cannot be accessed from \noutside package\n        comjdojoclsHuman jack\n                     \n1 error\nThis time the compiler is not saying that it does not understand the Human  type It is saying that it knows \nwhat comjdojoclsHuman  type is however it is accessible only inside the comjdojocls  package in which \nit has been declared In other words the Human  type is not accessible inside the comjdojocommon  package \nHere comes the concept of the access level for a class\nWhen you declare a class you can also specify whether the class can be accessed or used or referred \nto from any package or only from within the package in which it has been declared For example you can \nspecify in the declaration of the Human  class whether it can be accessed only from within the comjdojo\ncls package or from any package including the comjdojocommon  package The general syntax specifying \naccess level for a class is as follows\naccesslevelmodifier class classname \n     Body of the class goes here\n\nThere are only two valid values for an access level modifier in a class declaration no value and public \n\t No value  It is the same as the absence of an access level modifier It is also known \nas packagelevel access If a class has packagelevel access it can be accessed only \nwithin the package in which it has been declared The Human  class in Listing 71 has \npackagelevel access This is the reason that you were able to use or access the \nHuman  class in the FieldAccessTest  class in Listing 73 Note that the Human  class \nand the FieldAccessTest  class are in the same package and both have package\nlevel access Therefore they can refer to each other The Human  class is in the com\njdojocls  package and it has packagelevel access Therefore it cannot be accessed \nfrom any other package for example comjdojocommon  This is the reason that you \nreceived an error when you tried to compile the ClassAccessTest  class\n\t public  A class with a public  access level modifier can be accessed from any package \nin the same module If you want the Human  class to be accessible from any package \neg comjdojocommon  you need to declare it as public \nCan a class C declared in module M be accessed in module N The answer to this question depends \non the access level modifier of class C and declaration of modules M and N For class C to be accessible in a \npackage in module N the following criteria must be met\n\t Class C in module M must be declared public \n\t Module M must export the package of class C to all other modules or to at least \nmodule N By exporting a package a module states that the public classes or any \ntype in the package can be used by all or some other modules\n\t The declaration of module N must require module MChapter 7  Classes\n238Module dependency is a vast topic We discuss it in detail in Chapter 10 In this chapter we limit the \ndiscussion of accessibility of a type in the same module unless module dependency must be mentioned\nLets redefine the Human  class as shown in Listing 75 This time you have specified its access level as \npublic  so it is accessible from any package\nListing 75  Redefined Human Class with the Public Access Level Modifier\n Humanjava\npackage comjdojocls\npublic class Human \n    String name          Instance variable\n    String gender        Instance variable\n    static long count    Class variable\n\nRecompile the Human  class and then compile the ClassAccessTest  class This time the \nClassAccessTest  class compiles without any errors\n Tip What does it mean when I state that a class is accessible from a package a class defines a new \nreference type a reference type can be used to dec lare a variable When a class is accessible in a package the \nclass name can be used as a reference type for example to declare a variable in the code that resides in that \npackage\n Import Declarations\nYou learned two rules in the previous section\n\t You must declare a class public  to use it in a package other than the package in \nwhich it is declared If the other package is in another module additional work is \nneeded in both module declarations for the public  class to be accessible\n\t You need to use the fully qualified name of a class to use it in a package other than \nthe one in which it is declared A class can be referred to using its simple name in the \npackage in which it is declared\nThere is no alternative to the first rule That is a class must be declared public  if it needs to be \naccessible from outside its package\nThere is another way to deal with the second rule You can refer to a class by its simple name outside its \npackage by using an import declaration An import declaration is used to import a class into a compilation \nunit from outside the package of the compilation unit Technically speaking an import declaration is used \nto import any type into a compilation unit not just a class Import declarations appear just after the package \ndeclaration and before the first type declaration Figure\u00a0 73 shows the place where import declarations \nappear You can have zero or more import declarations in a compilation unitChapter 7  Classes\n239This section mentions importing only classes However the same rules apply for importing any other \ntypes for example interfaces annotations or enums Because I have covered only class types up to this \npoint I do not mention any other types in this discussion\nThere are two types of import declarations\n\t Singletype import declaration\n\t Importondemand declaration\n SingleType Import Declaration\nA singletype import declaration is used to import a single type eg one class from a package It takes the \nfollowing form\nimport fullyqualifiednameofatype\nThe following import declaration imports the Human  class from the comjdojocls  package\nimport comjdojoclsHuman\nA singletype import declaration imports only one type from a package If you want to import more than \none type eg three classes from a package you need to use a separate import declaration for each type \nThe following import declarations import Class11  from the pkg1  package Class21  and Class22  from the \npkg2  package and Class33  from the pkg3  package\nimport pkg1Class11\nimport pkg2Class21\nimport pkg2Class22\nimport pkg3Class33Figure 73  The structure of a compilation unit in JavaChapter 7  Classes\n240Lets revisit the comjdojocommonClassAccessTest  class which had a compiletime error\n ClassAccessTestjava\npackage comjdojocommon\npublic class ClassAccessTest \n    public static void mainString args \n        Human jack\n    \n\nYou received a compiletime error when you used the simple name of the Human  class because the \ncompiler could not find a Human  class in the comjdojocommon  package You resolved this error by using the \nfully qualified name of the Human  class like so\n ClassAccessTestjava\npackage comjdojocommon\npublic class ClassAccessTest \n    public static void mainString args \n        comjdojoclsHuman jack  Uses full qualified name for the Human class\n    \n\nYou have another way to resolve this error which is by using a singletype import declaration You \ncan import the comjdojoclsHuman  class to use its simple name The modified ClassAccessTest  class \ndeclaration is as follows\n ClassAccessTestjava   Modified version\npackage comjdojocommon\nimport comjdojoclsHuman  Import the Human class\npublic class ClassAccessTest \n    public static void mainString args \n        Human jack          Use simple name of the Human class\n    \n\nThe modified version of the ClassAccessTest  class compiles fine When the compiler comes across the \nsimple name of the Human  class in the statement like\nHuman jack\nit goes through all import declarations to resolve the simple name to a fully qualified name When it tries \nto resolve the simple name Human  it finds the import declaration import comjdojoclsHuman  which \nimports the Human  class It assumes that you intended to use the comjdojoclsHuman  class when you used \nthe simple name Human  in the previous statement The compiler replaces the previous statement with the \nfollowing statement\ncomjdojoclsHuman jackChapter 7  Classes\n241 Ti p Import dec larations let you use the simple name of a type in your code thus making your code more \nreadable When you compile your code the compiler replaces the simple name of a type with its fully qualified \nname It uses import declarations for converting simple names of the types to their fully qualified names It is to \nbe emphasized that using import declarations in your Java program does not affect the size of your compiled \ncode or runtime performance Using import declarations is just a way to use the simple names of classes in \nyour source code\nThere are many subtle points to remember while using import declarations We will discuss them shortly\n ImportonDemand Declaration\nSometimes you may need to import multiple types from the same package You need to use as many \nsingletype import declarations as the number of types you need to import from the package An import\nondemand declaration is used to import multiple types from a package using one import  declaration The \nsyntax for an importondemand declaration is\nimport packagename\nHere the package name is followed by a dot and an asterisk   For example the following importon\ndemand declaration imports all types from the comjdojocls  package\nimport comjdojocls\nSometimes the use of an asterisk in an importondemand declaration leads to the wrong assumption \nabout the types that are imported Suppose there are two classes C1 and C2 They are in packages p1 and p1\np2 respectively That is their fully qualified names are p1C1  and p1p2C2  You may write an importon\ndemand declaration as\nimport p1\nthinking that it will import both classes p1C1  and p1p2C2  This assumption is wrong The declaration\nimport p1\nimports all types only from the p1 package It will not import the p1p2C2  class because the C2 class is not \nin the p1 package rather it is in the p2 package which is a subpackage of p1 The asterisk at the end of an \nimportondemand declaration means all types only from the specified package The asterisk does not mean \nsubpackages and types inside those subpackages Sometimes developers attempt to use multiple asterisks \nin an importondemand declaration thinking that it will import types from all subpackages too\nimport p1  A compiletime error\nThis importondemand declaration results in a compiletime error because it uses multiple asterisks It \ndoes not follow the syntax for an importondemand declaration In an importondemand declaration the \ndeclaration must end with a dot followed by one and only one asteriskChapter 7  Classes\n242If you want to import both classes C1 and C2 you need to use two importondemand declarations\nimport p1\nimport p1p2\nYou can rewrite the code for the ClassAccessTest  class using an importondemand declaration\n ClassAccessTestjava   Modified version uses importondemand\npackage comjdojocommon\n Import all types from the comjdojocls package including the Human class\nimport comjdojocls\npublic class ClassAccessTest \n    public static void mainString args \n        Human jack  Use simple name of the Human class\n    \n\nWhen the compiler tries to resolve the simple name Human  in the previous code it will use the import\nondemand declaration to see if a Human  class exists in the comjdojocls  package In fact the asterisk in \nthe import  declaration will be replaced by Human  and then the compiler checks if the comjdojoclsHuman  \nclass exists Suppose you have two classes in the comjdojocls  package named Human  and Table  The \nfollowing code will compile with one importondemand declaration\n ClassAccessTestjava   Modified version uses importondemand\npackage comjdojocommon\n Import all types from comjdojocls package including Human and Table classes\nimport comjdojocls\npublic class ClassAccessTest \n    public static void mainString args \n        Human jack  Use simple name of the Human class\n        Table t1     Use simple name of the Table class\n    \n\nThe one importondemand declaration in the previous code has the same effect as the following two \nsingletype import declarations\nimport comjdojoclsHuman  Import Human class\nimport comjdojoclsTable  Import Table class\nWhich type of import declaration is better to use in your Java program singletype import or importon\ndemand It is simple to use the importondemand declaration However it is not readable Lets look at the \nfollowing code which compiles fine Assume that classes A and B are not in the comjdojocls  package\n ImportOnDemandTestjava\npackage comjdojocls\nimport p1\nimport p2\npublic class ImportOnDemandTest \n    public static void mainString args \n        A a  Declare a variable of class A typeChapter 7  Classes\n243        B b  Declare a variable of class B type\n    \n\nCan you tell by looking at this code the fully qualified names of the classes A and B Is class A in the \npackage p1 or p2 It is impossible to tell just by looking at the code the package to which classes A and B \nbelong because you have used importondemand declarations Lets rewrite the previous code using two \nsingletype import declarations\n ImportOnDemandTestjava\npackage comjdojocls\nimport p1A\nimport p2B\npublic class ImportOnDemandTest \n    public static void mainString args \n        A a  Declare a variable of class A type\n        B b  Declare a variable of class B type\n    \n\nBy looking at the import declarations you can now tell that class A is in the package p1 and class B is \nin the package p2 A singletype import declaration makes it easy for readers to know which class is being \nimported from which package It also makes it easy to know the number and names of the classes used from \nother packages in your program This book uses singletype import declaration in all examples except in \nexamples where we discuss importondemand declarations\nEven though you are advised to use singletype import declaration in your programs you need to know \nsome tricky uses and implications of using both singletype import and importondemand declarations in \nthe same program Subsequent sections discuss them in detail\n Import Declarations and\u00a0Type Search Order\nImport declarations are used to resolve simple names of types to their fully qualified names during \ncompilation The compiler uses predefined rules to resolve the simple names Suppose the following \nstatement appears in a Java program that uses a simple name A\nA var\nThe Java compiler must resolve the simple name A to its fully qualified name during the compilation \nprocess It searches for a type referenced in a program in the following order\n\t The current compilation unit\n\t Singletype import declarations\n\t Types declared in the same package\n\t Importondemand declarations\nThis list of type searches is not complete If a type has nested types the nested type is searched before \nlooking in the current compilation unit We will defer the discussion of nested types until inner classes are \ndiscussed in the second book of this seriesChapter 7  Classes\n244Lets discuss the rules for a type search using a few examples Suppose you have a Java source file \na compilation unit called Bjava  whose contents are as follows Note that the file Bjava  contains \ndeclarations for two classes A and B\n Bjava\npackage p1\nclass B \n    A var\n\nclass A \n     Code goes here\n\nClass B refers to class A using the simple name when it declares an instance variable var of type A \nWhen the Bjava  file is compiled the compiler will look for a type with the simple name A in the current \ncompilation unit  Bjava  file It will find a class declaration whose simple name is A in the current \ncompilation unit The simple name A will be replaced with its fully qualified name p1A  Note that both \nclasses A and B are declared in the same compilation unit and therefore they are in the same package p1 \nThe class B definition will be changed as follows by the compiler\npackage p1\nclass B \n    p1A var  A has been replaced by p1A by the compiler\n\nSuppose you want to use class A from package p2 in the previous example That is there is a class p2A  \nand you want to declare the instance variable var of type p2A  in class B instead of p1A  Lets try to solve it \nby importing class p2A  using a singletype import declaration like so\n Bjava   Includes a new import declaration\npackage p1\nimport p2A\nclass B \n    A var  You want to use p2A when you use A here\n\nclass A \n     Code goes here\n\nWhen you compile the modified Bjava  file you will get the following compilation error\nBjava p1A is already defined in this compilation unit at line 2 column 1\nWhat is wrong with the modified source code When you remove the singletype import declaration \nfrom it it compiles fine It means it is the singletype import declaration that is causing the error Before you \nresolve this error you need to learn about a new rule about singletype import declarations The rule is\nIt is a compiletime error to import more than one type with the same simple name using \nmultiple singletype import declarationsChapter 7  Classes\n245Suppose you have two classes p1A  and p2A  Note that both classes have the same simple name A \nplaced in two different packages According to this rule if you want to use the two classes p1A  and p2A  in \nthe same compilation unit you cannot use two singletype import declarations\n Testjava\npackage pkg\nimport p1A\nimport p2A  A compiletime error\nclass Test \n    A var1  Which A to use p1A or p2A\n    A var2  Which A to use p1A or p2A\n\nThe reason behind this rule is that the compiler has no way of knowing which class  p1A  or p2A  to use \nwhen you use simple name A in the code Java might have solved this issue by using the first imported class \nor the last imported class which would have been errorprone Java decided to nip the problem in the bud \nby giving you a compiletime error when you import two classes with the same simple names so you cannot \nmake silly mistakes like this and end up spending hours resolving them\nLets go back to the problem of importing the p2A  class in a compilation unit which already declares a \nclass A The following code produces a compiletime error\n Bjava   Includes a new import declaration\npackage p1\nimport p2A\nclass B \n    A var1  You want to use p2A when you use A\n\nclass A \n     Code goes here\n\nThis time you have used only one singletype import declaration not two Why did you get an error \nWhen you declare more than one class in the same compilation unit most likely they are closely related \nand they would refer to each other You need to think as if Java imported each of the classes declared in the \nsame compilation unit using a singletype import declaration You can think of the previous code being \ntransformed by Java as shown\n Bjava   Includes a new import declaration\npackage p1\nimport p1A  Think of it being added by Java\nimport p1B  Think of it being added by Java\nimport p2A\nclass B \n    A var  We want to use p2A when you use A\n\nclass A \n            Code goes here\nChapter 7  Classes\n246Can you now see the problem The class A has been imported twice once by Java and once by you \nand this is the reason for the error How do you refer to p2A  in your code anyway It is simple Use the fully \nqualified name p2A  whenever you want to use p2A  in your compilation unit\n Bjava   Uses fully qualified name p2A in class B\npackage p1\nclass B \n    p2A var  Use fully qualified name of A\n\nclass A \n               Code goes here\n\n Ti p It is a compiletime error to import a type using a singletype import dec laration into a compilation unit \nif a type with the same simple name exists in the same compilation unit\nLets resolve the compiletime error with the code that needs to use classes from different packages with \nthe same simple name The code is as follows\n Testjava\npackage pkg\nimport p1A\nimport p2A  A compiletime error\nclass Test \n    A var1   Which A to use p1A or p2A\n    A var2   Which A to use p1A or p2A\n\nYou can resolve the error using one of the following two methods The first method is to remove both \nimport declarations and use the fully qualified name of class A as follows\n Testjava\npackage pkg\nclass Test \n    p1A var1  Use p1A\n    p2A var2  Use p2A\n\nThe second method is to use only one import declaration to import class A from one package say p1 \nand use the fully qualified name of class A from the p2 package as follows\n Testjava\npackage pkg\nimport p1A\nclass Test \n    A var1     Refers to p1A\n    p2A var2  Uses the fully qualified name p2A\nChapter 7  Classes\n247 Ti p If you want to use multiple c lasses with the same simple name in a compilation unit but from different \npackages you can import a maximum of one class For the rest of the classes you must use the fully qualified \nname You have the option of using the fully qualified name for all classes\nLets discuss a few rules about using importondemand declarations The compiler uses the import\nondemand declarations to resolve a simple name of a type after it has used all other means to resolve the \nsimple name It is valid to import a class with the same simple name using a singletype import declaration \nas well as an importondemand declaration In such a case the singletype import declaration is used \nSuppose you have three classes p1A  p2A  and p2B  Suppose you have a compilation unit as follows\n Cjava\npackage p3\nimport p1A\nimport p2\nclass C \n    A var  Will always use p1A not p2A\n\nIn this example class A has been imported twice once using simpletype import declaration from \npackage p1 and once using importondemand declaration from package p2 The simple name A is resolved \nto p1A  because a singletype import declaration always takes precedence over an importondemand \ndeclaration Once the compiler finds a class using a singletype import declaration it stops the search \nwithout looking for that class using any importondemand declarations\nLets change the import declarations in the previous example to use importondemand declarations as \nfollows\n Cjava\npackage p3\nimport p1\nimport p2\nclass  C \n    A var  A compiletime error Which A to use p1A or p2A\n\nCompiling class C generates the following error\nCjava reference to A is ambiguous both class p2A in p2 and class p1A in p1 match at \nline 8 column 5\nThe error message is loud and clear When the compiler finds a class using an importondemand \ndeclaration it continues searching for the class in all importondemand declarations If it finds the class \nwith the same simple name using multiple importondemand declarations it generates an error You can \nresolve this error in several ways\n\t Use two singletype import declarations\n\t Use one singletype import and one importondemand declaration\n\t Use fully qualified names for both classesChapter 7  Classes\n248The following list covers a few more rules about import declarations\n\t Duplicate singletype import and importondemand declarations are ignored The \nfollowing code is valid\n Djava\npackage p4\nimport p1A\nimport p1A  Ignored A duplicate import declaration\nimport p2\nimport p2  Ignored A duplicate import declaration\nclass D \n              Code goes here\n\n\t It is legal though not needed to import classes from the same package using single\ntype import declarations or importondemand declaration The following code \nimports class F from the same package p5 Note that all classes declared in the same \npackage are automatically imported for you In such a case the import declaration is \nignored\n Ejava\npackage p5\nimport p5F  Will be ignored\nclass E \n              Code goes here\n\n Fjava\npackage p5\nimport p5  Will be ignored\nclass F \n              Code goes here\n\n Automatic Import Declarations\nYou have been using the String  class and the System  class by their simple names and you never cared to \nimport them in any of your programs The fully qualified names of these classes are javalangString  and \njavalangSystem  Java always imports all types declared in the javalang  package automatically Think of \nthe following importondemand declaration being added to your source code before compilation\nimport javalang\nThis is the reason that you were able to use the simple names of String  and System  classes in your code \nwithout importing them You can use any types from the javalang  package by their simple names in your \nprogramsChapter 7  Classes\n249It is not an error to use an import declaration to import types from the javalang  package They will be \nsimply ignored by the compiler The following code will compile without errors\npackage p1\nimport javalang        Will be ignored because it is automatically done for you\npublic class G \n    String anythingGoes  Refers to javalangString\n\nYou need to be careful when using the simple name of a type which is the same as a type that is defined \nin the javalang  package Suppose you declare a p1String  class\n Stringjava\npackage p1\npublic class String \n     Code goes here\n\nSuppose you have a Test  class in the same package p1\n Testjava\npackage p1\npublic class Test \n     Which String class will be used p1String or javalangString\n    String myStr\n\nWhich String  class is referred to in the Test  class p1String  or javalangString  It will refer to p1\nString  not javalangString  because the package of the compilation unit which is p1 in this case is \nsearched before any import declarations to resolve the simple names of types The compiler finds the String  \nclass in package p1 It will not search the javalang  package for the String  class If you want to use the \njavalangString  class in this example you must use its fully qualified name as shown\n Testjava\npackage p1\npublic class Test \n    javalangString s1  Use javalangString\n    p1String s2          Use p1String\n    String s3             Will use p1String\n\n Static Import Declarations\nA static import declaration does what its name suggests It imports static members static variables\nmethods of a type into a compilation unit You learned about static variables or class variables in the \nprevious sections We discuss static methods in the next section A static import declaration comes in two \nflavors\n\t Singlestatic import\n\t StaticimportondemandChapter 7  Classes\n250A singlestatic import declaration imports one static member of a type A staticimportondemand \ndeclaration imports all static members of a type The general syntax of static import declaration is as follows\n Singlestaticimport declaration\nimport static packagenametypenamestaticmembername\nStaticimportondemand declaration\nimport static packagenametypename\nYou have been printing messages on the standard output using the Systemoutprintln  method \nSystem  is a class in the javalang  package that has a static variable named out When you use Systemout  \nyou are referring to that static variable named out of the System  class You can use a static import declaration \nto import the out static  variable from the System  class as follows\nimport static javalangSystemout\nYour program now does not need to qualify the out variable with the System  class name as Systemout  \nRather it can use the name out to mean Systemout  in your program The compiler will use the static import \ndeclaration to resolve the name out to Systemout \nListing 76 demonstrates how to use a static import declaration It imports the out static variable of the \nSystem  class Note that the main  method uses the outprintln  method not Systemoutprintln  \nThe compiler will replace the outprintln  call with the Systemoutprintln  call\nListing 76  Using Static Import Declarations\n StaticImportTestjava\npackage comjdojocls\nimport static javalangSystemout\npublic class StaticImportTest \n    public static void mainString args \n        outprintlnHello static import\n    \n\nHello static import\n Tip an import dec laration imports a type name and it lets you use the types simple name in your program \nWhat an import declaration does with a type a static import declaration does with a static member of a type \na static import declaration lets you use the name of a static member static variablemethod of a type without \nqualifying it with the type name\nLets look at another example of using static import declarations The Math  class in the javalang  \npackage contains many utility constants and static methods For example it contains a class variable named \nPI whose value is equal to 227  the pi in mathematics If you want to use any of the static variables or \nmethods of the Math  class you need to qualify them with the class name Math  For example you would \nrefer to the PI static variable as MathPI  and the sqrt  method as Mathsqrt  You can import all static \nmembers of the Math  class using the following staticimportondemand declaration\nimport static javalangMathChapter 7  Classes\n251Now you can use the name of the static member without qualifying it with the class name Math   \nListing 77 demonstrates using the Math  class by importing its static  members\nListing 77  Using Static Imports to Import Multiple Static Members of a Type\n StaticImportTest2java\npackage comjdojocls\nimport static javalangSystemout\nimport static javalangMath\npublic class StaticImportTest2 \n    public static void mainString args \n        double radius  29\n        double area  PI  radius  radius\n        outprintlnValue of PI is   PI\n        outprintlnRadius of circle   radius\n        outprintlnArea of circle   area\n        outprintlnSquare root of 20   sqrt20\n    \n\nValue of PI is 3141592653589793\nRadius of circle 29\nArea of circle 26420794216690158\nSquare root of 20 14142135623730951\nThe following are a few important rules about static import declaration\n Static Import Rule 1\nIf two static members with the same simple name are imported one using singlestatic import declaration \nand the other using staticimportondemand declaration the one imported using singlestatic import \ndeclaration takes precedence Suppose there are two classes p1C1  and p2C2  Both classes have a static \nmethod named m1 The following code will use the p1C1m1  method because it is imported using the \nsinglestatic import declaration\n Testjava\npackage comjdojocls\nimport static p1C1m1  Imports C1m1 method\nimport static p2C2    Imports C2m1 method too\npublic class Test \n    public static void mainString args \n        m1            C1m1 will be called\n    \nChapter 7  Classes\n252 Static Import Rule 2\nUsing a singlestatic import declaration to import two static members with the same simple name is not \nallowed The following static import declarations generate a compiletime error because both of them \nimport a static member with the same simple name m1\nimport static p1C1m1\nimport static p1C2m1  A compiletime error\n Static Import Rule 3\nIf a static member is imported using a singlestatic import declaration and there exists a static member in \nthe same class with the same name the static member in the class is used The following is the code for two \nclasses p1A  and p2Test \n Ajava package p1\npublic class A \n    public static void test \n        Systemoutprintlnp1Atest\n    \n\n Testjava\npackage p2\nimport static p1Atest\npublic class Test \n    public static void mainString args \n        test  Will use p2Testtest method not p1Atest method\n    \n    public static void test \n        Systemoutprintlnp2Testtest\n    \n\np2Testtest\nThe Test  class imports the static method test  from class p1A  using a singlestatic import \ndeclaration The Test  class also defines a static method test  When you use the simple name test  to call \nthe test  method in the main  method it refers to the p2Testtest  method not the one imported by \nthe static import\nThere is a hidden danger in using static import declarations in such cases Suppose you did not \nhave a test  static method in the p2Test  class In the beginning the test  method call will call the \np1Atest  method Later you add a test  method in the Test  class Now the test  method call will \nstart calling p2Testtest  which will introduce a hardtofind bug in your program\n Ti p It may seem tha t static imports help you use simple names of static members to make the program \nsimpler to write and read sometimes static imports may introduce subtle bugs in your program which may be \nhard to debug You are advised to use static imports only in rare circumstancesChapter 7  Classes\n253 Declaring a\u00a0Record\nA Record in Java is a special type of class that has immutable fields meaning they cannot be changed \nhas multiple methods automatically generated for it by the compiler and extends javalangRecord It was \nintroduced in Java 14 as a preview feature and finalized in Java 16\nThe Record type allows the Java compiler and runtime to make large performance improvements that \ncould not be done otherwise The main characteristics of Java Records are they are immutableonce an \ninstance is created its field values cant be changedand they have accessor methods that match the names \nof the fields defined in the Records definition\nThe general syntax for declaring a Record in Java is as follows\nmodifiers record recordname fielddefinitions  \n     Body of the record class goes here\n\nHere\n\tmodifiers  are optional they are keywords that associate special meanings to the \nRecord declaration A Record declaration may have zero or more modifiers much \nlike a class declaration\n\t The word record is used to declare a Record It is not a keyword and can still be used \nas a variable name\n\t The recordname  is a userdefined name of the Record which should be a valid Java \nidentifier\n\t Each Record has a body which is specified inside a pair of braces   The body of a \nRecord can contain different components for example fields methods etc or it can \nbe empty\n\t The field definitions is a commaseparated list of datatype fieldname  \ndeclarations which define the immutable fields  of the Record\nFor example lets recreate the Human class as a Record Listing 78\nListing 78  Redefined Human Class as a Record\n Humanjava\npackage comjdojocls\npublic record Human String name String gender \n    static long count    Class variable\n\nNow when creating an instance of a Human the name and gender fields must be provided and \ncannot change for that instance Unlike for a class there is no default initialization of fields As shown in \nthe example you can still have static variables on a Record which are not immutable Class variables aka \nstatic variables are associated with the class Human in this case not a particular instance of that class\nTo create a Record you use the constructor like the following for example\nHuman bob  new HumanBob maleChapter 7  Classes\n254You access the values using method calls like so the next chapter will explain all about methods\nString name  bobname Bob\nRecords also have several methods autogenerated equals hashCode and toString which we will \nlearn more about in subsequent chapters\n Summary\nClasses are the basic building blocks in objectoriented programming A class represents a reference \ntype in Java Classes serve as templates to create objects A class consists of four parts fields initializers \nconstructors and methods Fields represent the state of objects of the class Initializers and constructors are \nused to initialize fields of the class The new operator is used to create objects of a class Methods represent \nthe behavior of the objects of the class\nFields and methods are known as members of the class Constructors are not members of the class A \ntoplevel class has an access level which determines from what part of the program it is accessible A top\nlevel class can have either public or packagelevel access A public class can be accessed from anywhere \nin the same module If the module of the class exports the classs package the public class can also be \naccessible from inside other modules if those modules declare dependency on the classs module Absence \nof an access level modifier on a toplevel class gives the class packagelevel access which makes the class \naccessible within its package\nEvery class in Java defines a new reference type Java has a special reference type called the null type \nIt has no name Therefore you cannot define a variable of the null reference type The null reference type \nhas only one value defined by Java which is the null  literal It is simply null  The null reference type is \nassignmentcompatible with all other reference types\nA class can have two types of fields They are called instance variables and class variables which are \nalso known as nonstatic and static variables respectively Instance variables represent the state of an object \nof the class A copy of all instance variables exists for each object of the class Class variables represent the \nstate of the class itself Only one copy of class variables exists for a class Fields of a class can be accessed \nusing dot notation which takes this form\nqualifierfieldname\nFor an instance variable the qualifier is a reference of an instance of the class For a class variable the \nqualifier can be a reference of an instance of the class or the class name\nAll fields of a class static as well as nonstatic are initialized to a default value The default value of a \nfield depends on its data type A numeric field  byte  short  char  int long  float  and double  is initialized \nto zero A boolean  field is initialized to false  A referencetype field is initialized to null \nImport statements in a compilation unit are used to import types from other packages They allow using \nthe simple names of types from other packages The compiler uses the import statements to resolve the \nsimple names to fully qualified names Static import statements are used to import static members of types \nfrom other packages\nJava 16 introduced Records which are immutable classes with automatically generated methods and \nare defined using the word record and a list of field definitions within parentheses Those fields do not get \ndefault values and must be supplied when creating an instance of the RecordChapter 7  Classes\n255EXERCISES\n 1 What is an instance variable of a class What is another name for an instance \nvariable\n 2 What is a class variable of a class What is another name used for a class variable\n 3 What are the default values of different types of fields of a class\n 4 Create a class named Point  with two int instance variables named x and y \nBoth instance variables should be declared public Do not initialize the two instance \nvariables\n 5 add a main  method to the Point  class that you created in the previous \nexercise Create an object of the Point  class and print the default values for the x \nand y instance variables set the values of x and y to 5 and 10 respectively and \nprint their values by reading them back in the program\n 6 What will happen when the following snippet of code is run assuming that Point  \nis the class name that you created in the previous exercise\nPoint p  null\nint x  px\n 7 What is the output of the following code\npublic class Employee \n    String name\n    boolean retired\n    double salary\n    public static void mainString args \n        Employee emp  new Employee\n        Systemoutprintlnempname\n        Systemoutprintlnempretired\n        Systemoutprintlnempsalary\n    \n\n 8 the javatime  package contains a LocalDate  class the class contains a \nnow  method that returns the current local date the CurrentDate  class uses \nthe simple name of the class LocalDate  in its main method the code in its \ncurrent form will not compile Complete and run the following code by adding \nan import statementfirst a singletype import statement and then an import\nondemand statementto import the LocalDate  class When you run the \nCurrentDate  class it will print the current local date in I sO format such as  \n20170827\n CurrentDatejava\npackage comjdojoclsexcercise\n Add an import statement here \npublic class CurrentDate Chapter 7  Classes\n256    public static void mainString args \n        LocalDate today  LocalDatenow\n        Systemoutprintlntoday\n    \n\n 9 Consider the follo wing code for a class named StaticImport  the code does \nnot compile because it uses outprintln  instead of the Systemout\nprintln  method in its main  method Complete the code by adding a static \nimport statement the System  class is in the javalang  package and out is a \nstatic variable in the System  class\n StaticImportjava\npackage comjdojoclsexcercise\n Add a static import statement here \npublic class StaticImport \n    public static void mainString args \n        outprintlnHello static import\n    \n\n 10 the following code for a class named MathStaticImport  does not compile add \na staticimportondemand statement to complete the code so it compiles the \njavalangMath  class contains a static variable named PI and a static method \nnamed sqrt \n MathStaticImportjava\npackage comjdojoclsexcercise\n Add a staticimportondemand statement here \npublic class MathStaticImport \n    public static void mainString args \n        double radius  20\n        double perimeter  2  PI  radius\n        SystemoutprintlnValue of PI is   PI\n        SystemoutprintlnSquare Root of 2 is   sqrt2\n        SystemoutprintlnPerimeter of a circle of radius 20 is \n                            perimeter\n    \n 11 Define a public record class named Computer with the following fields and types \nstring name int numberOf processors int memory int disk space and string brand257\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730748CHAPTER 8\nMethods\nIn this chapter you will learn\n\t What methods are and how to declare methods in a class\n\t The meaning of the pronoun this  in a Java program\n\t What local variables are and rules for using them\n\t How to invoke methods of a class\n\t Different parameterpassing mechanisms in general and parameterpassing \nmechanisms in Java\n\t How to declare and use varargs parameters\nExample classes in this chapter are in the comjdojocls  package which is a member of the jdojocls  \nmodule You created the jdojocls  module in Chapter 7\n What Is a\u00a0Method\nA method in a class defines the behavior of the objects of that class or the behavior of the class itself A \nmethod is a named block of code The method can be invoked to execute its code The code that invokes the \nmethod is called the caller of the method Optionally a method may accept input values from the caller and \nit may return a value to the caller The list of input values is known as parameters A method may have zero \nparameters If a method has zero parameters you say that method does not have any parameters or that \nmethod does not takeaccept any parameters A method is always defined inside the body of a class or an \ninterface That is you cannot have a method by itself To keep the sample code simple it shows a method as \nan isolated block of code in this chapter We show a method inside a class body when we discuss a complete \nexample\n Declaring Methods of\u00a0a\u00a0Class\nThe general syntax for a method declaration is of the form\nmodifiers returntype methodname parameterslist throwsclause \n     Body of the method goes here\nChapter 8  Methods\n258Here\n\tmodifiers  is an optional list of modifiers for the method\n\treturntype  is the data type of the value returned by the method\n\tmethodname  is the name of the method\n\tparameterslist  is the list of parameters that the method accepts This is optional \nMultiple parameters are separated by a comma Parameters are always enclosed in \nan opening and closing parenthesis If a method takes no parameters an empty pair \nof parentheses is used\n\t The list of parameters may optionally be followed by a throws  clause that declares \nthe types of exceptions that the method may throw\n\t Finally you specify the code for the method also known as the body of the method \ninside an opening brace and a closing brace\nNote that four parts in a method declaration are mandatory the return type method name a pair \nof opening and closing parentheses and a pair of opening and closing braces Lets discuss each part in \na method declaration in detail We discuss modifiers in various sections of this chapter and subsequent \nchapters in this book We discuss the throws  clause in Chapter 13 The following is an example of a method\nint addint n1 int n2 \n    int sum  n1  n2\n    return sum\n\nThe methods name is add It takes two parameters Both parameters are of type int The parameters \nare named n1 and n2 The method returns an int value which is indicated in its return type The body of the \nmethod computes the sum of two parameters and returns the sum Figure\u00a0 81 shows the different parts of \nthe add method\nThe return type of a method is the data type of the value that the method will return when it is invoked \nIt could be a primitive data type eg int double  boolean  etc or a reference type eg Human String  \netc Sometimes a method does not return a value to its caller The keyword void  is used as the return type if \na method does not return any value to the caller In the previous example the add method returns the sum of \ntwo integers which will be an integer This is the reason that its return type is specified as intFigure 81  Parts of the add methodChapter 8  Methods\n259The method name must be a valid Java identifier Conventionally a Java method starts with a lowercase \nand subsequently a word cap is used For example getName  setName  getHumanCount  and createHuman  are \nvalid method names AbCDeFg  is also a valid method name however it just doesnt follow standard method \nnaming conventions\nA method may take input values from its caller A parameter is used to take an input value from the \ncaller A parameter consists of two parts a data type and a variable name In fact a method parameter \ndeclaration is a variable declaration Variables are used to hold the input values that are passed from the \nmethods caller A comma is used to separate two parameters of a method In the previous example the add \nmethod declares two parameters n1 and n2 Both parameters are of the int data type When the add method \nis called the caller must pass two int values The first value passed from the caller is stored in n1 and the \nsecond value in n2 The parameters n1 and n2 are also known as formal parameters \nA method has a signature which uniquely identifies the method in a particular context The signature of \na method is the combination of the following four parts\n\t Name of the method\n\t Number of parameters\n\t Types of parameters\n\t Order of parameters\nModifiers return types parameter names and the throws  clause are not part of the signature of a \nmethod Table\u00a0 81 lists some examples of method declarations and their signatures\nMost often you will have situations where you need to understand whether two methods have the \nsame signature It is very important to understand that the type and order of the methods parameters are \npart of its signature For example double addint n1 double d1  and double adddouble d1 int n1  \nhave different signatures because the order of their parameters differs even though the number and types of \nparameters are the same\n Tip the signa ture of a method uniquely identifies the method within a class It is not allowed to have more \nthan one method in a class with the same signatureTable 81  Examples of Method Declarations and Their Signatures\nMethod Declaration Method Signature\nint addint n1 int n2 addint int\nint addint n3 int n4 addint int\npublic int addint n1 int n2 addint int\npublic int addint n1 int n2 throws OutofRangeException addint int\nvoid processint n processint\ndouble addint n1 double d1 addint double\ndouble adddouble d1 int n1 adddouble intChapter 8  Methods\n260Finally the code for the method is specified in the methods body which is enclosed in braces \nExecuting the code for a method is also called calling a method or invoking a method  A method is \ninvoked using its name with the values for its parameters if any within parentheses To call the add method \nyou need to use the following statement\nadd10 12\nThis call to the add method passes 10 and 12 as the values for parameters n1 and n2 respectively The \ntwo values 10 and 12 that are used to call the add method are called actual parameters  Java copies the actual \nparameters to the formal parameters before it executes the code inside the body of the method In the previous \ncall to the add method 10 will be copied in n1 and 12 will be copied in n2 You can refer to the formal parameter \nnames as variables having actual parameter values inside the methods body You can see n1 and n2 being \ntreated as variables in the following statement in the add method\nint sum  n1  n2\nA return  statement is used to return a value from a method It starts with the return  keyword If a \nmethod returns a value the return  keyword must be followed by an expression which evaluates to the value \nbeing returned If the method does not return a value its return type is specified as void  If the methods \nreturn type is void  the method does not have to include a return  statement If a method with a void  return \ntype wants to include a return  statement the return  keyword must not be followed by any expression the \nreturn  keyword is immediately followed by a semicolon to mark the end of the statement Here are the two \nflavors of the return  statement\n If a method returns a value an expression must evaluate to a data type\n which is assignment compatible with the specified return type of the method\nreturn an expression\nor\n If methods return type is void\nreturn\nWhat does a return  statement do As its name suggests it returns the control to the caller of the \nmethod If it has an expression it evaluates the expression and returns the value of the expression to the \ncaller If a return  statement does not have an expression it simply returns the control to its caller A return  \nstatement is the last statement that is executed in a methods body You can have multiple return  statements \nin a methods body However at most only one return  statement may be executed for a particular method \ncall\nThe add method returns the sum of two of its parameters How do you capture the returned value of \na method A method call itself is an expression whose data type is the return type of the method and it \nevaluates to the returned value from the method For example if you write a statement like this\nadd10 12\nadd10 12  is an expression and its data type is int At runtime it will be evaluated to an int value of 22 \nwhich is the value returned from the add method To capture the value of a method call you can use the \nmethod call expression anywhere you can use a value For example the following snippet of code assigns the \nvalue returned from the add method to a variable called sum\nint sum  add10 12  sum variable will be assigned 22Chapter 8  Methods\n261Now turn your attention to a method that does not return a value You specify void  as the return type for \nsuch a method Consider the following method declaration for a method named printPoem \nvoid printPoem \n    SystemoutprintlnStrange fits of passion have I known\n    SystemoutprintlnAnd I will dare to tell\n    SystemoutprintlnBut in the lovers ear alone\n    SystemoutprintlnWhat once to me befell\n\nThe printPoem  method specifies void  as its return type which means that it does not return a value to \nits caller It does not specify any parameters which means it does not accept any input values from its caller \nIf you need to call the printPoem  method you need to write the following statement\nprintPoem\n Note  When we refer to a method in this book  we use the method name followed by a pair of opening \nand closing parentheses For example we refer to the add method as add  and printPoem  method as \nprintPoem  sometimes we need to refer to the formal parameters of the method to make the meaning \nof the method clear In those cases we may just use the data type of the formal parameters for example \naddint int  to refer to the addint n1 int n2  method No matter what convention we use to refer \nto a method in the discussion the context of its use will make the meaning clear\nSince the printPoem  method does not return any value you cannot use a call to this method \nas part of any expression where a value is expected For example the following statement results in a \ncompiletime error\nint x  printPoem  A compiletime error\nWhen a methods return type is void  it is not necessary to use a return  statement inside the methods \nbody because you do not have a value to return from the method Recall that a return  statement does two \nthings evaluates its expression if any and returns the control to the caller by ending the execution in the \nmethods body Even if you do not return a value from a method you can still use a return  statement simply \nto end the execution of the method Lets add a parameter to the printPoem  method to allow the caller to \npass the stanza number that it wants to print The modified method declaration is as follows\nvoid printPoemint stanzaNumber \n    if stanzaNumber  1  stanzaNumber  2 \n        SystemoutprintlnCannot print stanza   stanzaNumber\n        return  End the method call\n    \n    if stanzaNumber  1 \n        SystemoutprintlnStrange fits of passion have I known\n        SystemoutprintlnAnd I will dare to tell\n        SystemoutprintlnBut in the lovers ear alone\n        SystemoutprintlnWhat once to me befellChapter 8  Methods\n262     else if stanzaNumber  2 \n        SystemoutprintlnWhen she I loved looked every day\n        SystemoutprintlnFresh as a rose in June\n        SystemoutprintlnI to her cottage bent my way\n        SystemoutprintlnBeneath an eveningmoon\n    \n\nThe modified printPoem  method knows how to print stanzas 1 and 2 If its caller passes a stanza \nnumber outside this range it prints a message and ends the method call This is accomplished by using \na return  statement in the first if statement You could have written the previous printPoem  method \nwithout writing any return  statement as follows\nvoid printPoemint stanzaNumber \n    if stanzaNumber  1 \n         Print stanza 1 \n     else if stanzaNumber  2 \n         Print stanza 2 \n     else \n        SystemoutprintlnCannot print stanza   stanzaNumber\n    \n\nThe compiler will force you to include a return  statement in the body of a method that specifies a \nreturn type in its declaration However if the compiler determines that a method has specified a return \ntype but it always ends its execution abnormally for example by throwing an exception you do not need \nto include a return  statement in the methods body For example the following method declaration is valid \nDo not worry about the throw  and throws  keywords at this time we cover them later in this book\nint aMethod throws Exception \n    throw new ExceptionDo not call me\n\n Local Variables\nA variable declared inside a method a constructor or a block is called a local variable We discuss \nconstructors in Chapter 9 A local variable declared in a method exists only for the duration the method \nis being executed Because a local variable exists only for a temporary duration it cannot be used outside \nthe method the constructor or the block in which it is declared The formal parameters of a method are \ntreated as local variables They are initialized with the actual parameter values when the method is invoked \nand before the methods body is executed You need to observe the following rules about the usage of local \nvariablesChapter 8  Methods\n263 Rule 1\nLocal variables are not initialized by default Note that this rule is the opposite of the rule for instanceclass \nvariable initialization When an instanceclass variable is declared it is initialized with a default value \nConsider the following partial definition of an add  method\nint addint n1 int n2 \n    int sum\n     What is the value of sum We do not know because it has not been initialized yet \n     More code goes here \n\n Rule 2\nThis rule is an offshoot of the first rule A local variable cannot be accessed in the program until it is assigned \na value The following snippet of code will generate a compiletime error because it tries to print the value \nof the local variable sum before it is assigned a value Note that the Java runtime has to read or access the \nvalue of the sum variable to print it\nint addint n1 int n2 \n    int sum\n     A compiletime error Cannot read sum because it is not assigned a value yet\n    Systemoutprintlnsum\n\nThe following snippet of code compiles fine because the local variable sum is initialized before it is read\nint addint n1 int n2 \n    int sum  0\n    Systemoutprintlnsum  Ok Will print 0\n\n Rule 3\nA local variable can be declared anywhere in the body of a method However it must be declared before it \nis used The implication of this rule is that you do not need to declare all local variables at the start of the \nmethod body It is a good practice to declare a variable closer to its use\n Rule 4\nA local variable hides the name of an instance variable and a class variable with the same name Lets discuss \nthis rule in detail Every variable irrespective of its type has a scope Sometimes the scope of a variable \nis also known as its visibility The scope of a variable is the part of the program where the variable can be \nreferred to with its simple name The scope of a local variable declared in a method is the part of the method \nbody that follows the variable declaration The scope of a local variable declared in a block is the rest of the Chapter 8  Methods\n264block that follows the variable declaration The scope of the formal parameters of a method is the entire \nbody of the method It means that the name of the formal parameters of a method can be used throughout \nthe body of that method for example\nint sumint n1 int n2 \n     n1 and n2 can be used here\n\nThe scope of instance variables and class variables is the entire body of the class For example the \ninstance variable n1 and the class variable n2 can be referred to with their simple names anywhere in the \nclass NameHidingTest1  as shown\nclass NameHidingTest1 \n    int n1  10           An instance variable\n    static int n2  20    A class variable\n                          m1 is a method\n    void m1 \n                          n1 and n2 can be used here\n    \n    int n3  n1          n1 can be used here\n\nWhat happens when two variables with the same name say one instance variable and one local \nvariable are in scope in the same part of a program Consider the following code for the NameHidingTest2  \nclass\nclass NameHidingTest2 \n         Declare an instance variable named n1\n    int n1  10\n         m1 is a method\n    void m1 \n         Declare a local variable named n1\n        int n1  20\n         Both instance variable n1 and local variable n1 are in scope here \n         What value will be assigned to n2 10 or 20\n        int n2  n1\n    \n     Only instance variable n1 is in scope here \n         n3 will be assigned 10 from the instance variable n1\n    int n3  n1\n\nWhen the m1  method is executed in the previous code what value will be assigned to the variable n2 \nNote the class declares an instance variable with the name n1 and the method m1  also declares a local \nvariable with the same name n1 The scope of the instance variable n1 is the entire class body that includes \nthe body of the m1  method The scope of the local variable n1 is the entire body of the m1  method When \nthis statement\nint n2  n1Chapter 8  Methods\n265is executed inside the m1  method two variables with the same name n1 are in scope one has a value of 10 \nand another has a value of 20 Which n1 does the previous statement refer to n1 the instance variable or n1 \nthe local variable When a local variable has the same name as the name of a class field an instanceclass \nvariable the local variable name hides the name of the class field This is known as name hiding  In this case \nthe local variable name n1 hides the name of the instance variable n1 inside the m1  method The previous \nstatement will refer to the local variable n1 not the instance variable n1 Therefore n2 will be assigned a \nvalue of 20\n Ti p a  local variable with the same name as a class field hides the name of the class field In other words \nwhen a local variable and a class field with the same name are in scope the local variable takes precedence\nThe following code for the class NameHidingTest3  clarifies the scenario when a local variable comes \ninto scope\npublic class NameHidingTest3 \n     Declare an instance variable named n1\n    int n1  10\n    public void m1 \n         Only the instance variable n1 is in scope here \n         Assigns 10 to n2\n        int n2  n1\n         Only the instance variable n1 is in scope here The local variable n2\n           is also in scope here which you are ignoring for our discussion for now\n        \n         Declare a local variable named n1\n        int n1  20\n         Both instance variable n1 and local variable n1 are in scope here\n           We are ignoring n2 for now\n        \n         Assigns 20 to n3\n        int n3  n1\n    \n\nThe previous code assigns the value of the n1 variable to n2 inside the m1  method You had not \ndeclared the local variable n1 at the time you assigned the value of n1 to n2 At this time only the instance \nvariable n1 is in scope When you assign n1 to n3 at that time both instance variable n1 and local variable n1 \nare in scope The values assigned to n2 and n3 depend on the name hiding rule When two variables with the \nsame name are in scope the local variable is used\nDoes it mean that you cannot declare an instanceclass variable and a local variable with the same \nname and use both at the same time The answer is no You can declare an instanceclass variable and a \nlocal variable with the same name The only thing you need to know is how to refer to the instanceclass \nvariable if its name is hidden by a local variable You learn about referring to the hidden instanceclass \nvariables in the next sectionChapter 8  Methods\n266 Instance Methods and\u00a0Class Methods\nIn Chapter 7 you learned two types of class fields instance variables and class variables A class can have \ntwo types of methods instance methods and class methods Instance methods and class methods are also \ncalled nonstatic methods and static methods respectively\nAn instance method is used to implement behavior of the instances also called objects of the class An \ninstance method can only be invoked in the context of an instance of the class\nA class method is used to implement the behavior of the class itself A class method always executes in \nthe context of a class\nThe static  modifier is used to define a class method The absence of the static  modifier in a method \ndeclaration makes the method an instance method The following are examples of declaring static and non\nstatic methods\n A static or class method\nstatic void aClassMethod \n     Methods body goes here\n\n A nonstatic or instance method\nvoid anInstanceMethod \n     Methods body goes here\n\nRecall that a separate copy of an instance variable exists for each instance of a class whereas only one \ncopy of a class variable exists irrespective of the existence of the number of instances possibly zero of the \nclass\nWhen a static method of a class is called an instance of that class may not exist Therefore it is not \nallowed to refer to instance variables from inside a static method Class variables exist as soon as the class \ndefinition is loaded into memory The class definition is always loaded into memory before the first instance \nof a class is created Note that it is not necessary to create an instance of a class to load its definition into \nmemory The JVM guarantees that all class variables of a class exist before any instances of the class exist \nTherefore you can always refer to a class variable from inside an instance method\n Tip a c lass method or static method can refer to only class variables or static variables of the class an \ninstance method nonsta tic method can refer to class variables as well as instance variables of the class\nListing 81 demonstrates the types of class fields that are accessible inside instance and class methods\nListing 81  Acces sing Class Fields from Static and Nonstatic Methods\n MethodTypejava\npackage comjdojocls\npublic class MethodType \n    static int m  100  A static variable\n    int n  200          An instance variable\n     Declare a static method\n    static void printM \n         You can refer to only static variable m in this method\n           because you are inside a static method\n        Chapter 8  Methods\n267        SystemoutprintlnprintM   m    m\n         Uncommenting the following statement results in a compiletime error\n        SystemoutprintlnprintM   n    n\n    \n     Declare an instance method\n    void printMN \n         You can refer to both static and instance variables m and n in this method\n        SystemoutprintlnprintMN   m    m\n        SystemoutprintlnprintMN   n    n\n    \n\nThe MethodType  class declares m as a static variable and n as a nonstatic variable It declares printM  \nas a static method and printMN  as an instance method Inside the printM  method you can refer to only \nstatic variable m because a static method can refer to only static variables If you uncomment the commented \nstatement inside the printM  method the code will not compile because a static method will attempt to \naccess a nonstatic variable n The printMN  method is a nonstatic method and it can access both static \nvariable m and nonstatic variable n Now you would like to invoke the printM  and printMN  methods of \nthe MethodType  class The next section explains how to invoke a method\n Invoking a\u00a0Method\nExecuting the code in the body of a method is called invoking or calling a method Instance methods and \nclass methods are invoked differently An instance method is invoked on an instance of the class using dot \nnotation The syntax to invoke an instance method is as follows\ninstancereferenceinstancemethodnameactualparameters\nNote that you must have a reference to an instance of a class before calling an instance method of that \nclass For example you can write the following snippet of code to invoke the printMN  instance method of \nthe MethodType  class listed in Listing 81\n Create an instance of MethodType class and store its reference in mt reference variable\nMethodType mt  new MethodType\n Invoke the printMN instance method using the mt reference variable\nmtprintMN\n Tip You might see a method reference in Java using classorinstancenamemethodname this is \na method reference  not a method call however this is outside the scope of this chapter\nTo invoke a class method you use the dot notation with the class name and method name The \nfollowing snippet of code invokes the printM  class method of the MethodType  class for example\n Invoke the printM class method\nMethodTypeprintM\nMethodType mt  new MethodType\nmtprintM  Call the class method using an instance mtChapter 8  Methods\n268Which is a better way to invoke a class method using the class name or using an instance reference \nBoth ways do the same job However using the class name to invoke a class method is more intuitive \nthan using an instance reference This book uses a class name to invoke a class method except for the \npurpose of demonstrating that you can also use an instance reference to invoke a class method Listing 82 \ndemonstrates how to invoke an instance method and a class method of a class Note that the output shows \nthe same result when you invoke the class method printM  using the class name or an instance reference\nListing 82  Exam ples of Invoking Instance Methods and Class Methods of a Class\n MethodTypeTestjava\npackage comjdojocls\npublic class MethodTypeTest \n    public static void mainString args \n         Create an instance of the MethodType class\n        MethodType mt  new MethodType\n         Invoke the instance method\n        SystemoutprintlnInvoking instance method\n        mtprintMN\n         Invoke the class method using the class name\n        SystemoutprintlnInvoking class method using class name\n        MethodTypeprintM\n         Invoke the class method using the instance reference\n        SystemoutprintlnInvoking class method using an instance\n        mtprintM\n    \n\nInvoking instance method\nprintMN   m  100\nprintMN   n  200\nInvoking class method using class name\nprintM   m  100\nInvoking class method using an instance\nprintM   m  100\n The Special main Method\nNow that you learned about declaring a method in a class in the previous section lets discuss the main  \nmethod that you have been using to run your classes The main  method declaration is as follows\npublic static void mainString args \n     Method body goes here\n\nTwo modifiers public  and static  are used in the declaration of the main  method The public  \nmodifier makes it accessible from anywhere in the application as long as the class in which it is declared \nis accessible The static  modifier makes it a class method so it can be invoked using a class name Its \nreturn type is void  which means it does not return a value to its caller Its name is main  and it accepts one \nparameter of type String  array String  Note that you have been using args  as the name of its parameter Chapter 8  Methods\n269However you can use any parameter name you wish For example you can declare the main  method as \npublic static void mainString myParameters  which is the same as declaring the main  method as \nshown previously Whatever parameter name you choose you will need to use the same name in the body of \nthe method if you need to refer to the parameter passed to this method\nWhat is special about the declaration of a main  method in a class You run a Java application by \npassing a class name to the java  command For example you would use the following command to run the \nMethodTypeTest  class\njava otheroptions module jdojoclscomjdojoclsMethodTypeTest\nWhen the previous command is executed the JVM the java  command essentially starts a JVM finds \nand loads the MethodTypeTest  class definition in memory Then it looks for a method declaration which \nis declared as public  and static  returns void  and has a method argument as String  array If it finds the \nmain  method declaration the JVM invokes the method If it does not find the main  method it does not \nknow where to start the application and it throws an error stating that no main  method was found\nWhy do you need to declare the main  method as static The main  method serves as the entry point \nfor a Java application It is invoked by the JVM when you run a class The JVM does not know how to create \nan instance of a class It needs a standard way to start Java applications Specifying all details about the \nmain  method and making it static provides the JVM a standard way to start a Java application By making \nthe main  method static the JVM can invoke it using the class name which is passed on the command line\nWhat will happen if you do not declare the main  method as static If you do not declare the main  \nmethod as static it will be treated as an instance method The code will compile fine However you will not \nbe able to run the class which has its main  method declared as an instance method\nCan you have more than one main  method in a class The answer is yes You can have multiple \nmethods in a class which can be named main  as long as they do not have the same signature The following \ndeclaration for the MultipleMainMethod  class which declares three main  methods is valid The first \nmain  method which is declared as public static void mainString args  may be used as the entry \npoint to run an application The other two main  methods have no special significance as far as the JVM is \nconcerned\n MultipleMainMethodjava\npackage comjdojocls\npublic class MultipleMainMethods \n    public static void mainString args \n         May be used as the application entry point \n    \n    public static void mainString args int a \n         Another main method \n    \n    public int main \n         Another main method \n        return 0\n    \n\nIs it required for each class in Java to have a main  method The answer is no It is required that you \ndeclare a public static void mainString args  method in a class if you want to run that class If you \nhave a Java application you will need to have a main  method in at least one class so you can start your \napplication by running that class All other classes that are used in the application but are not used to start \nthe application do not need to have a main  methodChapter 8  Methods\n270Can you invoke the main  method in your code Or can it be invoked only by the JVM The main  \nmethod is invoked by the JVM when you run a class Apart from that you can treat the main  method as \nany other class method Programmers have a general and wrong impression that the main  method can \nonly be invoked by a JVM\u00a0However that is not true It is true that the main  method is generally but not \nnecessarily invoked by a JVM to start a Java application However it does not have to be invoked at least \ntheoretically only by a JVM\u00a0Here is an example that shows how the main  method can be invoked like any \nother class method Listing 83 has the definition of a MainTest1  class which declares a main  method \nListing 84 has the definition of a MainTest2  class which declares a main  method\nListing 83  A MainT est1 Class Which Declares a main Method\n MainTest1java\npackage comjdojocls\npublic class MainTest1 \n    public static void mainString args \n        SystemoutprintlnInside the MainTest1main method\n    \n\nListing 84  A MainT est2 Class Which Declares a main Method Which in Turn Calls the main Method of \nthe MainTest1 Class\n MainTest2java\npackage comjdojocls\npublic class MainTest2 \n    public static void mainString args \n        SystemoutprintlnInside the MainTest2main method\n        MainTest1mainargs\n    \n\nInside the MainTest2main method\nInside the MainTest1main method\nThe main  method of the MainTest2  class prints a message and invokes the main  method of the \nMainTest1  class using the following code\nMainTest1mainargs\nNote that the main  method of the MainTest1  class accepts a String  array as a parameter and the \nprevious statement passes args  as the actual value for that parameter\nThe JVM will invoke the main  method of the MainTest2  class which in turn invokes the main  \nmethod of the MainTest1  class The output in Listing 84 confirms this You can also let the JVM invoke the \nmain  method of the MainTest1  class by running the MainTest1  class which will produce the following \noutput\nInside the MainTest1main methodChapter 8  Methods\n271 Tip the main  method in a class which is declared as public static void mainString \nargs  has a special meaning only when the class is run by the JVM it serves as an entry point for the Java \napplication otherwise  the main  method is treated the same as any other class methods\n What Is this\nJava has a keyword called this  It is a reference to the current instance of a class It can be used only in the \ncontext of an instance It can never be used in the context of a class because it means the current instance \nand no instance exists in the context of a class The keyword this  is used in many contexts We will cover \nmost of its uses in this chapter and in Chapter 9 Consider the following snippet of code that declares a class \nThisTest1 \npublic class ThisTest1 \n    int varA  555\n    int varB  varA        Assign value of varA to varB\n    int varC  thisvarA  Assign value of varA to varC\n\nThe ThisTest1  class declares three instance variables varA  varB  and varC  The instance variable \nvarA  is initialized to 555 The instance variable varB  is initialized to the value of varA  which is 555 The \ninstance variable varC  is initialized to the value of varA  which is 555 Note the difference in the initialization \nexpressions for varB  and varC  We used unqualified varA  when we initialized varB  We used thisvarA  \nwhen we initialized varC  However the effect is the same Both varB  and varC  are initialized with the value \nof varA  When we use thisvarA  it means the value of varA  for the current instance which is 555 In this \nsimple example it was not necessary to use the keyword this  In the previous case the unqualified varA  \nrefers to the varA  for the current instance However there are some cases where you must use the keyword \nthis  We will discuss such cases shortly\nSince the use of the keyword this  is illegal in the context of a class you cannot use it when you initialize \na class variable like so\n Would not compile\npublic class ThisTest2 \n    static int varU  555\n    static int varV  varU\n    static int varW  thisvarU  A compiletime error\n\nWhen you compile the code for the class ThisTest2  you receive the following error\nThisTest2java nonstatic variable this cannot be referenced from a static context at \nline 4 column 21Chapter 8  Methods\n272The error is loud and clear that you cannot use the keyword this  in a static context Note that static and \nnonstatic words are synonymous with class and instance terms in Java Static context is the same as \nclass context and nonstatic context is the same as instance context The previous code can be corrected by \nremoving the qualifier this  from the initialization expression for varW  as follows\npublic class CorrectThisTest2 \n    static int varU  555\n    static int varV  varU\n    static int varW  varU  Now it is fine\n\nYou can also qualify a class variable with a class name as shown in the CorrectThisTest3  class\npublic class CorrectThisTest3 \n    static int varU  555\n    static int varV  varU\n    static int varW  CorrectThisTest3varU\n\n Ti p Most of the time  you can use the simple name of instance and class variables within the class in \nwhich they are declared You need to qualify an instance variable with the keyword this  and a class variable \nwith the class name only when the instance variable or the class variable is hidden by another variable with the \nsame name\nConsider the following snippet of code for the ThisTest3  class\npublic class ThisTest3 \n    int varU  555\n    static int varV  varU  A compiletime error\n    static int varW  varU  A compiletime error\n\nWhen you compile the ThisTest3  class you receive the following error\nThisTest3java nonstatic variable varU cannot be referenced from a static context at \nline 3 column 21\nThisTest3java nonstatic variable varU cannot be referenced from a static context at \nline 4 column 21\nThe error is the same in kind although differently phrased compared to the error that you received \nfor the ThisTest2  class Last time the compiler complained about using the keyword this  This time it \ncomplained about using the instance variable varU  Both the keyword this  and the varU  exist in the context \nof an instance They do not exist in the context of a class Whatever exists in the context of an instance \ncannot be used in the context of a class However whatever exists in the context of a class can always be used \nin the context of an instance The instance variable declaration and initialization occurs in the context of an \ninstance In the ThisTest3  class varU  is an instance variable and it exists only in the context of an instance \nThe varV  and varW  in ThisTest3  class are class variables and they exist only in the context of a class This is \nthe reason that the compiler generated an errorChapter 8  Methods\n273Consider the code for the ThisTest4  class shown in Listing 85 It declares an instance variable num \nand an instance method printNum  In the printNum  instance method it prints the value of the instance \nvariable num In its main  method it creates an instance of the ThisTest4  class and invokes the printNum  \nmethod on it The output of the ThisTest4  class shows the expected result\nListing 85  An Exam ple of Using the Simple Name of an Instance Variable in an Instance Method\n ThisTest4java\npackage comjdojocls\npublic class ThisTest4 \n    int num  1982  An instance variable\n    public static void mainString args \n        ThisTest4 tt4  new ThisTest4\n        tt4printNum\n    \n    void printNum \n        SystemoutprintlnInstance variable num   num\n    \n\nInstance variable num 1982\nNow modify the printNum  method of the ThisTest4  class so it accepts an int parameter and name the \nparameter num Listing 86 has the modified code for the printNum  method as part of the ThisTest5  class\nListing 86  Variable Name Hiding\n ThisTest5java\npackage comjdojocls\npublic class ThisTest5 \n    int num  1982  An instance variable\n    public static void mainString args \n        ThisTest5 tt5  new ThisTest5\n        tt5printNum1969\n    \n    void printNumint num \n        SystemoutprintlnParameter num   num\n        SystemoutprintlnInstance variable num   num\n    \n\nParameter num 1969\nInstance variable num 1969\nThe output of the ThisTest5  class indicates that the printNum  method is using its parameter num \nwhen you use the simple name num inside its body This is an example of name hiding where the local \nvariable method parameter is considered a local variable num hides the name of the instance variable \nnum inside the printNum  methods body In the printNum  method the simple name num refers to its \nparameter num not the instance variable num In this case you must use the keyword this  to qualify the num \nvariable if you want to refer to the num instance variable inside the printNum  methodChapter 8  Methods\n274Using thisnum  is the only way you can refer to the instance variable from inside the printNum  \nmethod as long as you keep the methods parameter name as num Another way is to rename the parameter \nto something other than num for example numParam  or newNum  Listing 87 shows how to use the keyword \nthis  to refer to the num instance variable inside the printNum  method\nListing 87  Using the this Keyword to Refer to an Instance Variable Whose Name Is Hidden by a Local \nVariable\n ThisTest6java\npackage comjdojocls\npublic class ThisTest6 \n    int num  1982  An instance variable\n    public static void mainString args \n        ThisTest6 tt6  new ThisTest6\n        tt6printNum1969\n    \n    void printNumint num \n        SystemoutprintlnParameter num   num\n        SystemoutprintlnInstance variable num   thisnum\n    \n\nParameter num 1969\nInstance variable num 1982\nThe output of ThisTest6  shows the expected result If you do not want to use the keyword this  you can \nrename the parameter of the printNum  method like so\nvoid printNumint numParam \n    SystemoutprintlnParameter num   numParam\n    SystemoutprintlnInstance variable num   num\n\nOnce you rename the parameter to something other than num the num instance variable is no longer \nhidden inside the body of the printNum  method and therefore you can refer to it using its simple name\nYou can use the keyword this  to refer to the instance variable num inside the printNum  method even if \nit is not hidden as shown here However using the keyword this  in the following case is a matter of choice \nnot a requirement\nvoid printNumint numParam \n    SystemoutprintlnParameter num   numParam\n    SystemoutprintlnInstance variable num   thisnum\n\nIn the previous example you saw that use of the keyword this  is necessary to access instance variables \nwhen the instance variable name is hidden You can avoid using the keyword this  in such circumstances \nby renaming the variable that hides the instance variable name or renaming the instance variable itself \nSometimes it is easier to keep the variable names the same as they represent the same thing This book uses \nthe convention of using the same name for instance variables and local variables if they represent the same \nthing in the class For example the following code is very commonChapter 8  Methods\n275public class Student \n    private int id  An instance variable\n    public void setIdint id \n        thisid  id\n    \n    public int getId \n        return thisid\n    \n\nThe Student  class declares an instance variable named id In its setId  method it also names the \nparameter id and uses thisid  to refer to the instance variable It also uses thisid  to refer to the instance \nvariable id in its getId  method Note that there is no name hiding occurring in the getId  method and \nyou could use the simple name id which means the instance variable id\nTable 82 lists the parts of a class the context in which they occur and the permitted use of the keyword \nthis  the instance variable and the class variable Although we have not yet covered all parts of a class that \nare listed in this table we will cover them in this chapter and in Chapter 9\nThe keyword this  is a final  a constant is called final  in Java because Java uses the final  keyword \nto declare a constant reference to the current instance of the class in which it appears Because it is final  \nyou cannot change its value Because this  is a keyword you cannot declare a variable named this  The \nfollowing code will generate a compiletime error\npublic class ThisError \n    void m1 \n         An error Cannot name a variable this\n        int this  10\n         An error Cannot assign a value to this because it is a constant\n        this  null\n    \nTable 82  The C ontext Type and Allowed Use of the Keyword this an Instance Variable and a Class Variable\nPart of a Class Context Can Use This \nKeywordCan Use Instance \nVariableCan Use Class \nVariable\nInstance variable initialization Instance Yes Yes Yes\nClass variable initialization Class No No Yes\nInstance initializer Instance Yes Yes Yes\nClass initializer\nalso called static initializerClass No No Yes\nConstructor Instance Yes Yes Yes\nInstance method\nalso called nonstatic methodInstance Yes Yes Yes\nClass method\nalso called static methodClass No No YesChapter 8  Methods\n276You can also use the keyword this  to qualify an instance method name although it is never required \nThe following snippet of code shows the m1  method invoking the m2  method using the keyword this  \nNote that both methods are instance methods\npublic class ThisTestMethod \n    void m1 \n         Invoke the m2 method\n        thism2  same as m2\n    \n    void m2 \n         do something\n    \n\n Access Levels for\u00a0Class Members\nIn Chapter 7 we covered access levels for a noninner class which can be public or default package \nlevel This section discusses access levels for class members fields and methods The access level for a class \nmember determines what area of the program can access use or refer to it One of the following four access \nlevel modifiers can be used for a class member\n\tpublic\n\tprivate\n\tprotected\n\t Default or packagelevel access\nThree out of the four types of access levels for a class member are specified using one of the three \nkeywords public  private  or protected  The fourth type is called the default access level or packagelevel \naccess and it is specified by using no access modifiers That is the absence of any of the three access level \nmodifiers public  private  or protected  specifies packagelevel access\nIf a class member is declared as public using the public  keyword it can be accessed from anywhere \nprovided the class itself is accessible\nIf a class member is declared as private using the private  keyword it can be accessed only within the \nbody of the declaring class and nowhere else\nIf a class member is declared as protected using the protected  keyword it can be accessed from the \nsame package or from descendants of the class even if the descendants are in a different package We \ndiscuss the protected access level in detail in Chapter 20\nIf you do not use any access level modifier for a class member it has packagelevel access A class \nmember with a packagelevel access can be accessed from the same package\nA class member belongs to the class defining the member A class member is accessible based on these \nrules only if the class itself is accessible If the class is inaccessible its members are inaccessible irrespective \nof the access level of the members Let us take an analogy A kitchen belongs to a house You can access the \nkitchen only if you can access the house If the front door of the house is locked the house is inaccessible \nthe kitchen is inaccessible even if the kitchen is labeled as public Think of a class member as a kitchen in Chapter 8  Methods\n277a house and the class as the house itself In Java 8 a public class was always accessible to all parts of the \nprogram which changed in Java 9 with the introduction of the module system A public class may not be \nreally public to everyone A public class defined in a module may fall into one of the three categories\n\t Public only within the defining module\n\t Public only to specific modules\n\t Public to everyone\nIf a class is defined public in a module but the module does not export the package that contains \nthe class the class is public only within the module No other modules can access the class In this case \nthe public members of a public class are accessible anywhere in the module that contains the class and \nnowhere else\nIf a class is defined public in a module but the module uses a qualified export  to export the package \nthat contains the class the class will be accessible only to the modules specified in the qualified export In \nthis case the public members of a public class are accessible to the module that contains the class and the \nspecified modules to which the package of the class is exported\nIf a class is defined public in a module but the module exports the package of the class using an \nunqualified export the class will be accessible to all modules that read the module defining the class In this \ncase the public members of a public class are accessible to all modules\nAccess levels for a class member can be listed from the most restrictive to the least restrictive as \nprivate  package level protected  and public  Table\u00a0 83 summarizes the four access levels for a class \nmember assuming that the class itself is accessible\nIn this chapter we restrict the discussion to accessing class members in the same module We discuss \nthe intermodule accessibility in Chapter 10 The following is a sample class that declares many class \nmembers with different access levels\n AccessLevelSamplejava\npackage comjdojocls\n Class AccessLevelSample has public access level\npublic class AccessLevelSample \n    private int num1              private access level\n    int num2                      packagelevel access\n    protected int num3           protected access level\n    public int num4               public access level\n    public static int count  1  public access level\n                                  The m1 method has private access level\n    private void m1 \n                                  Code goes here\n    Table 83  List of Access Levels for Class Members\nAccess Level for Class Member Accessibility\nprivate Only within the same class\npackagelevel In the same package\nprotected Same package or descendant in any package\npublic EverywhereChapter 8  Methods\n278     The m2 method has packagelevel access\n    void m2 \n         Code goes here\n    \n     The m3 method has protected access level\n    protected void m3 \n         Code goes here\n    \n     The m4 method has public access level\n    public void m4 \n         Code goes here\n    \n     The doSomething method has private access level\n    private static void doSomething \n         Code goes here\n    \n\nNote that access levels can be specified for both instance and static members of a class It is a \nconvention to specify the access level modifier as the first modifier in the declaration If you declare a static \nfield for a class that is public you should use the public  modifier first and then the static  modifier as a \nconvention For example both of the following declarations for an instance variable num are valid\n Declaration 1\npublic static int num  Conventionally used\n Declaration 2\nstatic public int num  Technically correct but conventionally not used\nLets discuss a few examples of using access level modifiers for class members and their effects \nConsider the code for the AccessLevel  class shown in Listing 88\nListing 88  An Acces sLevel Class with Class Members Having Different Access Levels\n AccessLeveljava\npackage comjdojocls\npublic class AccessLevel \n    private int v1  100\n    int v2  200\n    protected int v3  300\n    public int v4  400\n    private void m1 \n        SystemoutprintlnInside m1\n        Systemoutprintlnv1    v1   v2    v2\n                  v3    v3   v4    v4\n    \n    void m2 \n        SystemoutprintlnInside m2\n        Systemoutprintlnv1    v1   v2    v2\n                  v3    v3   v4    v4\n    Chapter 8  Methods\n279    protected void m3 \n        SystemoutprintlnInside m3\n        Systemoutprintlnv1    v1   v2    v2\n                  v3    v3   v4    v4\n    \n    public void m4 \n        SystemoutprintlnInside m4\n        Systemoutprintlnv1    v1   v2    v2\n                  v3    v3   v4    v4\n    \n\nThe class has four instance variables called v1 v2 v3 and v4 and four instance methods called \nm1  m2  m3  and m4  Four different access level modifiers have been used for instance variables \nand instance methods Weve chosen to use instance variables and methods in this example the same \naccess level rules apply to class variables and class methods The code for the AccessLevel  class compiles \nwithout any errors Note that no matter what the access level for a class member is it is always accessible \ninside the class in which it is declared This can be verified by the fact that you have accessed read their \nvalues all instance variables which have different access levels inside all four methods Consider the \nAccessLevelTest1  class shown in Listing 89\nListing 89  A Tes t Class Located in the Same Package as the AccessLevel Class\n AccessLevelTest1java\npackage comjdojocls\npublic class AccessLevelTest1 \n    public static void mainString args \n        AccessLevel al  new AccessLevel\n         int a  alv1  A compiletime error \n        int b  alv2\n        int c  alv3\n        int d  alv4\n        Systemoutprintlnb    b   c    c   d    d\n        alm1  A compiletime error \n        alm2\n        alm3\n        alm4\n         Modify the values of instance variables\n        alv2  20\n        alv3  30\n        alv4  40\n        SystemoutprintlnnAfter modifying v2 v3 and v4\n        alm2\n        alm3\n        alm4\n    \nChapter 8  Methods\n280b  200 c  300 d  400\nInside m2\nv1  100 v2  200 v3  300 v4  400\nInside m3\nv1  100 v2  200 v3  300 v4  400\nInside m4\nv1  100 v2  200 v3  300 v4  400\nAfter modifying v2 v3 and v4\nInside m2\nv1  100 v2  20 v3  30 v4  40\nInside m3\nv1  100 v2  20 v3  30 v4  40\nInside m4\nv1  100 v2  20 v3  30 v4  40\nThe AccessLevel  and AccessLevelTest1  classes are in the same package The AccessLevelTest1  class \ncan access all class members of the AccessLevel  class except the ones declared private  You cannot access \nthe instance variable v1 and the instance method m1  of the AccessLevel  class from the AccessLevelTest1  \nclass because their access level is private  If you uncomment the two statements in the AccessLevelTest1  \nclass which attempts to access the private  instance variable v1 and the private  instance method m1  of \nthe AccessLevel  class you will receive the following compiletime errors\nAccessLevelTest1java8 error v1 has private access in AccessLevel\n        int a  alv1  A compiletime error \n                  \nAccessLevelTest1java15 error m1 has private access in AccessLevel\n        alm1  A compiletime error \n          \n2 errors\nThe AccessLevelTest1  class reads the values of the instance variables of the AccessLevel  class as well \nas modifies them You must note one thing even though you cannot access the private  instance variable v1 \nand the private  method m1  of the AccessLevel  class from the AccessLevelTest1  class you can print the \nvalue of the private  instance variable v1 as shown in the output\nAn access level modifier for a class member specifies who can access it directly If a class member is \nnot accessible directly it might be accessible indirectly In this example the instance variable v1 and the \ninstance method m1  are not directly accessible from outside the AccessLevel  class however they may \nbe indirectly accessible from outside Indirect access to an inaccessible class member is usually given by \nproviding another method which is accessible from outside\nSuppose you want the outside world to read and modify the value of the otherwise inaccessible private  \ninstance variable v1 You need to add two public  methods getV1  and setV1  to the AccessLevel  class \nthese two methods will read and modify the value of the v1 instance variable Your modified AccessLevel  \nclass would look as follows\npublic class AccessLevel \n    private int v1\n     Other code goes here \n    public int getV1 \n        return thisv1\n    Chapter 8  Methods\n281    public void setV1int v1 \n        thisv1  v1\n    \n\nNow even if the private instance variable v1 is not directly accessible from outside it is made indirectly \naccessible through the public methods getV1  and setV1  We say that v1 is encapsulated  in the \nAccessLevel class Encapsulation  is the concept of wrapping variables in a class so that we limit how those \nvariables are manipulated from outside\nConsider another test class as shown in Listing 810 \nListing 810  A Tes t Class Located in a Different Package from the AccessLevel Class\n AccessLevelTest2java\npackage comjdojoclsp1\nimport comjdojoclsAccessLevel\npublic class AccessLevelTest2 \n    public static void mainString args \n        AccessLevel al  new AccessLevel\n        int a  alv1  A compiletime error \n        int b  alv2  A compiletime error \n        int c  alv3  A compiletime error \n        int d  alv4\n        Systemoutprintlnd    d\n        alm1  A compiletime error \n        alm2  A compiletime error \n        alm3  A compiletime error \n        alm4\n         Modify the values of instance variables \n        alv2  20    A compiletime error \n        alv3  30    A compiletime error \n        alv4  40\n        SystemoutprintlnAfter modifying v4\n        alm2    A compiletime error \n        alm3    A compiletime error \n        alm4\n    \n\nd  400\nInside m4\nv1  100 v2  200 v3  300 v4  400\nAfter modifying v4\nInside m4\nv1  100 v2  200 v3  300 v4  40\nNote the AccessLevelTest2  class in the comjdojoclsp1  package which is different from the \ncomjdojocls  package in which the AccessLevel  class exists The code for the AccessLevelTest2  \nclass is similar to the code for the AccessLevelTest1  class except that most of the statements have been \ncommented Notice the use of an import statement to import the AccessLevel  class from the  Chapter 8  Methods\n282comjdojocls  package so you can use its simple name inside the main  method In the \nAccessLevelTest1  class it was not necessary to import the AccessLevel  class because they are in the \nsame package The AccessLevelTest2  class can access only the public members of the AccessLevel  class \nbecause it is in a different package than the AccessLevel  class This is the reason that the uncommented \nstatements access only the public instance variable v4 and the public  method m4  Note that even if only \nthe v4 instance variable is accessible you are able to print the values of v1 v2 and v3 as well by accessing \nthem indirectly through the public method m4 \nNow consider a trickier situation See Listing 811 \nListing 811  A Cl ass with PackageLevel Access Having a Public Instance Variable\n AccessLevel2java\npackage comjdojocls\nclass AccessLevel2 \n    public static int v1  600\n\nNote that there is no access level modifier used for the AccessLevel2  class which gives it a package\nlevel access by default That is the AccessLevel2  class is accessible only within the comjdojocls  package \nThe AccessLevel2  class is simple It declares only one member which is the public static  variable v1\nConsider the class AccessLevelTest3  shown in Listing 812  which is in a different package than the \nclass AccessLevel2 \nListing 812  A Tes t Class That Attempts to Access a Public Member of a Class with a PackageLevel Access\n AccessLevelTest3java\npackage comjdojoclsp1\nimport comjdojoclsAccessLevel2  A compiletime error\npublic class AccessLevelTest3 \n    public static void mainString args \n        int a  AccessLevel2v1    A compiletime error\n    \n\nThe AccessLevelTest3  class attempts to access the public static variable v1 of the AccessLevel2  class \nwhich generates a compiletime error Here is an exception to the rule that a class member with public \naccess level is accessible from anywherea public class member is accessible from anywhere if and only if \nthe class itself is accessible In the beginning of this section we used an analogy of a house and a kitchen in \nthe house If you missed that analogy lets have another\nSuppose you have some money in your pocket and you declare that your money is public Therefore \nanyone can have your money However you hide yourself so that no one can have access to you How \ncan anyone access your money unless you become accessible to them first This is the case with the \nAccessLevel2  class and its public static variable v1 Compare the AccessLevel2  class with yourself and \nits public static variable v1 with your money The AccessLevel2  class has packagelevel access Therefore \nonly the code within its package  comjdojocls  can access its name Its static variable v1 has the access \nlevel of public which means any code can access it from any package The static variable v1 belongs to \nthe AccessLevel2  class Unless the AccessLevel2  class itself is accessible its static variable v1 cannot be \naccessed even though it has been declared public\nThe import  statement in Listing 812  will also generate a compiletime error for the reason that the \nAccessLevel2  class is not accessible outside its package comjdojocls Chapter 8  Methods\n283 Ti p Y ou must consider the access level of both the class and its member to determine whether a class \nmember is accessible the access level of a class member may make it accessible to a part of a program \nhowever that part of a program can access the class member only if the class itself to which the member \nbelongs is also accessible\n Access Level A\u00a0Case Study\nA class member can have one of the four access levels private  protected  public  or package level Which \naccess level should be used with a class member The answer depends on the member type and its purpose \nLets discuss an example of a bank account Suppose you create a class named Account  to represent a bank \naccount as follows\n Accountjava\npackage comjdojocls\npublic class Account \n    public double balance\n\nA bank account holds the balance in the account This Account  class does just that In the real world \na bank account can hold many more pieces of information for example account number account holder \nname address etc Lets keep the Account  class simple so you can focus on the discussion of access levels \nIt allows every instance to hold a numeric value in its balance  instance variable If you want to create an \ninstance of the Account  class and manipulate its balance it will look like this\n Create an account object\nAccount ac  new Account\n Change the balance to 100000\nacbalance  100000\n Change the balance to 55029\nacbalance  55029\nThis snippet of code can be executed anywhere in a Java application where the Account  class is \naccessible because both the Account  class and its balance  instance variable are public However in the \nreal world no one would let their bank account be manipulated like this For example a bank may require \nyou to have a minimum balance of zero in your account With this implementation nothing stops you from \nexecuting the following statement which reduces the balance in an account to a negative number\n Set a negative balance\nacbalance  44067\nIn objectoriented programming as a rule of thumb the pieces of information that define the state of an \nobject should be declared private All instance variables of a class constitute the state of objects of that class \nTherefore they should be declared private  If code outside a class is needed to have access to a private \ninstance variable the access should be given indirectly by providing a method The method should have \nan appropriate access level which will allow only intended client code to access it As noted earlier this is \nknown as encapsulationChapter 8  Methods\n284Lets declare the balance  instance variable as private The modified code for the Account  class is as follows\n Accountjava\npackage comjdojocls\npublic class Account \n    private double balance\n\nWith the modified Account  class you can create an object of the Account  class anywhere in a Java \napplication if the Account  class is accessible like so\n Create an account object\nAccount ac  new Account\nHowever you cannot access the balance  instance variable of the Account  object unless you write the \ncode inside the Account  class itself The following code is valid only if the code is written inside the Account  \nclass because the private instance variable balance  cannot be accessed from outside the Account  class\n Change the balance\nacbalance  18837\nThe modified version of the Account  class is not acceptable in this form because you can create an \naccount but you cannot read or manipulate its balance The Account  class must provide some interface for \nthe outside world to access and manipulate its balance in a controlled way For example if you have money \nand want to share it with the outside world you do not show the money to everyone and ask them to take it \ndirectly Rather anyone who wants your money needs to ask you send you a message and then you give \nthem your money according to certain situations In other words money is your private possession and you \nlet others access it in a controlled way by making them ask you for that money instead of letting them just \ntake money directly from your pocket Similarly you want others to view the balance of an account credit \nmoney to an account and debit money from an account However all these actions should happen through \nan Account  object rather than manipulating the balance of an Account object directly\nJava lets you send a message to an object by using instance methods An object can receive a message \nfrom the outside world and it can respond differently to the same message depending on its internal state \nFor example when all your money is gone and someone asks you for money you can respond by saying that \nyou do not have any money However you responded to the same message give me money differently by \ngiving the money when you had money\nLets declare three public methods in the Account  class that will serve as an interface to the outside \nworld for those needing to access and manipulate the balance of an account\n\t A getBalance  method will return the balance of an account\n\t A credit  method will deposit a specified amount to an account\n\t A debit  method will withdraw a specified amount from an account\nBoth credit  and debit  methods will return 1 if the transaction is successful and 1 if the \ntransaction failsChapter 8  Methods\n285Listing 813  has the code for the modified Account  class\nListing 813  A Mo dified Version of the Account Class with a Private Instance Variable and Public Methods\n Accountjava\npackage comjdojocls\npublic class Account \n    private double balance\n    public double getBalance \n         Return the balance of this account\n        return thisbalance\n    \n    public int creditdouble amount \n         Make sure credit amount is not negative NaN or infinity\n        if amount  00  DoubleisNaNamount  DoubleisInfiniteamount \n            SystemoutprintlnInvalid credit amount   amount\n            return 1\n        \n         Credit the amount\n        SystemoutprintlnCrediting amount   amount\n        thisbalance  thisbalance  amount\n        return 1\n    \n    public int debitdouble amount \n         Make sure the debit amount is not negative NaN or infinity \n        if amount  00  DoubleisNaNamount  DoubleisInfiniteamount \n             SystemoutprintlnInvalid debit amount   amount\n            return 1\n        \n         Make sure a minimum balance of zero is maintained\n        if thisbalance  amount \n            SystemoutprintlnInsufficient funds Debit attempted   amount\n            return 1\n        \n         Debit the amount\n        SystemoutprintlnDebiting amount   amount\n        thisbalance  thisbalance   amount\n        return 1\n    \n\nThe class contains a private instance variable It contains public methods that let the outside world \naccess and modify the private instance variable The public methods are acting like protective covers for \nthe private instance variable They let the outside world read or modify the private instance variable in a \ncontrolled way For example you cannot credit a negative amount and a minimum of zero balance must be \nmaintained Lets test the Account  class The test code is shown in Listing 814 \nListing 814  A Tes t Class to Test the Account Class Behavior\n AccountTestjava\npackage comjdojocls\npublic class AccountTest Chapter 8  Methods\n286    public static void mainString args \n        Account ac  new Account\n        double balance  acgetBalance\n        SystemoutprintlnBalance    balance\n         Credit and debit some amount\n        accredit23478\n        acdebit10012\n        balance  acgetBalance\n        SystemoutprintlnBalance    balance\n         Attempt to credit and debit invalid amounts\n        accredit23490\n        acdebitDoublePOSITIVEINFINITY\n        balance  acgetBalance\n        SystemoutprintlnBalance    balance\n         Attempt to debit more than the balance\n        acdebit200000\n        balance  acgetBalance\n        SystemoutprintlnBalance    balance\n    \n\nBalance  00\nCrediting amount 23478\nDebiting amount 10012\nBalance  13466\nInvalid credit amount 2349\nInvalid debit amount Infinity\nBalance  13466\nInsufficient funds Debit attempted 20000\nBalance  13466\nThe AccountTest  class creates an object of the Account  class and attempts various operations on it \nusing its public methods The results are shown in the output which indicates that this is an improved \nAccount  class that protects an Account object from being manipulated incorrectly You can also note that \nmaking the instance variables private and allowing access to them through public methods lets you enforce \nyour business rules If you expose the instance variables you cannot enforce any business rules that control \ntheir valid values because anyone can modify them without any restrictions\nOne important point to keep in mind when you design a class is its maintainability Keeping all instance \nvariables private and allowing access to them through public methods makes your code ready for future \nchanges Suppose you started with a zero minimum balance for an account You have deployed the Account  \nclass in the production environment and it is being used in many places in the application Now you want \nto implement a new business rule that states that every account must have a minimum balance of 100 It is \neasy to make this change Just change the code for the debit  method and you are done You do not need \nto make any changes to the client code that is calling the debit  method of the Account  class Note that you \nneed a little more work on the Account  class to fully enforce the rule of a minimum balance of 100 When an \naccount is created the balance is zero by default To enforce this new minimum balance rule at the time an \naccount is created you will need to know about constructors of a class This book covers constructors in the \nnext chapterChapter 8  Methods\n287Another option for the access level for the balance  instance variable in the Account  class is to give it \na packagelevel access Recall that a packagelevel access is given to a class member by using no access \nmodifier in its declaration If the balance  instance variable has packagelevel access it is a little better \nthan giving it public  access because it is not accessible from everywhere However it can be accessed and \nmanipulated directly by the code inside the same package in which the Account  class has been declared By \nnow you understand that letting any code access the balance  instance variable directly from outside the \nAccount  class is not acceptable Additionally if you declare the method of the Account  class to have package\nlevel access it can be used only inside the same package in which the Account  class has been declared You \nwant objects of the Account  class to be manipulated from anywhere in the application using its methods \nTherefore you cannot declare the methods or the instance variable of the Account  class to have package\nlevel access When do you declare a class andor a class member to have packagelevel access Typically \npackagelevel access is used for a class and its members when the class has to serve as a helper class or \ninternal implementation for other classes in a package\nWhen do you use a private access level for class members You have already seen the benefits of using \nthe private  instance variables for the Account  class The private access level for instance variables provides \ndata hiding where the internal state of the object is protected from outside access An instance method for \na class defines a behavior for its objects If a method is used only internally within a class and no outside \ncode has any business knowing about it the method should have a private access level Lets go back to your \nAccount  class You have used the same logic to validate the amount passed to the credit  and debit  \nmethods You can move the code that validates the amount to a private method isValidAmount  which \nis used internally by the Account  class It checks if an amount being used for credit or debit is not a negative \nnumber not a NaN and not infinity These three criteria for a number to be a valid number apply only to \nthe Account  class and no other class needs to be using them This is why you need to declare this method \nprivate Declaring it private has another advantage In the future you may make a rule that you must credit \nor debit a minimum of 10 from any account At that time you could just change the private isValidAmount  \nmethod and you are done If you had made this method public it would affect all the client code which was \nusing it to validate an amount You may not want to change the criteria for a valid amount globally To keep \nthe effect of a change localized in a class when the business rules change you must implement a method as \nprivate You can implement this logic in your Account  class as follows only changed code is shown\n Accountjava\npackage comjdojocls\npublic class Account \n     Other code goes here \n    public int creditdouble amount \n         Make sure credit amount is valid\n        if thisisValidAmountamount credit \n          return 1\n        \n         Other code goes here \n    \n    public int debitdouble amount \n         Make sure debit amount is valid\n        if thisisValidAmountamount debit \n          return 1\n        \n         Other code goes here \n    \n     Use a private method to validate creditdebit amount\n    private boolean isValidAmountdouble amount String operation \n         Make sure amount is not negative NaN or infinityChapter 8  Methods\n288        if amount  00  DoubleisNaNamount  DoubleisInfiniteamount \n          SystemoutprintlnInvalid   operation   amount   amount\n          return false\n        \n        return true\n    \n\nNote that you might have implemented the credit  method the debit  method as well in a simpler \nway using the following logic\nif amount  0   \n    thisbalance  thisbalance  amount\n    return 1\n else \n     Print error here \n    return 1\n\nYou could use the simpler logic to implement the credit  method which checks if the amount \nis valid instead of checking if the amount is invalid We did not use this logic because we wanted to \ndemonstrate in the same example how to use a private method Sometimes one writes more code to drive \nhome a point in a discussion\nNow you are left with the protected access level modifier When do you declare a class member \nprotected A class member with the protected access level can be accessed in the same package and in \nthe descendant class even if the descendant class is not in the same package We discuss how to create a \ndescendant class and the use of the protected access level in Chapter 20\n What Is a\u00a0VarArgs Method\nThe term varargs is shorthand for variablelength arguments  It lets you declare a method or constructor \nthat accepts a variable number of arguments or parameters We use only the term method in this \ndiscussion However the discussion also applies to constructors\nThe number of arguments a method accepts is called its arity  A method that accepts variablelength \narguments is called a variablearity method or varargs method What does a varargs method look like Lets \ndiscuss how a nonvarargs method works before you look at a varargs method\nConsider the following code for a MathUtil  class that declares a max  method The method has two \nparameters It computes and returns the maximum of its two arguments\npublic class MathUtil \n    public static int maxint x int y \n        int max  x\n        if y  max \n            max  y\n        \n        return max\n    \nChapter 8  Methods\n289There is nothing extraordinary going on in the MathUtil  class or its max  method Suppose you want to \ncompute the maximum of two integers say 12 and 18 You would invoke the max  method as follows\nint max  MathUtilmax12 18\nWhen this statement is executed 18 will be assigned to the variable max Suppose you want to compute \nthe maximum of three integers You might come up with the following logic\nint max  MathUtilmaxMathUtilmax70 9 30\nThis logic works fine It computes the maximum of two integers and then computes the maximum of \nthe result of the two and the third integer Suppose you want to compute the maximum of ten integers You \nmight repeat this logic and that will work although the code may not be readable You need a better way of \ndoing this\nNow try overloading the max  method so it accepts three integer arguments Here is the newer version \nof the MathUtil  class called MathUtil2 \npublic class MathUtil2 \n    public static int maxint x int y \n        int max  x\n        if y  max \n            max  y\n        \n        return max\n    \n    public static int maxint x int y int z \n        int max  x\n        if y  max \n            max  y\n        \n        if z  max \n            max  z\n        \n        return max\n    \n\nYou can compute the maximum of two and three integers as follows\nint max1  MathUtil2max12 18\nint max2  MathUtil2max10 8 18\nAdding a max  method with three int arguments did solve the problem temporarily The real problem \nstill remains You will have to add a max  method with all possible number of integer arguments You \nwould agree that no programmer wants to write a max  method where they will have to keep adding newer \nversionsChapter 8  Methods\n290Before the introduction of varargs methods in Java when the number of arguments of a method was \nnot known at design time you would declare the method argument as an array of int as shown here We \ndiscuss arrays in detail in a later chapter\npublic class MathUtil3 \n    public static int maxint num \n         Must check for zero element in num here \n        int max  IntegerMINVALUE\n        forint i  0 i  numlength i \n            if numi  max \n                max  numi\n            \n        \n        return max\n    \n\nYou can write the following snippet of code that will compute the maximum of two and three integers \nusing the MathUtil3max  method\nint num1  new int 10 1\nint max1  MathUtil3maxnum1\nint num2  new int 10 8 18 \nint max2  MathUtil3maxnum2\nYou can pass an arbitrary number of integers to the MathUtil3max  method In a sense you have \na way to pass an arbitrary number of arguments to a method What bothers programmers is the way the \nmethod needs to be called when its argument type is an array You must create an array object and package \nthe values of all its elements when you need to call the method with an array argument The issue here is not \nthe code inside the maxint num  method rather it is the client code that calls this method\nVarargs comes to the rescue Lets declare a max  method which can accept any number of integer \narguments including zero arguments The beauty of a varargs method is in the simpler client code that calls \nthe method So how do you declare a varargs method All you need to do is to add an ellipsis or triple dot \nlike   after the data type of the methods argument The following snippet of code shows a max  method \ndeclaration with one variablelength argument num which is of the int data type Note the placement of the \nellipsis after the data type int\npublic static int maxint num \n     Code goes here\n\nAdding whitespace before and after the ellipsis is optional All of the following varargs method \ndeclarations are valid They use different types of whitespace before and after the ellipsis\npublic static int maxint  num     A space after\npublic static int maxint  num    A space before and after\npublic static int maxint  num     No space before and after\npublic static int maxint  num\n                                      A space before and a newline afterChapter 8  Methods\n291A varargs method can have more than one argument The following snippet of code shows that \naMethod  accepts three arguments one of which is a variablelength argument\npublic static int aMethodString str double d1 intnum \n     Code goes here\n\nThere are two restrictions on a varargs method\n\t A varargs method can have a maximum of one variablelength argument The \nfollowing declaration for the m1  method is invalid because it declares two variable\nlength arguments n1 and n2\n An invalid declaration\nvoid m1String str intn1 intn2 \n     Code goes here\n\n\t The variablelength argument of a varargs method must be the last argument in the \nargument list The following declaration for the m2  method is invalid because the \nvariablelength argument n1 is not declared as the last argument\n An invalid declaration\nvoid m2intn1 String str \n     Code goes here\n\nYou can fix the previous declaration by moving the argument n1 to the last like so\n A valid declaration\nvoid m2String str intn1 \n     Code goes here\n\nLets rewrite the max  method to make it a varargs method as shown\npublic class MathUtil4 \n    public static int maxintnum \n        int max  IntegerMINVALUE\n        forint i  0 i  numlength i \n            if numi  max \n                max  numi\n            \n        \n        return max\n    \n\nYou almost always have a loop inside a varargs method that processes the list of arguments for the \nvariablelength argument The length  property gives you the number of values that were passed for the \nvariablelength argument For example numlength  in the max  varargs method will give you the number \nof integers that were passed to the method To get the nth value in the variablelength argument you need Chapter 8  Methods\n292to use varArgsNamen1  For example num0  num1  and numn1  will contain the first second and nth \nvalue passed in for the num variablelength argument If you just want to process all values passed in for a \nvariablelength argument you can use a simpler loop a foreach  loop You can rewrite the code for the max  \nmethod using a foreach  loop as follows\npublic static int max2intnum \n    int max  IntegerMINVALUE\n    forint currentNumber  num \n        if currentNumber  max \n            max  currentNumber\n        \n    \n    return max\n\nThe body of the MathUtil4max  method is the same as if the num argument were declared as an int \narray You are right in thinking so The Java compiler implements a variablelength argument using an array \nThe previous declaration of the MathUtil4max  method is changed by the compiler The declaration part \nmaxintnum  is changed to maxint num  when you compile the code What benefit do you get using \na variablelength argument The benefit of using a variablelength argument in a method comes from the \nelegant way of calling the method You can call the MathUtil4max  method as follows\nint max1  MathUtil4max12 8\nint max2  MathUtil4max10 1 30\nYou can use zero or more arguments for a variablelength argument in a method The following code is \na valid call to the max  method\nint max  MathUtil4max  Passing no argument is ok\nWhat will be returned by calling the MathUtil4max  method with no argument If you look at the \nmethods body it will return IntegerMINVALUE  which is 2147483648  Practically a call to the max  \nmethod without at least two arguments is not a valid call You must check for invalid number of arguments \nwhen a method is a varargs method You do not get a problem of invalid number of arguments for non\nvarargs methods because the compiler will force you to use the exact number of arguments The following \ndeclaration of the max  method will force its caller to pass at least two integers\n Arguments n1 and n2 are mandatory\npublic static int maxint n1 int n2 int num \n     Code goes here\n\nThe compiler will treat the first two arguments n1 and n2 as mandatory and the third argument num \nas optional Now you can pass two or more integers to the max  method Listing 815  shows the final \ncomplete code for the max  methodChapter 8  Methods\n293Listing 815  A Utility Class to Compute the Maximum of Some Specified Integers Using a VarArgs Method\n MathUtil5java\npackage comjdojocls\npublic class MathUtil5 \n    public static int maxint n1 int n2 int num \n         Initialize max to the maximum of n1 and n2\n        int max  n1  n2  n1  n2\n        forint i  0 i  numlength i \n            if numi  max \n                max  numi\n            \n        \n        return max\n    \n    public static void mainString args \n        Systemoutprintlnmax7 9    MathUtil5max7 9\n        Systemoutprintlnmax70 19 30    MathUtil5max70 19 30\n        Systemoutprintlnmax7 1 3    MathUtil5max70 1 3\n    \n\nmax7 9  9\nmax70 19 30  70\nmax7 1 3  3\nYou can pass any number of integers when you call the MathUtil5max  method All of the following \nstatements are valid\nint max1  MathUtil5max12 8          Assigns 12 to max1\nint max2  MathUtil5max10 1 30      Assigns 30 to max2\nint max3  MathUtil5max11 3 7 37  Assigns 37 to max3\nIf you call the MathUtil5max  method with no arguments or one argument the compiler will generate \nan error\nint max1  MathUtil5max     A compiletime error\nint max2  MathUtil5max10  A compiletime error\n Overloading a\u00a0VarArgs Method\nThe same overloading rules for methods also apply to varargs methods You can overload a method with \na variablelength argument as long as the parameters for the methods differ in type order or number For \nexample the following is a valid example of an overloaded max  method\npublic class MathUtil6 \n    public static int maxint x int y \n         Code goes here\n    Chapter 8  Methods\n294    public static int maxintnum \n         Code goes here\n    \n\nConsider the following snippet of code which calls the overloaded method MathUtil6max  with two \narguments\nint max  MathUtil6max12 13  which max will be called\nThe MathUtil6  class has two max  methods One method accepts two int parameters and another \naccepts a variablelength int parameter In this case Java will call the maxint x int y  Java first \nattempts to find a method declaration using an exact match for the number of parameters If it does not find \nan exact match it looks for a match using variablelength parameters\n Ti p If a var args method is overloaded Java uses the more specific version of the method instead of using \na varargs method Java uses the varargs method as the last resort to resolve a method call\nSometimes a call to an overloaded varargs method may cause confusion to the Java compiler The \noverloading of the method itself may be valid However the call to it may cause an issue Consider the \nfollowing snippet of code for the MathUtil7  class which is a valid example of method overloading\npublic class MathUtil7 \n    public static int maxintnum \n         Code goes here\n    \n    public static int maxdoublenum \n         Code goes here\n    \n\nWhich version of the max  method will be called when the following statement is executed\nint max  MathUtil7max  Which max to call\nThe previous statement will generate a compiletime error stating that the call to MathUtil7max  \nis ambiguous Java allows you to pass zero or more values for a variablelength argument In the previous \nstatement both methods maxintnum  and maxdoublenum  qualify for the MathUtil7max  call \nThe compiler cannot decide which one to call You may find many other instances where a call to an \noverloaded varargs method results in an ambiguous method call and the compiler will generate an error \nThe error message will guide you to the offending code\n VarArgs Methods and\u00a0the\u00a0main Method\nRecall that if you want to run a class you need to declare a main  method in it with a String  array as \nits argument The signature for the main  method must be mainString args  A varargs method is \nimplemented by the compiler using an array If your method signature is m1Xxxargs  it is changed Chapter 8  Methods\n295to m1Xxx args  by the compiler Now you can declare the main  method of your class using the older \nnotation that uses a String  array or using a newer notation that uses a varargs The following declaration of \nthe main  method for the Test  class is valid You will be able to run the Test  class using the java  command\npublic class Test \n    public static void mainStringargs   \n        SystemoutprintlnHello from varargs main\n    \n\n ParameterPassing Mechanisms\nThis section discusses different ways of passing parameters to a method that are used in different \nprogramming languages This section is not specific to Java The syntax or symbols used in this section may \nnot be supported by Java This section is important to programmers in understanding the memory states \nin the process of a method call If you are an experienced programmer you may skip this section The next \nsection discusses the parameterpassing mechanisms in Java\nThe following are a few of the commonly used mechanisms to pass parameters to a method\n\t Pass by value\n\t Pass by constant value\n\t Pass by reference\n\t Pass by reference value\n\t Pass by result\n\t Pass by result value\n\t Pass by name\n\t Pass by need\nA variable has three components a name a memory address or a location and data The name of \na variable is a logical name that is used in a program to refer to its memory address Data is stored at the \nmemory address that is associated with the variable name The data stored at the memory address is also \nknown as the value of the variable Suppose you have an int variable named id whose value is 785 which is \nstored at the memory address 131072  You may declare and initialize the id variable as follows\nint id  785\nYou can visualize the relationship between the variable name its memory address and the data stored \nat the memory address as depicted in Figure\u00a0 82Chapter 8  Methods\n296In Figure\u00a0 82 you see that the actual data of the variable id is stored at the memory address You can \nalso store data at a memory address that is not the actual value for the variable rather it is the memory \naddress of the location where the actual value is stored In this case the value stored at the first memory \naddress is a reference to the actual data stored at some other memory address and such a value is known as \na reference or a pointer If a variable stores the reference to some data it is called a reference variable \nContrast the phrases a variable and a reference variable  A variable stores the actual data itself at its \nmemory location A reference variable stores the reference or memory address of the actual data Figure\u00a0 83 \ndepicts the difference between a variable and a reference variable\nIn Figure\u00a0 83 idRef  is a reference variable and id is a variable Both variables are allocated memory \nseparately The actual value of 785 is stored at the memory location of the id variable which is 131072  \nHowever the memory location  262144  of idRef  stores the address of the id variable or memory location \nwhere 785 is stored You can get to the value 785 in memory using either variable The operation to get the \nactual data that a reference variable refers to is called dereferencing \nA method also called a function or procedure in some programming languages can optionally accept \nparameters from its caller A methods parameters allow data sharing between the caller context and the \nmethod context Many mechanisms are in practice to pass the parameters to a method The following \nsections discuss some of the commonly used parameterpassing mechanismsFigure 83  Difference b etween a variable and a reference variableFigure 82  Relationship between a variable name its memory address and dataChapter 8  Methods\n297 Pass by Value\nPass by value is the simplest parameterpassing mechanism to understand However it is not necessarily \nthe most efficient and the easiest to implement in all situations When a method is called the values of the \nactual parameters are copied to the formal parameters When the method execution starts two copies of the \nvalue exist in memory one copy for the actual parameter and one copy for the formal parameter Inside the \nmethod the formal parameter operates on its own copy of the value Any changes made to the value of the \nformal parameter do not affect the value of the actual parameter\nFigure 84 depicts the memory state when a method is called using the pass by value mechanism It \nis to be emphasized that once the formal parameter gets its value which is a copy of the actual parameter \nthe two parameters have nothing to do with each other The formal parameter is discarded at the end of the \nmethod call However the actual parameter persists in memory after the method call ends How long the \nactual parameter persists in memory depends on the context of the actual parameter\nConsider the following code for an increment  method which accepts an int parameter and \nincrements it by 2\n Assume that num is passed by value\nvoid incrementint num \n     2 \n    num  num  2\n     3 \n\nSuppose you call the increment  method with the following snippet of code\nint id  57\n 1 \nincrementid\n 4 \nFour points of execution in the code are labeled as 1 2 3 and 4 Table\u00a0 84 describes the memory \nstates for the actual parameter and the formal parameter before after and when the increment  method is \ninvoked Note that the formal parameter num no longer exists in memory at 4Figure 84  Memor y states for actual and formal parameters when a method is calledChapter 8  Methods\n298All local variables including formal parameters are discarded when a method invocation is over \nYou can observe that incrementing the value of the formal parameter inside the increment  method was \npractically useless because it could never be communicated back to the caller environment If you want to \nsend back one value to the caller environment you can use a return  statement in the method body to do \nthat The following is the code for the smartIncrement  method which returns the incremented value to \nthe caller\n Assume that num is passed by value\nint smartIncrementint num \n    num  num  2\n    return num\n\nYou will need to use the following snippet of code to store the incremented value that is returned from \nthe method in the id variable\nint id  57\nid  smartIncrementid    Store the returned value in id\n At this point id has a value of 59 \nNote that pass by value lets you pass multiple values from the caller environment to the method using \nmultiple parameters However it lets you send back only one value from the method If you just consider the \nparameters in a method call pass by value is a oneway communication It lets you pass information from \nthe caller to the method using parameters However it does not let you pass back information to the caller \nthrough the parameters Sometimes you may want to send multiple values from a method to the callers \nenvironment through the parameters In those cases you need to consider different ways to pass parameters \nto the method The pass by value mechanism is of no help in such situationsTable 84  Description of Memory States for Actual and Formal Parameters When the increment Method Is \nCalled and the Parameter Is Passed by Value\nPoint of Execution Memory State of Actual  \nParameter idMemory State of Formal Parameter num\n1 The id variable exists in \nmemory and its value is 57The num variable does not exist at this point\n2 The id variable exists in \nmemory and its value is 57The formal parameter num has been created in \nmemory The value of the actual parameter id has \nbeen copied to the address associated with the num \nvariable At this point num holds the value of 57\n3 The id variable exists in \nmemory and its value is 57At this point num holds a value of 59\n4 The id variable exists in \nmemory and its value is 57The formal parameter num does not exist in \nmemory at this point because the method call is \noverChapter 8  Methods\n299A method that is used to swap two values does not work when the parameters are passed by values \nConsider the following code for a classical swap  method\n Assume that x and y are passed by value\nvoid swapint x int y \n    int temp  x\n    x  y\n    y  temp\n\nYou can call the previous swap  method using the following snippet of code\nint u  75\nint v  53\nswapu v\n At this point u and v will be still 75 and 53 respectively \nBy this time you should be able to figure out why the values of u and v were not swapped when they \nwere passed to the swap  method When the swap  method was called the values of u and v were copied \nto the locations of the x and y formal parameters respectively Inside the swap  method the values of the \nformal parameters x and y were swapped and the values of actual parameters u and v were not touched at \nall When the method call was over the formal parameters x and y were discarded\nThe advantages of using pass by value are as follows\n\t It is easy to implement\n\t If the data being copied is a simple value it is faster\n\t The actual parameters are protected from any side effects when they are passed to \nthe method\nThe disadvantages of using pass by value are as follows\n\t If the actual parameter is complex data such as a large object it may be difficult if \nnot impossible to copy the data to another memory location\n\t Copying a large amount of data takes memory space and time which may slow down \nthe method call\n Pass by Constant Value\nPass by constant value  is essentially the same mechanism as pass by value  with one difference that the formal \nparameters are treated as constants and hence they cannot be changed inside the methods body The \nvalues of actual parameters are copied to the formal parameters as is done in pass by value  You can only \nread the value of formal parameters inside the methods body if they are passed by constant value\n Pass by Reference\nIt is important that you do not confuse the phrases reference and pass by reference  A reference is a \npiece of information typically a memory address that is used to get to the actual data stored at some other \nlocation Pass by reference is a mechanism to pass information from a callers environment to a method \nusing formal parametersChapter 8  Methods\n300In pass by reference the memory address of the actual parameter is passed and the formal parameter \nis mapped or associated with the memory address of the actual parameter This technique is also known \nas aliasing where multiple variables are associated with the same memory location The formal parameter \nname is an alias for the actual parameter name When a person has two names no matter which of the \ntwo names you use you refer to the same person Similarly when a parameter is passed by reference no \nmatter which name you use in the code the actual parameter name or the formal parameter name you are \nreferring to the same memory location and hence the same data\nIn pass by reference if the formal parameter is modified inside the method the actual parameter sees \nthe modification instantaneously Figure\u00a0 85 depicts the memory state for actual and formal parameters \nwhen a parameter to a method is passed by reference\nMany books use the phrase pass by reference  However they do not mean the one we are discussing \nin this section They really mean pass by reference value  which we discuss in the next section Note that in \npass by reference you do not allocate separate memory for the formal parameter Rather you just associate \nthe formal parameter name to the same memory location of the actual parameter\nLets do the increment  method call exercise again This time assume that the num parameter is \npassed by reference\n Assume that num is passed by reference\nvoid incrementint num \n     2 \n    num  num  2\n     3 \nFigure 85  Memor y states of actual and formal parameters when the parameters are passed by referenceChapter 8  Methods\n301You will call the increment  method with the following snippet of code\nint id  57\n 1 \nincrementid\n 4 \nTable 85 describes the memory states for the actual parameter and formal parameter before after and \nduring the increment  methods invocation Note that at 4 the formal parameter num no longer exists in \nmemory and still the actual parameter id has the value of 59 after the method call is over\nPass by reference allows you to have twoway communication between the caller environment and the \ncalled method You can pass multiple parameters by reference to a method and the method can modify \nall parameters All modifications to formal parameters are reflected back to the callers environment \ninstantaneously This lets you share multiple pieces of data between the two environments\nThe classical swap  method example works when its parameters are passed by reference Consider the \nfollowing swap  methods definition\n Assume that x and y are passed by reference\nvoid swapint x int y \n    int temp  x\n    x  y\n    y  temp\nTable 85  Description of Memory States for Actual and Formal Parameters When the increment Method Is \nCalled and the Parameter Is Passed by Reference\nPoint of \nExecutionMemory State of Actual Parameter id Memory State of Formal Parameter num\n1 The id variable exists in memory and its \nvalue is 57The num variable does not exist at this \npoint\n2 The id variable exists in memory and its \nvalue is 57The formal parameters name num has \nbeen associated with the memory address \nof actual parameter id At this point num \nrefers to the value of 57 which is exactly \nthe same as what id refers to\n3 The id variable exists in memory and its \nvalue is 59 Inside the method you used the \nformal parameter named num to increment \nthe value by 2 However id and num are two \nnames for the same memory location and \ntherefore the value of id is also 59At this point num holds a value of 59\n4 The id variable exists in memory and its \nvalue is 59The formal parameter named num does \nnot exist in memory at this point because \nthe method call is overChapter 8  Methods\n302You can call the previous swap  method using the following snippet of code\nint u  75\nint v  53\nswapu v\n At this point u and v will be 53 and 75 respectively \nConsider the following snippet of code for a method named getNumber \n Assume that x and y are passed by reference\nint getNumberint x int y \n    int x  3\n    int y  5\n    int sum  x  y\n    return sum\n\nSuppose you call the getNumber  method as follows\nint w  100\nint s  getNumberw w\n What is the value of s at this point 200 8 10 or something else \nWhen the getNumber  method returns what value will be stored in the variable s Note that both \nparameters to the getNumber  method are passed by reference and you pass the same variable w for both \nparameters in your call When the getNumber  method starts executing the formal parameters x and y \nare aliases to the same actual parameter w When you use w x or y you are referring to the same data in \nmemory Before adding x and y and storing the result in the sum local variable the method sets the value of \ny to 5 which makes w x and y all have a value of 5 When x and y are added inside the method both x and y \nrefer to the value 5 The getNumber  method returns 10\nConsider another call to the getNumber  method as a part of an expression as follows\nint a  10\nint b  19\nint c  getNumbera b  a\n What is the value of c at this point \nIt is a little trickier to guess the value of c in the previous snippet of code You need to consider the side \neffect of the getNumber  method call on the actual parameters The getNumber  method will return 8 and it \nwill also modify the value of a and b to 3 and 5 respectively A value of 11 8  3  will be assigned to c Consider \nthe following statement in which you have changed the order of the operands for the addition operator\nint a  10\nint b  19\nint d   a  getNumbera b\n What is the value of d at this point \nThe value of d will be 18 10  8  The local value of 10 will be used for a You need to consider the side \neffects on actual parameters by a method call if the parameters are passed by reference You would have \nthought that expressions getNumbera b  a  and a  getNumbera b  would give the same result \nHowever when the parameters are passed by reference the result may not be the same as we have explainedChapter 8  Methods\n303The advantages of using pass by reference are as follows\n\t It is more efficient compared to pass by value as actual parameter values are not copied\n\t It lets you share more than one piece of value between the caller and the called \nmethod environments\nThe disadvantages of using pass by reference are as follows\n\t It is potentially dangerous if the caller doesnt take into consideration the \nmodification made to the actual parameters inside the called method\n\t The program logic is not simple to follow because of the side effects on the actual \nparameters through formal parameters\n Pass by Reference Value\nThe mechanism of passing parameters to a method using pass by reference value is different from that \nof pass by reference However both mechanisms have the same effect In the pass by reference value \nthe reference of the actual parameter is copied to the formal parameter The formal parameter uses a \ndereferencing mechanism to access the actual parameters value The modification made by the formal \nparameters inside the method is immediately visible to the actual parameters as is the case in pass by \nreference Figure\u00a0 86 depicts the memory states for the actual and formal parameters when the pass by \nreference value mechanism is used\nFigure 86  Memor y states for actual and formal parameters when a method call is made using the pass by \nreference value mechanism\nThere is an important difference between pass by reference and pass by reference value In pass by \nreference value the reference of the actual parameter is copied to the formal parameter as part of the \nmethod call However you can change the formal parameter to refer to a different location in memory \ninside the method which will not make the actual parameter refer to the new location in memory Once \nyou change the reference stored in the formal parameter any changes made to the value stored at the new \nlocation will not change the value of the actual parameterChapter 8  Methods\n304The discussions and examples referring to the side effects and memory states for pass by reference also \napply to the pass by reference value mechanism Most of the programming languages simulate the pass by \nreference mechanism using pass by reference value\n Pass by Constant Reference Value\nPass by constant reference value is essentially the same as pass by reference value with one difference The \nformal parameter is treated as a constant inside the method body That is the formal parameter holds the \ncopy of the reference held by the actual parameter throughout the execution of the method The formal \nparameter cannot be modified inside the methods body to hold reference of data other than what the actual \nparameter is referencing\n Pass by Result\nYou can think of pass by result as the opposite of pass by value In pass by value the value of the actual \nparameter is copied to the formal parameter In pass by result the value of the actual parameter is not \ncopied to the formal parameter The formal parameter is considered an uninitialized local variable when the \nmethod execution starts During the method execution the formal parameter is assigned a value At the end \nof the method execution the value of the formal parameter is copied back to the actual parameter\nFigure 87 depicts the memory state for the actual and formal parameters when the pass by result \nmechanism of parameter passing is used\nSometimes the formal parameters are also known as OUT parameters when the pass by result \nmechanism is used They are called OUT parameters because they are used to copy out  a value from the \nmethod to the callers environment Likewise formal parameters are sometimes known as IN parameters if \nthe pass by value mechanism is used because they are used to copy in  the value of the actual parameter\n Pass by Value Result\nAlso known as pass by copyrestore this is a combination of pass by value and pass by result hence the \nname pass by value result It is also known as the INOUT  way of passing parameters When a method \nis called the value of the actual parameter is copied to the formal parameter During the execution of the Figure 87  Memor y states for actual and formal parameters when the pass by result parameterpassing \nmechanism is usedChapter 8  Methods\n305method the formal parameter operates on its own local copy of data When the method call is over the value \nof the formal parameter is copied back to the actual parameter This is the reason that it is also called pass \nby copyrestore It copies the value of the actual parameter in the beginning of the method call and restores \nthe value of formal parameter in the actual parameter at the end of the method call Figure\u00a0 88 depicts the \nmemory state of actual and formal parameters when the pass by value result mechanism is used to pass \nparameters\nIt achieves the effect of pass by reference in a different way In pass by reference any modification \nmade to the formal parameter is visible to the actual parameter immediately In pass by value result any \nmodification to the formal parameter is visible to the actual parameter only when the method call returns If \nthe formal parameter which uses pass by value result is modified multiple times inside a method only the \nfinal modified value will be seen by the actual parameter\nPass by value result is used to simulate pass by reference in distributed applications Suppose you \nmake a remote method call which executes on a different machine The reference memory address of \nthe actual parameter which exists in one machine will not make any sense in the machine on which the \nremote method is executed In such cases the client application sends a copy of the actual parameter to the \nremote machine The value copied to the formal parameter is on the remote machine The formal parameter \noperates on the copy When the remote method call returns the value of the formal parameter on the \nremote machine is copied back to the actual parameter on the client machine This gives the client code the \nfunctionality of passing parameters by reference to remote methods that run on another machine\n Pass by Name\nTypically the actual parameter expression is evaluated before its valuereference is passed to a method In \npass by name the actual parameters expressions are not evaluated when a method is called The formal \nparameters names inside the body of the method are substituted textually with the expressions of their \ncorresponding actual parameters Actual parameters are evaluated each time they are encountered during \nthe execution of the method and they are evaluated in the callers context not the methods context If there \nis a name conflict between the local variables in the method and the actual parameter expression during \nsubstitution the local variables are renamed to give every variable a unique name\nPass by name is implemented using thunks A thunk  is a piece of code that computes and returns the \nvalue of an expression in a specific context A thunk is generated for each actual parameter and its reference \nis passed to the method At each use of a formal parameter a call to thunk is made which evaluates the \nactual parameter in the caller contextFigure 88  Memor y states for actual and formal parameters when the pass by result parameterpassing \nmechanism is usedChapter 8  Methods\n306The advantage of pass by name is that the actual parameters are never evaluated unless they are used \nin the method This is also known as lazy evaluation Contrast it with the pass by value mechanism where \nactual parameters are always evaluated before they are copied to the formal parameter This is called eager \nevaluation The disadvantage of pass by name is that the actual parameters are evaluated every time the \ncorresponding formal parameters are used inside the methods body It is also harder to follow the logic of a \nmethod if it uses the pass by name formal parameter which can also have side effects\nConsider the following declaration for a method squareDivide \nint squareDivideint x int y \n    int z   x  xy  y\n    return z\n\nConsider the following snippet of code that calls the squareDivide  method\nsquareDivide44 22\nYou can visualize the execution of this call as if you had written the squareDivide  method as follows \nNote that the actual argument expressions of 22  and 44  are evaluated multiple times inside the \nmethods body\nint squareDivide \n    int z  44442222\n    return z\n\n Pass by Need\nPass by need is similar to pass by name with one difference In pass by name actual parameters are \nevaluated each time they are used in the method In pass by need the actual parameters are evaluated only \nonce upon their first use When a thunk for an actual parameter is called for the first time it evaluates the \nactual parameter expression caches the value and returns it When the same thunk is called again it simply \nreturns the cached value rather than reevaluating the actual parameter expression again\n ParameterPassing Mechanisms in\u00a0Java\nJava supports two kinds of data types primitive data type and reference data type A primitive data type \nis a simple data structure and it has only one value associated with it A reference data type is a complex \ndata structure and it represents an object A variable of a primitive data type stores the value directly at its \nmemory address Suppose you have an int variable id Further suppose it has been assigned a value of 754 \nand its memory address is 131072 \nint id  754Chapter 8  Methods\n307Figure 89 shows the memory state of the id variable\nThe value 754 is directly stored at the memory address 131072  which is associated with the id variable \nname What happens if you execute the following statement which assigns a new value of 351 to the id \nvariable\nid  351\nWhen a new value 351 is assigned to the id variable the old value 754 is replaced with the new value at \nthe memory address as shown in Figure\u00a0 810 Figure 89  The memor y state for an id variable when its value is 754\nFigure 810  The memor y state for an id variable when a new value of 351 is assigned to it\nThings are different when you work with objects and reference variables Consider the declaration of \na Car class as shown in Listing 816  It has three instance variables model  year  and price which have \nbeen given initial values of Unknown  2000  and 00 respectively\nListing 816  Car C lass with Three Public Instance Variables\n Carjava\npackage comjdojocls\npublic class Car \n    public String model  Unknown\n    public int year       2000\n    public double price  00\nChapter 8  Methods\n308When you create an object of a reference type the object is created on heap and it is stored at a specific \nmemory address Lets create an object of the Car class as follows\nnew Car\nFigure 811  shows the memory state when the previous statement is executed to create a Car object You \nprobably assumed that the memory address where the object is stored is 262144  Notice that when an object \nis created memory is allocated for all of its instance variables and they are initialized In this case model  \nyear  and price  of the new Car object have been initialized properly as shown in the figure\nAt this point there is no way to refer to the newly created Car object from a Java program even though \nit exists in memory The new operator as used in new Car  returns the memory address of the object it \ncreates In your case it will return 262144  Recall that the memory address of the data the Car object in \nyour case is also called a reference of that data From now onward you will say that the new operator in Java \nreturns a reference to the object it creates instead of saying that it returns the memory address of the object \nBoth mean the same thing However Java uses the term reference  which has a more generic meaning \nthan memory address  In order to access the newly created Car object you must store its reference in \na reference variable Recall that a reference variable stores the reference to some data which is stored \nsomewhere else All variables of reference types are reference variables in Java A reference variable in Java \ncan store a null  reference which means that it refers to nothing Consider the following snippet of code that \nperforms different things on reference variables\nCar myCar  null     1 \nmyCar  new Car    2 \nCar xyCar  null     3 \nxyCar  myCar        4 \nWhen the statement labeled 1 is executed memory is allocated for the myCar  reference variable say at \nmemory address 8192  The null  value is a special value typically a memory address of zero which is stored \nat the memory address of the myCar  variable Figure\u00a0 812  depicts the memory state for the myCar  variable \nwhen it is assigned a null  referenceFigure 811  Memor y state when a Car object is created using the new Car statementChapter 8  Methods\n309The execution of statement labeled 2 is a twostep process First it executes the new Car  part of the \nstatement to create a new Car object Suppose the new Car object is allocated at memory address of 9216 \nThe new Car  expression returns the reference of the new object which is 9216  In the second step the \nreference of the new object is stored in myCar  reference variable The memory state for the myCar  reference \nvariable and the new Car object after the statement labeled 2 is executed is shown in Figure\u00a0 813  Note that \nthe memory address of the new Car object 9216  and the value of the myCar  reference variable match at this \npoint You do not need to worry about the numbers used in this example for memory addresses I just made \nup some numbers to drive home the point of how the memory addresses are used internally Java does not \nlet you access the memory address of an object or a variable Java lets you accessmodify the state of objects \nthrough reference variables\nThe statement labeled 3 is similar to the statement labeled 1 The memory state for the xyCar  \nreference variable is shown in Figure\u00a0 814  assuming that 10240  is the memory address for the xyCar  \nreference variableFigure 812  Memor y state for the myCar variable when the Car myCar  null statement is executed\nFigure 813  Memor y states for the myCar reference variable and the new Car object when the myCar  new \nCar statement is executed\nFigure 814  Memor y state of xyCar reference variable\nIt is interesting to note the memory state when the statement labeled 4 is executed The statement \nreads as follows\nxyCar  myCar    4 Chapter 8  Methods\n310Recall that a variable name has two things associated with it a memory address and a value stored \nat that memory address The memory address or location is also known as its lvalue  whereas the value \nstored at its memory address is also called rvalue  When a variable is used to the left of an assignment \noperator  xyCar  in statement labeled 4 it refers to its memory address When a variable is used to the right \nof an assignment operator  myCar  in statement labeled 4 it refers to its value  rvalue  stored at its memory \naddress The statement labeled 4 can be read as follows\nxyCar  myCar  4 \nAt lvalue of xyCar store rvalue of myCar         4  another way \nAt memory address of xyCar store value of myCar  4   another way \nTherefore when you execute the statement xyCar  myCar  it reads the value of myCar  which is 9216  \nand stores it at the memory address of xyCar  The reference variable myCar  stores a reference to a Car object \nAn assignment like xyCar  myCar  does not copy the object to which myCar  refers Rather it copies the value \nstored in myCar  a reference to the Car object to xyCar  When the assignment xyCar  myCar  is complete \nthe reference variables of myCar  and xyCar  have reference to the same Car object in memory At this point \nonly one Car object exists in memory Figure\u00a0 815  shows the memory state when statement labeled 4 is \nexecuted\nAt this time you can use reference variable myCar  or xyCar  to access the Car object in memory The \nfollowing snippet of code will access the same object in memory\nmyCarmodel  Civic LX  Use myCar to change model \nmyCaryear    1999        Use myCar to change year \nxyCarprice  1600000     Use xyCar to change the price \nAfter executing the previous three statements model  year  and price  will be changed for the Car \nobject and the memory state will look as shown in Figure\u00a0 816 Figure 815  Memor y state showing myCar and xyCar referencing the same Car object in memoryChapter 8  Methods\n311At this point two reference variables myCar  and xyCar  and one Car object exist in memory Both reference \nvariables are referencing the same Car object Lets execute the following statement and label it as 5\nmyCar  new Car  5 \nThe previous statement will create a new Car object in memory with initial values for its instance \nvariables and assign the reference of the new Car object to the myCar  reference variable The xyCar  reference \nvariable still references the Car object it was referencing before Suppose the new Car object has been \nallocated at memory address 5120  The memory state for two reference variables myCar  and xyCar  and two \nCar objects are shown in Figure\u00a0 817 Figure 816  Memor y state showing myCar and xyCar referencing the same Car object in memory after myCar \nand xyCar have been used to change the state of the Car object\nFigure 817  Memor y state of reference variables myCar and xyCar and two Car objects\nLets make one more change and set the xyCar  reference variable to null  as shown\nxyCar  null  6 Chapter 8  Methods\n312Figure 818  shows the memory state after statement 6 is executed\nNow the xyCar  reference variable stores a null  reference and it no longer refers to any Car object The \nCar object with the Civic LX  model is not being referenced by any reference variable You cannot access \nthis Car object at all in your program because you do not have a reference to it In Java terminology the Car \nobject with the Civic LX  model is not reachable When an object in memory is not reachable it becomes \neligible for garbage collection Note that the Car object with the Civic LX  model is not destroyed or \ndeallocated immediately after xyCar  is set to null  It stays in memory until the garbage collector runs and \nmakes sure that it is not reachable Refer to a book on garbage collection for more details on how an objects \nmemory is deallocated\nWe have covered enough background about variable types and how they work in Java It is time to \ndiscuss the parameterpassing mechanism in Java In brief we can state\nAll parameters in Java are passed by value\nThis brief statement causes a lot of confusion Does it mean that when a parameter is a reference \ntype a copy of the object the actual parameter refers to is made and assigned to the formal parameter It is \nimportant to elaborate on the statement  All parameters in Java are passed by value with examples Even \nveteran Java programmers have problems understanding the parameterpassing mechanism in Java To be \nmore elaborate Java supports the following four types of parameterpassing mechanisms\n\t Pass by value\n\t Pass by constant value\n\t Pass by reference value\n\t Pass by constant reference value\nNote that all four ways of passing parameters in Java include the word value  This is the reason that \nmany books on Java summarize them as Java passes all parameters by value  Refer to the previous section \nfor more details for the previously mentioned four types of parameterpassing mechanisms\nThe first two types pass by value and pass by constant value apply to parameters of primitive data \ntypes The last two types pass by reference value and pass by constant reference value apply to the \nparameters of reference type\nWhen a formal parameter is of a primitive data type the value of the actual parameter is copied to the \nformal parameter Any changes made to the formal parameters value inside the methods body will change \nonly the copy of the formal parameter and not the value of the actual parameter Now you can tell that the \nswap  method to swap two primitive values will not work in JavaFigure 818  Memor y state of reference variables myCar and xyCar and two Car objects after xyCar has been \nassigned a null referenceChapter 8  Methods\n313Listing 817  demonstrates that the swap  method cannot be written in Java because primitivetype \nparameters are passed by value The output shows that the x and y formal parameters of the swap  method \nreceive the values of a and b The values of x and y are swapped inside the method which does not affect the \nvalues of actual parameters a and b at all\nListing 817  An Incor rect Attempt to Write a swap Method to Swap Two Values of Primitive Types in Java\n BadSwapTestjava\npackage comjdojocls\npublic class BadSwapTest \n    public static void swapint x int y \n        Systemoutprintln2 x    x   y    y\n        int temp  x\n        x  y\n        y  temp\n        Systemoutprintln3 x    x   y    y\n    \n    public static void mainString args \n        int a  19\n        int b  37\n        Systemoutprintln1 a    a   b    b\n         Call the swap method to swap values of a and b\n        BadSwapTestswapa b\n        Systemoutprintln4 a    a   b    b\n    \n\n1 a  19 b  37\n2 x  19 y  37\n3 x  37 y  19\n4 a  19 b  37\nA pr imitivetype parameter is passed by value However you can modify the value of the formal \nparameter inside the method without affecting the actual parameter value Java also lets you pass by \nconstant value In this case the formal parameter cannot be modified inside the method The formal \nparameter is initialized with the value of the actual parameter by making a copy of the actual parameter \nand then it is a constant value which can only be read You need to use the final  keyword in the formal \nparameter declaration to indicate that you mean to pass the parameter by constant value Any attempt to \nchange the value of a parameter which uses pass by constant value results in a compiletime error  \nListing 818  demonstrates how to use the pass by constant value mechanism to pass the parameter x to the \ntest  method Any attempt to change the value of the formal parameter x inside the test  method will \nresult in a compiletime error If you uncomment the x  10  statement inside the test  method you \nwould get the following compiler error\nError10   final parameter x may not be assigned\nYou have passed two parameters x and y to the test  method The parameter y is passed by value \nand hence it can be changed inside the method This can be confirmed by looking at the outputChapter 8  Methods\n314Listing 818  An Exam ple of Pass by Constant Value\n PassByConstantValueTestjava\npackage comjdojocls\npublic class PassByConstantValueTest \n     x is passed by constant value and y is passed by value\n    public static void testfinal int x int y \n        Systemoutprintln2 x    x   y    y\n         Uncommenting the following statement will generate a compiletime error \n         x  79  Cannot change x It is passed by constant value \n        y  223  Ok to change y\n        Systemoutprintln3 x    x   y    y\n    \n    public static void mainString args \n        int a  19\n        int b  37\n        Systemoutprintln1 a    a   b    b\n        PassByConstantValueTesttesta b\n        Systemoutprintln4 a    a   b    b\n    \n\n1 a  19 b  37\n2 x  19 y  37\n3 x  19 y  223\n4 a  19 b  37\nLets discuss the parameterpassing mechanism for referencetype parameters Java lets you use the \npass by reference value and pass by constant reference value mechanisms to pass referencetype parameters \nto a method When a parameter is passed by reference value the reference stored in the actual parameter \nis copied to the formal parameter When the method starts executing both the actual parameter and the \nformal parameter refer to the same object in memory If the actual parameter has a null  reference the \nformal parameter will contain the null  reference You can assign a reference to another object to the formal \nparameter inside the methods body In this case the formal parameter starts referencing the new object \nin memory and the actual parameter still references the object it was referencing before the method call \nListing 819  demonstrates the pass by reference mechanism in Java It creates a Car object inside the main  \nmethod and stores the reference of the Car object in the myCar  reference variable\n Create a Car object and assign its reference to myCar\nCar myCar  new Car\nIt modifies the model year and price of the newly created Car object using the myCar  reference variable\n Change model year and price of Car object using myCar\nmyCarmodel  Civic LX\nmyCaryear    1999\nmyCarprice  160000Chapter 8  Methods\n315The message labeled 1\u00a0in the output shows the state of the Car object The myCar  reference variable is \npassed to the test  method using the following call\nPassByReferenceValueTesttestmyCar\nSince the type of the formal parameter xyCar  in the test  method is Car which is a reference type \nJava uses the pass by reference value mechanism to pass the value of the myCar  actual parameter to the \nxyCar  formal parameter When the testmyCar  method is called Java copies the reference of the Car object \nstored in the myCar  reference variable to the xyCar  reference variable When the execution enters the test  \nmethods body myCar  and xyCar  reference the same object in memory At this time there is only one Car \nobject in memory and not two It is very important to understand that the testmyCar  method call did \nnot make a copy of the Car object referenced by the myCar  reference variable Rather it made a copy of the \nreference memory address of the Car object referenced by the myCar  reference variable which is the actual \nparameter and copied that reference to the xyCar  reference variable which is the formal parameter The fact \nthat both myCar  and xyCar  reference the same object in memory is indicated by the message labeled 2\u00a0in \nthe output which is printed using the xyCar  formal parameter inside the test  method\nNow you create a new Car object and assign its reference to the xyCar  formal parameter inside the \ntest  method\n Lets make xyCar refer to a new Car object\nxyCar  new Car\nAt this point there are two Car objects in memory The xyCar  formal parameter references the new Car \nobject and not the one whose reference was passed to the method Note that the actual parameter myCar  still \nreferences the Car object that you created in the main  method The fact that the xyCar  formal parameter \nreferences the new Car object is indicated by the message labeled 3\u00a0in the output When the test  method \ncall returns the main  method prints details of the Car object being referenced by the myCar  reference \nvariable See Listing 819 \n Tip When a referencetype parameter is passed to a method in Java  the formal parameter can access the \nobject the same way the actual parameter can access the object the formal parameter can modify the object \nby directly changing the values of the instance variables or by calling methods on the object  any modification \nmade on the object through the formal parameter is immediately visible through the actual parameter because \nboth hold the reference to the same object in memory the formal parameter itself can be modified to reference \nanother object or the null  reference inside the method\nListing 819  An Exam ple of Pass by Reference Value\n PassByReferenceValueTestjava\npackage comjdojocls\npublic class PassByReferenceValueTest \n    public static void mainString args \n         Create a Car object and assign its reference to myCar\n        Car myCar  new Car\n         Change model year and price of Car object using myCar\n        myCarmodel  Civic LX\n        myCaryear  1999Chapter 8  Methods\n316        myCarprice  160000\n        Systemoutprintln1 model    myCarmodel\n                  year    myCaryear\n                  price    myCarprice\n        PassByReferenceValueTesttestmyCar\n        Systemoutprintln4 model    myCarmodel\n                  year    myCaryear\n                  price    myCarprice\n    \n    public static void testCar xyCar \n        Systemoutprintln2 model    xyCarmodel\n                  year    xyCaryear\n                  price    xyCarprice\n         Lets make xyCar refer to a new Car object\n        xyCar  new Car\n        Systemoutprintln3 model    xyCarmodel\n                  year    xyCaryear\n                  price    xyCarprice\n    \n\n1 model  Civic LX year  1999 price  160000\n2 model  Civic LX year  1999 price  160000\n3 model  Unknown year  2000 price  00\n4 model  Civic LX year  1999 price  160000\nIf you do not want the method to change the referencetype formal parameter to reference a different \nobject than the one referenced by the actual parameter you can use the pass by constant reference value \nmechanism to pass that parameter If you use the keyword final  in the referencetype formal parameter \ndeclaration the parameter is passed by constant reference value and the formal parameter cannot be \nmodified inside the method The following declaration of the test  method declares the xyzCar  formal \nparameter as final  and the parameter is passed by constant reference value The method attempts to \nchange the xyzCar  formal parameter by assigning a null  reference to it and then by assigning a reference to \na new Car object Both of these assignment statements will generate a compiler error\n xyzCar is passed by constant reference value because it is declared final\nvoid testfinal Car xyzCar \n     Can read the object referenced by xyzCar\n    String model  xyzCarmodel\n     Can modify object referenced by xyzCar\n    xyzCaryear  2001\n     Cannot modify xyzCar That is xyzCar must reference the object what the actual\n       parameter is referencing at the time this method is called You cannot even set it to\n       null reference\n    \n    xyzCar  null        A compiletime error Cannot modify xyzCar\n    xyzCar  new Car  A compiletime error Cannot modify xyzCar\nChapter 8  Methods\n317Lets discuss one more example on parameterpassing mechanisms in Java Consider the following code \nfor the changeString  method\npublic static void changeStringString s2 \n     2 \n    s2  s2   there\n     3 \n\nConsider the following snippet of code that calls the changeString  method\nString s1  hi\n 1 \nchangeStrings1\n 4 \nWhat will be the content of s1 at 4 String  is a reference type in Java At 1 s1 is referencing a String  \nobject whose content is hi  When the changeStrings1  method is called s1 is passed to s2 by reference \nvalue At 2 s1 and s2 are referencing the same String  object in memory whose content is hi  When the\ns2  s2   there\nstatement is executed two things happen First the s2   there  expression is evaluated which creates a \nnew String  object in memory with content of hi there  and returns its reference The reference returned \nby the s2   there  expression is assigned to the s2 formal parameter At this time there are two String  \nobjects in memory one with the content of hi  and another with the content of hi there  At 3 the \nactual parameter s1 is referencing the String  object with the content of hi  and the formal parameter s2 \nis referencing the String  object with content hi there  When the changeString  method call is over the \nformal parameter s2 is discarded Note that the String  object with content hi there  still exists in memory \nafter the changeString  method call is over Only the formal parameter is discarded when a method call is \nover not the object to which the formal parameter was referencing At 4 the reference variable s1 still refers \nto the String  object with content hi  Listing 820  has the complete code that attempts to modify a formal \nparameter of String  type\n Tip a String  object is immutable meaning that its contents cannot be changed after it is created If you \nneed to change the contents of a String  object you must create a new String  object with the new contents\nListing 820  Another Exam ple of Pass by Reference Value Parameter Passing in Java\n PassByReferenceValueTest2java\npackage comjdojocls\npublic class PassByReferenceValueTest2 \n    public static void changeStringString s2 \n        Systemoutprintln2 s2    s2\n        s2  s2   there\n        Systemoutprintln3 s2    s2\n    \n    public static void mainString args \n        String s1  hiChapter 8  Methods\n318        Systemoutprintln1 s1    s1\n        PassByReferenceValueTest2changeStrings1\n        Systemoutprintln4 s1    s1\n    \n\n1 s1  hi\n2 s2  hi\n3 s2  hi there\n4 s1  hi\n Summary\nA method in a class defines the behavior of the objects of that class or the behavior of the class itself A \nmethod is a named block of code The method can be invoked to execute its code The code that invokes \nthe method is called the caller of the method Optionally a method may accept input values from the caller \nand it may return a value to the caller The list of input values is known as a methods parameters Varargs \nparameters are used to define parameters for methods and constructors where they can take a variable \nnumber of parameters A method is always defined inside the body of a class or an interface\nMethods of a class can have one of the following four access levels public private protected or \npackage level The presence of the keyword public  private  or protected  in defining them gives them \nthe public private or protected access level respectively Absence of any of these keywords specifies the \npackagelevel access\nYou can declare variables inside a methods body and such variables are called local variables Unlike \nfields of a class local variables are not initialized by default Local variables must be initialized before their \nvalues can be read An attempt to read a local variables value before the local variable is initialized results in \na compiletime error\nA class can have two types of methods instance methods and class methods Instance methods and \nclass methods are also called nonstatic methods and static methods respectively An instance method is \nused to implement behavior of the instances also called objects of the class An instance method can only \nbe invoked in the context of an instance of the class A class method is used to implement the behavior of the \nclass itself A class method always executes in the context of a class The static  modifier is used to define a \nclass method The absence of the static  modifier in a method declaration makes the method an instance \nmethod\nMethods of a class can be accessed using dot notation which is of the form\nqualifiermethodnamemethodactualparameters\nFor an instance method the qualifier is a reference to an instance of the class For a class method the \nqualifier can be a reference of an instance of the class or the class name\nYou can call static methods of a class from a nonstatic method of the class however calling nonstatic \nmethods from a static method is not allowed Static methods of a class can access all static fields of the class \nwhereas nonstatic methods can access both static and nonstatic fields of the class\nJava has a keyword called this  It is a reference to the current instance of a class It can be used only \nin the context of an instance It can never be used in the context of a class because it means the current \ninstance and no instance exists in the context of a class The keyword this  is used in many contexts such as \nnonstatic methods constructors instance initializers and expressions to initialize instance variablesChapter 8  Methods\n319Different mechanisms to pass parameters to methods and constructors exist Java uses pass by value \nand pass by constant value mechanisms to pass parameters of primitive data types Pass by reference value \nand pass by constant reference value are used to pass parameters of reference types in Java\nEXERCISES\n 1 What is a method in Java\n 2 describe the difference between a static method and a nonstatic method  \nof a class\n 3 Can a sta tic method access instance variables of a class If your answer is no \nexplain the reason\n 4 What is the meaning of void  when it is used as the return type of a method\n 5 Create a class named Point2D  with two int instance variables named x and y\nBoth instance variables should be declared private do not initialize the two instance \nvariables add setters and getters for the two instance variables that will allow the \nusers of the Point  class to change and access their values declare the setters as \nsetXint x  and setYint y  and getters as getX  and getY \n 6 Implement a method named distance  in the Point2D  class that you created in \nthe previous exercise the method accepts an instance of the Point2D  class and \nreturns the distance between the current point and the point represented by the \nparameter the method should be declared as follows\npublic class Point2D \n     Code from the previous exercise goes here \n    public double distancePoint2D p \n         Your code for this exercise goes here \n    \n\n Hint the distance between two points x1 y1  and x2 y2  is computed as xx yy 12 1222g16g11g12 g14g16g11g12  \nYou can use the Mathsqrtn  method to compute the square root of a number n\n 7 enhance the Point2D  class by adding a static factory method named create  \na factory method in a class is used to create objects of the class the create  \nmethod should be declared as follows\npublic class Point2D \n     Code from the previous exercise goes here \n    public Point2D createint x int y \n         Your code for this exercise goes here \n    \nChapter 8  Methods\n320the x and y instance variables of the returned Point2D  object from the create  \nmethod should be initialized to the x and y parameters of this method respectively\n 8 Create a class named MathUtil  with a method name avg  It computes and \nreturns the average of a list of numbers the method must accept variablelength \narguments of double  types with a minimum of two double  values run the \nMathUtil  class and verify that the output prints the correct results\n MathUtiljava\npackage comjdojoclsexcercise\npublic class MathUtil \n    public static void mainString args \n        Systemoutprintlnavg10 15    avg10 15\n        Systemoutprintlnavg2 3 4    avg2 3 4\n        Systemoutprintlnavg205 305 405  \n                            avg205 305 405\n        Systemoutprintlnavg20 00 20  \n                            avg20 00 20\n    \n    public static double avg Your parameters go here  \n         Your code goes here \n    \n\n 9 the main  method of a class serves as an entry point of a Java application It is \ndeclared as follows\npublic static void mainString args \n     Your code goes here\n\nChange this declaration of the main  method using a varargs\n 10 What will be the output when the following PassByValueTest  class is run\n PassByValueTestjava\npackage comjdojoclsexcercise\npublic class PassByValueTest \n    public static void mainString args \n        int x  100\n        Systemoutprintlnx    x\n        changex\n        Systemoutprintlnx    x\n        Point2D p  new Point2D\n        psetX40\n        psetY60\n        Systemoutprintlnpx    pgetX\n                           py    pgetY\n        changePointReferencep\n        Systemoutprintlnpx    pgetXChapter 8  Methods\n321                           py    pgetY\n        changePointp\n        Systemoutprintlnpx    pgetX\n                           py    pgetY\n    \n    public static void changeint x \n        x  200\n    \n    public static void changePointReferencePoint2D p \n        p  new Point2D\n    \n    public static void changePointPoint2D p \n        int newX  pgetX  2\n        int newY  pgetY  2\n        psetXnewX\n        psetYnewY\n    \n323\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg10100797814842730749CHAPTER 9\nConstructors\nIn this chapter you will learn\n\t What constructors are and how to use them\n\t Different types of initializers of a class\n\t Declaring final  variables fields classes and methods\n\t What generic classes are and how to use them\n What Is a\u00a0Constructor\nA constructor is a named block of code that is used to initialize an object of a class immediately after the \nobject is created The structure of a constructor looks similar to a method However the similarity between \nthe two stops right there They are two different constructs and they are used for different purposes\n Declaring a\u00a0Constructor\nThe general syntax for a constructor declaration is as follows\nmodifiers constructornameparameterslist throwsclause \n     Body of the constructor goes here\n\nThe declaration of a constructor starts with modifiers A constructor can have its access modifier as public  \nprivate  protected  or package level no modifier The constructor name is the same as the simple name of \nthe class The constructor name is followed by a pair of opening and closing parentheses which may include \nparameters Optionally the closing parenthesis may be followed by a throws  clause which in turn is followed \nby a commaseparated list of exceptions I discuss the use of the keyword throws  in Chapter 13 The body of the \nconstructor where you place your code is enclosed in braces\nIf you compare the syntax to declare a method with the syntax to declare a constructor you will find \nthat they are almost the same It is suggested to keep the method declaration in mind when learning about \nconstructor declaration because most of the characteristics are similarChapter 9  Constru Ctors\n324The following code shows an example of declaring a constructor for a class Test  Figure\u00a0 91 shows the \nanatomy of the constructor\n Testjava\npackage comjdojocls\npublic class Test \n    public Test \n         Code goes here\n    \n\n Tip the name of a constructor must ma tch the simple name not the fully qualified name of the class\nUnlike a method a constructor does not have a return type You cannot even specify void  as a return \ntype for a constructor Consider the following declaration of a class Test2 \npublic class Test2 \n     Below is a method not a constructor\n    public void Test2 \n         Code goes here\n    \n\nDoes the class Test2  declare a constructor The answer is no The class Test2  does not declare a \nconstructor Rather what you may be looking at is a method declaration which has the same name as the \nsimple name of the class It is a method declaration because it specifies a return type of void  Note that a \nmethod name could also be the same as the class name as is the case in this example\nJust the name itself does not make a method or constructor If the name of a construct is the same as the \nsimple name of the class it could be a method or a constructor If it specifies a return type it is a method If it \ndoes not specify a return type it is a constructorFigure 91  Anatomy of the constructor for the Test classChapter 9  Constru Ctors\n325When do you use a constructor You use a constructor with the new operator to initialize an instance or \nan object of a class just after the new instance is created Sometimes the phrases create and initialize are \nused interchangeably in the context of a constructor However you need to be clear about the difference in \ncreating and initializing an object The new operator creates an object and a constructor initializes that object\nThe following statement uses a constructor of the Test  class to initialize an object of the Test  class\nTest t  new Test\nFigure 92 shows the anatomy of this statement The new operator is followed by the call to the \nconstructor The new operator along with the constructor call for example new Test  is called an \ninstance or object creation expression An instance creation expression creates an object in memory \nexecutes the code in the body of the specified constructor and finally returns the reference of the new \nobject\nI have covered enough theories for declaring a constructor It is time to see a constructor in action \nListing 91 has the code for a Cat class\nListing 91  A Ca t Class with a Constructor\n Catjava\npackage comjdojocls\npublic class Cat \n    public Cat \n        SystemoutprintlnMeow\n    \n\nThe Cat class declares a constructor Inside the constructors body it prints a message Meow  \nListing 92 contains the code for a CatTest  class which creates two Cat objects in its main  method Note \nthat you always use an object creation expression to create a new object of the Cat class It is up to you to \nstore the reference of the new object in a reference variable The first Cat object is created and its reference \nis not stored The second Cat object is created and its reference is stored in a reference variable c\nListing 92  A Tes t Class That Creates Two Cat Objects\n CatTestjava\npackage comjdojocls\npublic class CatTest \n    public static void mainString args \n         Create a Cat object and ignore its reference\n        new CatFigure 92  Anatomy of a constructor call with the new operatorChapter 9  Constru Ctors\n326         Create another Cat object and store its reference in c\n        Cat c  new Cat\n    \n\nMeow\nMeow\n Overloading a\u00a0Constructor\nA class can have more than one constructor If a class has multiple constructors they are called overloaded  \nconstructors Since the name of the constructor must be the same as the simple name of the class there is a \nneed to differentiate one constructor from another The rules for overloaded constructors are the same as for \noverloaded methods If a class has multiple constructors all of them must differ from the others in number \norder or type of parameters Listing 93 contains the code for a Dog class which declares two constructors \nOne constructor accepts no parameters and another accepts a String  parameter\nListing 93  A Do g Class with Two Constructors One with No Parameters and One with a String Parameter\n Dogjava\npackage comjdojocls\npublic class Dog \n     Constructor 1\n    public Dog \n        SystemoutprintlnA dog is created\n    \n     Constructor 2\n    public DogString name \n        SystemoutprintlnA dog named   name   is created\n    \n\nIf a c lass declares multiple constructors you can use any of them to create an object of that class For \nexample the following two statements create two objects of the Dog class\nDog dog1  new Dog\nDog dog2  new DogCupid\nThe first statement uses the constructor with no parameters and the second one uses the constructor \nwith a String  parameter If you use a constructor with parameters to create an object the actual parameters \norder type and number must match the formal parameters order type and number Listing 94 has the \ncomplete code that creates two Dog objects using different constructors\nListing 94  Testing the Constructors of the Dog Class\n DogTestjava\npackage comjdojocls\npublic class DogTest \n    public static void mainString args Chapter 9  Constru Ctors\n327        Dog d1  new Dog           Uses Constructor 1\n        Dog d2  new Dog Canis  Uses Constructor 2\n    \n\nA dog is created\nA dog named Canis is created\nThe output of running the DogTest  class indicates that different constructors are called when two Dog \nobjects are created in the main  method\nA constructor is called once per object creation expression You can execute the code for one \nconstructor only once in the process of an object creation If the code for a constructor is executed N \ntimes it means N number of objects of that class will be created and you must use N number of object \ncreation expressions to do that However when an object creation expression calls a constructor the \ncalled constructor may call another constructor from its body This book covers this scenario where one \nconstructor calls another later in this section\n Writing Code for\u00a0a\u00a0Constructor\nSo far you have been writing trivial code in constructors What kind of code should you write in a \nconstructor The purpose of a constructor is to initialize the instance variables of the newly created object \nInside a constructor you should restrict yourself only to writing code that initializes instance variables of the \nobject An object is not fully created when a constructor is called The object is still in the process of creation \nIf you write some processing logic in a constructor assuming that a fullblown object exists in memory \nsometimes you may get unexpected results Lets create another class to represent a Dog object You will call \nthis class SmartDog  as shown in Listing 95\nListing 95  A Smar tDog Class That Declares Two Constructors to Initialize Instance Variables Differently\n SmartDogjava\npackage comjdojocls\npublic class SmartDog \n    private String name\n    private double price\n    public SmartDog \n         Initialize the name to Unknown and the price to 00\n        thisname  Unknown\n        thisprice  00\n        SystemoutprintlnUsing SmartDog constructor\n    \n    public SmartDogString name double price \n         Initialize name and price instance variables with the\n         values of the name and price parameters\n        thisname  name\n        thisprice  price\n        SystemoutprintlnUsing SmartDogString double constructor\n    Chapter 9  Constru Ctors\n328    public void bark \n        Systemoutprintlnname   is barking\n    \n    public void setNameString name \n        thisname  name\n    \n    public String getName \n        return thisname\n    \n    public void setPricedouble price \n        thisprice  price\n    \n    public double getPrice \n        return thisprice\n    \n    public void printDetails \n        SystemoutprintName   thisname\n        if price  00 \n            Systemoutprintln price   thisprice\n         else \n            Systemoutprintln price Free\n        \n    \n\nThe SmartDog  class looks a little bigger However its logic is very simple The following are the main \npoints in the SmartDog  class that you need to understand\n\t It declares two instance variables they are name  and price  The name  instance \nvariable stores the name of a smart dog The price  instance variable stores the price \nfor which it can be sold\n\t It declares two constructors The first constructor has no parameters It initializes the \nname and price instance variables to Unknown  and 00 respectively The second \nconstructor accepts two parameters named name  and price  It initializes the name  \nand price  instance variables to whatever values are passed for the two parameters \nNote the use of the keyword this  inside the constructors The keyword this  refers to \nthe object for which the constructors code is executing The use of the keyword this  \nis not necessary in the first constructor However you must use the keyword this  to \nrefer to instance variables in the second constructor because the names of the formal \nparameters hide the names of the instance variables\n\t The two constructors initialize instance variables or state of the object in their \nbodies They do not include any other processing logic\n\t The instance method bark  prints a message on the standard output with the name \nof the smart dog who is barking\n\t The setName  and getName  methods are used to set and get the name of the \nsmart dog The setPrice  and getPrice  methods are used to set and get the \nprice of the smart dog\n\t The printDetails  method prints the name  and price  of a smart dog If the price \nfor a smart dog is not set to a positive value it prints the price as Free Chapter 9  Constru Ctors\n329Listing 96 has the code for a SmartDogTest  class that demonstrates how the two constructors initialize \nthe instance variables\nListing 96  A Tes t Class to Demonstrate the Use of the SmartDog Class\n SmartDogTestjava\npackage comjdojocls\npublic class SmartDogTest \n    public static void mainString args \n         Create two SmartDog objects\n        SmartDog sd1  new SmartDog\n        SmartDog sd2  new SmartDogNova 2192\n         Print details about the two dogs\n        sd1printDetails\n        sd2printDetails\n         Make them bark\n        sd1bark\n        sd2bark\n         Change the name and price of Unknown dog\n        sd1setNameOpal\n        sd1setPrice32180\n         Print details again\n        sd1printDetails\n        sd2printDetails\n         Make them bark one more time\n        sd1bark\n        sd2bark\n    \n\nUsing SmartDog constructor\nUsing SmartDogString double constructor\nName Unknown price Free\nName Nova price 2192\nUnknown is barking\nNova is barking\nName Opal price 3218\nName Nova price 2192\nOpal is barking\nNova is barkingChapter 9  Constru Ctors\n330 Calling a\u00a0Constructor from\u00a0Another Constructor\nA constructor may call another constructor of the same class Lets consider the following Test  class It \ndeclares two constructors one accepts no parameters and one accepts an int parameter\npublic class Test \n    Test \n    \n    Testint x \n    \n\nSuppose you want to call the constructor with an int parameter from the constructor with no \nparameters Your first attempt which is wrong would be as follows\npublic class Test \n    Test \n         Call another constructor\n        Test103  A compiletime error\n    \n    Testint x \n    \n\nThe previous code does not compile Java has a special way to call a constructor from another \nconstructor You must use the keyword this  as if it were the name of the constructor to call a constructor \nfrom another constructor The following code calls the constructor with an int parameter from the \nconstructor with no parameters using the statement  this103  This is another use of the keyword this \npublic class Test \n    Test \n         Call another constructor\n        this103  OK  Note the use of the keyword this\n    \n    Testint x \n    \n\nThere are two rules about calling a constructor from another constructor The rules ensure that one \nconstructor is executed only once during the process of an object creation of a class These rules are as \nfollows\n\t The call to another constructor must be the first statement in the constructor\n\t A constructor cannot call itselfChapter 9  Constru Ctors\n331If a constructor calls another constructor it must be the first executable statement in the constructors \nbody This makes it easy for the compiler to check that a constructor has been called and it has been \ncalled only once For example the following code will generate a compiletime error because a call to the \nconstructor with int parameter thisk  is the second statement inside the constructors body not the first \nstatement\npublic class Test \n    Test \n        int k  10  First statement\n        thisk      Second statement A compiletime error\n    \n    Testint x \n    \n\nAn a ttempt to compile the code for this Test  class will generate the following error message\nError4   call to this must be first statement in constructor\nA cons tructor cannot call itself because it will result in a recursive call In the following code for the Test  \nclass both constructors attempt to call themselves\npublic class Test \n    Test \n        this\n    \n    Testint x  \n        this10\n    \n\nAn a ttempt to compile this code will result in the following error One error message is generated for \neach attempt to call the constructor itself\nError2   recursive constructor invocation\nError6   recursive constructor invocation\nTypically you create overloaded constructors for a class when you have many ways to initialize an \nobject of the class Lets consider the SmartDog  class shown in Listing 95 Two constructors give you \ntwo ways to initialize a new SmartDog  object The first one initializes the name  and the price  with default \nvalues The second constructor lets you initialize the name  and price  with the values supplied by the caller \nSometimes you may perform some logic to initialize the object inside a constructor Letting you call another \nconstructor from a constructor allows you to write such logic only once You can use this feature for your \nSmartDog  class as shown\n SmartDogjava\npackage comjdojocls\npublic class SmartDog \n    private String name\n    private double price\n    public SmartDog Chapter 9  Constru Ctors\n332         Call another constructor with Unknown and 00 as parameters\n        thisUnknown 00\n        SystemoutprintlnUsing SmartDog constructor\n    \n    public SmartDogString name double price \n         Initialize name and price to specified name and price\n        thisname  name\n        thisprice  price\n        SystemoutprintlnUsing SmartDogString double constructor\n    \n     Rest of code remains the same \n\nNote that you changed the code only inside the constructor that accepts no parameters Instead of \nsetting the default values for name  and price  in the first constructor you called the second constructor with \nthe default values as parameters from the first one\n Using a\u00a0return Statement Inside a\u00a0Constructor\nA constructor cannot have a return type in its declaration It means a constructor cannot return any value \nRecall that a return  statement is of two types one with a return expression and one without a return \nexpression The return  statement without a return expression simply returns the control to the caller without \nreturning any value You can use a return  statement without a return expression inside a constructor body \nalthough this is considered a bad practice that should be avoided When a return  statement in a constructor \nis executed the control returns to the caller ignoring the rest of the constructors code\nThe following code shows an example of using a return  statement in a constructor If the parameter x \nis a negative number the constructor simply executes a return  statement to end the call to the constructor \nOtherwise it performs some logic\npublic class Test \n    public Testint x \n        if x  0 \n            return\n        \n         Perform some logic here \n    \n\n Access Level Modifier for\u00a0a\u00a0Constructor\nAccess level for a constructor determines the part of the program that can use that constructor in an object \ncreation expression to create an object of that class Similar to fields and methods you can specify one of the \nfour access levels for a constructor\n\tpublic\n\tprivate\n\tprotected\n\t packagelevelChapter 9  Constru Ctors\n333The following code declares four constructors for the Test  class A comment for each constructor \nexplains its access level\n Class Test has public access level\npublic class Test \n     Constructor 1   packagelevel access\n    Test \n    \n     Constructor 2   public access level\n    public Testint x \n    \n     Constructor 3   private access level\n    private Testint x int y \n    \n     Constructor 4   protected access level\n    protected Testint x int y int z\n    \n\nThe effect of these access levels is the same as their effect on a method A constructor with a public  \naccess level can be used in any part of the application provided the class itself is accessible A constructor \nwith a private  access level can be used only inside the same class in which it is declared A constructor with \na protected  access level can be used in any part of the program in the same package in which its class is \ndeclared and inside any descendant class in any package A constructor with packagelevel access can be \nused inside the same package in which its class is declared\nYou can specify a public  access level or packagelevel access for a class A class defines a new reference \ntype which you can use to declare a reference variable The access level of a class determines in which \npart of the program the name of the class can be used Usually you use the name of a class in a cast or in a \nreference variable declaration as shown\n Test class name is used to declare the reference variable t\nTest t\n Test class name is used to cast the reference variable xyz\nTest t2  Testxyz\nLets discuss the different combinations of access levels for a class and its constructor and their effects \nin a program Consider the following code that declares a class T1 with a public  access level It also has a \nconstructor which also has a public  access level\n T1java\npackage comjdojoclsp1\npublic class T1 \n    public T1 \n    \nChapter 9  Constru Ctors\n334Because the class T1 has a public  access level you can declare a reference variable of type T1 anywhere \nin the same module If this code is in a different module assume that the module containing the class \nexports the classs package and the module having this code reads the first module\n Code inside any package\nT1 t\nBecause the constructor for the class T1 has a public  access level you can use it in an object creation \nexpression in any package\n Code inside any package\nnew T1\nYou can combine the previous two statements into one in the code in any package\n Code inside any package\nT1 t  new T1\nLets consider the following code for the class T2 which has a public  access level and has a constructor \nwith a private  access level\n T2java\npackage comjdojoclsp1\npublic class T2 \n    private T2 \n    \n\nBecause class T2 has a public  access level you can use its name to declare a reference variable in any \npackage in the same module If the package is in a different module assume that the module can read the \npackage that contains the T2 class The constructor for class T2 has a private  access level The implication \nof having a private  constructor is that you cannot create an object of the T2 class outside the T2 class \nRecall that a private  method field or constructor cannot be used outside the class in which it is declared \nTherefore the following code will not compile unless it appears inside the T2 class\n Code outside the T2 class\nnew T2  A compiletime error\nWhat is the use of the T2 class if you cannot create its object outside of the T2 class Lets consider the \npossible situations where you can declare a constructor private  and still create and use objects of the class\nA constructor is used to create an object of a class You may want to restrict the number of objects \nof a class The only way you can restrict the number of objects of a class is by having full control over its \nconstructors If you declare all constructors of a class to have the private  access level you have full control \nover how the objects of that class will be created Typically you include one or more public static methods in \nthat class which create andor return an object of that class If you design a class so that only one object of \nthe class may exist it is called a singleton pattern  The following code is a version of the T2 class that is based \non the singleton pattern\n T2java\npackage comjdojoclsp1\npublic class T2 Chapter 9  Constru Ctors\n335    private static T2 instance  new T2\n    private T2 \n    \n    public static T2 getInstance \n        return T2instance\n    \n     Other code goes here \n\nThe T2 class declares a private static reference variable called instance  which holds the reference of an \nobject of the T2 class Note that the T2 class uses its own private  constructor to create an object Its public static \ngetInstance  method returns the lone object of the class More than one object of the T2 class cannot exist\nYou can use the T2getInstance  method to get the reference of an object of the T2 class Internally \nthe T2 class does not create a new object every time you call the T2getInstance  method Rather it \nreturns the same object reference for all calls to this method\nT2 t1  T2getInstance\nT2 t2  T2getInstance\nSometimes you want a class to have only static members It may not make sense to create an object of \nsuch a class For example the javalangMath  class declares its constructor private The Math  class contains \nstatic variables and static methods to perform numeric operations It does not make sense to create an \nobject of the Math  class\nYou can also declare all constructors of a class private to prevent inheritance Inheritance lets you \ndefine a class by extending the definition of another class If you do not want anyone else to extend your \nclass one way to achieve this is to declare all constructors of your class private Another way to prevent your \nclass from being extended is to declare it final We discuss inheritance in detail in Chapter 20\nLets consider the class T3 whose constructor has a protected access level as shown\n T3java\npackage comjdojoclsp1\npublic class T3 \n    protected T3 \n    \n\nA cons tructor with a protected access level can be used anywhere in the same package or inside a \ndescendant class in any package The class T3 is in the comjdojoclsp1  package You can write the \nfollowing statement anywhere in the comjdojoclsp1  package which creates an object of the T3 class\n Valid anywhere in the comjdojoclsp1 package\nnew T3\nYou will learn more about inheritance in detail later However to complete the discussion of a protected \nconstructor you will use inheritance in the following example Things about inheritance will be clearer \nwhen we discuss it in Chapter 20 You inherit or extend a class using the keyword extends  The following \ncode creates a T3Child  class by inheriting it from the T3 class\n T3Childjava\npackage comjdojoclsp2\nimport comjdojoclsp1T3Chapter 9  Constru Ctors\n336public class T3Child extends T3 \n    public T3Child \n        super  Ok Calls T3 constructor which is declared protected\n    \n\nThe T3 class is called the parent class of the T3Child  class An object of a child class cannot be created \nuntil the object of its parent class is created Note the use of the super  statement inside T3Child  \nconstructors body The statement super  calls the protected constructor of the T3 class The super  \nkeyword is used to call the parent classs constructor as you use the keyword this  to call another constructor \nof the same class You cannot call the protected constructor of T3 directly as this is outside the comjdojo\nclsp1  package\nnew T3\nConsider a T4 class with a constructor having packagelevel access Recall that using no access level \nmodifier gives packagelevel access\n T4java\npackage comjdojoclsp1\npublic class T4 \n     T4 has packagelevel access\n    T4 \n    \n\nYou can use T4s constructor to create its object anywhere in the comjdojoclsp1  package \nSometimes you need a class that works as a helper class for other classes in a package Objects of these \nclasses need to be created only within the package You can specify packagelevel access for constructors of \nsuch helper classes\n Default Constructor\nThe primary goal of declaring a class is to create an object of its type You need a constructor to create an \nobject of a class The necessity to have a constructor for a class is so obvious that the Java compiler adds a \nconstructor to your class if you do not declare one The constructor that is added by the compiler is called \nthe default constructor  The default constructor does not have any parameters Sometimes the default \nconstructor is also called a noargs constructor  The access level of the default constructor is the same as the \naccess level of the class\nThe classes that you have been working with are called toplevel classes You can also declare a class \nwithin another class which is called an inner class  or nested  class A toplevel class can have public or \npackagelevel access However an inner class can have public private protected or packagelevel access \nThe Java compiler adds a default constructor for a toplevel class as well as for a nested class  A default \nconstructor for a toplevel class can have either public or packagelevel access depending on the access \nlevel of the class However a default constructor for an inner class can have access level of public private \nprotected or package level depending on its class access level\nTable 91 shows a few examples of classes and the compiler adding a default constructor to them \nWhen the compiler adds a default constructor it also adds a statement called super  to call the noargs \nconstructor of the parent class Sometimes the call to the parents noargs constructor inside the default \nconstructor may cause your class not to compile Refer to Chapter 20 for a complete discussion on this topicChapter 9  Constru Ctors\n337 Tip It is good programming practice to add a constructor explicitly to all your classes ra ther than letting \nthe compiler add a default constructor for your classes the stor y of constructors is not over yet You will revisit \nconstructors in Chapter 20\n A static Constructor\nConstructors are used in the context of creating a new object hence they are considered part of the object \ncontext not the class context You cannot declare a constructor static  The keyword this  which is a \nreference to the current object is available inside the body of constructors as it is available inside the body \nof all instance methodsTable 91  Examples of Classes for Which a Default Constructor Is Added by the Java Compiler\nSource Code for Your Class Compiled Version of Your \nClassComments\npublic class Test \npublic class Test \n    public Test \n    \nThe compiler adds a default constructor \nwith public level access\nclass Test \nclass Test \n    Test \n    \nThe compiler adds a default constructor \nwith packagelevel access\npublic class Test \n    Test \n     \npublic class Test \n    Test \n    \nThe Test  class already has a constructor \nThe compiler does not add any \nconstructor\npublic class Test \n    public Testint x \n    \npublic class Test \n    public Testint x \n    \nThe Test  class already has a constructor \nThe compiler does not add any \nconstructor\npublic class Test \n    private class Inner \n    \npublic class Test \n    public Test \n    \n    private class Inner \n        private Inner\n        \n    \nTest  is a public toplevel class and Inner  \nis a private inner class The compiler adds \na public  default constructor for the Test  \nclass and a private  default constructor for \nthe Inner  classChapter 9  Constru Ctors\n338 Instance Initialization Block\nYou have seen that a constructor is used to initialize an instance of a class An instance initialization \nblock also called instance initializer is also used to initialize objects of a class Why does Java provide two \nconstructs to perform the same thing\nNot all classes in Java can have a constructor Are you surprised to learn that not all classes can have \nconstructors Briefly this book mentioned inner classes which are different from toplevel classes There is \nanother type of class called an anonymous class  As the name suggests an anonymous class does not have a \nname Recall that a constructor is a named block of code whose name is the same as the simple name of the \nclass Because an anonymous class cannot have a name it cannot have a constructor either How will you \ninitialize an object of an anonymous class You can use an instance initializer to initialize an object of an \nanonymous class The use of an instance initializer to initialize an object is not limited only to anonymous \nclasses any type of class can use it to initialize its objects\nAn instance initializer is simply a block of code inside the body of a class but outside any methods or \nconstructors Recall that a block of code is a sequence of legal Java statements enclosed within braces An \ninstance initializer does not have a name Its code is simply placed inside an opening brace and a closing brace \nThe following snippet of code shows how to declare an instance initializer for a Test  class Note that an instance \ninitializer is executed in instance context and the keyword this  is available inside the instance initializer\npublic class Test \n    private int num\n     An instance initializer\n    \n        thisnum  101\n         Other code for the instance initializer goes here \n    \n     Other code for Test class goes here \n\nYou can have multiple instance initializers for a class All of them are executed automatically in textual \norder for every object you create Code for all instance initializers is executed before any constructors \nListing 97 demonstrates the sequence in which the constructor and instance initializers are executed\nListing 97  Exam ple of Using an Instance Initializer\n InstanceInitializerjava\npackage comjdojocls\npublic class InstanceInitializer \n    \n        SystemoutprintlnInside instance initializer 1\n    \n    \n        SystemoutprintlnInside instance initializer 2\n    \n    public InstanceInitializer \n        SystemoutprintlnInside noargs constructor\n    \n    public static void mainString args \n        InstanceInitializer ii  new InstanceInitializer\n    \nChapter 9  Constru Ctors\n339Inside instance initializer 1\nInside instance initializer 2\nInside noargs constructor\n Tip an instance initializer cannot ha ve a return  statement It cannot throw checked exceptions unless all \ndeclared constructors list those checked exceptions in their throws  clause an exception to this rule is made in \nthe case of an anonymous class because it does not have a constructor an instance initializer of an anonymous \nclass may throw checked exceptions\n Static Initialization Block\nA static initialization block is also known as a static initializer It is similar to an instance initialization block \nIt is used to initialize a class In other words you can initialize class variables inside a static initializer block \nAn instance initializer is executed once per object whereas a static initializer is executed only once for a \nclass when the class definition is loaded into the JVM\u00a0To differentiate it from an instance initializer you \nneed to use the static  keyword at the beginning of its declaration You can have multiple static initializers \nin a class All static initializers are executed in textual order in which they appear and are executed before \nany instance initializers Listing 98 demonstrates when a static initializer is executed\nListing 98  An Exam ple of Using a static Initializer in a Class\n StaticInitializerjava\npackage comjdojocls\npublic class StaticInitializer \n    private static int num\n     An instance initializer\n    \n        SystemoutprintlnInside instance initializer\n    \n     A static initializer Note the use of the keyword static below\n    static \n        num  1245\n        SystemoutprintlnInside static initializer\n    \n     Constructor\n    public StaticInitializer \n        SystemoutprintlnInside constructor\n    \n    public static void mainString args \n        SystemoutprintlnInside main 1 num   num\n         Declare a reference variable of the class\n        StaticInitializer si\n        SystemoutprintlnInside main 2 num   num\n         Create an object\n        new StaticInitializer\n        SystemoutprintlnInside main 3 num   num\n         Create another objectChapter 9  Constru Ctors\n340        new StaticInitializer\n    \n\nInside static initializer\nInside main 1 num 1245\nInside main 2 num 1245\nInside instance initializer\nInside constructor\nInside main 3 num 1245\nInside instance initializer\nInside constructor\nThe output may be confusing at first It shows that the static  initializer has executed even before the \nfirst message is displayed in the main  method You get the output when you run the StaticInitializer  \nclass using the following command\nCJava17Fundamentalsjava modulepath dist module jdojoclscomjdojocls\nStaticInitializer\nThe java  command must load the definition of the StaticInitializer  class before it can execute its \nmain  method When the definition of the StaticInitializer  class is loaded into memory at that time \nthe class is initialized and its static initializer is executed This is the reason that you see the message from \nthe static initializer before you see the message from the main  method Note that the instance initializer is \ncalled twice because you create two objects of the StaticInitializer  class\n Ti p a static  initializer cannot throw checked exceptions and it cannot have a return  statement\n The final Keyword\nThe final  keyword is used in many contexts in Java It takes on different meanings in different contexts \nHowever as its name suggests its primary meaning is the same in all contexts Its primary meaning is as \nfollows\nThe construct with which the final keyword is associated does not allow modifying or \nreplacing the original value or definition of the construct\nIf you remember the primary meaning of the final  keyword it will help you understand its specialized \nmeaning in a specific context The final  keyword can be used in the following three contexts\n\t A variable declaration\n\t A class declaration\n\t A method declarationChapter 9  Constru Ctors\n341In this section we discuss the use of the final  keyword only in the context of a variable declaration \nChapter 20 discusses its use in the context of class and method declarations in detail This section will briefly \ndescribe its meaning in all three contexts\nIf a variable is declared final  it can be assigned a value only once That is the value of a final  variable \ncannot be modified once it has been set If a class is declared final it cannot be extended or subclassed If \na method is declared final  it cannot be redefined overridden or hidden in the subclasses of the class that \ncontains the method\nLets discuss the use of the final  keyword in a variable declaration In this discussion a variable \ndeclaration means the declaration of a local variable a formal parameter of a methodconstructor an \ninstance variable and a class variable To declare a variable as final  you need to use the final  keyword in \nthe variables declaration The following snippet of code declares four final  variables YES NO MSG and act\nfinal int YES  1\nfinal int NO  2\nfinal String MSG  Goodbye\nfinal Account act  new Account\nYou can set the value of a final  variable only once Attempting to set the value of a final  variable the \nsecond time will generate a compiletime error\nfinal int x  10\nint y  101  x  Reading x is ok\n A compiletime error Cannot change value of the final variable x once it is set\nx  17\nThere are two ways to initialize a final  variable\n\t You can initialize it at the time of its declaration\n\t You can defer its initialization until a later time\nHow long you can defer the initialization of a final  variable depends on the variable type However you \nmust initialize the final  variable before it is read the first time\nIf you do not initialize a final  variable at the time of its declaration such a variable is known as a blank \nfinal variable  The following is an example of declaring a blank final variable\n A blank final variable\nfinal int multiplier\n Do something here \n Set the value of multiplier first time\nmultiplier  3\n Ok to read the multiplier variable\nint value  100  multiplier\nLets go through examples of each type of variable and see how to declare them final Chapter 9  Constru Ctors\n342 final Local Variables\nYou can declare a local variable final  If you declare a local variable as a blank final variable you must \ninitialize it before using You will receive a compiletime error if you try to change the value of the final local \nvariable the second time The following snippet of code uses final and blank final local variables in a test  \nmethod Comments in the code explain what you can do with the final  variables in the code\npublic static void test \n    int x  4          A variable\n    final int y  10  A final variable Cannot change y here onward\n    final int z        A blank final variable\n     We can read x and y and modify x\n    x  x  y\n     We cannot read z here because it is not initialized yet \n     Initialize the blank final variable z \n    z  87\n     Can read z now Cannot change z here onwards \n    x  x  y  z\n     Perform other logic here \n\n final Parameters\nYou can also declare a formal parameter final  A formal parameter is initialized automatically with the \nvalue of the actual parameter when the method or the constructor is invoked Therefore you cannot change \nthe value of a final formal parameter inside the methods or the constructors body The following snippet of \ncode shows the final formal parameter x for a test2  method\npublic void test2final int x \n     Can read x but cannot change it\n    int y  x  11\n     Perform other logic here \n\n final Instance Variables\nYou can declare an instance variable final and blank final An instance variable also known as a field  is \na part of an objects state A final instance variable specifies part of the objects state that does not change \nafter the object is created A blank final instance variable must be initialized when an object is created The \nfollowing rules apply to initializing a blank final instance variable\n\t It must be initialized in one of the instance initializers or all constructors The \nfollowing rules expand on this rule\n\t If it is initialized in an instance initializer it should not be initialized again in any \nother instance initializers or constructorsChapter 9  Constru Ctors\n343\t If it is not initialized in any of the instance initializers the compiler makes sure it \nis initialized only once when any of the constructors is invoked This rule can be \nbroken into two subrules As a rule of thumb a blank final instance variable must \nbe initialized in all constructors If you follow this rule a blank final instance variable \nwill be initialized multiple times if a constructor calls another constructor To avoid \nmultiple initialization of a blank final instance variable it should not be initialized in \na constructor if the first call in the constructor is a call to another constructor which \ninitializes the blank final instance variable\nThese rules for initializing a blank final instance variable may seem complex However it is simple to \nunderstand if you remember only one rulethat a blank final instance variable must be initialized once and \nonly once when any of the constructors of the class is invoked All of the previously described rules are to \nensure that this rule is followed\nLets consider different scenarios of initializing final and blank final instance variables We do not have \nanything to discuss about final instance variables where x is a final instance variable for the Test  class\npublic class Test \n    private final int x  10\n\nThe final  instance variable x has been initialized at the time of its declaration and its value cannot be \nchanged afterward The following code shows a Test2  class with a blank final instance variable named y\npublic class Test2 \n    private final int y  A blank final instance variable\n\nAttempting to compile the Test2  class generates an error because the blank final instance variable y \nis never initialized Note that the compiler will add a default constructor for the Test2  class but it will not \ninitialize y inside the constructor The following code for the Test2  class will compile because it initializes y \nin an instance initializer\npublic class Test2 \n    private final int y\n    \n        y  10  Initialized in an instance initializer\n    \n\nThe following code will not compile because it initializes y more than once inside two instance \ninitializers\npublic class Test2 \n    private final int y\n    \n        y  10  Initialized y for the first time\n    \n    \n        y  10  An error Initializing y again\n    \nChapter 9  Constru Ctors\n344This code may seem legal to you However it is not legal because two instance initializers are initializing \ny even though both of them set y to the same value 10 The rule is about the number of times a blank final \ninstance variable should be initialized irrespective of the value being used for its initializations Since all \ninstance initializers are executed when an object of the Test2  class is created y will be initialized twice \nwhich is not legal\nThe following code for the class Test2  with two constructors would compile\npublic class Test2 \n    private final int y\n    public Test \n        y  10  Initialize y\n    \n    public Testint z \n        y  z  Initialize y\n    \n\nThis code initializes the blank final instance variable y in both constructors It may seem that y is being \ninitialized twiceonce in each constructor Note that y is an instance variable and one copy of y exists \nfor each object of the Test2  class When an object of the Test2  class is created it will use one of the two \nconstructors not both Therefore for each object of the Test2  class y is initialized only once\nThe following is the modified code for the Test2  class which presents a tricky situation Both \nconstructors initialize the blank final instance variable y The tricky part is that the noargs constructor calls \nanother constructor\npublic class Test2 \n    private final int y\n    public Test \n        this20  Call another constructor\n        y  10    Initialize y\n    \n    public Testint z \n        y  z    Initialize y\n    \n\nThis code for the Test2  class does not compile The compiler generates an error message which reads \nas variable y might already have been assigned  Lets consider creating an object of the Test2  class as \nfollows\nTest2 t  new Test230\nThere is no issue in creating an object of the Test2  class by invoking the onearg constructor The blank \nfinal instance variable y is initialized only once Lets create an object of the Test2  class\nTest2 t2  new Test2Chapter 9  Constru Ctors\n345When the noargs constructor is used it calls the onearg constructor which initializes y to 20  \nThe noargs constructor initializes y again to 10 which is the second initialization for y For this reason the \nprevious code for the Test2  class would not compile You need to remove the initialization of y from the  \nnoargs constructor and the code would then compile The following is the modified code for the Test2  \nclass that would compile\npublic class Test2 \n    private final int y\n    public Test \n        this20  Another constructor will initialize y\n    \n    public Testint z \n        y  z     Initialize y\n    \n\n final Class Variables\nYou can declare a class variable final and blank final You must initialize a blank final class variable in one of \nthe static initializers If you have more than one static initializer for a class you must initialize all the blank \nfinal class variables only once in one of the static initializers\nThe following code for the Test3  class shows how to deal with a final class variable It is customary to \nuse all uppercase letters to name final class variables It is also a way to define constants  in Java programs \nThe Java class library has numerous examples where it defines public static final  variables to use them \nas constants\npublic class Test3 \n    public static final int YES  1\n    public static final int NO  2\n    public static final String MSG\n    static \n        MSG  I am a blank final static variable\n    \n\n final Reference Variables\nAny type of variables primitive and reference can be declared final The primary meaning of the final  \nkeyword is the same in both cases That is the value stored in a final  variable cannot be changed once it \nhas been set We cover the final reference variable in a little more detail in this section A reference variable \nstores the reference of an object A final reference variable means that once it references an object or null  \nit cannot be modified to reference another object Consider the following statement\nfinal Account act  new Account\nHere act is a final  reference variable of the Account  type It is initialized at the time of its declaration \nAt this time act is referencing an object in memoryChapter 9  Constru Ctors\n346Now you cannot make the act variable reference another object in memory The following statement \ngenerates a compiletime error\nact  new Account  A compiletime error Cannot change act\nA common misconception arises in this case Mistakenly programmers believe that the Account  object \nthat is referenced by the act reference variable cannot be changed The declaration statement of the act \nreference variable as final has two things\n\t An act as a reference variable which is final\n\t An Account  object in memory whose reference is stored in the act variable\nIt is the act reference variable that cannot be changed not the Account  object it is referencing If the \nAccount  class allows you to change the state of its object you can change the state using the act variable \nThe following are valid statements which modify the balance  instance variable of the Account  object\nactdeposit200100  Modifies state of the Account object\nactdebit200        Modifies state of the Account object\nIf you do not want an object of a class to be modified after it is created you need to include that logic in \nthe class design The class should not let any of its instance variables be modified after the object is created \nSuch objects are called immutable objects \n CompileTime vs Runtime final Variables\nYou use final  variables to define constants This is the reason that final  variables are also called constants \nIf the value of a final  variable can be computed by the compiler at compile time such a variable is a \ncompiletime constant  If the value of a final  variable cannot be computed by the compiler it is a runtime \nfinal variable  The values of all blank final variables are not known until runtime References are not \ncomputed until runtime Therefore all blank final variables and final reference variables are runtime \nconstants \nJava performs an optimization when you use compiletime constants in an expression It replaces the \nuse of the compiletime constant with the actual value of the constant Suppose you have a Constants  class \nas follows which declares a static final variable named MULTIPLIER \npublic class Constants \n    public static final int MULTIPLIER  12\n\nConsider the following statement\nint x  100  ConstantsMULTIPLIER\nWhen you compile this statement the compiler will replace ConstantsMULTIPLIER  with its value 12 \nand your statement is compiled as follows\nint x  100  12Chapter 9  Constru Ctors\n347Now 100  12 is also a compiletime constant expression The compiler will replace it with its value \n1200 and your original statement will be compiled as follows\nint x  1200\nThere is one downside of this compiler optimization If you change the value of the MULTIPLIER final  \nvariable in the Constants  class you must recompile all the classes that refer to the ConstantsMULTIPLIER  \nvariable Otherwise they will continue using the old value of the MULTIPLIER  constant that existed when they \nwere compiled last time\n Generic Classes\nAbstraction and polymorphism are at the heart of objectoriented programming Defining a variable is an \nexample of abstraction where the variable hides the actual values and the location where the values are \nstored Defining a method hides the details of its implementation logic which is another form of abstraction \nDefining parameters for a method is part of polymorphism that allows the method to work on different types \nof values or objects\nJava has a feature called generics  that allows for writing true polymorphic code in Java Using generics \nyou can write code without knowing the type of the objects your code operates on It lets you create generic \nclasses constructors and methods\nA generic class is defined using formal type parameters Formal type parameters are a list of  \ncommaseparated variable names placed in angle brackets   after the class name in the class declaration \nThe following snippet of code declares a generic class Wrapper  that takes one formal type parameter\npublic class WrapperT   \n     Code for the Wrapper class goes here\n\nThe parameter has been given a name T What is T at this point The answer is that you do not know All \nyou know at this point is that T is a type variable which could be any reference type in Java such as String  \nInteger  Double  Human  Account  etc The formal type parameter value is specified when the Wrapper  class \nwill be used The classes that take formal type parameters are also known as parameterized classes \nYou can declare a variable of the WrapperT  class by specifying the String  type as the value for its \nformal type parameter as shown here Here String  is the actual type parameter\nWrapperString stringWrapper\nJava lets you use a generic class without specifying the formal type parameters This is allowed for \nbackward compatibility You can also declare a variable of the WrapperT  class as shown\nWrapper aRawWrapper\nWhen a generic class is used without specifying the actual type parameters it is known as raw type  The \nprevious declaration used the WrapperT  class as a raw type as it did not specify the value for T\n Ti p t he actual type parameter for a generic class if specified must be a reference type for example \nString  Human  etc primitive types are not allowed as the actual type parameters for a generic classChapter 9  Constru Ctors\n348A class may take more than one formal type parameter The following snippet of code declares a Mapper  \nclass that takes two formal parameters named T and R\npublic class MapperTR   \n     Code for the Mapper class goes here\n\nYou can declare a variable of the MapperT R  class as follows\nMapperStringInteger mapper\nHere the actual type parameters are String  and Integer \nIt is customary not a requirement to give onecharacter names to the formal type parameters for \nexample T R U V etc Typically T stands for Type  R for Return  etc Onecharacter names make the code \nmore readable However nothing stops you from declaring a generic class as follows which has four formal \ntype parameters named MyType  YourType  Hello  and WhoCares \npublic class FunMyType YourType Hello WhoCares \n     Code for the Fun class goes here\n\nJava will compile the Fun class but readers of your code will complain for sure The formal type \nparameters are available inside the class body to be used as types There is another option which is clearer \nto use all capital letters such as\npublic class Fun2TYPE1 TYPE2 RETURNTYPE \n     Code for the Fun2 class goes here\n\nListing 99 declares a generic class WrapperT  an example of using generics in Java\nListing 99  Declaring a Generic Class WrapperT\n Wrapperjava\npackage comjdojocls\npublic class WrapperT \n    private T obj\n    public WrapperT obj \n        thisobj  obj\n    \n    public T get \n        return obj\n    \n    public void setT obj \n        thisobj  obj\n    \n\nThe WrapperT  class uses the formal type parameter to declare instance variable obj to declare a \nformal parameter for its constructor and set  method and as a return type for the get  methodChapter 9  Constru Ctors\n349You can create an object of the generic type by specifying the actual type parameter for the constructor \nas follows\nWrapperString w1  new WrapperStringHello\nMost of the time the compiler can infer the actual type parameter for the constructor In those cases \nyou can omit the actual type parameter In the following assignment statement the compiler will infer the \nactual type parameter for the constructor as String this  is called the  diamond operator \nWrapperString w1  new WrapperHello\nOnce you have declared a variable of the generic class you can think of the formal type parameter as \nthe specified actual type parameter for all practical purposes Now you can think that for w1 the get  \nmethod of the WrapperT  class returns a String \nString s1  w1get\nThe program in Listing 910  shows how to use the generic WrapperT  class\nListing 910  Using a Generic Class in Your Code\n WrapperTestjava\npackage comjdojocls\npublic class WrapperTest \n    public static void mainString args \n        WrapperString w1  new WrapperHello\n        String s1  w1get\n        Systemoutprintlns1  s1\n        w1setTesting generics\n        String s2  w1get\n        Systemoutprintlns2  s2\n        w1setnull\n        String s3  w1get\n        Systemoutprintlns3  s3\n    \n\ns1Hello\ns2Testing generics\ns3null\nThis is just the tip of the iceberg when it comes to what generics offer in Java To understand generics \ncompletely you must cover other topics such as inheritance firstChapter 9  Constru Ctors\n350 Summary\nA constructor is a named block of code that is used to initialize an object of a class immediately after the \nobject is created The structure of a constructor looks similar to a method However they are two different \nconstructs and they are used for different purposes The name of a constructor is the same as the simple \nname of the class Like methods constructors may accept parameters Unlike methods constructors cannot \nspecify a return type A constructor is used with the new operator which allocates memory for a new object \nand the constructor initializes the new object A constructor does not return a value to its caller You can use \na return  statement without an expression inside a constructor The return  statement ends the constructor \ncall and returns the control to the caller\nConstructors are not considered members of the class Like fields and methods constructors also have \nan access level public private protected or package level The presence of the keyword public  private  or \nprotected  in defining them gives them a public private or protected access level respectively Absence of \nany of these keywords specifies the packagelevel access\nA class can have more than one constructor If a class has multiple constructors they are called \noverloaded constructors Since the name of the constructor must be the same as the simple name of the \nclass there is a need to differentiate one constructor from another All constrictors of a class must differ from \nthe others in number order or type of parameters\nA constructor may call another constructor of the same class using the keyword this  as if it were a method \nname If a constructor of a class calls another constructor of the same class the following rules must be met\n\t The call to another constructor must be the first statement in the constructor\n\t A constructor cannot call itself\nIf you do not add a constructor to your class the Java compiler adds one Such a constructor is called a \ndefault constructor  The default constructor has the same access level as its class and it takes no parameters\nA class can also have one or more instance initializers to initialize objects of the class An instance \ninitializer is simply a block of code inside the body of a class but outside any methods or constructors Recall \nthat a block of code is a sequence of legal Java statements enclosed within braces An instance initializer \ndoes not have a name Its code is simply placed inside an opening brace and a closing brace When an object \nof a class is created all instance initializers of the class are executed in textual order Typically instance \ninitializers are used to initialize an object of an anonymous class\nA class can have one or more static initializers which are used to initialize a class typically class \nvariables An instance initializer is executed once per object whereas a static initializer is executed only \nonce for a class when the class definition is loaded into the JVM\u00a0To differentiate it from an instance \ninitializer you need to use the static  keyword in the beginning of its declaration All static initializers of a \nclass are executed in textual order in which they appear and are executed before any instance initializers\nYou can define a class and its members final If something is final it means its definition or value \nwhatever it represents cannot be modified Final variables are used to define constants in Java Compile\ntime constants are constants whose values are known when the program is compiled Runtime constants are \nconstants whose values are not known until the program is run\nA variable can be declared blank final in which case the variable is declared final but not assigned \na value at the time of declaration A blank final variable must be assigned a value before its value is read \nA blank final instance variable must be initialized once in its instance initializers or constructors You can \ndeclare a class variable as a blank final You must initialize a blank final class variable in one of the static \ninitializers If you have more than one static initializer for a class you must initialize all the blank final class \nvariables only once in one of the static initializers\nJava allows you to write true polymorphic code using generics in which code is written in terms of \nformal type parameters A generic class is defined using formal type parameters Formal type parameters \nare a list of commaseparated variable names placed in angle brackets   after the class name in the class \ndeclaration Classes that take formal type parameters are also known as parameterized classes  The actual \ntype parameters are specified when the parameterized classes are usedChapter 9  Constru Ctors\n351EXERCISES\n 1 What is a constructor What is the name of the operator that must be used along \nwith a constructor to create an object of a class\n 2 What is a default constructor What is the access level of a default constructor\n 3 how do you call a constructor of a class from another constructor of the same \nclass Describe any restrictions where such a call should be placed in the code\n 4 What are static and instance initializers\n 5 What are final  variables and blank final variables\n 6 What is the effect of declaring a methods parameter or a constructors parameter \nfinal\n 7 Consider the follo wing code for a Cat class\n Catjava\npackage comjdojoclsexcercise\npublic class Cat \n\nWhen the Cat class is compiled the compiler will add a default constructor to it \nrewrite the Cat class as if you were adding the default constructor instead of the \ncompiler\n 8 Consider the follo wing code for a Mouse  class\n Mousejava\npackage comjdojoclsexcercise\nclass Mouse \n\nWhen the Mouse  class is compiled the compiler will add a default constructor to \nit rewrite the Mouse  class as if you were adding the default constructor instead of \nthe compiler\n 9 Create a SmartPoint2D  class with two int instance variables named x and y \nthe instance variables should be declared private and final an instance of the \nSmartPoint2D  class represents an immutable point in a 2D plane that is once an \nobject of the SmartPoint2D  class is created the x and y values of that object cannot \nbe changed add a public constructor to the class which should accept the values for \nthe two instance variables x and y and initialize them with the passedin values\n 10 add getters for the x and y instance variables in the SmartPoint2D  class that you \ncreated in the previous exercise\n 11 add a public static final  variable named ORIGIN  to the SmartPoint2D  \nclass the ORIGIN  variable is of the SmartPoint2D  class and it is a \nSmartPoint2D  with x  0 and y  0Chapter 9  Constru Ctors\n352 12 Implement a method named distance  in the SmartPoint2D  class that \nyou created in the previous exercise the method accepts an instance of the \nSmartPoint2D  class and returns the distance between the current point and the \npoint represented by the parameter the method should be declared as follows\npublic class SmartPoint2D \n     Code from the previous exercise goes here \n    public double distanceSmartPoint2D p \n         Your code for this exercise goes here \n    \n\n Hint the distance between two points x1 y1  and x2 y2  is computed as x2x12  y2y12 \nYou can use the Mathsqrtn  method to compute the square root of a number n\n 13 Create a Circle  class that has three private final instance variables named x y \nand radius  the x and y instance variables represent the x and y coordinates of \nthe center of the circle they are of int data type the radius  instance variable \nrepresents the radius of the circle it is of the double  data type add a constructor \nto the Circle  class that accepts the values for its instance variables x y and \nradius  add getters for the three instance variables\n 14 enhance the Circle  class by adding four instance methods named \ncenterDistance  distance  overlaps  and touches  all these methods \naccept a Circle  as a parameter the centerDistance  method returns the \ndistance as a double  between the centers of the circle and another circle passed \nin as the parameter the distance  method returns the minimum distance as a \ndouble  between the two circles If two circles overlap the distance  method \nreturns a negative number the overlaps  method returns true  if two circles \noverlap and false  otherwise the touches  method returns true  if two circles \ntouch each other and false  otherwise the distance  method must use the \ncenterDistance  method the body of the overlaps  and touches  methods \nmust contain only one statement that uses the distance  method\n Hint the distance between two circles is the distance between their centers minus their radii two circ les \noverlap if the distance between them is negative two circ les touch if the distance between them is zero\n 15 enhance the Circle  class by adding two methods named perimeter  and area  \nthat compute and return the perimeter and area of the circle respectively\n 16 add a second constructor to the Circle  class that takes a double  parameter \nwhich is the radius of the circle this constructor should call another existing \nconstructor of the Circle  class with three parameters passing zero as the values \nfor x and yChapter 9  Constru Ctors\n353 17 a double value can be NaN positive infinity and negative infinity enhance the \nconstructor of the Circle  class with three parameters x y and radius  so it \nthrows a RuntimeException  when the value of the radius  parameter is not a \nfinite number or a negative number\n Hint the javalangDouble  class contains a static isFinitedouble n  method which returns \ntrue  if the specified parameter n is a finite number and false  otherwise use the following statement to throw \na RuntimeException \nthrow new RuntimeException\n           Radius must be a finite nonnegative number\n 18 Consider the follo wing InitializerTest  class how many static and instance \ninitializers are in this class What will be printed when this class is run\n InitializerTestjava\npackage comjdojoclsexcercise\npublic class InitializerTest \n    private static int count\n    \n        Systemoutprintlncount\n    \n    \n        Systemoutprintlncount\n    \n    static \n        Systemoutprintlncount\n    \n    public static void mainString args \n        new InitializerTest\n        new InitializerTest\n    \n\n 19 Describe why the follo wing FinalTest  class does not compile\n FinalTestjava\npackage comjdojoclsexcercise\npublic class FinalTest \n    public static int squarefinal int x \n        x  x  x\n        return x\n    \nChapter 9  Constru Ctors\n354 20 Describe why the follo wing BlankFinalTest  class does not compile\n BlankFinalTestjava\npackage comjdojoclsexcercise\npublic class BlankFinalTest \n    private final int x\n    private final int y\n    \n        y  100\n    \n    public BlankFinalTest \n        y  100\n    \n     More code goes here \n355\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307410CHAPTER 10\nModules\nIn this chapter you will learn\n\t What modules are\n\t How to declare modules\n\t What the implicit readability of a module means and how to declare it\n\t The difference between unqualified and qualified exports\n\t Declaring the runtime optional dependency of a module\n\t How to open an entire module or its selected packages for deep reflection\n\t Rules on splitting packages across modules\n\t Restrictions on module declarations\n\t Different types of modules named unnamed explicit automatic normal and open \nmodules\n\t Knowing about modules at runtime\n\t How to disassemble a modules definition using the javap  tool\nThe code for some examples in this chapter goes through several steps The source code for this book \ncontains the code used in the final step for those examples If you want to see those examples in action at \nevery step as you read through this chapter you need to modify the source code a bit to keep it in sync with \nthe step you are working on\n What Is a\u00a0Module\nIn simple terms a module is a group of packages A module may optionally contain resources such as images \nproperty files etc For now lets focus only on a module being a group of packages A module specifies the \naccessibility for its packages to other modules and its dependence on other modules The accessibility of \na package in a module determines whether other modules can access the package The dependence of a \nmodule determines the list of other modules that this module reads Three termsdepends on  reads  and \nrequiresare used interchangeably to indicate dependence of a module on another module If module M \ndepends on module N the following three phrases mean the same Module M depends on module N Module \nM requires module N or Module M reads module NChapter 10  Modules\n356By default a package in a module is accessible only within the same module If a package in a module \nneeds to be accessible outside its module the module that contains the package needs to export  the \npackage A module may export its packages to all other modules or only to a selected list of other modules\nIf a module wants to access packages from another module the first module must declare dependence \non the second module and the second module must export packages in order for them to be accessible to \nthe first module\n Declaring Modules\nA module is declared in a compilation unit This book introduced the concept of the compilation unit in \nChapter 3 in which a compilation unit contained type declarations class and interface declarations  \nA compilation unit that contains a module declaration is different from a compilation unit that contains type \ndeclarations Starting in Java 9 there are two types of compilation units\n\t Ordinary compilation unit\n\t Modular compilation unit\nAn ordinary compilation unit consists of three parts a package declaration import declarations and \ntoplevel type declarations All parts in an ordinary compilation unit are optional Refer to Chapter 3 for \nmore details on ordinary compilation units\nA modular compilation unit contains a module declaration The module declaration may be preceded \nby optional import declarations A modular compilation unit cannot have a package declaration Import \ndeclarations in a modular compilation unit let you use the simple names of types and static members of \ntypes in the module declaration\n Tip a modular compila tion unit is named moduleinfo  with an extension java  or jav  all modular \ncompilation units in this books examples are named moduleinfojava \nThe syntax to use a modular compilation unit is as follows\nimportdeclarations\nmoduledeclaration\nTypes used in import declarations may be from packages in the same module or other modules Refer \nto Chapter 7 for more details on how to use import declarations The syntax for a module declaration is as \nfollows\nopen module modulename \n    modulestatement1\n    modulestatement2\n    \n\nThe module  keyword is used to declare a module A module declaration may optionally start with the \nopen  keyword to declare an open module which will be described later The module  keyword is followed \nwith a module name A module name  is a qualified Java identifier which is a sequence of one or more Java \nidentifiers separated by a dot similar to package namesChapter 10  Modules\n357The body of the module declaration is placed inside curly braces which may have zero or more module \nstatements Module statements are also known as module  directives  This book uses the term statement not \ndirective There are five types of module statements\n\t The exports  statement\n\t The opens  statement\n\t The requires  statement\n\t The uses  statement\n\t The provides  statement\nFor one module to access types in another module the second module makes the packages containing \nsuch types accessible and the first module reads the second module All five types of module statements are \nused for these two purposes\n\t Making types accessible\n\t Accessing those types\nThe exports  opens  and provides  statements express availability of types in a module to other \nmodules The requires  and uses  statements in a module are used to express dependence of a module to \nread types that are made available using the exports  opens  and provides  statements by other modules \nThe difference in these types of statements lies in the context in which the types are made available by a \nmodule and those types are used by other modules The following is an example of a module declaration \nthat contains all five types of module statements\nmodule jdojopolicy \n    exports comjdojopolicy\n    requires javasql\n    opens comjdojopolicymodel\n    uses comjdojocommonJob\n    provides comjdojocommonJob with comjdojopolicyJobImpl\n\nThe following terms are restricted keywords in Java open  module  requires  transitive  exports  \nopens  to uses  provides  and with  They are treated as keywords only when they appear in a modular \ncompilation unit at specific positions They are normal terms everywhere else For example the following \nmodule declaration is valid even though the module name which is  module   is not very intuitive\nmodule module \n    exports comjdojopolicy\n\nHere the first module term is a restricted keyword and the second one is a normal term used as the \nname of the module\nThe subsequent sections describe the exports  and requires  statements in detail We explain the opens  \nstatement briefly in this chapterChapter 10  Modules\n358 Declaring Module Dependence\nUp to Java SE 8 a public type in one package could be accessed by other packages without any restrictions \nIn other words packages did not control the accessibility of the types they contained The module system in \nJava SE 9 and above provides a finegrained control over the accessibility of types contained in packages of a \nmodule\nAccessibility across modules is a twoway agreement between the used module and the using module \nA module explicitly makes its public types available to other modules for use and the modules using those \npublic types explicitly declare dependence on the first module All nonexported packages of a module are \nprivate to the module and they cannot be accessed from outside the module\nMaking public types in a package available to other modules is known as exporting  that package and it \nis accomplished using an exports  statement in the modules declaration A module may export its packages \nto all other modules or to a selected list of modules When a module exports its package to all other modules \nit is called an unqualified export  The following is the syntax to export a package to all other modules\nexports package\nHere package  is the package in the current module All other modules that read the current module \ncan use the public types in this package Consider the following declaration\nmodule jdojoaddress \n    exports comjdojoaddress\n\nThe jdojoaddress  module exports a package named comjdojoaddress  to all other modules All \nother packages in the jdojoaddress  module are accessible only within the jdojoaddress  module\nA module can also export a package selectively only to one or more named modules Such exports are \ncalled qualified exports  or modulefriendly exports  The public types in a package in a qualified export are \naccessible only to the specified named modules The following is the syntax for using a qualified export\nexports package to friendmodule  friendmodule \nHere package  is a package in the current module which is exported only to friend modules listed \nin the to  clause The following is a module declaration for a jdojopolicy  module that uses a qualified \nexport\nmodule jdojopolicy \n    exports comjdojopolicy to jdojoclaim jdojopayment\n\nThe jdojopolicy  module contains a package named comjdojopolicy  The module uses a qualified \nexport to export this package to only two modules jdojoclaim  and jdojopayment \n Ti p Modules specified in the to clause of a qualified export do not need to be observable\nWhich one is better to usean unqualified export or a qualified export An unqualified export should \nbe used when you are sharing public types in a package to the public for example when you are developing \na module for public use Once you distribute your module you should not be changing the public APIs in \nthe exported packages Sometimes bad APIs remain in a module forever because the module is in public Chapter 10  Modules\n359use and changingremoving the APIs will impact a lot of users Sometimes you may need to share public \ntypes between modules where the modules are part of a library or framework however public types in those \nmodules are not for public use In such cases you should use qualified exports which will minimize the \nimpact should you change the APIs involving those shared public types The javabase  module uses several \nqualified exports to export its packages to other JDK modules You can describe the javabase  module using \nthe following command to list qualified exports\nC java describemodule javabase\njavabase17\nexports javaio\nexports javalang\n\nqualified exports jdkinternalorgxmlsax to jdkjfr\nqualified exports sunsecuritytools to jdkjartool\n\ncontains suninvoke\ncontains suninvokeutil\ncontains sunio\n\nA requires  statement is used to specify a modules dependence on another module If a module reads \nanother module the first module needs to have a requires  statement in its declaration The general syntax \nfor the requires  statement is as follows\nrequires transitive static module\nHere module  is the name of the module that the current module reads Both transitive  and static  \nmodifiers are optional If the static  modifier is present the dependence on module  is mandatory at \ncompile time but optional at runtime Without the static  modifier the read module is required at compile \ntime and runtime The presence of the transitive  modifier implies that a module that reads the current \nmodule implicitly also reads module  We will cover an example of using the transitive  modifier in a \nrequires  statement shortly The following is an example of using a requires  statement\nmodule jdojoclaim \n    requires jdojopolicy\n\nHere the jdojoclaim  module uses a requires  statement to indicate that it reads the jdojopolicy  \nmodule All public types from all exported packages in the jdojopolicy  module are accessible inside the \njdojoclaim  module\nEvery module implicitly reads the javabase  module The compiler adds a requires  statement to read \nthe javabase  module to a module declaration if the declaration does not explicitly read the javabase  \nmodule The following two module declarations for a jdojocommon  module are the same\n Declaration 1\nmodule jdojocommon \n     The compiler will add a dependence to the javabase module\n\n Declaration 2Chapter 10  Modules\n360module jdojocommon \n     Add a dependence to the javabase module explicitly\n    requires javabase\n\nYou can visualize dependence between two modules as depicted in Figure\u00a0 101  which depicts the \ndependence between two example modules named jdojopolicy  and jdojoclaim \nThe jdojopolicy  module contains two packages named comjdojopolicy  and comjdojopolicy\nimpl  it exports the comjdojopolicy  package which is shown in a dashed boundary to distinguish it \nfrom the comjdojopolicyimpl  package which is not exported The jdojoclaim  module contains two \npackages comjdojoclaim  and comjdojoclaimimpl  it does not export any package and declares a \ndependence on the jdojopolicy  module The following two module declarations express this dependence \nin Java code\nmodule jdojopolicy \n    exports comjdojopolicy\n\nmodule jdojoclaim \n    requires jdojopolicy\n\n Tip the dependence dec larations in two modules the used module and the using module are \nasymmetricthe used module exports a package  whereas the using module requires a module \n An Example of\u00a0Module Dependence\nIn this section we walk you through a complete example of using module dependence Suppose you have \ntwo modules named jdojoaddress  and jdojoperson  The jdojoaddress  module contains a package \nnamed comjdojoaddress  which contains a class named Address  The jdojoperson  module wants to \nuse the Address  class from the jdojoaddress  module Figure\u00a0 102  shows the module graph for the jdojo\nperson module Figure 101  Declaring dependency between modulesChapter 10  Modules\n361In NetBeans you can create two modules named jdojoaddress  and jdojoperson  Listings 101  and \n102  contain the module declaration and the code for the Address  class\nListing 101  The M odule Declaration for the jdojoaddress Module\n moduleinfojava\nmodule jdojoaddress \n     Export the comjdojoaddress package\n    exports comjdojoaddress\n\nListing 102  The A ddress Class\n Addressjava\npackage comjdojoaddress\npublic class Address \n    private String line1  1111 Main Blvd\n    private String city  Jacksonville\n    private String state  FL\n    private String zip  32256\n    public Address \n    \n    public AddressString line1 String city String state String zip \n        thisline1  line1\n        thiscity  city\n        thisstate  state\n        thiszip  zip\n    \n    public String getLine1 \n        return line1\n    \nFigure 102  The mo dule graph for the jdojoperson moduleChapter 10  Modules\n362    public void setLine1String line1 \n        thisline1  line1\n    \n    public String getCity \n        return city\n    \n    public void setCityString city \n        thiscity  city\n    \n    public String getState \n        return state\n    \n    public void setStateString state \n        thisstate  state\n    \n    public String getZip \n        return zip\n    \n    public void setZipString zip \n        thiszip  zip\n    \n    Override\n    public String toString \n        return Line1  line1   State  state \n                City  city   ZIP  zip  \n    \n\nThe Address  class is a simple class with four fields and their getters and setters The default values are \nset for these fields so you dont have to type them in examples A toString  method in the Address  class \nreturns a string representation of the Address object this book covers the use of the toString  method in \ndetail in Chapters 11 and 20\nThe jdojoaddress  module exports the comjdojoaddress  package so the Address  class which is \npublic and in the exported comjdojoaddress  package can be used by other modules You will be using \nthe Address  class in the jdojoperson  module in this example Listings 103  and 104  contain the module \ndeclaration for the jdojoperson  module and the code for the Person  class\nListing 103  The M odule Declaration for the jdojoperson Module\n moduleinfojava\nmodule jdojoperson \n     Read the jdojoaddress module\n    requires jdojoaddress\n     Export the comjdojoperson package\n    exports comjdojoperson\nChapter 10  Modules\n363Listing 104  A Person Class\n Personjava\npackage comjdojoperson\nimport comjdojoaddressAddress\npublic class Person \n    private long personId\n    private String firstName\n    private String lastName\n    private Address address  new Address\n    public Personlong personId String firstName String lastName \n        thispersonId  personId\n        thisfirstName  firstName\n        thislastName  lastName\n    \n    public long getPersonId \n        return personId\n    \n    public void setPersonIdlong personId \n        thispersonId  personId\n    \n    public String getFirstName \n        return firstName\n    \n    public void setFirstNameString firstName \n        thisfirstName  firstName\n    \n    public String getLastName \n        return lastName\n    \n    public void setLastNameString lastName \n        thislastName  lastName\n    \n    public Address getAddress \n        return address\n    \n    public void setAddressAddress address \n        thisaddress  address\n    \n    Override\n    public String toString \n        return Person Id  personId   First Name  firstName \n                Last Name  lastName   Address  address  \n    \n\nThe Person  class is in the jdojoperson  module and it uses a field of the Address  type which is in the \njdojoaddress  module This means that the jdojoperson  module reads the jdojoaddress  module This \nis indicated by the requires  statement in the jdojoperson  module declaration\n Read the jdojoaddress module\nrequires jdojoaddressChapter 10  Modules\n364The declaration of the jdojoperson  module includes a requires  statement without a static  modifier \nimplying that the jdojoaddress  module is required at compile time as well as at runtime When you \ncompile the jdojoperson  module you must include the jdojoaddress  module in the module path In \nthe supplied source code these two modules are part of a single NetBeans modular project and you do not \nneed to perform an additional step to modify the module path\nIf you create the two modules using two separate NetBeans projects you need to include the project for \nthe jdojoaddress  module in the module path of the jdojoperson  module Rightclick the jdojoperson  \nproject in NetBeans and select Properties In the Categories list select Libraries Select the Compile tab and \nclick the  sign on the Modulepath row Select the Add Project from the menu as shown in Figure\u00a0 103  \nand select the jdojoaddress  NetBeans project from the file system If you have a compiled jdojoaddress  \nmodule in a modular JAR or a directory you can use the Add JARFolder menu option\nThe jdojoperson  module also exports the comjdojoperson  package so the public types in this \npackage for example the Person  class may be used by other modules Listing 105  contains the code for a \nMain  class which is in the jdojoperson  module\nFigure 103  Setting the module path for a project in NetBeansChapter 10  Modules\n365Listing 105  A M ain Class to Test the jdojoperson Module\n Mainjava\npackage comjdojoperson\nimport comjdojoaddressAddress\npublic class Main \n    public static void mainString args \n        Person john  new Person1001 John Jacobs\n        String fName  johngetFirstName\n        String lName  johngetLastName\n        Address addr  johngetAddress\n        Systemoutprintfs sn fName lName\n        Systemoutprintfsn addrgetLine1\n        Systemoutprintfs s sn addrgetCity\n                          addrgetState addrgetZip\n    \n\nJohn Jacobs\n1111 Main Blvd\nJacksonville FL 32256\nWhen you run this class the output shows that you are able to use the Address  class from the jdojo\naddress  module We are done with this example that shows how to use the exports  and requires  module \nstatements If you have any trouble running this example refer to the next section which lists a few possible \nerrors and their solutions\nAt this point you can also run this example using a command prompt You will need to include the \ncompiled exploded directories or the modular JARs for the jdojoperson  and jdojoaddress  modules in \nthe module path The following command uses the modular JARs from the dist  directory\nCJavaFunjava modulepath distjdojopersonjardistjdojoaddressjar module jdojo\npersoncomjdojopersonMain\nJohn Jacobs\n1111 Main Blvd\nJacksonville FL 32256\nThe supplied source code for this book contains all modular JARs in the JavaFundist  directory In the \nprevious command we selectively included the modular JARs for the jdojoperson  and jdojoaddress  \nmodules to show you that all other modules are not being used when you run the comjdojopersonMain  \nclass You can simplify this command by adding only the dist  directory to the module path as follows and \nthe Java runtime will use the needed two modules as before\nCJavaFunjava modulepath dist module jdojopersoncomjdojopersonMain\nJohn Jacobs\n1111 Main Blvd\nJacksonville FL 32256Chapter 10  Modules\n366 Troubleshooting\nIf you are using the JDK for the first time a number of things can go wrong when you are working through \nthis example The following are a few scenarios with error messages and the corresponding solutions\n Empty Package Error\nThe error is\nerror package is empty or does not exist comjdojoaddress\n    exports comjdojoaddress\n                     \n1 error\nYou get this error when you compile the module declaration for the jdojoaddress  module without \nincluding the source code for the Address  class The module exports the comjdojoaddress  package You \nmust have at least one type defined in the exported package\n Module Not Found Error\nThe error is\nerror module not found jdojoaddress\n    requires jdojoaddress\n                      \n1 error\nYou get this error when you compile the module declaration for the jdojoperson  module without \nincluding the jdojoaddress  module in the module path The jdojoperson  module reads the jdojo\naddress  module so the former must be able to find the latter on the module path at compile time as well as \nat runtime If you are using a command prompt use the modulepath  option to specify the module path \nfor the jdojoaddress  module If you are using NetBeans refer to the previous section on how to configure \nthe module path for the jdojoperson  module\n Package Does Not Exist Error\nThe error is\nerror package comjdojoaddress does not exist\nimport comjdojoaddressAddress\n                        \nerror cannot find symbol\n    private Address address  new Address\n            \n  symbol   class Address\n  location class PersonChapter 10  Modules\n367You get this error when you compile the Person  and Main  classes in the jdojoperson  module without \nadding a proper requires  statement in the module declaration The error message states that the compiler is \nnot able to find the comjdojoaddressAddress  class The solution is to add a  requires jdojoaddress  \nstatement to the module declaration for the jdojoperson  module and add the jdojoaddress  module to \nthe module path while compiling and running the jdojoperson  module\n Module Resolution Exception\nThe partial error is\nError occurred during initialization of VM\njavalangmoduleResolutionException Module jdojoperson not found\n\nYou may get this error for the following reasons when you attempt to run the example using a command \nprompt\n\t The module path is not specified correctly\n\t The module path is correct but no compiled code in the specified directories or \nmodular JARs is found on the module path\nSuppose you use the following command to run the example\nCJavaFunjava modulepath dist module jdojopersoncomjdojopersonMain\nMake sure that the following modular JARs exist\n\tCJavaFundistjdojopersonjar\n\tCJavaFundistjdojoaddressjar\nIf these modular JARs do not exist build the JavaFun  project in NetBeans If you are running the \nexample using the module code from the exploded directories using the following command make sure to \ncompile the projects in NetBeans\nCJavaFunjava modulepath buildmodulesjdojopersonbuildmodulesjdojoaddress\nmodule jdojopersoncomjdojopersonMain\n Implicit Dependence\nIf a module can read another module without the first module including in its declaration a requires  \nstatement to read the second module it is said that the first module implicitly reads the second module \nEvery module implicitly reads the javabase  module An implicit read is not limited to the javabase  \nmodule A module can also implicitly read another module other than the javabase  module Before we \nshow you how to add an implicit readability to a module we will build an example to show you why we need \nthis featureChapter 10  Modules\n368In the previous section you created two modules named jdojoaddress  and jdojoperson  where the \nsecond module reads the first module using the following declaration\nmodule jdojoperson \n    requires comjdojoaddress\n    \n\nThe Person  class in the jdojoperson  module refers to the Address  class in jdojoaddress  module \nLets create another module named jdojopersontest  which reads the jdojoperson  module The \nmodule declaration is shown in Listing 106 \nListing 106  The M odule Declaration for the jdojopersontest Module\n moduleinfojava\nmodule jdojopersontest \n    requires jdojoperson\n\nThe module graph for the jdojopersontest  module is shown in Figure\u00a0 104  Notice that the jdojo\npersontest  module does not read the jdojoaddress  module so the public types in the comjdojo\naddress  package exported by the jdojoaddress  module are not accessible in the jdojopersontest  \nmodule\nFigure 104  The mo dule graph of the jdojopersontest module\nListing 107  contains the code for a Main  class in the jdojopersontest  moduleChapter 10  Modules\n369Listing 107  A Main C lass to Test the jdojopersontest Module\n Mainjava\npackage comjdojopersontest\nimport comjdojopersonPerson\npublic class Main \n    public static void mainString args \n        Person john  new Person1001 John Jacobs\n         Get Johns city and print it\n        String city  johngetAddressgetCity\n        SystemoutprintfJohn lives in sn city\n    \n\nThe code in the main  method is very simpleit creates a Person  object and reads the value of the city \nin a persons address\nPerson john  new Person1001 John Jacobs\nString city  johngetAddressgetCity\nCompiling the code for the jdojopersontest  module generates the following error\nCJavaFunsrcjdojopersontestclassescomjdojopersontestMainjava11 error  \nAddressgetCity in package comjdojoaddress is not accessible\n        String city  johngetAddressgetCity\n  package comjdojoaddress is declared in module jdojoaddress but module  \njdojopersontest does not read it\n1 error\nThe compiler message is not very clear It is stating that the Address  class is not accessible to  \nthe jdojopersontest  module Recall that the Address  class is in the jdojoaddress  module which the \njdojopersontest module  does not read Looking at the code it seems obvious that the code should \ncompile You have access to the Person  class which uses the Address  class so you should be able to use the \nAddress  class Here the call to the johngetAddress  method returns an object of the Address  type which \nyou do not have access to The module system is simply doing its job in enforcing the encapsulation defined \nby the jdojoaddress  module If a module wants to use the Address  class explicitly or implicitly it must \nread the jdojoaddress  module How do you fix it The simple answer would be for the jdojopersontest  \nmodule to read the jdojoaddress  module by changing the declaration to the one shown in Listing 108 \nListing 108  The M odified Module Declaration for the jdojopersontest Module\n moduleinfojava\nmodule jdojopersontest \n    requires jdojoperson\n    requires jdojoaddress\n\nFigure 105  shows the modified module graph for the jdojopersontest  moduleChapter 10  Modules\n370Compile and run the Main  class in the jdojopersontest  module and it will print the following\nJohn lives in Jacksonville\nYou solved the problem by adding a requires  statement in the jdojopersontest  modules \ndeclaration However it is very likely that other modules that read the jdojoperson  module will need to \nwork with addresses and they will need to add the same requires  statement If the jdojoperson  module \nexposes types in its public API from more than one other module the modules reading the jdojoperson  \nmodule will need to add a requires  statement for each such module It will be simply cumbersome for all \nthose modules to add an extra requires  statement\nThere is another use case that may create this kind of scenario Suppose there are only two modules\njdojopersontest  and jdojoperson where the former reads the latter and the latter exports all packages \nwhose public types are used by the former The comjdojoaddress  package is in the jdojoperson  module \nand the jdojopersontest  module compiled fine Later the jdojoperson  module is refactored into two \nmodules jdojoperson  and jdojoaddress  Now the jdojopersontest  module stops working because \nsome of the public types that were in the jdojoperson  module are now moved to the jdojoaddress  \nmodule which is not read by the jdojopersontest  module\nThe JDK 9 designers realized this problem and provided a simple way to solve this In this case all you \nneed to do is change the declaration for the jdojoperson  module to add a transitive  modifier in the \nrequires  statement to read the jdojoaddress  module Listing 109  contains the modified declaration for \nthe jdojoperson  module\nFigure 105  The mo dified module graph for the jdojopersontest moduleChapter 10  Modules\n371Listing 109  The M odified Module Declaration for the jdojoperson Module That Uses a Transitive Export\n moduleinfojava\nmodule jdojoperson \n     Read the jdojoaddress module\n    requires transitive  jdojoaddress\n     Export the comjdojoperson package\n    exports comjdojoperson\n\nNow you can remove this statement\nrequires jdojoaddress\nfrom the declaration of the jdojopersontest  module You need to keep the jdojoaddress  project on \nthe module path to compile and run the jdojopersontest  module project because the jdojoaddress  \nmodule is still needed to use the Address  type in this module Recompile the jdojoperson  module \nRecompile and run the main class in the jdojopersontest  module to get the desired output\n Tip When a module M uses public types from module N and those public types are part of the public \napI of module M consider using a requires transitive N  in module M suppose you ha ve a module \nP that exports packages and another module Q that reads module P If you refactor module P to split it into \nmultiple modules say S and T consider adding requires transitive S  and requires transitive T  \nstatements to Ps module declaration to ensure that all modules reading P module Q in this case continue to \nwork without any changes\nWhen a requires  statement contains the transitive  modifier the module that depends on the current \nmodule implicitly reads the module specified in the requires  statement Referring to Listing 109  any \nmodule that reads the jdojoperson  module implicitly reads the jdojoaddress  module Essentially an \nimplicit read makes the module declaration simpler to read and refactoring a module into multiple modules \neasier but harder to reason about because by just looking at a module declaration you cannot tell about all \nits dependencies Figure\u00a0 106  shows the final module graph for the jdojopersontest  moduleChapter 10  Modules\n372When modules are resolved the module graph is augmented by adding a read edge for each transitive \ndependency In this example a read edge will be added from the jdojopersontest  module to the jdojo\naddress  module as shown by a dashed arrow in Figure\u00a0 107  The figure shows the edge connecting the \njdojopersontest  module to the jdojoaddress  module in a dashed line to indicate that it is added after \nthe module graph is resolved\nFigure 106  The mo dule graph for the jdojopersontest moduleChapter 10  Modules\n373 Optional Dependence\nThe module system verifies the module dependencies at compile time and runtime There are times when \nyou want to make a module dependence mandatory at compile time but optional at runtime\nYou may develop a library that performs better if a specific module is available at runtime Otherwise \nit falls back to another module that makes it perform less than optimal However the library is compiled \nagainst the optional module and it makes sure that the code dependent on the optional module is not \nexecuted if the optional module is not available\nAnother example would be a module that exports an annotation bundle The Java runtime already \nignores nonexistent annotation types However module dependence is verified at startup and if the module \nis missing at runtime the application wont start Therefore it is essential to declare the module dependence \non the module containing the annotation bundle as optional\nYou can declare an optional dependency by using the static  keyword in a requires  statement\nrequires static optionalmodule\nThe following module declaration contains an optional dependence on the jdojoannotation  module\nmodule jdojoclaim \n    requires static jdojoanotation\n\nFigure 107  The module graph for the jdojopersontest module after augmenting it with implicit read edgesChapter 10  Modules\n374It is allowed to have both transitive  and static  modifiers in a requires  statement\nmodule jdojoclaim \n    requires transitive static  jdojoanotation\n\n Opening Modules and\u00a0Packages\nReflection  is a vast topic If this is your first encounter with Java you may have difficulty in understanding this \nsection You can revisit this section when you gain more experience in Java or just read it without worrying \nabout following everything that is explained\nReflection is a way to work with Java types without knowing about them at compile time You have used \ntypes such as the Person  class in this chapter To create a Person  and call its getFirstName  method you \nwrite code as shown\nimport comjdojopersonPerson\n\nPerson john  new Person1001 John Jacobs\nString firstName  johngetFirstName\nIn this case the Java compiler makes sure that there is a class named Person  in the comjdojoperson  \npackage The compiler also makes sure that this code has access to the Person  class its constructor and its \ngetFirstName  method If the Person  class does not exist you cannot compile this code When you run this \ncode the Java runtime again verifies the existence of the Person  and the access needed for this code to use \nit Using reflection you can rewrite this code without knowing about the existence of the Person  class Your \ncode and the compiler will have no knowledge of the Person  class yet you will be able to achieve the same \nFor this to happen this code will need only runtime access to the Person  class There are two types of access \nin Java\n\t Compiletime access\n\t Runtime access\nThe compiler verifies the compiletime access during compilation Compiletime access must follow \nthe Java language access rules for example code outside a class cannot access the private members of the \nclass\nThe Java runtime verifies the runtime access to types and their members At runtime code may access \ntypes and their members in two ways\n\t The first way is to run compiled code that was written in terms of the types being \naccessed In this case the runtime reinforces the accessibility rules of the Java \nlanguage as it does during compilation\n\t The second way is to use reflection to access types and their members at runtime \nIn this case the compiler has no knowledge of the types and their members your \ncode would access at runtime Accessing types and their members using reflection \nis called using reflective access  Unlike normal access reflective access allows access \nto all types not just public types and all members of those types even private \nmembersChapter 10  Modules\n375Reflective access is good as well as bad It is good because it lets you develop libraries that will work on \nall types that are not known There are several great frameworks such as Spring and Hibernate that depend \nheavily on deep reflective access to members of types defined in application libraries Reflective access is \nbad because it breaks encapsulationit can access types and members of those types which are otherwise \ninaccessible using normal access rules Accessing otherwise inaccessible types and their members using \nreflection is sometimes referred to as deep reflection \nFor over 20 years Java has allowed reflective access Designers of the module system in Java 9 faced \na big challenge in designing the deep reflective access to the modular code Allowing deep reflection on \nthe types of an exported package violates the strong encapsulation  theme of the module system It makes \neverything accessible to the outside code even if the module developer did not want to expose some part of \nthe module On the other hand not allowing deep reflection will make the Java community devoid of some \ngreat widely used frameworks and it will also break many existing applications that rely on deep reflection \nMany existing applications would simply not migrate to JDK 9 because of this limitation\nAfter a few iterations of design and experiments the module system designers came up with a middle \ngroundyou can have your cake and eat it too The design allows you to have a module with strong \nencapsulation deep reflective access and partly both Here are the rules\n\t An exported package will allow access to only public types and their public\nprotected members at compile time and runtime If you do not export a package \nall types in that package are inaccessible to other modules This provides strong \nencapsulation\n\t You can open a module to allow deep reflection on all types in all packages in that \nmodule at runtime Such a module is called an open module \n\t You can have a normal modulea module that is not open for deep reflectionwith \nspecific packages opened for deep reflection at runtime All other packages which \nare not open are strongly encapsulated Packages in a module that allow for deep \nreflection are known as open packages \n\t Sometimes you may want to access types in a package at compile time to write code \nin terms of the types in that package and at the same time you want deep reflective \naccess to those types at runtime You can export and open the same package to \nachieve this\n Open Modules\nAn open module is declared using the open  modifier before the module  keyword\nopen module jdojomodel \n     Module statements go here\n\nHere the jdojomodel  module is an open module Other modules can use deep reflection on all \ntypes in all packages in this module You can have exports  requires  uses  and provides  statements \nin the declaration of an open module You cannot have opens  statements inside an open module An \nopens  statement is used to open a specific package for deep reflection Because an open module opens all \npackages for deep reflection an opens  statement is not allowed inside an open moduleChapter 10  Modules\n376 Opening Packages\nOpening a package means granting normal runtime access to other modules to public types in that package \nand allowing other modules to use deep reflection on the types in that package You can open a package to \nall other modules or to a specific list of modules The syntax for the opens  statement to open a package to all \nother modules is as follows\nopens package\nHere package  is available for deep reflection to all other modules You can also open a package to \nspecific modules using a qualified opens  statement\nopens package to module1 module2\nHere package  is open for deep reflection only to module1  module2  etc The following is an \nexample of using the opens  statement in a module declaration\nmodule jdojomodel \n     Export the comjdojoutil package to all modules\n    exports comjdojoutil\n     Open the comjdojoutil package to all modules\n    opens comjdojoutil\n     Open the comjdojomodelpolicy package only to the hibernatecore module\n    opens comjdojomodelpolicy to hibernatecore\n\nThe jdojomodel  module exports the comjdojoutil  package which means all public types and \ntheir public members are accessible at compile time and for normal reflection at runtime The second \nstatement opens the same package for deep reflection at runtime In summary all public types and their \npublic members of the comjdojoutil  package are accessible at compile time and the package allows \ndeep reflection at runtime The third statement opens the comjdojomodelpolicy  package only to the \nhibernatecore  module for deep reflection which means that no other modules can access any types of \nthis package at compile time and the hibernatecore  module can access all types and their members using \ndeep reflection at runtime\n Ti p a  module that performs deep reflection on open packages of another module does not need to read \nthe module containing the open packages however adding a dependence on a module with open packages \nis allowed and strongly encouragedif you know the module nameso the module system can verify the \ndependence at compile time and at runtime\nWhen a module M opens its package P for deep reflection to another module N it is possible that the \nmodule N grants the deep reflective access that it has on package P to another module Q The module N will \nneed to do it programmatically using the Module API\u00a0Delegating reflective access to another module avoids \nopening the entire module to all other modules and at the same time it creates additional work on the part \nof the module that is granted the reflective accessChapter 10  Modules\n377 Splitting Packages Across Modules\nSplitting packages into multiple modules is not allowed  That is the same package cannot be defined in \nmultiple modules If types in the same package are in multiple modules those modules should be combined \ninto one module or you need to rename packages Sometimes you can compile these modules successfully \nand receive a runtime error other times you receive a compiletime error Splitting packages is not \ndisallowed unconditionally as I mentioned in the beginning You need to know the simple rule behind such \nerrors\nIf two modules named M and N define the same package named P there must not exist a module Q such \nthat the package P in both M and N modules is accessible to Q In other words the same package in multiple \nmodules must not be readable to a module at the same time Otherwise an error occurs If a module is \nusing a type T in package P that is found in two modules the module system cannot make a decision about \nusing PT from one of the two modules It generates an error and wants you to fix the problem Consider the \nfollowing snippet of code\n Testjava\npackage javautil\npublic class Test \n\nThe javabase  module in the JDK contains a javautil  package which is available to all modules If \nyou compile the Test  class in JDK 17 as part of a module or by itself you will receive the following error\nerror package exists in another module javabase\npackage javautil\n\n1 error\nIf you have this class in a module named M the compiletime error is stating that the javautil  package \nin this module as well as in the javabase  module is readable by the module M You must change the \npackage for this Test  class from javautil  to something else say comjdojoutil  which does not exist in \nany observable modules\n Restrictions in\u00a0Module Declarations\nThere are several restrictions in declaring modules If you violate them you will get errors at compile time or \nat startup\n\t A module graph cannot contain circular dependencies That is two modules \ncannot read each other If they do they should be one module not two Note that \nit is possible to have circular dependencies at runtime by adding readability edges \nprogrammatically or using the commandline options\n\t Module declarations do not support module versions You will need to add the \nmodules version as the class file attribute using the jar tool or some other tools such \nas javac \n\t The module system does not have a concept of submodules That is jdojoperson  \nand jdojopersonclient  are two separate modules the second one is not a sub\nmodule of the first oneChapter 10  Modules\n378 Types of\u00a0Modules\nJava has been around for over 20 years and applications old as well as new will keep using libraries that \nhave not been modularized or will never be modularized If JDK 9 had forced everyone to modularize \ntheir applications JDK 9 probably would not be adopted by most The JDK 9 designers kept the backward \ncompatibility in mind You can adopt JDK 9 and above by modularizing your application at your own pace \nor by deciding not to modularize at allby just running your existing application In most cases your \napplication that worked in JDK 8 or earlier will continue to work in JDK 9 and above without any changes  \nTo ease migration JDK defines four types of modules\n\t Normal modules\n\t Open modules\n\t Automatic modules\n\t Unnamed modules\nIn fact you will come across six terms describing six different types of modules which are for a \nbeginner to JDK 9 confusing at best The other two types of modules are used to convey broader categories \nof these four types of modules Figure\u00a0 108  shows a pictorial view of all types of modules\nFigure 108  Types of modules\nBefore I describe the main types of modules I give you brief definitions of the module types shown in \nFigure\u00a0 108 \n\t A module is a collection of code and data\n\t Based on whether a module has a name or not a module can be a named module  or \nan unnamed module  There are no further categories of unnamed modules\n\t When a module has a name the name can be given explicitly in a module \ndeclaration or the name can be generated automatically or implicitly If the name \nis given explicitly in a module declaration it is called an explicit module  If the name \nis generated by the module system by reading the JAR file name on the module path \nit is called an automatic module Chapter 10  Modules\n379\t If you declare a module without using the open  modifier it is called a normal module \n\t If you declare a module using the open  modifier it is called an open module \nBased on these definitions an open module is also an explicit module and a named module An \nautomatic module is a named module as it has a name which is automatically generated but it is not an \nexplicit module because it is implicitly declared by the module system at compile time and runtime The \nfollowing subsections describe these module types\n Ti p If the Ja va platform was initially designed with the module system you would have only one module \ntypea normal module all other module types exist for backward compatibility and smooth migration and \nadoption of modules\n Normal Modules\nA module that is declared explicitly using a module declaration without using an open  modifier is always \ngiven a name and it is called a normal module  or simply a module  So far you have been working mostly \nwith normal modules I have been referring to normal modules as modules and I continue using this term \nin this sense unless I need to make a distinction between the four types of modules By default all types in a \nnormal module are encapsulated An example of a normal module is as follows\nmodule anormalmodule \n     Module statements go here\n\n Open Modules\nIf a module declaration contains the open  modifier the module is known as an open module An example of \nan open module is as follows\nopen module anopenmodule \n     Module statements go here\n\n Automatic Modules\nFor backward compatibility the class path mechanism to look up types still works in JDK 9 You have options \nto place your JARs on the class path module path and a combination of both Note that you can place \nmodular JARs as well as JARs on both the module path and the class path\nWhen you place a JAR on the module path the JAR is treated as a module which is called an automatic  \nmodule The name automatic  module is derived from the fact that the module is automatically defined \nout of a JARyou do not explicitly declare the module by adding a moduleinfoclass  file An automatic \nmodule has a name What is the name of an automatic module What modules does it read and what \npackages does it export I will answer these questions shortly\nAutomatic modules exist solely for the purpose of migrating existing Java applications to the module \nsystem They let you use the existing JARs as modules by placing them on the module path However they \nare unreliable because when the author of the JARs convert them to modular JARs they may choose to give \nthem different module names than are automatically derived Exported packages in automatic modules may \nalso change when the author converts the JARs to modular JARs Keep these risks in mind when you use \nautomatic modules in your applicationChapter 10  Modules\n380To safeguard against the module name change for automatic modules the author may suggest a module \nname before they convert their JAR to a modular JAR\u00a0You can use the suggested module name in the MANIFESTMF  \nfile of the JAR to specify it as an automatic module name You can specify an automatic module name as the value \nfor the attribute  AutomaticModuleName in the main section of the MANIFESTMF  file in the JAR\nAn automatic module is also a named module Suppose that you want to use a JAR comjdojo\nintro10  as an automatic module Its name and version are derived from the name of the JAR file using the \nfollowing rules\n\t If the JAR file has the attribute  AutomaticModuleName in its main section in \nits MANIFESTMF  file the attributes value is the module name The module name is \notherwise derived from the name of the JAR file using the following steps\n\t The jar  extension of the JAR file is removed This step removes the jar  extension \nand the following steps use comjdojointro10  to derive the name of the module \nand its version\n\t If the name ends with a hyphen followed by at least one digit which is optionally \nfollowed by a dot the module name is derived from the part of the name that \nprecedes the last hyphen The part that follows the hyphen is assigned as the version \nof the module if it can be parsed as a valid version otherwise this part is ignored In \nour example the module name will be derived from comjdojointro  The version \nwill be derived as 10\n\t For module name all trailing digits and dots are removed In our case the remaining \npart for the module name comjdojointro  does not contain any trailing digits and \ndots So this step does not change anything\n\t Every nonalphanumeric character in the name part is replaced with a dot and \nin the resulting string two consecutive dots are replaced by one dot and all \nleading and trailing dots are removed In our example we do not have any non\nalphanumeric characters in the name part so the module name is comjdojointro \nApplying these rules in sequence gives you a module name and a module version In the end of this \nsection we show you how to know the name of an automatic module by having the JAR file Table\u00a0 101  lists \na few JAR names and derived automatic module names for them Note that the table does not show the \nextension jar  in the JAR file names and it is assumed that no  AutomaticModuleName attribute has been \nspecified in the main section in the MANIFESTMF  file of the JARs\nTable 101  Examples of Deriving Names of Automatic Modules from a JAR File Name\nJAR Name Module Name Module Version\ncomjdojointro10 comjdojointro 10\njunit410jar Junit 410\njdojologging150 NA\nspringcore401RELEASE springcore 401RELEASE\njdojotransapi15spec100 NA NA\n NA NAChapter 10  Modules\n381Lets look at three odd cases in the table where you will receive an error if you place the JARs on the \nmodule path The first JAR name is jdojologging150  Applying all the rules the derived module name \nis jdojologging150  which is an invalid module name Recall that a module name is a qualified Java \nidentifier That is every part in a module name must be a valid Java identifier In this case the two parts of the \nname5 and 0are not valid Java identifiers Using this JAR on the module path will generate an error \nunless you specify a valid module name using the  AutomaticModuleName attribute in the manifest file\nThe second JAR name that gives an error is jdojotransapi15spec100  Lets apply the rules to \nderive the automatic module name\n\t It finds the last hyphen after which you have only digits and dots and splits the JAR \nname into two parts jdojotransapi15spec  and 100  The first part is used to \nderive the module name The second part is the module version\n\t The name part does not contain any trailing digits and dots So the next rule is \napplied that converts all nonalphanumeric characters to a dot The resulting string \nis jdojotransapi15spec  Now 1 and 5 are two parts in the module name \nwhich are not valid Java identifiers So the derived module name is invalid and this \nis the reason you get an error when you add this JAR file to the module path\nThe third JAR name which is the last entry in the table is an underscore   That is the JAR file is \nnamed jar  If you apply the rules the underscore is replaced by a dot and that dot will be removed \nleaving the derived name an empty string which is not a valid module name The jar  file on the module \npath will cause the following exception\njavalangmoduleResolutionException Unable to derive module descriptor for jar\nYou can use the jar command with the describemodule  option to know the name of the automatic \nmodule that will be derived from a JAR\u00a0The general syntax is as follows\njar describemodule file yourJARfilepath\nThe following command prints the automatic module name for the JAR named jdojoutil22jar  \nassuming that the JAR exists in the CJavaFun  directory\ncJavaFunjarsjar describemodule file jdojoutil22jar\nNo module descriptor found Derived automatic module\njdojoutil22 automatic\nrequires javabase mandated\ncontains comjdojoperson\nThe first line in the output indicates that the jdojoutil22jar  is a JAR not a modular JAR\u00a0If it were \na modular JAR the module name would be read from the moduleinfoclass  file The first line indicates \nthat no module descriptor was found The second line prints jdojoutil  as the module name and 22 \nas the module version In the end of the second line the word automatic  is printed to indicate that this \nmodule name was derived as an automatic module name The third and fourth lines in the output print the \ndependence and package information of the automatic moduleChapter 10  Modules\n382You can use the jar command to update the manifest entries We will show you how to add the \n AutomaticModuleName attribute to a JAR\u00a0We use the jdojoutil22jar  in this example You need \nto create a text file and add the manifest attribute Listing 1010  shows the contents of a manifest file named \nmanifesttxt  The file contains two lines The first line specifies an attribute named  AutomaticModule\nName  and its value is jdojomisc  The second line is an empty line that you do not see Make sure to have \nan empty line in this file Otherwise the next command will not work\nListing 1010  Con tents of a manifesttxt File\nAutomaticModuleName jdojomisc\nThe following command will update the manifest file in the jdojoutil22jar  file assuming that \nboth the JAR file and the manifesttxt  file are placed in the same directory CJavaFun \ncJavaFunjarsjar update manifest manifesttxt file jdojoutil22jar\nIf you describe the jdojoutil22jar  file to see the derived automatic module name the module \nname will be read from the  AutomaticModuleName attribute of its manifest file Lets rerun the previous \ncommand to describe the module\ncJavaFunjarsjar describemodule file jdojoutil22jar\nNo module descriptor found Derived automatic module\njdojomisc22 automatic\nrequires javabase mandated\ncontains comjdojoperson\nOnce you know the name of an automatic module other explicit modules can read it using requires  \nstatements The following module declaration reads the automatic module named jdojomisc  that comes \nfrom the jdojoutil22jar  on the module path assuming that the automatic module name is derived \nfrom the JAR file name\nmodule jdojolib \n    requires jdojoutil\n    \n\nAn a utomatic module to be used effectively must export packages and read other modules Lets look \nat the rules on this\n\t An automatic module reads all other modules It is important to note that readability \nfrom an automatic module to all other modules is added after the module graph is \nresolved\n\t All packages in an automatic module are exported and opened\nThe two rules are based on the fact that there is no practical way to tell which other modules an \nautomatic module depends on and which packages of the automatic module other modules will need to \ncompile or for deep reflection\nAn automatic module reading all other modules may create cyclic dependency which is allowed after \nthe module graph has been resolved Recall that cyclic dependency between modules is not allowed during \nthe module graph resolution That is you cannot have cyclic dependency in your module declarationsChapter 10  Modules\n383Figure 109  An a utomatic module acting as a bridge between an explicit module and an unnamed moduleAutomatic modules do not have a module declaration so they cannot declare dependence on other \nmodules Explicit modules may declare dependence on other automatic modules Consider a case where \nan explicit module M reads an automatic module P and the module P uses a type T in another automatic \nmodule Q When you launch the application using the main class from module M the module graph will \nconsist of only M and Pexcluding the javabase  module in this discussion for brevity The resolution \nprocess will start with the module M and will see that it reads another module P The resolution process has \nno practical way to tell that the module P reads the module Q You will be able to compile both modules \nP and Q by placing them on the class path However when you run this application you will receive a \nClassNotFoundException  The exception occurs when the module P tries to access a type from the module \nQ To solve this problem the module Q must be included in the module graph by adding it as a root module \nusing the addmodules  commandline option and specifying Q as the value for this option\n Unnamed Modules\nYou can place JARs and modular JARs on the class path When a type is being loaded and its package is not found \nin any known modules the module system attempts to load the type from the class path If the type is found on \nthe class path it is loaded by a class loader and becomes a member of a module called unnamed module  of that \nclass loader Every class loader defines an unnamed module whose members are all types it loads from the class \npath An unnamed module does not have a name so an explicit module cannot declare a dependency on it using \na requires  statement If you have an explicit module that needs to use the types in an unnamed module you \nmust use the JAR for the unnamed module as an automatic module by placing the JAR on the module path\nIt is a common mistake to try to access types in an unnamed module from explicit modules at compile \ntime This is simply not possible because an unnamed module does not have a name and an explicit module \nneeds a module name to read another module at compile time Automatic modules act as a bridge between \nexplicit modules and unnamed modules as shown in Figure\u00a0 109  Explicit modules can access automatic \nmodules using requires  statements and automatic modules can access unnamed modules\nAn unnamed module does not have a name This does not mean that an unnamed modules name is \nan empty string unnamed  or null  The following declaration for a module which attempts to declare \ndependence on an unnamed module is invalid\nmodule somemodule \n    requires           A compiletime error\n    requires unnamed  A compiletime error\n    requires unnamed     A compiletime error unless a named module named unnamed exists\n    requires null        A compiletime error\n\nAn unn amed module reads other modules and exports and opens all its packages to other modules \nusing the following rules\n\t An unnamed module reads every other module Therefore an unnamed module can \naccess public types in all exported packages in all modules including the platform \nmodules This rule makes it possible for applications using the class path that \ncompiled and ran in Java SE 8 to continue to compile and run in Java SE 9 provided \nthey use only standard nondeprecated Java SE APIsChapter 10  Modules\n384\t An unnamed module opens all its packages to all other modules Therefore it \nis possible that an explicit module can access types in unnamed modules using \nreflection at runtime\n\t An unnamed module exports all its packages An explicit module cannot read an \nunnamed module at compile time After the module graph is resolved all automatic \nmodules are made to read unnamed modules\n Ti p  It is possible for an unnamed module to contain a packa ge that is also exported by a named module \nIn such a case the package in the unnamed module is ignored\n Aggregator Modules\nYou can create a module that contains no code of its own It collects and reexports the contents of other \nmodules Such a module is called an aggregator module  Suppose there are several modules that depend \non five modules You can create an aggregator module for those five modules and now your modules \ncan depend only on one modulethe aggregator module An aggregator module is not a separate type \nof module than explained in previous sections It is a named module It has a special name aggregator  \nbecause it does not have contents of its own Rather it combines the contents of several other modules into \none module under a different name\nAn aggregator module contains only one class file and that is moduleinfoclass  The module \ndeclaration for an aggregator module consists of all  requires transitive module  statements The \nfollowing is an example of an aggregator module declaration The aggregator module is named jdojoall  \nand it aggregates three modules jdojopolicy  jdojoclaim  and jdojopayment \nmodule jdojoall \n    requires transitive jdojopolicy\n    requires transitive jdojoclaim\n    requires transitive jdojopayment\n\nAggregator modules exist for convenience Java since version 9 contains several aggregator modules \nsuch as javase  and javaseee  The javase  module gathers parts of the Java SE that do not overlap with \nJava EE\u00a0The javaseee  module gathers all of the modules that comprise the Java SE including modules \nthat overlap with the Java EE\n Knowing About Modules at\u00a0Runtime\nJava SE 17 provides a set of classes and interfaces to work with modules programmatically They are \ncollectively known as the Module API  The Module API lets you query module information and modify it In \nthis section we give a quick preview of the Module API\nEach type loaded in the JVM is represented by an instance of the javalangClassT  class That is \nan instance of the ClassT  class represents type T at runtime You can get the reference of a type using the \ngetClass  method of the object of that class Assuming that a Person  class exists the following snippet of \ncode gets the reference of the Person  class\nPerson p  new Person\nClassPerson cls  pgetClassChapter 10  Modules\n385You can also get the reference of a class using a class literal A class literal is the name of a class followed \nby a class   For example you can get the reference of the Person  class using the class literal Personclass  \nYou can rewrite the previous snippet of code as follows\nClassPerson cls  Personclass\nAt runtime each type is loaded as a member of a module If the type is loaded from the class path it is a \nmember of an unnamed module of the class loader that loads the type If the type is loaded from the module \npath it is a member of a named module An instance of the javalangModule  class represents a module at \nruntime The Class  class contains a getModule  method that returns a Module  representing the module of \nthe type The following snippet of code gets the reference of the Module  object of which the Person  class is a \nmember\nClassPerson cls  Personclass\nModule m  clsgetModule\nThe Module  class contains several methods that let you query the modules declared state that existed at \ncompile time and actual state at runtime Note that a module state can be changed from how it was declared \nin the source code Other classes and interfaces in the Module API are in the javalangmodule  package For \nexample an instance of the ModuleDescriptor  class which is in the javalangmodule  package represents \nthe module descriptor as it was declared in the source file for explicit modules and as it was synthesized \nfor automatic modules You can use the getDescriptor  method of the Module  class to an instance of the \nModuleDescriptor  class An unnamed module does not have a module descriptor so the getDescriptor  \nmethod returns null  for an unnamed module You can use the getName  method of the Module  class to get \nthe name of the module the method returns null  for an unnamed module\nListing 1011  contains the declaration for a jdojomod  module Listing 1012  contains the code for a \nModuleInfo  class which prints the information of a module of which it is a member\nListing 1011  The M odule Declaration for the jdojomod Module\n moduleinfojava\nmodule jdojomod \n    exports comjdojomod\n\nListing 1012  A Mo duleInfo Class\n ModuleInfojava\npackage comjdojomod\nimport javalangmoduleModuleDescriptor\npublic class ModuleInfo \n    public static void mainString args \n         Get the class reference\n        ClassModuleInfo cls  ModuleInfoclass\n         Get the module reference\n        Module m  clsgetModule\n        if misNamed \n             It is a named module\n             Get the module name\n            String name  mgetName\n             Get the module descriptorChapter 10  Modules\n386            ModuleDescriptor md  mgetDescriptor\n             Print the module details\n            SystemoutprintlnModule Name   name\n            SystemoutprintlnModule is open   mdisOpen\n            SystemoutprintlnModule is automatic   mdisAutomatic\n         else \n             It is an unnamed module\n            SystemoutprintlnUnnamed module\n        \n    \n\nThe following command runs the ModuleInfo  class by placing the modular JAR for the jdojomod  \nmodule on the module path The output clearly shows the correct module information\nCJavaFunjava modulepath distjdojomodjar module jdojomodcomjdojomodModuleInfo\nModule Name jdojomod\nModule is open false\nModule is automatic false\nThe following command runs the ModuleInfo  class by placing the modular JAR for the jdojomod  \nmodule on the class path This time the class is loaded from the class path and it becomes a member of the \nunnamed module of the class loader that loads it\nCJavaFunjava classpath distjdojomodjar comjdojomodModuleInfo\nUnnamed module\n Migration Path to\u00a0Modules\nIf you are learning modules for the first time you may skip this section You can revisit when you have to \nmigrate existing Java applications to use modules\nWhen you are to migrate your application to modules you should keep two benefits in mind that are \nprovided by the module system strong encapsulation and reliable configuration Your goal is to have an \napplication that consists of solely normal modules with an exception of a few open modules It may seem \nthat someone can give you a clear list of steps you need to perform to migrate your existing applications \nto modules However that is not possible given the variety of applications their interdependence of other \ncode and different configuration needs All we can do is lay out a few generic guidelines that may help you \nthrough the migration and that is what this section does\nA nontrivial Java application typically consists of several JARs residing in three layers\n\t Application JARs in the application layer developed by application developers\n\t Library JARs in the library layer provided by third parties\n\t Java runtime JARs in the JVM layerChapter 10  Modules\n387Java has already modularized the Java runtime JARs by converting them to modules That is the Java \nruntime consists of modules and only modules\nThe library layer consists of mainly thirdparty JARs placed on the class path If you want to migrate \nyour application to use modules you may not get a modular version of the thirdparty JARs You also do not \nhave control on how the thirdparty JARs will be converted into modules by their vendors You can place the \nlibrary JARs onto the module path and treat them as automatic modules\nYou have a choice to fully modularize your application code The following are the choices you have for \nthe module type selection starting from the least desirable to the most desirable\n\t Unnamed modules\n\t Automatic modules\n\t Open modules\n\t Normal modules\nThe first step in migration is to check if your application runs in JDK 17 by placing all JARsapplication \nJARs and library JARsonto the class path without any modification to your code All types from the JARs \non the class path will be part of unnamed modules Your application in this state uses JDK 17 without any \nstrong encapsulation and reliable configuration\nOnce your application runs as is in JDK 17 you can start converting the application code into automatic \nmodules All packages in an automatic module are open for deep reflective access and exported for ordinary \ncompiletime and runtime access to their public types In this sense it is no better than unnamed modules \nit does not provide you with strong encapsulation However automatic modules provide you reliable \nconfiguration because other explicit modules can declare dependence on automatic modules\nYou have another choice of converting your application code into open modules that offers a modest \ndegree of stronger encapsulation in open modules all packages are open for deep reflective access but \nyou can specify which packages if any are exported for ordinary compiletime and runtime access Explicit \nmodules can also declare dependence on open modules thus giving you a benefit of reliable configuration\nA normal module offers the strongest encapsulation which lets you choose which packages if any are \nopen exported or both Explicit modules can also declare dependence on normal modules\nTable 102  contains the list of module types with the degree of strong encapsulation and reliable \nconfiguration they offer\nTable 102  Module Types and Varying Degrees of Strong \nEncapsulation and Reliable Configuration They Offer\nModule Type Strong Encapsulation Reliable Configuration\nUnnamed No No\nAutomatic No Modest\nOpen Modest Yes\nNormal Strongest Strongest\n Java Class Dependency Analyzer\nTo assist in determining what modules to require when converting a project to use open or normal modules \nyou can use the Java class dependency analyzer named jdeps for short It is a commandline tool for \nanalyzing the dependencies of existing JAR files and modulesChapter 10  Modules\n388For example assuming you have a JAR file named aopalliance10jar you can run jdeps on it like so \nwith the following output\n jdeps aopalliance10jar\naopalliance10jar  javabase\n   orgaopallianceaop               javaio                        javabase\n   orgaopallianceaop               javalang                      javabase\n   orgaopallianceintercept         javalang                      javabase\n   orgaopallianceintercept         javalangreflect              javabase\n   orgaopallianceintercept         orgaopallianceaop            aopalliance10jar\nThis essentially shows all the packages relied on and which module they are contained in This JAR only \nrelies on the javabase module\nIt can also be used to analyze the reversewhat modules depend on a given module for example\n jdeps inverse require javasql\nInverse transitive dependences on javasql\njavasql  javase\njavasql  javasqlrowset  javase\n Disassembling Module Definitions\nIn this section we explain the javap  tool that ships with the JDK which can be used to disassemble \nclass files This tool is very useful in learning the module system especially in decompiling the modules \ndescriptors\nWe will use the code from the JavaFun  directory in the supplied source code We assume that you \nhave extracted it in the CJavaFun  directory If it is different replace this path with yours in the following \nexamples\nIn Chapter 3 you had two copies of the moduleinfoclass  file for the jdojointro  module one in the \nmodjdojointro  directory and another in the modular JAR in the libcomjdojointrojar  file When you \npackaged the modules code into a JAR you had specified a version and a main class for the module Where \ndid these pieces of information go They were added to the moduleinfoclass  file as class attributes \nTherefore the contents of the two moduleinfoclass  files are not the same How do you prove it Start \nby printing the module declaration in both moduleinfoclass  files You can use the javap  tool which is \nlocated in the JDKHOMEbin  directory to disassemble code in any class file You can specify a file name a \nURL or a class name to be disassembled The following commands print the module declarations\nCJavaFunjavap modjdojointromoduleinfoclass\nCompiled from moduleinfojava\nmodule jdojointro \n  requires javabase\nChapter 10  Modules\n389CJavaFunjavap jarfilelibcomjdojointrojarmoduleinfoclass\nCompiled from moduleinfojava\nmodule jdojointro \n  requires javabase\n\nThe first command uses a file name and the second command uses a URL using the jar scheme Both \ncommands use relative paths You can use absolute paths if you wish\nThe outputs indicate that both moduleinfoclass  files contain the same module declaration You \nneed to print the class information using the verbose  option or the v option to see the class attributes \nThe following command prints the moduleinfoclass  file information from the mod directory and it shows \nthat the module version and main class name do not exist A partial output is shown\nCJavaFunjavap verbose modjdojointromoduleinfoclass\nClassfile CJavaFunmodjdojointromoduleinfoclass\n  Last modified Jul 23 2021 size 154 bytes\n  MD5 checksum 2e4a3e6b8b8b03c92fdede9a5784b1d7\n  Compiled from moduleinfojava\nmodule jdojointro\n\nThe following command prints the moduleinfoclass  file information from the libcomjdojo\nintrojar  file and it shows that the module version and main class name do exist A partial output is \nshown The relevant lines in the output have been shown in a bold font\nCJavaFunjavap verbose jarfilelibcomjdojointrojarmoduleinfoclass\nClassfile jarfilelibcomjdojointrojarmoduleinfoclass\n  Last modified Jul 24 2021 size 263 bytes\n  MD5 checksum 60f5f169a580f02fa8085fd36e50c0e5\n  Compiled from moduleinfojava\nmodule jdojointro10\n\n   8  Utf8                ModuleMainClass\n   9  Utf8                comjdojointroWelcome\n  10  Class               9              comjdojointroWelcome\n\n  14  Utf8                10\n  \nModulePackages\n  7                                       comjdojointro\nModuleMainClass 10                        comjdojointroWelcome\nModule\n  130                                    jdojointro\n  14                                      10\n Chapter 10  Modules\n390You can also disassemble the code for a class in a module You need to specify the module path the \nmodule name and the fully qualified name of the class The following command prints the code for the com\njdojointroWelcome  class from its modular JAR\nCJavaFunjavap modulepath lib module jdojointro comjdojointroWelcome\nCompiled from Welcomejava\npublic class comjdojointroWelcome \n  public comjdojointroWelcome\n  public static void mainjavalangString\n\nYou can also print the class information for system classes The following command prints the class \ninformation for the javalangObject  class from the javabase  module Note that you do not need to \nspecify the module path when you print system class information\nCJavaFunjavap module javabase javalangObject\nCompiled from Objectjava\npublic class javalangObject \n  public javalangObject\n  public final native javalangClass getClass\n  public native int hashCode\n  public boolean equalsjavalangObject\n  \n\nHow would you print the module declaration for a system module such as javabase  or javasql  \nRecall that system modules are packaged in a special file format called JIMAGE not as modular JARs JDK \n9 introduced a new URL scheme called jrt jrt is short for Java runtime to refer to the contents of the Java \nruntime image or system modules The syntax for using the jrt scheme is\njrtmodulepathtoafile\nThe following command prints the module declaration for the system module named javasql \nCJavaFunjavap jrtjavasqlmoduleinfoclass\nCompiled from moduleinfojava\nmodule javasql17 \n  requires transitive javalogging\n  requires transitive javaxml\n  requires javabase\n  exports javaxtransactionxa\n  exports javaxsql\n  exports javasql\n  uses javasqlDriver\nChapter 10  Modules\n391The following command prints the module declaration for the javase  which is an aggregator module\nCJavaFunjavap jrtjavasemoduleinfoclass\nCompiled from moduleinfojava\nmodule javase17 \n  requires transitive javanaming\n  requires transitive javainstrument\n  requires transitive javacompiler\n  requires transitive javasqlrowset\n  requires transitive javalogging\n  requires transitive javamanagementrmi\n  requires transitive javadesktop\n  requires transitive javarmi\n  requires transitive javadatatransfer\n  requires transitive javaprefs\n  requires transitive javaxmlcrypto\n  requires transitive javasql\n  requires transitive javaxml\n  requires transitive javasecuritysasl\n  requires transitive javascripting\n  requires transitive javamanagement\n  requires javabase\n  requires transitive javasecurityjgss\n\nYou can also use the jrt scheme to refer to a system class The following command prints the class \ninformation for the javalangObject  class in the javabase  module\nCJavaFunjavap jrtjavabasejavalangObjectclass\nCompiled from Objectjava\npublic class javalangObject \n  public javalangObject\n  public final native javalangClass getClass\n  public native int hashCode\n  public boolean equalsjavalangObject\n  \n\n Summary\nIn simple terms a module is a group of packages A module may optionally contain resources such as \nimages property files etc If a module needs to use public types contained in another module the second \nmodule needs to export the package containing the types and the first module needs to read the second \nmoduleChapter 10  Modules\n392A module exports its packages using the exports  statement A module can export its packages only to \na set of named modules or to all other modules Public types in exported packages are available to other \nmodules at compile time and runtime An exported package does not allow deep reflection on nonpublic \nmembers of public types\nIf a module wants to allow other modules to access all types of memberspublic and nonpublic\nusing reflection the module must either be declared as an open module or the module can open packages \nselectively using the opens  statement A module accessing types from open packages does not need to read \nthe module containing those open packages\nA module declares a dependence on another module using the requires  statement Such a \ndependence can be declared transitive using the transitive  modifier If module M declares a transitive \ndependence on module N any module declaring a dependence on module M declares an implicit \ndependence on module N\nA dependence can be declared mandatory at compile time but optional at runtime using the static  \nmodifier in the requires  statement A dependency can be optional at runtime and transitive at the same \ntime\nBased on how a module is declared and whether it has a name there are several types of modules \nBased on whether a module has a name or not a module can be a named module  or an unnamed module  \nWhen a module has a name the name can be given explicitly in a module declaration or the name can be \ngenerated automatically or implicitly If the name is given explicitly in a module declaration it is called an \nexplicit module  If the name is specified in the  AutomaticModuleName attribute in the JARs manifest or \nis generated by the module system by reading the JAR file name on the module path it is called an automatic \nmodule  If you declare a module without using the open  modifier it is called a normal module  If you declare \na module using the open  modifier it is called an open module  Based on these definitions an open module \nis also an explicit module and a named module An automatic module is a named module as it has a name \nwhich is automatically generated but it is not an explicit module because it is implicitly declared by the \nmodule system at compile time and runtime\nWhen you place a JAR not a modular JAR on the module path the JAR represents an automatic \nmodule whose name is specified in the  AutomaticModuleName attribute of the JARs manifest or is \nderived from the JAR file name An automatic module reads all other modules and all its packages are \nexported and opened\nIn JDK 9 a class loader can load a class from a module or from the class path Every class loader \nmaintains a module called unnamed module that contains all types that it loads from the class path An \nunnamed module reads every other module It exports and opens all its packages to all other modules An \nunnamed module does not have a name so an explicit module cannot declare a compiletime dependence \non an unnamed module If an explicit module needs to access types in an unnamed module the former can \nuse an automatic module as a bridge or use reflection\nYou can create a module that contains no code of its own It collects and reexports the contents of other \nmodules Such a module is called an aggregator  module  An aggregator module contains only one class file \nand that is moduleinfoclass  The module declaration for an aggregator module consists of all requires \ntransitive module  statements\nSplitting packages into multiple modules is not allowed  That is the same package cannot be defined \nin multiple modules If two modules named M and N define the same package named P there must not exist \na module Q such that the package P in both M and N modules is accessible to Q In other words the same \npackage in multiple modules must not be readable to a module at the same time Otherwise an error occurs\nJava 9 provides a set of classes and interfaces to work with modules at runtime They are collectively \nknown as the Module API\u00a0The Module API lets you query module information and modify it at runtime A \nmodule is represented as an instance of the javalangModule  class at runtime You can get the reference of \nthe module of a type using the getModule  method of the javalangClassT  class\nYou can use the javap  tool to print the module declaration or attributes Use the verbose  or v \noption of the tool to print the class attributes of the module descriptor The JDK stores the runtime image in \na special format JDK 9 introduced a new file scheme called jrt that you can use to access the contents of the \nruntime image Its syntax is jrtmodulepathtoafile Chapter 10  Modules\n393EXERCISES\n 1 What is a module\n 2 What keyword do you use to declare a module\n 3 What are the rules to specify a module name Which of the following module \nnames are valid\njdojodashboard\njdojodashboard\njdojopolicy10\njavaFundamentals\n 4 list all restricted keywords that are treated as keywords only when used in specific \npositions in a module declaration\n 5 What module statement do you use to export a package to all other modules or to a \nset of named modules\n 6 Consider the follo wing declaration for a module named jdojocore \nmodule jdojocore \n    exports comjdojocore to jdojoext jdojoutil\n\nexplain the effect of the exports  statement in this module declaration do these \ntwo modules jdojoext  and jdojoutil  have to exist when the jdojocore  \nmodule is compiled\n 7 What module statement do you use to express dependence of a module to another \nmodule What is a transitive dependence and what are the benefits of using a \ntransitive dependence\n 8 Consider the follo wing declaration for a module named jdojoext \nmodule jdojoext \n    requires jdojocore\n\nWhat are the two modules the jdojoext  reads\n 9 how do you express dependence of a module on another module that is mandatory \nat compile time but optional at runtime\n 10 What is an open module When do you use an open module\n 11 What is the difference between an open module and opening the packages of \na module selectively Why cant you use the opens  statement inside an open \nmoduleChapter 10  Modules\n394 12 Consider the follo wing declaration for a module named jdojomisc \nmodule jdojomisc \n    opens comjdojomisc\n    exports comjdojomisc\n\nIs this module declaration valid If it is valid explain the effects of opening and \nexporting the same package of the module\n 13 Can you ha ve two modules that contain the same package describe the exact rule \nthat prohibits two modules having the same package\n 14 What is an automatic module describe two ways that the name of an automatic \nmodule can be specified or derived\n 15 What is an unnamed module If you place a modular J ar on the class path will all \ntypes from the modular J ar be members of an unnamed module\n 16 What is an aggregator module Name an aggregator module in J dK 9\n 17 What is the fully qualified class name of the class that represents a module at \nruntime\n 18 how do you get the reference of the module that a class belongs to at runtime\n 19 Consider the follo wing snippet of code assuming that a Person  class exists\nPerson john  new Person\nString moduleName  john Complete the code \nSystemoutprintlnModule name of Person class is   moduleName\nComplete this snippet of code by replacing the comment in the second line with \nyour code this code snippet is supposed to print the name of the module the \nPerson  class is a member of or null  if it is a member of an unnamed module\n 20 What option do you use with the jar and java  tools to describe a module\n 21 If you are given a moduleinfoclass  file that contains the compiled code for \na module declaration how will you get the source code of the module In other \nwords what tool do you use to disassemble a class file which can also be a \nmoduleinfoclass  file\n 22 JdK modules are stored in an internal format called JIM aGe\u00a0What is the name of \nthe new scheme that J dK 9 introduced to access the class files and resources of a \nJdK module\n 23 use the javap  command to print the declaration of the javasql  module which \nis a J dK module395\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307411CHAPTER 11\nObject and\u00a0Objects Classes\nIn this chapter you will learn\n\t The hierarchical class structure in Java\n\t That the Object  class is the superclass of all other classes\n\t How to use methods of the Object  class with detailed examples\n\t How to reimplement methods of the Object  class in your class\n\t How to check two objects for equality\n\t The difference between immutable and mutable objects\n\t How to use the utility methods of the Objects  class to deal with null  values \ngracefully\n\t A brief introduction to lambda expressions\nAll classes in this chapter are a member of a jdojoobject  module as declared in Listing 111 \nListing 111  The D eclaration of a jdojoobject Module\n moduleinfojava\nmodule jdojoobject \n    exports comjdojoobject\n\n The Object Class\nJava has an Object  class in the javalang  package which is a member of the javabase  module All Java \nclasses those that are included in the Java class libraries and those that you create extend the Object  class \ndirectly or indirectly All Java classes are a subclass of the Object  class and the Object  class is the superclass \nof all classes Note that the Object  class itself does not have a superclass\nClasses in Java are arranged in a treelike hierarchical structure where the Object  class is at the root \nor top We will discuss class hierarchy in detail in Chapter 20 which covers inheritance We discuss some \ndetails of the Object  class in this chapter\nThere are two important rules about the Object  class We will not explain the reasons behind these \nrules here The reasons why you could do these things with the Object  class will be clear after you read \nChapter 20Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n396 Rule 1\nA reference variable of the Object  class can hold a reference of an object of any class As any reference \nvariable can store a null  reference so can a reference variable of the Object  type Consider the following \ndeclaration of a reference variable obj of the Object  type\nObject obj\nYou can assign a reference of any object in Java to obj All of the following statements are valid\n Can assign the null reference\nobj  null\n Can assign a reference of an object of the Object class\nobj  new Object\n Can assign a reference of an object of the Account class\nAccount act  new Account\nobj  act\n Can assign a reference to an object of any class Assume that the AnyClass class exists\nobj  new AnyClass\nThe opposite of this rule is not true You cannot assign a reference of an object of the Object  class to a \nreference variable of any other type The following statement is not valid\nAccount act  new Object  A compiletime error\nSometimes you may store the reference of an object of a specific type say an Account  type in a \nreference variable of the Object  type and later you would like to assign the same reference back to a \nreference variable of the Account  type You can do so by using a cast as shown\nObject obj2  new Account Account act  Account obj2  Must use a cast\nSometimes you may not be sure that a reference variable of the Object  class holds a reference to \nan object of a specific type In those situations you need to use the instanceof  operator to test The left \noperand of the instanceof  operator is a reference variable and its right operand is a class nameto be \nspecific a type name which includes class and interface If its left operand is a reference of its right operand \ntype it returns true  Otherwise it returns false  Refer to Chapter 20 for a more detailed discussion of the \ninstanceof  operator\nObject obj\nCat c\n Do something here and store a reference in obj \nif obj instanceof Cat \n     If we get here obj holds a reference of a Cat for sure\n    c  Catobj\n\nYou need to use this rule when you have a method that takes an Object  as a parameter You can pass \na reference of any object for the parameter of the Object  class Consider the following snippet of code that \nshows a method declaration\npublic void m1Object obj \n   Code goes here\nChapter 11  Obje Ct and\u00a0Obje Cts Classes\n397You can call m1  in a number of different ways\nm1null             Pass null reference\nm1new Object     Pass a reference of an object of the Object class\nm1new AnyClass  Pass a reference of an object of the AnyClass class\n Rule 2\nThe Object  class contains nine methods which are available to be used in all classes in Java We can put the \nmethods into two categories\n\t Methods in the first category have been implemented in the Object  class You are \nsupposed to use them as they have been implemented You cannot reimplement the \ntechnical term for reimplement is override  these methods in any class you create \nTheir implementation is final  Methods that fall into this category are getClass  \nnotify  notifyAll  and wait \n\t Methods in the second category have a default implementation in the Object  class \nYou can customize their implementation by reimplementing them in your classes \nMethods that fall into this category are toString  equals  hashCode  clone  \nand finalize \nA Java programmer must understand the proper use of all of the methods in the Object  class We \ndiscuss them in detail except for the notify  notifyAll  and wait  methods These methods are used \nin thread synchronization which is out of the scope of this book but is discussed by the second volume \nof this series Table\u00a0 111  lists all methods in the Object  class with a brief description The Yes in the \nImplemented column indicates that the Object  class has implementation for the method which can be \nused without writing any code The No in this column means that you need to implement the method \nbefore using it The Yes in the Customizable column indicates that you can reimplement the method \nin your class to customize it The No in this column indicates that the Object  class has implemented the \nmethod and its implementation is final \nTable 111  Metho ds in the Object Class\nMethod Implemented Customizable Description\npublic String toString Yes Yes Returns a string representation of \nan object Typically it is used for \ndebugging purposes\npublic boolean  \nequalsObject objYes Yes Used to compare two objects for \nequality\npublic int hashCode Yes Yes Returns a hash code an integer \nvalue of an object\nprotected Object \nclone throws \nCloneNotSupportedExceptionNo Yes Used to make a copy of an object\ncontinued Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n398To reimplement a method of the Object  class you need to declare the method the same way as it \nhas been declared in the Object  class and then write your own code in its body There are more rules to \nreimplement a method We cover all rules in Chapter 20 You can reimplement the toString  method of \nthe Object  class in your class say Test  as shown\npublic class Test \n     Reimplement the toString method of the Object class \n    public String toString \n        return Here is a string\n    \n\nThis book will discuss six methods of the Object  class in detail in the sections to follow\n What Is the\u00a0Class of\u00a0an\u00a0Object\nEvery object in Java belongs to a class You define a class in source code which is compiled into a binary \nformat a class file with the class  extension Before a class is used at runtime its binary representation \nis loaded into the JVM\u00a0Loading the binary representation of a class into the JVM is handled by an object \ncalled a class loader Typically multiple class loaders are used in a Java application to load different types of \nclasses A class loader is an instance of the class javalangClassLoader  Java lets you create your own class \nloaders by extending the ClassLoader  class Typically you do not need to create your own class loaders The \nJava runtime will use its builtin class loaders to load your classesMethod Implemented Customizable Description\nprotected void finalize \nthrows ThrowableNo Yes Called by the garbage collector before \nan object is destroyed It has been \ndeprecated in Java SE 9\npublic final Class getClass Yes No Returns a reference to the Class  \nobject of the object\npublic final void notify Yes No Notifies one thread in the wait queue \nof the object\npublic final void notifyAll Yes No Notifies all threads in the wait queue \nof the object\npublic final void wait\nthrows InterruptedException\npublic final void waitlong \ntimeout\nthrows InterruptedException\npublic final void waitlong \ntimeout int nanos\nthrows InterruptedExceptionYes No Makes a thread wait in the wait \nqueue of the object with or without a \ntimeoutTable 111  continued Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n399A class loader reads the binary format of the class definition into the JVM\u00a0The binary class format \nmay be loaded from any accessible location for example a local file system a network a database etc \nThen it creates an object of the javalangClassT  class which is the binary representation of type T in \nthe JVM\u00a0Note the uppercase C in the class name javalangClass  The binary format of a class definition \nmay be loaded multiple times in the JVM by different class loaders A class inside a JVM is identified by \nthe combination of its fully qualified name and its class loader Typically the binary definition of a class is \nloaded only once in a JVM\n Ti p Y ou can think of an object of the ClassT  class as a runtime descriptor of the source code of a class \nYour source code for a class is represented by an object of the Class  class at runtime In fact all types in \njavaclasses interfaces and primitive typesare represented by an instance of the Class  class at runtime\nThe getClass  method of the Object  class returns the reference of the Class  object Since the \ngetClass  method is declared and implemented in the Object  class you can use this method on a \nreference variable of any type The following snippet of code shows how to get the reference of the Class  \nobject for a Cat object\nCat c  new Cat\nClass catClass  cgetClass\nThe Class  class is generic and its formal type parameter is the name of the class that is represented by \nits object You can rewrite this statement using generics like so\nClassCat catClass  cgetClass\nBy default the class definition is loaded only once and there is only one Class  object per Java class \nWe are not considering those cases where you have written code to load the same class more than once If \nyou use the getClass  method on different objects of the same class you will get the reference of the same \nClass  object Consider the following snippet of code\nCat c2  new Cat\nCat c3  new Cat\nClass catClass2  c2getClass\nClass catClass3  c3getClass\nHere c2 and c3 are two objects of the same Cat class Therefore c2getClass  and c3getClass  \nreturn the reference of the same Class  object which represents the Cat class in the JVM\u00a0The expression \ncatClass2  catClass3  will evaluate to true \nThe Class  class has many useful methods You can use its getName  method to get the fully qualified \nname of the class You can use its getSimpleName  to get the simple name of the class for example\nString fullName  catClassgetName\nString simpleName  catClassgetSimpleName\n Ti p n ot all classes in an application are loaded into the jVM when the application starts a class is loaded \nand a corresponding Class  object is created when the application uses the class for the first timeChapter 11  Obje Ct and\u00a0Obje Cts Classes\n400 Computing the\u00a0Hash Code of\u00a0an\u00a0Object\nA hash code is an integer value that is computed for a piece of information using an algorithm A hash code \nis also known as a hash sum a hash value or simply a hash The algorithm to compute an integer from a \npiece of information is called a hash function The definition of a hash code involves three things\n\t A piece of information\n\t An algorithm\n\t An integer value\nYou have a piece of information You apply an algorithm to it to produce an integer value The \ninteger value that you get is the hash code for the piece of information you have If you change the piece \nof information or the algorithm the computed hash code may or may not change Figure\u00a0 111  depicts the \nprocess of computing a hash code\nComputing a hash code is a oneway process Getting the original piece of information from a hash \ncode is not an easy task and it is not the goal of the hash code computation either\nThe piece of information that could be used to generate a hash code could be an arbitrary sequence of \nbytes characters numbers or a combination of them For example you may want to compute the hash code \nfor a string Hello \nWhat does a hash function look like A hash function may be as simple as the following function which \nreturns the integer zero for all input data\nint myHashFunctionyour input data \n    return 0    Always return zero\n\nThis hash function fits the definition of a hash function although it is not a practically good one Writing \na good hash function is not an easy task You need to consider a number of things about the input data \nbefore you can write a good hash function\nWhy would you need a hash code It is needed for efficient retrieval of data associated with it when the \ndata is stored in a hashbased collection or container Before data is stored in a container its hash code is \ncomputed and then it is stored at a location also called a bucket  which is based on its hash code When \nyou want to retrieve the data its hash code is used to find its location in the container making the retrieval \nof the information faster It is worth noting that an efficient retrieval of data using a hash code is based on \nthe distribution of the hash code values over a range If the hash codes that are generated are not uniformly \ndistributed the retrieval of data may not be efficient In the worst case the retrieval of data may be as bad as \na linear search through all elements stored in the container If you use a hash function all elements in the Figure 111  Process of computing a hash codeChapter 11  Obje Ct and\u00a0Obje Cts Classes\n401container will be stored in the same bucket which will require searching through all elements Using a good \nhash function so that it gives you uniformly distributed hash codes is critical in implementing an efficient \nhashbased container for fast data retrieval\nWhat is the use of hash codes in Java Java uses hash codes for the same reason describedto efficiently \nretrieve data from hashbased collections If the objects of your class are not used as keys in a hashbased \ncollection for example in a HashSet  HashMap  etc you need not worry about hash codes for your objects\nYou can compute a hash code for an object in Java In the case of an object the pieces of information \nthat will be used to compute the hash code are the pieces of information that make up the state of the \nobject Java designers considered the hash code for an object so important that they provided a default \nimplementation to compute the hash code for an object in the Object  class\nThe Object  class contains a hashCode  method that returns an int which is the hash code of the \nobject The default implementation of this method computes the hash code of an object by converting the \nmemory address of the object into an integer Since the hashCode  method is defined in the Object  class it \nis available in all classes in Java However you are free to override the implementation in your class Here are \nthe rules that you must follow when you override the hashCode  method in your class Suppose there are \ntwo object references x and y\n\t If xequalsy  returns true  xhashCode  must return an integer which is equal \nto yhashCode  That is if two objects are equal using the equals  method they \nmust have the same hash code\n\t If xhashCode  is equal to yhashCode  it is not necessary that xequalsy  \nreturns true  That is if two objects have the same hash code using the hashCode  \nmethod they do not have to be equal using the equals  method\n\t If the hashCode  method is called on the same object multiple times in the same \nexecution of a Java application the method must return the same integer value \nThe hashCode  and equals  methods are closely tied If your class overrides any \nof these two methods it must override both for the objects of your class to work \ncorrectly in hashbased collections Another rule is that you should use only those \ninstance variables to compute the hash code for an object which are also used in the \nequals  method to check for equality\nIf your class is mutable you should not be using objects of your class as keys in hashbased collections \nIf the object used as a key changes after its use you will not be able to locate the object in the collection \nbecause locating an object in a hashbased collection is based on its hash code In such cases you will have \nstranded objects in the collection\nHow should you implement a hashCode  method for a class Here are some guidelines to write the \nlogic for the hashCode  method for your class which are reasonable for most purposes\n 1 Start with a prime number say 37\nint hash  37\n 2 Compute the hash code value for each instance variable of primitive data \ntype separately using the following logic Note that you need to use only those \ninstance variables in the hash code computation which are also part of the \nequals  method logic Lets store the result of this step in an int variable code  \nLets assume that value  is the name of the instance variable\nFor byte  short  int and char  data types use their integer value as\ncode  intvalueChapter 11  Obje Ct and\u00a0Obje Cts Classes\n402For the long  data type use the XOR for two halves of 64bit as\ncode  intvalue  value  32\nFor the float  data type convert its floatingpoint values to an equivalent integer \nvalue using\ncode  FloatfloatToIntBitsvalue\nFor the double  data type convert its floatingpoint value to long  using the \ndoubleToLongBits  method of the Double  class and then convert the long value to \nan int value using the procedure described previously for the long  data type\nlong longBits  DoubledoubleToLongBitsvalue\ncode  intlongBits  longBits  32\nFor the boolean  data type use 1 for true  and 0 for false \ncode  value  1  0\n 3 For a r eference instance variable use 0 if it is null  Otherwise call its hashCode  \nmethod to get its hash code Suppose ref is the name of the reference variable\ncode  ref  null  0 refhashCode\n 4 Com pute the hash code using the following formula Using 59 in the formula is \nan arbitrary decision Any other prime number say 47 will work fine\nhash  hash  59  code\n 5 Rep eat the previous three steps for all instance variables you want to include in \nyour hashCode  computation\n 6 Finally return the value contained in the hash  variable from your hashCode  \nmethod\nThis method is one of the many ways not the only way to compute the hash code of an object in \nJava Consult a good textbook on computing hash codes if you need a stronger hash function All primitive \nwrapper classes and the String  class override the hashCode  method to provide reasonably good \nimplementations of hash functions\n Tip a utility c lass named javalangObjects  was added in java 7 It contains a hash  method that \ncomputes the hash code for any number of values of any type You are advised to use the Objectshash  \nmethod to compute the hash code of an object refer to the Objects Class  section later in this chapter for \nmore details\nListing 112  contains the code for a Book  class It shows one of the possible implementations of the \nhashCode  method Notice the use of the Override  annotation in the declaration of the hashCode  method \nIt is an annotation that you should use when you reimplement a method of the superclass in your class Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n403Annotations are used to mark things like methods fields and classes with additional information In this case \nOverride tells the Java compiler that you intend to override a method from a superclass or interface This will \nbe covered in more detail in Chapters 20 and 21\nListing 112  A Bo ok Class That Reimplements the hashCode Method\n Bookjava\npackage comjdojoobject\npublic class Book \n    private String title\n    private String author\n    private int pageCount\n    private boolean hardCover\n    private double price\n     Other code goes here \n     Must implement the equals method too \n    Override\n    public int hashCode \n        int hash  37\n        int code  0\n         Use title\n        code  title  null  0  titlehashCode\n        hash  hash  59  code\n         Use author\n        code  author  null  0  authorhashCode\n        hash  hash  59  code\n         Use pageCount\n        code  pageCount\n        hash  hash  59  code\n         Use hardCover\n        code  hardCover  1  0\n        hash  hash  59  code\n         Use price\n        long priceBits  DoubledoubleToLongBitsprice\n        code  int priceBits  priceBits  32\n        hash  hash  59  code\n        return hash\n    \n\nThe Book  class has five instance variables title  author  pageCount  hardcover  and price  The \nimplementation uses all five instance variables to compute the hash code for a Book  object You must also \nimplement the equals  method for the Book  class which must use all the five instance variables to check \nif two Book  objects are equal You need to make sure that the equals  method and the hashCode  method \nuse the same set of instance variables in their logic Suppose you add one more instance variable to the \nBook  class Lets call it ISBN  Because ISBN  identifies a book uniquely you might use only the ISBN  instance \nvariable to compute its hash code and to compare for equality with another Book  object In this case it will \nbe sufficient to use only one instance variable to compute the hash code and check for equality\nThere are some misconceptions about the hash code of an object in Java Developers think that the hash \ncode uniquely identifies an object and it must be a positive integer However they are not true The hash \ncode does not identify an object uniquely Two distinct objects may have the same hash code A hash code \ndoes not have to be only a positive number It could be any integer value positive or negative There is also Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n404confusion about the usage of hash codes They are used solely for the purpose of efficient retrieval of data \nfrom a hashbased collection If your objects are not used as keys in hashbased collections and you do not \noverride the equals  method in your class you do not need to worry about reimplementing the hashCode  \nmethod in your class at all Most likely it will be overriding the equals  method that will prompt you to \noverride the hashCode  method for your class If you do not override and provide correct implementation \nof the hashCode  and equals  methods in your class at the same time the objects of your class would not \nbehave properly in hashbased collections The Java compiler or the Java runtime will never give you any \nwarnings or errors about the incorrect implementations of these two methods in your class\n Comparing Objects for\u00a0Equality\nEvery object in the universe is different from all other objects and every object in a Java program is different \nfrom all other objects All objects have a unique identity The memory address at which an object is allocated \ncan be treated as its identity which will make it always unique Two objects are the same if they have the \nsame identity or reference in Java terminology Consider the following snippet of code\nObject obj1\nObject obj2\n Do something \nif obj1  obj2 \n     obj1 and obj2 are the same object based on identity \n else \n     obj1 and obj2 are different objects based on identity \n\nThis code uses identity comparison to test for equality of obj1  and obj2  It compares the references of \ntwo objects to test whether they are equal\nSometimes you want to treat two objects as equal if they have the same state based on some or all of \ntheir instance variables If you want to compare two objects of your class for equality based on criteria other \nthan their references identities your class needs to reimplement the equals  method of the Object  class \nThe default implementation of the equals  method in the Object  class compares the references of the \nobject being passed as the parameter and the object on which the method is called If the two references are \nequal it returns true  Otherwise it returns false  In other words the equals  method in the Object  class \nperforms identitybased comparison for equality The implementation of the method is as follows Recall \nthat the keyword this  inside an instance method of a class refers to the reference of the object on which the \nmethod is called\npublic boolean equalsObject obj \n    return this  obj\n\nConsider the following snippet of code It compares some Point  objects using the equality operator \n which always compares the references of its two operands It also uses the equals  method of the \nObject  class to compare the same two references The output shows that the result is the same Note that \nyour Point  class does not contain an equals  method When you call the equals  method on a Point  \nobject the equals  methods implementation in the Object  class is used\nPoint pt1  new Point10 10\nPoint pt2  new Point10 10\nPoint pt3  new Point12 19Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n405Point pt4  pt1\nSystemoutprintlnpt1  pt1   pt1  pt1\nSystemoutprintlnpt1equalspt1   pt1equalspt1\nSystemoutprintlnpt1  pt2   pt1  pt2\nSystemoutprintlnpt1equalspt2   pt1equalspt2\nSystemoutprintlnpt1  pt3   pt1  pt3\nSystemoutprintlnpt1equalspt3   pt1equalspt3\nSystemoutprintlnpt1  pt4   pt1  pt4\nSystemoutprintlnpt1equalspt4   pt1equalspt4\npt1  pt1 true\npt1equalspt1 true\npt1  pt2 false\npt1equalspt2 false\npt1  pt3 false\npt1equalspt3 false\npt1  pt4 true\npt1equalspt4 true\nIn practice two points are considered the same if they have the same x y coordinates If you want to \nimplement this rule of equality for your Point  class you must reimplement the equals  method as shown \nin Listing 113 \nListing 113  A Smar tPoint Class That Reimplements equals and hashCode Methods\n SmartPointjava\npackage comjdojoobject\npublic class SmartPoint \n    private int x\n    private int y\n    public SmartPointint x int y \n        thisx  x\n        thisy  y\n    \n     Reimplement the equals method \n    Override\n    public boolean equalsObject otherObject \n         Are the same\n        if this  otherObject \n            return true\n        \n         Is otherObject a null reference\n        if otherObject  null \n            return false\n        \n         Do they belong to the same class\n        if thisgetClass  otherObjectgetClass \n            return false\n        Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n406         Get the reference of otherObject in a SmartPoint variable\n        SmartPoint otherPoint  SmartPointotherObject\n         Do they have the same x and y coordinates\n        boolean isSamePoint  thisx  otherPointx  thisy  otherPointy\n        return isSamePoint\n    \n     Reimplement hashCode method of the Object class\n       which is a requirement when you reimplement equals method\n    \n    Override\n    public int hashCode \n        return thisx  thisy\n    \n\nYou call your new class SmartPoint  Java advises to reimplement hashCode  and equals  methods \ntogether if any one of them is reimplemented in your class The Java compiler would not complain if you \nreimplement the equals  method and not the hashCode  method However you will get unpredictable \nresults when you use the objects of your class in hashbased collections\nThe only requirement for a hashCode  method is that if the mequalsn  method returns true  \nmhashCode  must return the same value as nhashCode  Because your equals  method uses x y \ncoordinates to test for equality you return the sum of the x and y coordinates from the hashCode  method \nwhich fulfills the technical requirement Practically you need to use a better hashing algorithm to compute \nthe hash value\nYou have written a few lines of code in the equals  method of the SmartPoint  class Lets go through \nthe logic one by one First you need to check if the object passed is the same as the object on which the \nmethod is called If the two objects are the same you consider them equal by returning true  This is \naccomplished by the following code\n Are they the same\nif this  otherObject \n    return true\n\nIf the parameter being passed is null  the two objects cannot be the same Note that the object on \nwhich the method is called can never be null  because you cannot call a method on a null  reference The \nJava runtime will throw a runtime exception when an attempt is made to call a method on a null  reference \nThe following code makes sure that you are comparing two nonnull objects\n Is otherObject a null reference\nif otherObject  null \n    return false\n\nThe parameter type of the method is Object  This means that any type of object reference can be \npassed For example you can use appleequalsorange  where apple  and orange  are references to an \nApple  object and an Orange  object respectively In your case you want to compare only a SmartPoint  object \nto another SmartPoint  object To make sure that the objects being compared are of the same class you need \nthe following code If someone calls the method with a parameter that is not a SmartPoint  object it returns \nfalse Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n407 Do they have the same class\nif thisgetClass  otherObjectgetClass \n    return false\n\nAt this point you are sure that someone is trying to compare two nonnull SmartPoint  objects that have \ndifferent identities references Now you would like to compare the x y coordinates of two objects To \naccess the x and y instance variables of the otherObject  formal parameter you must cast it to a SmartPoint  \nobject The following statement does it\n Get the reference of otherObject in a SmartPoint variable\nSmartPoint otherPoint  SmartPointotherObject\nAt this point it is just the matter of comparing the values of x and y instance variables of the two \nSmartPoint  objects If they are the same you consider two objects equal by returning true  Otherwise two \nobjects are not equal and you return false  This is accomplished by the following code\n Do they have the same x and y coordinates\nboolean isSamePoint  thisx  otherPointx  thisy  otherPointy\nreturn isSamePoint\nIt is time to test your reimplementation of the equals  method in the SmartPoint  class Listing 114  \nis your test class You can observe in the output that you have two ways of comparing two SmartPoint  \nobjects for equality The equality operator   compares them based on identity and the equals  method \ncompares them based on values of the x y coordinates Note that if x y coordinates are the same for two \nSmartPoint  objects the equals  method returns true \nListing 114  A Tes t Class to Demonstrate the Difference Between Identity and State Comparisons\n SmartPointTestjava\npackage comjdojoobject\npublic class SmartPointTest \n    public static void mainString args   \n        SmartPoint pt1  new SmartPoint10 10\n        SmartPoint pt2  new SmartPoint10 10\n        SmartPoint pt3  new SmartPoint12 19\n        SmartPoint pt4  pt1\n        Systemoutprintlnpt1  pt1   pt1  pt1\n        Systemoutprintlnpt1equalspt1   pt1equalspt1\n        Systemoutprintlnpt1  pt2   pt1  pt2\n        Systemoutprintlnpt1equalspt2   pt1equalspt2\n        Systemoutprintlnpt1  pt3   pt1  pt3\n        Systemoutprintlnpt1equalspt3   pt1equalspt3\n        Systemoutprintlnpt1  pt4   pt1  pt4\n        Systemoutprintlnpt1equalspt4   pt1equalspt4\n    \nChapter 11  Obje Ct and\u00a0Obje Cts Classes\n408pt1  pt1 true\npt1equalspt1 true\npt1  pt2 false\npt1equalspt2 true\npt1  pt3 false\npt1equalspt3 false\npt1  pt4 true\npt1equalspt4 true\nThere are some specifications for implementing the equals  method in your class so your class will \nwork correctly when used with other areas eg hashbased collections of Java It is the responsibility of the \nclass designer to enforce these specifications If your class does not conform to these specifications the Java \ncompiler or Java runtime will not generate any errors Rather objects of your class will behave incorrectly \nFor example you will add your object to a collection but you may not be able to retrieve it Here are \nspecifications for the equals  methods implementation Assume that x y and z are nonnull references of \nthree objects\n\t Reflexivity  It should be reflexive The expression xequalsx  should return true  \nThat is an object must be equal to itself\n\t Symmetry  It should be symmetric If xequalsy  returns true  yequalsx  must \nreturn true  That is if x is equal to y y must be equal to x\n\t Transitivity  It should be transitive If xequalsy  returns true  and yequalsz  \nreturns true  xequalsz  must return true  That is if x is equal to y and y is equal \nto z x must be equal to z\n\t Consistency  It should be consistent If xequalsy  returns true  it should keep \nreturning true  until the state of x or y is modified If xequalsy  returns false  it \nshould keep returning false  until the state of x or y is modified\n\t Comparison with a null reference  An object of any class should not be equal to a \nnull  reference The expression xequalsnull  should always return false \n\t Relationship with the hashCode method  If xequalsy  returns true  \nxhashCode  must return the same value as yhashCode  That is if two objects \nare equal according to the equals  method they must have the same hash code \nvalue returned from their hashCode  methods However the opposite may not be \ntrue If two objects have the same hash code that does not imply that they must \nbe equal according to the equals  method That is if xhashCode  is equal to \nyhashCode  that does not imply that xequalsy  will return true \nYour SmartPoint  class satisfies all six rules for equals  and hashCode  methods It was fairly easy to \nimplement the equals  method for the SmartPoint  class It has two primitivetype instance variables and \nyou used both of them in comparison for equality\nThere are no rules as to how many instance variables should be used to compare for equality of two \nobjects of a class It all depends on the use of the class For example if you have an Account  class the \naccount number itself may be sufficient in your case to compare for the equality of two Account  objects \nHowever make sure you use the same instance variables in the equals  method to compare for equality \nand in the hashCode  method to compute hash code value If your class has reference instance variables \nyou may call their equals  methods from inside the equals  method of your class Listing 115  shows how \nto use a reference instance variable comparison inside the equals  methodChapter 11  Obje Ct and\u00a0Obje Cts Classes\n409Listing 115  Overriding the equals and hashCode Methods in a Class\n SmartCatjava\npackage comjdojoobject\npublic class SmartCat \n    private String name\n    public SmartCatString name \n        thisname  name\n    \n     Reimplement the equals method \n    Override\n    public boolean equalsObject otherObject \n         Are they the same\n        if this  otherObject \n            return true\n        \n         Is otherObject a null reference\n        if otherObject  null \n            return false\n        \n         Do they belong to the same class\n        if thisgetClass  otherObjectgetClass \n            return false\n        \n         Get the reference of otherObject is a SmartCat variable\n        SmartCat otherCat  SmartCatotherObject\n         Do they have the same names\n        boolean isSameName  thisname  null  otherCatname  null\n                            thisnameequalsotherCatname \n        return isSameName\n    \n     Reimplement the hashCode method which is a requirement\n       when you reimplement equals method\n    \n    Override\n    public int hashCode \n        return thisname  null  0  thisnamehashCode\n    \n\nThe SmartCat  class has a name  instance variable which is of the type String  The String  class has its \nown version of the equals  method implementation that compares two strings character by character The \nequals  method of the SmartCat  class calls the equals  method on the name  instance variables to check if \ntwo names are equal Similarly it makes use of the hashCode  methods implementation in the String  class \nin its hashCode  methodChapter 11  Obje Ct and\u00a0Obje Cts Classes\n410 String Representation of\u00a0an\u00a0Object\nAn object is represented by its state which is the combination of values of all its instance variables at a point \nin time Sometimes it is helpful usually in debugging to represent an object in a string form What should \nbe in the string that represents an object The string representation of an object should contain enough \ninformation about the state of the object in a readable format The toString  method of the Object  class \nlets you write your own logic to represent the object of your class as a string The Object  class provides a \ndefault implementation of the toString  method It returns a string in the following format\nfullyqualifiedclassnamehashcodeofobjectinhexadecimalformat\nConsider the following snippet of code and its output You may get a different output\n Create two objects\nObject obj  new Object\nIntHolder intHolder  new IntHolder234\n Get string representation of objects\nString objStr  objtoString\nString intHolderStr  intHoldertoString\n Print the string representations\nSystemoutprintlnobjStr\nSystemoutprintlnintHolderStr\njavalangObject360be0\ncomjdojoobjectIntHolder45a877\nNote that the IntHolder  class does not have a toString  method Still you were able to call the \ntoString  method using the intHolder  reference variable because all methods in the Object  class are \navailable in all classes automatically\nYou may notice that the string representation that is returned from the toString  method for the \nIntHolder  object is not so useful It does not give you any clues about the state of the IntHolder  object Lets \nreimplement the toString  method in the IntHolder  class You will call the new class SmartIntHolder  \nWhat should your toString  method return An object of the SmartIntHolder  class represents an integer \nvalue It would be fine just to return the stored integer value as a string You can convert an integer value say \n123 into a String  object using the valueOf  static method of the String  class as follows\nString str  StringvalueOf123  str contains 123 as a string\nListing 116  contains the complete code for the SmartIntHolder  class\nListing 116  Reim plementing the toString Method of the Object Class in the SmartIntHolder Class\n SmartIntHolderjava\npackage comjdojoobject\npublic class SmartIntHolder \n    private int value\n    public SmartIntHolderint value \n        thisvalue  value\n    Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n411    public void setValueint value \n        thisvalue  value\n    \n    public int getValue \n        return value\n    \n     Reimplement toString method of the Object class \n    Override\n    public String toString \n         Return the stored value as a string\n        String str  StringvalueOfthisvalue\n        return str\n    \n\nThe following snippet of code shows you how to use the toString  method of the SmartIntHolder  class\n Create an object of the SmartIntHolder class\nSmartIntHolder intHolder  new SmartIntHolder234\nString intHolderStr  intHoldertoString\nSystemoutprintlnintHolderStr\n Change the value in SmartIntHolder object\nintHoldersetValue8967\nintHolderStr  intHoldertoString\nSystemoutprintlnintHolderStr\n234\n8967\nThere is no special technical requirement for reimplementing the toString  method in your class \nYou need to make sure it is declared public  its return type is String  and it does not take any parameters \nThe returned string should be humanreadable text to give an idea about the state of the object at the time \nthe method is called It is recommended to reimplement the toString  method of the Object  class in every \nclass you create\nSuppose you have a Point  class to represent a 2D point as shown in Listing 117  A Point  holds the x \nand y coordinates of a point An implementation of the toString  method in the Point  class may return a \nstring of the form x y  where x and y are the coordinates of the point\nListing 117  A Poin t Class Whose Object Represents a 2D Point\n Pointjava\npackage comjdojoobject\npublic class Point \n    private int x\n    private int y\n    public Pointint x int y \n        thisx  x\n        thisy  y\n    Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n412     Reimplement toString method of the Object class \n    Override\n    public String toString \n        String str    x     y  \n        return str\n    \n\nThe toString  method of a class is very important and Java provides you with easy ways to use it \nJava calls the toString  method of an object automatically for you in situations where it needs a string \nrepresentation of the object Two such situations that are worth mentioning are\n\t A string concatenation expression involving a reference of an object\n\t A call to the Systemoutprint  and Systemoutprintln  methods with an \nobject reference as a parameter\nWhen you concatenate a string and an object like this\nString str  Hello  new Point10 20\nJava calls the toString  method on the Point  object and concatenates the returned value to the \nHello  string This statement will assign a Hello10 20  string to the str variable This statement is the \nsame as the following one\nString str  Hello  new Point10 20toString\nYou use the string concatenation operator   to concatenate data of different types First Java gets the \nstring representations of all data before concatenating them Calling the toString  method of an object \nautomatically for you in a concatenation expression helps you save some typing If the object reference that \nis used in concatenation is a null  reference Java uses a null  string as the string representation\nThe following snippet of code makes the call to the toString  method on object references clear \nYou may observe that the result is the same when you use the objects reference by itself or you call \nits toString  method in a string concatenation expression Similarly when you use Systemout\nprintlnpt  Java automatically calls the toString  method on the pt reference variable\nPoint pt  new Point10 12\n str1 and str2 will have the same contents\nString str1  Test   pt\nString str2  Test   pttoString\nSystemoutprintlnpt\nSystemoutprintlnpttoString\nSystemoutprintlnstr1\nSystemoutprintlnstr2\n10 12\n10 12\nTest 10 12\nTest 10 12Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n413The following snippet of code shows the effect of using a null  reference in a string concatenation \nexpression and in the Systemoutprintln  method call Note that you cannot use pttoString  when \npt is holding a null  reference The call to any method on a null  reference will generate a runtime exception\n Set pt to null\nPoint pt  null\nString str3  Test   pt\nSystemoutprintlnpt\nSystemoutprintlnstr3\nSystemoutprintlnpttoString  Will generate a runtime exception \nnull\nTest null\n Cloning Objects\nJava does not provide an automatic mechanism to clone make a copy an object Recall that when you \nassign a reference variable to another reference variable only the reference of the object is copied not \nthe content of the object Cloning an object means copying the content of the object bit by bit If you want \nobjects of your class to be cloned you must reimplement the clone  method in your class Once you \nreimplement the clone  method you should be able to clone objects of your class by calling the clone  \nmethod The declaration of the clone  method in the Object  class is as follows\nprotected Object clone throws CloneNotSupportedException\nYou need to observe a few things about the declaration of the clone  method\n\t It is declared protected  Therefore you will not be able to call it from the client code \nThe following code is not valid\nObject obj  new Object\nObject clone  objclone  Error Cannot access protected clone\n                             method\n\t This means you need to declare the clone  method public  in your class if you want \nthe client code to clone objects of your class\n\t Its return type is Object  It means you will need to cast the returned value of the \nclone  method Suppose MyClass  is cloneable Your cloning code will look like this\nMyClass mc  new MyClass\nMyClass clone  MyClassmcclone  Need to use a cast\nYou do not need to know any internal details about an object to clone it The clone  method in the \nObject  class has all the code that is needed to clone an object All you need to do is call it from the clone  \nmethod of your class It will make a bitwise copy of the original object and return the reference of the copy\nThe clone  method in the Object  class throws a CloneNotSupportedException  It means when you \ncall the clone  method of the Object  class you need to place the call in a trycatch  block or rethrow the \nexception You will learn more about the trycatch  block in Chapter 13 You have the option not to throw Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n414a CloneNotSupportedException  from the clone  method of your class The following snippet of code is \nplaced inside the clone  method of your class which calls the clone  method of the Object  class using \nthe super  keyword\nYourClass obj  null\ntry \n     Call clone method of the Object class using superclone\n    obj  YourClasssuperclone\n catch CloneNotSupportedException e \n    e printStackTrace\n\nreturn obj\nOne important thing that you must do is add an implements Cloneable  clause in your class declaration \nCloneable  is an interface declared in the javalang  package You will learn about interfaces in Chapter 21 \nFor now just add this clause in your class declaration Otherwise you will get a runtime error when you call \nthe clone  method on the objects of your class Your class declaration must look like this\npublic class MyClass implements Cloneable \n     Code for your class goes here\n\nListing 118  contains the complete code for a DoubleHolder  class It overrides the clone  method \nof the Object  class The comments in the clone  method explain what the code is doing The clone  \nmethod of the DoubleHolder  class does not have a throws  clause as the clone  method of the Object  class \nhas When you override a method you have an option to drop the throws  clause that is declared in the \nsuperclass\nListing 118  A Do ubleHolder Class with Cloning Capability\n DoubleHolderjava\npackage comjdojoobject\npublic class DoubleHolder implements Cloneable \n    private double value\n    public DoubleHolderdouble value \n        thisvalue  value\n    \n    public void setValuedouble value \n        thisvalue  value\n    \n    public double getValue \n        return thisvalue\n    \n    Override\n    public Object clone \n        DoubleHolder copy  null\n        try \n             Call the clone method of the Object class which will do a\n             bitbybit copy and return the reference of the clone\n            copy  DoubleHolder superclone\n         catch CloneNotSupportedException e Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n415             If anything goes wrong during cloning print the error details\n            eprintStackTrace\n        \n        return copy\n    \n\nOnce your class implements the clone  method correctly cloning an object of your class is as \nsimple as calling its clone  method The following snippet of code shows how to clone an object of the \nDoubleHolder  class Note that you must cast the returned reference from the dhclone  method call to the \nDoubleHolder  type\nDoubleHolder dh  new DoubleHolder10000\nDoubleHolder dhClone  DoubleHolder dhclone\nAt this point there are two separate objects of the DoubleHolder  class The dh variable references the \noriginal object and the dhClone  variable references the clone of the original object The original and the \ncloned object hold the same value of 10000  However they have separate copies of the value If you change \nthe value in the original object for example dhsetValue200  the value in the cloned object remains \nunchanged Listing 119  shows how to use the clone  method to clone an object of the DoubleHolder  class \nThe output proves that once you clone an object there are two separate objects in memory\nListing 119  A Tes t Class to Demonstrate Object Cloning\n CloningTestjava\npackage comjdojoobject\npublic class CloningTest \n    public static void mainString args   \n        DoubleHolder dh  new DoubleHolder10000\n         Clone dh\n        DoubleHolder dhClone  DoubleHolderdhclone\n         Print the values in original and clone\n        SystemoutprintlnOriginal  dhgetValue\n        SystemoutprintlnClone  dhClonegetValue\n         Change the value in original and clone\n        dhsetValue20000\n        dhClonesetValue40000\n         Print the values in original and clone again\n        SystemoutprintlnOriginal  dhgetValue\n        SystemoutprintlnClone   dhClonegetValue\n    \n\nOriginal1000\nClone1000\nOriginal2000\nClone4000Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n416From Java 5 you need not specify the return type of the clone  method in your class as the Object  \ntype You can specify your class as the return type in the clone  method declaration This will not force \nthe client code to use a cast when it calls the clone  method of your class The following snippet of code \nshows the changed code for the DoubleHolder  class which will compile only in Java 5 or later It declares \nDoubleHolder  as the return type of the clone  method and uses a cast in the return  statement\n DoubleHolderjava\npackage comjdojoobject\npublic class DoubleHolder implements Cloneable \n     The same code goes here as before \n    public DoubleHolder  clone \n        Object copy  null\n         The same code goes here as before \n        return DoubleHoldercopy\n    \n\nWith the previous declaration for the clone  method you can write code to clone an object as follows \nNote that no cast is needed anymore\nDoubleHolder dh  new DoubleHolder10000\nDoubleHolder dhClone  dhclone Clone dh No cast is needed\nAn object may be composed of another object In such cases two objects exist in memory separatelya \ncontained object and a container object The container object stores the reference of the contained object \nWhen you clone the container object the reference of the contained object is cloned After cloning is \nperformed there are two copies of the container object both of them have references to the same contained \nobject This is called a shallow  cloning because references are copied not the objects The clone  method \nof the Object  class makes only shallow cloning unless you code it otherwise Figure\u00a0 112  shows the memory \nstate of a compound object where an object contains a reference of another object Figure\u00a0 113  shows the \nmemory state when the compound object is cloned using a shallow cloning You may notice that in shallow \ncloning the contained object is shared by the original compound object and the cloned compound object\nFigure 112  A com pound object The container object stores a reference of another object contained objectChapter 11  Obje Ct and\u00a0Obje Cts Classes\n417Figure 113  Memor y state after the container object is cloned using shallow cloning\nWhen the contained objects are copied rather than their references during cloning of a compound \nobject it is called deep cloning You must clone all the objects referenced by all reference variables of an \nobject to get a deep cloning A compound object may have multiple levels of chaining of contained objects \nFor example the container object may have a reference of another contained object which in turn has a \nreference of another contained object and so on Whether you will be able to perform a deep cloning of a \ncompound object depends on many factors If you have a reference of a contained object it may not support \ndeep cloning and in that case you have to be content with shallow cloning You may have a reference of a \ncontained object which itself is a compound object However the contained object supports only shallow \ncloning and in that case again you will have to be content with shallow cloning Lets look at examples of \nshallow and deep cloning\nIf the reference instance variables of an object store references to immutable objects you do not need \nto clone them That is if the contained objects of a compound object are immutable you do not need to \nclone the contained objects In this case shallow copy of the immutable contained objects is fine Recall \nthat immutable objects cannot be modified after they are created An immutable objects reference can be \nshared by multiple objects without any side effects This is one of the benefits of having immutable objects If \na compound object contains some references to mutable objects and some to immutable objects you must \nclone the referenced mutable objects to have a deep copy Listing 1110  has code for a ShallowClone  class\nListing 1110  A Sh allowClone Class That Supports Shallow Cloning\n ShallowClonejava\npackage comjdojoobject\npublic class ShallowClone implements Cloneable \n    private DoubleHolder holder  new DoubleHolder00\n    public ShallowClonedouble value \n        thisholdersetValuevalue\n    \n    public void setValuedouble value \n        thisholdersetValuevalue\n    Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n418    public double getValue \n        return thisholdergetValue\n    \n    Override\n    public Object clone \n        ShallowClone copy  null\n        try \n            copy  ShallowClone superclone\n         catch CloneNotSupportedException e \n            eprintStackTrace\n        \n        return copy\n    \n\nAn obj ect of the ShallowClone  class is composed of an object of the DoubleHolder  class The code in the \nclone  method of the ShallowClone  class is the same as for the clone  method of the DoubleHolder  class \nThe difference lies in the type of instance variables that are used for the two classes The DoubleHolder  class \nhas an instance variable of primitive type double  whereas the ShallowClone  class has an instance variable \nof the reference type DoubleHolder  When the ShallowClone  class calls the clone  method of the Object  \nclass using superclone  it receives a shallow copy of itself That is it shares the DoubleHolder  object \nused in its instance variable with its clone\nListing 1111  has test cases to test an object of the ShallowClone  class and its clone The output \nshows that after you make a clone changing the value through the original object also changes the value \nin the cloned object This is so because the ShallowClone  object stores the value in another object of the \nDoubleHolder  class which is shared by both the cloned and the original objects\nListing 1111  A Tes t Class to Demonstrate the Shallow Copy Mechanism\n ShallowCloneTestjava\npackage comjdojoobject\npublic class ShallowCloneTest \n    public static void mainString args \n        ShallowClone sc  new ShallowClone10000\n        ShallowClone scClone  ShallowClone scclone\n         Print the value in original and clone\n        SystemoutprintlnOriginal   scgetValue\n        SystemoutprintlnClone   scClonegetValue\n         Change the value in original and it will change the value\n         for clone too because we have done shallow cloning\n        scsetValue20000\n         Print the value in original and clone\n        SystemoutprintlnOriginal   scgetValue\n        SystemoutprintlnClone   scClonegetValue\n    \nChapter 11  Obje Ct and\u00a0Obje Cts Classes\n419Original 1000\nClone 1000\nOriginal 2000\nClone 2000\nIn deep cloning you need to clone all objects referenced by all reference instance variables of an \nobject You must perform a shallow cloning before you can perform a deep cloning The shallow cloning \nis performed by calling the clone  method of the Object  class Then you need to write code to clone all \nreference instance variables Listing 1112  shows code for a DeepClone  class which performs a deep cloning\nListing 1112  A De epClone Class That Performs Deep Cloning\n DeepClonejava\npackage comjdojoobject\npublic class DeepClone implements Cloneable \n    private DoubleHolder holder  new DoubleHolder00\n    public DeepClonedouble value \n        thisholdersetValuevalue\n    \n    public void setValuedouble value \n        thisholdersetValuevalue\n    \n    public double getValue \n        return thisholdergetValue\n    \n    Override\n    public Object clone \n        DeepClone copy  null\n        try \n            copy  DeepClone superclone\n             Need to clone the holder reference variable too\n            copyholder  DoubleHolder thisholderclone\n         catch CloneNotSupportedException e \n            eprintStackTrace\n        \n        return copy\n    \n\nIf you compare the code in the clone  methods of the ShallowClone  and DeepClone  classes you will \nfind that for deep cloning you had to write only one extra line of code\n Need to clone the holder reference variable too\ncopyholder  DoubleHolderthisholderclone\nWhat will happen if the DoubleHolder  class is not cloneable In that case you would not be able to write \nthis statement to clone the holder  instance variable You could have cloned the holder instance variable as \nfollows\n Need to clone the holder reference variable too\ncopyholder  new DoubleHolderthisholdergetValueChapter 11  Obje Ct and\u00a0Obje Cts Classes\n420The goal is to clone the holder  instance variable and it does not have to be done by calling its clone  \nmethod Listing 1113  shows how your DeepClone  class works Compare its output with the output of the \nShallowCloneTest  class to see the difference\nListing 1113  A Tes t Class to Test Deep Cloning of Objects\n DeepCloneTestjava\npackage comjdojoobject\npublic class DeepCloneTest \n    public static void mainString args \n        DeepClone sc  new DeepClone10000\n        DeepClone scClone  DeepClone scclone\n         Print the value in original and clone\n        SystemoutprintlnOriginal   scgetValue\n        SystemoutprintlnClone   scClonegetValue\n         Change the value in original and it will not change the value\n         for clone because we have done deep cloning\n        scsetValue20000\n         Print the value in original and clone\n        SystemoutprintlnOriginal   scgetValue\n        SystemoutprintlnClone   scClonegetValue\n    \n\nOriginal 1000\nClone 1000\nOriginal 2000\nClone 1000\n Tip Using the clone  method of the Object  class is not the only way to make a clone of an object \nYou can use other methods to clone an object You may provide a copy constructor which accepts an object of \nthe same class and creates a clone of that object You may provide a factory method in your class which may \naccept an object and return its clone another way to c lone an object is to serialize it and then deserialize it \nserializing and deserializing objects is not covered here\n Finalizing an\u00a0Object\nSometimes an object uses resources that need to be released when the object is destroyed Java provides \nyou with a way to perform resource release or some other type of cleanup when an object is about to be \ndestroyed In Java you create objects but you cannot destroy objects The JVM runs a lowpriority special \ntask called garbage collector  to destroy all objects that are no longer referenced The garbage collector gives \nyou a chance to execute your cleanup code before an object is destroyed The Object  class has a finalize  \nmethod which is declared as follows\nprotected void finalize throws Throwable  Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n421The finalize  method in the Object  class does not do anything You need to override the method \nin your class The finalize  method of your class will be called by the garbage collector before an object \nof your class is destroyed Listing 1114  contains code for the Finalize  class It overrides the finalize  \nmethod of the Object  class and prints a message on the standard output You can perform any cleanup logic \nin this method The code in the finalize  method is also called finalizer \nListing 1114  A Fin alize Class That Overrides the finalize Method of the Object Class\n Finalizejava\npackage comjdojoobject\npublic class Finalize \n    private int x\n    public Finalizeint x \n        thisx  x\n    \n    Override\n    public void finalize \n        SystemoutprintlnFinalizing   thisx\n         Perform any cleanup work here \n    \n\nThe garbage collector calls the finalizer for each object only once Running a finalizer for an object does \nnot necessarily mean that the object will be destroyed immediately after the finalizer finishes A finalizer is \nrun when the garbage collector determines that no references to the object exist However an object may \npass its own reference to some other part of the program when its finalizer is run This is the reason that the \ngarbage collector checks one more time after it runs an objects finalizer to make sure that no references \nexist for that object and then it destroys deallocates memory the object The order in which finalizers are \nrun and the time at which they are run are not specified It is not even guaranteed that a finalizer will run at \nall This makes it undependable for a programmer to write cleanup logic in the finalize  method There \nare better ways to perform cleanup logic for example using a tryfinally  block It is suggested not to \ndepend on the finalize  method in your Java program to clean up resources used by an object\n Tip the finalize  method in the Object  class has been deprecated since java 9 because using the \nfinalize  method to clean up resources is inherently problematic there are several better alterna tives to \nclean up resources for example using trywithresources  and tryfinally  blocks We discuss these \ntechniques in Chapter 13 of this book We have covered the finalize  method in this chapter just for the \npurpose of completeness\nListing 1115  contains code to test the finalizers for your Finalize  class You may get different output \nwhen you run this program\nListing 1115  A Tes t Class to Test Finalizers\n FinalizeTestjava\npackage comjdojoobject\npublic class FinalizeTest \n    public static void mainString args \n         Create many objects say 2000000 objectsChapter 11  Obje Ct and\u00a0Obje Cts Classes\n422        forint i  0 i  2000000 i \n            new Finalizei\n        \n    \n\nFinalizing 977620\nFinalizing 977625\nFinalizing 977627\nThe program creates 2000000 objects of the Finalize  class without storing their references It is \nimportant that you do not store the references of the objects you create As long as you hold the reference \nof an object it will not be destroyed and its finalizer will not be run You can see from the output that only \nthree objects got a chance to run their finalizers before the program finished You may get no output at all \nor a different output If you do not get any output you can try by increasing the number of objects to create \nThe garbage collector will destroy objects when it feels it is running low in memory You may need to create \nmore objects to trigger garbage collection which in turn will run finalizers of your objects\n Immutable Objects\nAn object whose state cannot be changed after it is created is called an immutable  object A class whose \nobjects are immutable is called an immutable class If an objects state can be changed or mutated after it \nhas been created it is called a mutable object and its class is called a mutable class\nBefore we go into details of creating and using immutable objects lets define the word immutability  \nInstance variables of an object define the state of an object There are two views of an objects state internal \nand external The internal state of the object is defined by the actual values of its instance variables at a point \nin time The external state of the object is defined by the values that the users or clients of the object see \nat a point in time When we state that an object is immutable we must be specific about which state of the \nobject we mean to be immutable internal state external state or both\nTypically when we use the phrase an immutable object in Java we mean external immutability In \nexternal immutability an object may change its internal state after its creation However the change in its \ninternal state is not visible to external users The users do not see any changes in its state after its creation \nIn internal immutability the state of an object does not change after it is created If an object is internally \nimmutable it is also externally immutable We discuss examples of both\nImmutable objects have several advantages over mutable objects An immutable object can be shared \nby different areas of a program without worrying about its state changes Testing an immutable class is easy \nAn immutable object is inherently threadsafe You do not have to synchronize access to your immutable \nobject from multiple threads since its state does not change Refer to the second volume of this series for \nmore details on thread synchronization An immutable object does not have to be copied and passed to \nanother area of the program in the same Java application because its state does not change You can just pass \nits reference and that serves as a copy Its reference can be used to access its content Avoiding copying is a \nbig performance advantage as it saves both time and space\nLets start with a mutable class whose objects state can be modified after it is created Listing 1116  \ncontains the code for an IntHolder  classChapter 11  Obje Ct and\u00a0Obje Cts Classes\n423Listing 1116  An Exam ple of a Mutable Class Whose Objects State Can Be Changed After Creation\n IntHolderjava\npackage comjdojoobject\npublic class IntHolder \n    private int value\n    public IntHolderint value \n        thisvalue  value\n    \n    public void setValueint value \n        thisvalue  value\n    \n    public int getValue \n        return value\n    \n\nThe value  instance variable defines the state of an IntHolder  object You create an object of the \nIntHolder  class as shown\nIntHolder holder  new IntHolder101\nint v  holdergetValue  Stores 101  in v\nAt this time the value  instance variable holds 101 which defines its state You can get and set the \ninstance variable using the getter and setter\n Change the value\nholdersetValue505\nint w  holdergetValue  Stores 505  in w\nAt this point the value  instance variable has changed from 101 to 505 That is the state of the object has \nchanged The change in state was facilitated by the setValue  method Objects of the IntHolder  class are \nexamples of mutable objects\nLets make the IntHolder  class immutable All you need to do is remove the setValue  method from \nit to make it an immutable class Lets call your immutable version of the IntHolder  class as IntWrapper  as \nshown in Listing 1117 \nListing 1117  An Exam ple of an Immutable Class\n IntWrapperjava\npackage comjdojoobject\npublic class IntWrapper \n    private final int value\n    public IntWrapperint value \n        thisvalue  value\n    \n    public int getValue \n        return value\n    \nChapter 11  Obje Ct and\u00a0Obje Cts Classes\n424This is how you create an object of the IntWrapper  class\nIntWrapper wrapper  new IntWrapper101\nAt this point the wrapper  object holds 101 and there is no way to change it Therefore the IntWrapper  \nclass is an immutable class and its objects are immutable objects You might have noticed that two changes \nwere made to the IntHolder  class to convert it to the IntWrapper  class The setValue  method was \nremoved and the value  instance variable was made final  In this case it was not necessary to make the \nvalue  instance variable final  The use of the final  keyword makes your intention clear to the reader of the \nclass and it protects the value  instance variable from being changed inadvertently It is good practice use \nit as a rule of thumb to declare all instance variables that define the immutable state of an object final  so \nthe Java compiler will enforce the immutability during compilation The objects of the IntWrapper  class are \nimmutable internally as well as externally There is no way to change its state once it is created\nLets create a variant of the IntWrapper  class which will be externally immutable but internally \nmutable Lets call it IntWrapper2  It is listed in Listing 1118 \nListing 1118  An Exam ple of an Externally Immutable and Internally Mutable Class\n IntWrapper2java\npackage comjdojoobject\npublic class IntWrapper2 \n    private final int value\n    private int halfValue  IntegerMAXVALUE\n    public IntWrapper2int value \n        thisvalue  value\n    \n    public int getValue \n        return value\n    \n    public int getHalfValue \n         Compute half value if it is not already computed\n        if thishalfValue  IntegerMAXVALUE \n             Cache the half value for future use\n            thishalfValue  thisvalue  2\n        \n        return thishalfValue\n    \n\nIntWrapper2  adds another instance variable called halfValue  which will hold the half value of the \nvalue that is passed to the constructor It is a trivial example However it serves the purpose to explain what \nyou mean by externally and internally immutable objects Suppose just for the sake of this discussion that \ncomputing half of an integer is a very costly process and you do not want to compute it in the constructor \nof the IntWrapper2  class especially if not everybody asks for it The halfValue  instance variable is \ninitialized to the maximum integer value which works as a flag that it is not computed yet You have added a \ngetHalfValue  method which checks if you have already computed the half value For the first time it will \ncompute the half value and cache it in the halfValue  instance variable From the second time onward it will \nsimply return the cached value\nThe question is Is an IntWrapper2  object immutable The answer is yes and no It is internally mutable \nHowever it is externally immutable Once it is created its client will see the same return value from the \ngetValue  and getHalfValue  methods However its state  halfValue  to be specific changes once in its Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n425lifetime when the getHalfValue  method is called for the first time However this change is not visible to the \nusers of the object This method returns the same value on all subsequent calls Objects like IntWrapper2  are \ncalled immutable objects Recall that typically an immutable object means externally immutable\nThe String  class in the Java class library is an example of an immutable class It uses the caching \ntechnique discussed for the IntWrapper2  class The String  class computes hash code for its content when \nits hashCode  method is called for the first time and caches the value Thus a String  object changes its \nstate internally but not for its client You will not come across the statement  A String  object in Java is \nexternally immutable and internally mutable  Rather you will come across the statement  A String  object \nin Java is immutable  You should understand that it means String  objects are at least externally immutable\nListing 1119  shows a tricky situation where an attempt has been made to create an immutable \nclass The IntHolderWrapper  class has no method that can directly let you modify the value stored in its \nvalueHolder  instance variable It seems to be an immutable class\nListing 1119  An Uns uccessful Attempt to Create an Immutable Class\n IntHolderWrapperjava\npackage comjdojoobject\npublic class IntHolderWrapper \n    private final IntHolder valueHolder\n    public IntHolderWrapperint value \n        thisvalueHolder  new IntHoldervalue\n    \n    public IntHolder getIntHolder \n        return thisvalueHolder\n    \n    public int getValue \n        return thisvalueHoldergetValue\n    \n\nListing 1120  contains a test class to test the immutability of the IntHolderWrapper  class\nListing 1120  A Tes t Class to Test Immutability of the IntHolderWrapper Class\n BadImmutableTestjava\npackage comjdojoobject\npublic class BadImmutableTest \n    public static void mainString args \n        IntHolderWrapper ihw  new IntHolderWrapper101\n        int value  ihwgetValue\n        Systemoutprintln1 value    value\n        IntHolder holder  ihwgetIntHolder\n        holdersetValue207\n        value  ihwgetValue\n        Systemoutprintln2 value    value\n    \n\n1 value  101\n2 value  207Chapter 11  Obje Ct and\u00a0Obje Cts Classes\n426The output shows that the IntHolderWrapper  class is mutable Two calls to its getValue  method \nreturn different values The culprit is its getIntHolder  method It returns the valueHolder  instance \nvariable which is a reference variable Note that the valueHolder  instance variable represents an object \nof the IntHolder  class which makes up the state of an IntHolderWrapper  object If the object that the \nvalueHolder  reference variable references is changed the state of IntHolderWrapper  is changed too Since \nthe IntHolder  object is mutable you should not return its reference to the client from the getIntHolder  \nmethod The following two statements change the state of the object from the client code\nIntHolder holder  ihwgetIntHolder  Got hold of instance variable \nholdersetValue207  Change the state by changing the instance variables state \nNote that the designer of the IntHolderWrapper  class missed the point when they returned the \nvalueHolder  reference that even though there is no direct way to change the state of the IntHolderWrapper  \nclass it can be changed indirectly\nHow do you correct the problem The solution is easy In the getIntHolder  method make a copy \nof the valueHolder  object and return the reference of the copy instead of the instance variable itself This \nway if the client changes the value it will be changed only in the clients copy not in the copy held by the \nIntHolderWrapper  object Listing 1121  contains the correct immutable version of the IntHolderWrapper  \nclass which you call IntHolderWrapper2 \nListing 1121  A Mo dified Immutable Version of the IntHolderWrapper Class\n IntHolderWrapper2java\npackage comjdojoobject\npublic class IntHolderWrapper2 \n    private final IntHolder valueHolder\n    public IntHolderWrapper2int value \n        thisvalueHolder  new IntHoldervalue\n    \n    public IntHolder getIntHolder \n         Make a copy of valueHolder\n        int v  thisvalueHoldergetValue\n        IntHolder copy  new IntHolderv\n         Return the copy instead of the original\n        return copy\n    \n    public int getValue \n        return thisvalueHoldergetValue\n    \n\nCreating an immutable class is a little trickier than it seems I have covered some of the cases in this \nsection Here is another case where you need to be careful Suppose you have designed an immutable \nclass that has a referencetype instance variable Suppose it accepts the initial value of its referencetype \ninstance variable in one of its constructors If the instance variables class is a mutable class you must make \na copy of the parameter passed to its constructor and store the copy in the instance variable The client code \nthat passes the objects reference in the constructor may change the state of this object through the same \nreference later Listing 1122  shows how to implement the second constructor for the IntHolderWrapper3  \nclass correctly It has the incorrect version of the implementation for the second constructor commentedChapter 11  Obje Ct and\u00a0Obje Cts Classes\n427Listing 1122  Using a Copy Constructor to Correctly Implement an Immutable Class\n IntHolderWrapper3java\npackage comjdojoobject\npublic class IntHolderWrapper3 \n    private final IntHolder valueHolder\n    public IntHolderWrapper3int value \n        thisvalueHolder  new IntHoldervalue\n    \n    public IntHolderWrapper3IntHolder holder \n         Must make a copy of holder parameter\n        thisvalueHolder  new IntHolderholdergetValue\n         Following implementation is incorrect Client code will be able to change the\n           state of the object using holder reference later \n        thisvalueHolder  holder  do not use it \n    \n     Rest of the code goes here \n\n The Objects Class\nThe JDK contains a utility class named Objects  in the javautil  package for working with objects It \nconsists of all static methods Most methods of the Objects  class deal with null  values gracefully Java 9 \nadded a few more utility methods to the class Methods in the Objects  class fit into the following categories \ndepending on the kind of operation they perform\n\t Bounds checks\n\t Comparing objects\n\t Computing hash code\n\t Checking for null\n\t Validating arguments\n\t Obtaining string representation of objects\n Bounds Checks\nMethods in this category are used to check if an index or a subrange is within the bounds of a range \nTypically you use these methods on arrays before performing an operation that involves the array bounds \nAn array in Java is a collection of the same type of elements Each element in an array has an index that is \nused to access them Array indexes are zerobased The first element has an index of 0 the second 1 the \nthird 2 etc Suppose you have an array of five elements and someone asks you to give them four elements \nof the array starting at index 3 This request is invalid because the array index ranges from 0 to 4 and the \nrequested elements are from indexes 3 to 6 The Objects  class contains the following three methods to \nperform bounds checksall of which were added in Java 9\n\tint checkFromIndexSizeint fromIndex int size int length\n\tint checkFromToIndexint fromIndex int toIndex int length\n\tint checkIndexint index int lengthChapter 11  Obje Ct and\u00a0Obje Cts Classes\n428All these methods throw an IndexOutOfBoundsException  if the check for an index or a subrange is not \nwithin the bounds of 0 to length  where length  is one of the arguments to the methods\nThe checkFromIndexSizeint fromIndex int size int length  method checks if the subrange \nfrom fromIndex  inclusive to fromIndex  size  exclusive is within the bounds of range from 0 inclusive \nto length  exclusive\nThe checkFromToIndexint fromIndex int toIndex int length  method checks if the subrange \nfrom fromIndex  inclusive to toIndex  exclusive is within the bounds of range from 0 inclusive to length  \nexclusive\nThe checkIndexint index int length  method checks if the index  is within the bounds of the \nrange from 0 inclusive to length  exclusive\n Comparing Objects\nMethods in this category are used to compare objects for sorting purposes or for equality There are three \nmethods in this category\n\tT int compareT a T b Comparator super T c\n\tboolean deepEqualsObject a Object b\n\tboolean equalsObject a Object b\nThe compare  method is used to compare two objects for sorting purposes It returns 0 if both arguments \nare identical Otherwise it returns the value of ccomparea b  It returns 0 if both arguments are null \nThe deepEquals  method is used to check if two objects are deeply equal It returns true  if both \narguments are deeply equal Otherwise it returns false  It returns true  if both arguments are null \nThe equals  method compares two objects for equality It returns true  if both arguments are equal \nOtherwise it returns false  It returns true  if both arguments are null  It returns false  if only one argument \nis null \n Computing Hash Code\nMethods in this category are used to compute hash codes for one or more objects There are two methods in \nthis category\n\tint hashObject values\n\tint hashCodeObject obj\nThe hash  method generates a hash code for all specified objects in its arguments It can be used to \ncompute the hash code for an object that contains multiple instance fields Listing 1123  contains another \nversion of the Book  class This time the hashCode  method uses the Objectshash  method to compute \nthe hash code of a Book  object Compare the code for the Book  class in Listing 112  with the code for the \nBook2  class in Listing 1123  Notice how easy it is to compute the hash code of an object using  \nthe Objectshash  method\nListing 1123  Using the Objectshash Method to Compute the Hash Code of an Object\n Book2java\npackage comjdojoobject\nimport javautilObjects\npublic class Book2 \n    private String title\n    private String authorChapter 11  Obje Ct and\u00a0Obje Cts Classes\n429    private int pageCount\n    private boolean hardCover\n    private double price\n     Other code goes here \n     Must implement the equals method too \n    Override\n    public int hashCode \n        return Objectshashtitle author pageCount hardCover price\n    \n\nIf a single object reference is passed to the Objectshash  method the returned hash code is not \nequal to the hash code returned from the objects hashCode  method In other words if book  is an object \nreference bookhashCode  is not equal to Objectshashbook \nThe ObjectshashCodeObject obj  method returns the hash code value of the specified object If the \nargument is null  it returns 0\n Checking for\u00a0Null\nMethods in this category are used to check if an object is null or not There are two methods in this category\n\tboolean isNullObject obj\n\tboolean nonNullObject obj\nThe isNull  method returns true  if the specified object is null  Otherwise it returns false  You can \nalso check whether an object is null using the comparison operator  for example obj  null  returns \ntrue  if obj is null  The isNull  method was added in Java 8 It exists to be used as a method reference like \nObjectsisNull \nThe nonNull  method performs the opposite check of the isNull  method It was also added in Java \n8 to be used as a method reference like ObjectsnonNull \n Validating Arguments\nMethods in this category are used to validate required  arguments of constructors and methods What you \ncould achieve by writing a few lines of code with if statements you can achieve the same in one line of code \nusing these methods There are five methods in this category\n\tT T requireNonNullT obj\n\tT T requireNonNullT obj String message\n\tT T requireNonNullT obj SupplierString messageSupplier\n\tT T requireNonNullElseT obj T defaultObj\n\tT T requireNonNullElseGetT obj Supplier extends T supplierChapter 11  Obje Ct and\u00a0Obje Cts Classes\n430The requireNonNullT obj  method checks if the argument is not null  If the argument is null  \nit throws a NullPointerException  This method is designed for validating arguments of methods and \nconstructors Notice the formal type parameter T in the methods declaration This makes it a generic \nmethod any type of object can be passed as an argument to this method Its return type is the same as the \ntype of the passed object The method is overloaded The second version of the method lets you specify \nthe message for the NullPointerException  that is thrown when the argument is null  The third version \nof the method takes a SupplierString  as the second argument It defers the creation of the message \nuntil the null check is performed If the first argument is null  the get  method of the SupplierString  \nobject is called to get the error message that is used in NullPointerException  Using a supplier delays the \nconstruction of the error message and it also gives you more options such as adding the timestamp in your \nerror message\nJava 9 added the requireNonNullElse  and requireNonNullElseGet  methods to the Objects  \nclass The requireNonNullElse  method returns the first argument if it is not null  otherwise it \nreturns the second argument if the second argument is not null  If both arguments are null it throws \na NullPointerException  The requireNonNullElseGet  method returns the first argument if it is not \nnull  otherwise it returns the not null  value returned from the get  method of the supplier  If the first \nargument is null  and the supplier is null or the supplier returns null  it throws a NullPointerException \n Obtaining String Representation of\u00a0Objects\nMethods in this category are used to obtain a string representation of an object There are two methods in \nthis category\n\tString toStringObject o\n\tString toStringObject o String nullDefault\nThe toString  method returns a null string if the argument is null  For a nonnull argument it \nreturns the value returned by calling the toString  method on the argument The second version of the \nmethod lets you specify the default returned string when the argument is null\n Using the\u00a0Objects Class\nListing 1124  demonstrates how to use some of the methods of the Objects  class The program uses a \nlambda expression to create a SupplierString  Lambda expressions are discussed in detail in Chapter 21 \nof this book It is used here to give you a complete example In short a lambda expression uses the following \nsyntax parameters   expression  If a lambda expression has no parameters it uses the following syntax  \n expression \nListing 1124  A Tes t Class to Demonstrate the Use of the Methods of the Objects Class\n ObjectsTestjava\npackage comjdojoobject\nimport javatimeInstant\nimport javautilObjects\nimport javautilfunctionSupplier\npublic class ObjectsTest \n    public static void mainString args \n         Compute hash code for two integers a char and a string\n        int hash  Objectshash10 8900 u20b9 Hello\n        SystemoutprintlnHash Code is   hash\n         Test for equalityChapter 11  Obje Ct and\u00a0Obje Cts Classes\n431        boolean isEqual  Objectsequalsnull null\n        Systemoutprintlnnull is equal to null   isEqual\n        isEqual  Objectsequalsnull XYZ\n        Systemoutprintlnnull is equal to XYZ   isEqual\n         toString method test\n        SystemoutprintlntoStringnull is   ObjectstoStringnull\n        SystemoutprintlntoStringnull XXX is   ObjectstoStringnull XXX\n         Testing requireNonNullT obj String message\n        try \n            printNameDoug Dyer\n            printNamenull\n         catch NullPointerException e \n            SystemoutprintlnegetMessage\n        \n         requireNonNullT obj SupplierString messageSupplier\n        try \n             Using a lambda expression to create a SupplierString object\n             The Supplier returns a time stamped message\n            SupplierString messageSupplier \n                      Name is required Error generated on   Instantnow\n            printNameWithSupplierBabalu messageSupplier\n            printNameWithSuppliernull messageSupplier\n         catch NullPointerException e \n            SystemoutprintlnegetMessage\n        \n         T T requireNonNullElseT obj T defaultObj\n         printNameWithDefaultKishori Sharan\n          Default name John Doe will be used\n         printNameWithDefaultnull\n    \n    public static void printNameString name \n         Test name for not null Generate a NullPointerException if it is null\n        ObjectsrequireNonNullname Name is required\n         Print the name if the above statement did not throw an exception\n        SystemoutprintlnName is   name\n    \n    public static void printNameWithSupplierString name SupplierString messageSupplier \n         Test name for not null Generate a NullPointerException if it is null\n        ObjectsrequireNonNullname messageSupplier\n         Print the name if the above statement did not throw an exception\n        SystemoutprintlnName is   name\n    \n    public static void printNameWithDefaultString name \n         Test name for not null Generate a NullPointerException if it is null\n        ObjectsrequireNonNullElsename John Doe\n         Print the name if the above statement did not throw an exception\n        SystemoutprintlnName is   name\n    \nChapter 11  Obje Ct and\u00a0Obje Cts Classes\n432Hash Code is 79643668\nnull is equal to null true\nnull is equal to XYZ false\ntoStringnull is null\ntoStringnull XXX is XXX\nName is Doug Dyer\nName is required\nName is Babalu\nName is required Error generated on 20170729T024425974523900Z\nName is Kishori Sharan\nName is null\n Summary\nClasses in Java are arranged in a treelike hierarchy Classes in the tree have a superclasssubclass \nrelationship The Object  class is at the root of the class hierarchy It is the superclass of all classes in Java \nThe Object  class is in the javalang  package which in turn is in the javabase  module The Object  class \ncontains methods that are automatically available in all classes Some methods have been implemented \nand some have an empty implementation Classes can also reimplement some methods in the Object  class \nA reference variable of the Object  class can store the reference of any reference type in Java\nEvery type loaded into the JVM is represented by an instance of the ClassT  class The getClass  \nmethod of the Object  class returns the reference of the ClassT  object of the type of the object on which \nthis method is called\nA hash code is an integer value that is computed for a piece of information using an algorithm A hash \ncode is also known as a hash sum a hash value or simply a hash The algorithm to compute an integer from \na piece of information is called a hash function The Object  class contains a hashCode  method that returns \nan int which is the hash code of the object The default implementation of this method computes the hash \ncode of an object by converting the memory address of the object into an integer Since the hashCode  \nmethod is defined in the Object  class it is available in all classes in Java However you are free to override \nthe implementation in your class\nEvery object in the universe is different from all other objects and every object in a Java program is \ndifferent from all other objects All objects have a unique identity The memory address at which an object \nis allocated can be treated as its identity which will make it always unique Two objects are the same if they \nhave the same identity or reference in Java terminology The equality operator   in Java compares the \nreferences of two objects to test whether they are equal Sometimes you want to treat two objects as equal \nif they have the same state based on some or all of their instance variables If you want to compare two \nobjects of your class for equality based on criteria other than their references identities your class needs to \nreimplement the equals  method of the Object  class The default implementation of the equals  method \nin the Object  class compares the references of the object being passed as the parameter and the object on \nwhich the method is called\nSometimes it is helpful usually when debugging to represent an object in a string form which should \ncontain enough information about the state of the object in a readable format The toString  method of \nthe Object  class lets you write your own logic to represent the object of your class as a string The Object  \nclass provides a default implementation of the toString  method It returns a string containing the fully \nqualified class name of the object and the hash code of the object in hexadecimal format\nCloning an object means copying the content of the object bit by bit Java does not provide an automatic \nmechanism to clone make a copy an object If you want objects of your class to be cloned you must \nreimplement the clone  method of the Object  class in your class Once you reimplement the clone  \nmethod you should be able to clone objects of your class by calling the clone  methodChapter 11  Obje Ct and\u00a0Obje Cts Classes\n433Sometimes an object uses resources that need to be released when the object is destroyed The \ngarbage collector gives you a chance to execute your cleanup code before an object is destroyed by \ncalling the finalize  method of your object The method is declared in the Object  class and its default \nimplementation does not do anything The code in the finalize  method is also called finalizer  You \nneed to reimplement the finalize  method in your class and write the logic to release resources The \nfinalize  method is problematic and it has been deprecated in Java 9 Many other techniques are \navailable to release resources held by an object\nJava 7 added a utility class Objects  in the javautil  package Java 8 and Java 9 added a few more \nmethods to this class Methods in the Objects  class fit into the following categories depending on the kind \nof operation they perform bounds checks for an index or subrange inside a range comparing objects \ncomputing hash code checking for null validating constructor and method arguments and obtaining string \nrepresentation of objects Most of the methods in this class exist to deal with null  values gracefully\nEXERCISES\n 1 What is the fully qualified name of the class that is the superclass of all classes in java\n 2 What is the superclass of the javalangObject  class\n 3 name three methods that are available in the Object  class and describe their \nusage in brief\n 4 What is a hash code When is it used in java What method in the Object  class is \nused to return the hash code of an object\n 5 how is the comparison of two objects performed using the  operator\n 6 What method of the Object  class must be overridden in your class if you want to \ncompare objects of your class for equality based on their state not their references\n 7 What is the default implementation of the equals  method in the Object  class\n 8 Is the follo wing statement true in java\nIf two objects are equal according to the equalsObject method then calling the \nhashCode method on each of the two objects must produce the same integer result\n 9 If your c lass overrides the equals  method of the Object  class which other \nmethod of the Object  class should also be overridden by your class\n 10 What is the cloning of objects in java What are shallow and deep cloning\n 11 What method of the Object  class do you need to override in your class to allow \ncloning of objects of your class Create a Phone  class with two fields as shown\n Phonejava\npackage comjdojoobjectexcercise\npublic class Phone \n    private String areaCode\n    private String number\n\nImplement the clone  method in the Phone  class so the Phone  objects can be \ncloned correctly both instance variables in the class are requiredChapter 11  Obje Ct and\u00a0Obje Cts Classes\n434 12 What method of the Object  class do you need to override to provide a string \nrepresentation of objects of your class enhance the Phone  class by implementing \nthe toString  method\n 13 What is the use of the finalize  method in a class should you use the \nfinalize  method to clean up resources held by objects of your class\n 14 What is an immutable object and an immutable class What are the benefits of \nusing immutable objects name one immutable class in java that you use very \noften\n 15 Use the methods of the Objects  class to implement the hashCode  method \nand other methods of the Phone  class For example use the requireNonNull  \nmethod of the Objects  class inside the constructors and methods of the Phone  \nclass to validate arguments values\n 16 how do you define a lambda expression with no parameters and return the string \nhello world\n 17 Write the missing pieces of the follo wing snippet of code that will print the simple \nname and the fully qualified name of the Phone  class\nPhone p  new Phone\nClass cls   your code goes here \nString simpleName  cls your code goes here \nString fullyQualifedName  cls your code goes here \nSystemoutprintlnSimple class name     simpleName\nSystemoutprintlnFully qualified name     fullyQualifedName435\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307412CHAPTER 12\nWrapper Classes\nIn this chapter you will learn\n\t The wrapper classes in Java and how to use them\n\t How to get primitive values from strings\n\t How primitive values are automatically boxed into wrapper objects when needed\n\t How wrapper objects are automatically unboxed into primitive values when needed\nAll classes in this chapter are a member of a jdojowrapper  module as declared in Listing 121 \nListing 121  The D eclaration of a jdojowrapper Module\n moduleinfojava\nmodule jdojowrapper \n    exports comjdojowrapper\n\n Wrapper Classes\nIn previous chapters you learned that primitive and reference types are not assignment compatible You \ncannot even compare a primitive value with an object reference Some parts of the Java library work only \nwith objects for example collections in Java work only with objects You cannot create a list of primitive \nvalues such as 1 3 8 and 10 You need to wrap the primitive values into objects before you can store them \nin a list or set\nThe assignment incompatibility between primitive values and reference values has existed in Java \nsince its first release The Java library provided eight classes in the javalang  package to represent each \nof the eight primitive types These classes are called wrapper classes  as they wrap a primitive value in an \nobject Table\u00a0 121  lists the primitive types and their corresponding wrapper classes Notice the names of the \nwrapper classes Following the Java convention for naming classes they start with an uppercase letterChapter 12  Wrapper Classes\n436All wrapper classes are immutable They provide three ways to create their objects\n\t Using constructors deprecated\n\t Using the valueOf  factory static methods\n\t Using the parseXxx  method where Xxx is the name of the wrapper class It is not \navailable in the Character  class\n Tip all constructors in all wra pper classes have been deprecated since Java se 9 as they were rarely \nneeded to create wrapper objects Being deprecated means they will be removed in a future version of Java \nYou should use other ways such as the valueOf  and parseXxx  methods to create their objects instead\nEach wrapper class except Character  provides at least two constructors one takes a value of \nthe corresponding primitive type and another takes a String  The Character  class provides only one \nconstructor that takes a char  All of the constructors in wrapper classes are deprecated and so should be \navoided The preferred way to create objects of wrapper classes is to use their valueOf  static methods The \nfollowing snippet of code creates objects of a few wrapper classes using their valueOf  methods\nInteger intObj1  IntegervalueOf100\nInteger intObj2  IntegervalueOf1969\nDouble doubleObj1  DoublevalueOf1045\nDouble doubleObj2  DoublevalueOf23460\nCharacter charObj1  CharactervalueOfA\nUse of the valueOf  method to create objects for integer numeric values  byte  short  int and long  \nresults in better memory usage as this method caches some objects for reuse The wrapper classes for these \nprimitive types cache wrapper objects for primitive values between 128 and 127 For example if you call \nIntegervalueOf25  multiple times the reference of the same Integer  object from the cache is returned \nHowever when you call new Integer25  multiple times a new Integer  object is created for each call \nListing 122  demonstrates the difference in using constructors and valueOf  methods for the Integer  \nwrapper classTable 121  List of Primitive Types and Their \nCorresponding Wrapper Classes\nPrimitive Type Wrapper Class\nByte Byte\nShort Short\nInt Integer\nLong Long\nFloat Float\ndouble Double\nChar Character\nboolean BooleanChapter 12  Wrapper Classes\n437Listing 122  The Difference Between Using Constructors and the valueOf Method to Create Integer Objects\n CachedWrapperObjectsjava\npackage comjdojowrapper\npublic class CachedWrapperObjects \n    public static void mainString args \n        SystemoutprintlnUsing the constructor\n         Create two Integer objects using constructors\n        Integer iv1  new Integer25\n        Integer iv2  new Integer25\n        Systemoutprintlniv1    iv1   iv2    iv2\n         Compare iv1 and iv2 references\n        Systemoutprintlniv1  iv2   iv1  iv2\n         Lets see if they are equal in values\n        Systemoutprintlniv1equalsiv2   iv1equalsiv2\n        SystemoutprintlnnUsing the valueOf method\n         Create two Integer objects using the valueOf\n        Integer iv3  IntegervalueOf25\n        Integer iv4  IntegervalueOf25\n        Systemoutprintlniv3    iv3   iv4    iv4\n         Compare iv3 and iv4 references\n        Systemoutprintlniv3  iv4   iv3  iv4\n         Lets see if they are equal in values\n        Systemoutprintlniv3equalsiv4   iv3equalsiv4\n    \n\nUsing the constructor\niv1  25 iv2  25\niv1  iv2 false\niv1equalsiv2 true\nUsing the valueOf method\niv3  25 iv4  25\niv3  iv4 true\niv3equalsiv4 true\nNotice that iv1 and iv2 are references to two different objects as iv1  iv2  returns false  However \niv3 and iv4 are references to the same object as iv3  iv4  returns true  Of course iv1 iv2 iv3 and \niv4 represent the same primitive value of 25 as indicated by the returned value from the equals  method \nTypically programs use smaller integer literals If you are wrapping bigger integers the valueOf  method \ncreates a new object every time it is called\n Ti p the new operator always creates a new object If you do not need new objects of the primitive values \nuse the valueOf  factory method of the wrapper class instead of using the constructors the equals  \nmethods in the wrapper classes have been reimplemented to compare the wrapped primitive values in wrapper \nobjects not their referencesChapter 12  Wrapper Classes\n438 Numeric Wrapper Classes\nByte  Short  Integer  Long  Float  and Double  classes are numeric wrapper classes They are all inherited \nfrom the Number  class The Number  class is declared abstract You cannot create an object of the Number  class \nHowever you can declare reference variables of the Number  class You can assign an object reference of any \nof the six numeric wrapper classes to a reference variable of the Number  class\nThe Number  class contains six methods They are named xxxValue  where xxx is the name of one of \nthe six primitive data types  byte  short  int long  float  and double  The return type of the methods is \nthe same as xxx That is the byteValue  method returns a byte  the intValue  method returns an int \netc The following snippet of code shows how to retrieve different primitive type values from a numeric \nwrapper object\n Creates an Integer object\nInteger intObj  IntegervalueOf100\n Gets byte from Integer\nbyte b  intObjbyteValue\n Gets double from Integer\ndouble dd  intObjdoubleValue\nSystemoutprintlnintObj    intObj\nSystemoutprintlnbyte from intObj    b\nSystemoutprintlndouble from intObj    dd\n Creates a Double object\nDouble doubleObj  DoublevalueOf32978\n Gets different types of primitive values from Double\ndouble d  doubleObjdoubleValue\nfloat f  doubleObjfloatValue\nint i  doubleObjintValue\nlong l  doubleObjlongValue\nSystemoutprintlndoubleObj    doubleObj\nSystemoutprintlndouble from doubleObj    d\nSystemoutprintlnfloat from doubleObj    f\nSystemoutprintlnint from doubleObj    i\nSystemoutprintlnlong from doubleObj    l\nintObj  100\nbyte from intObj  100\ndouble from intObj  1000\ndoubleObj  32978\ndouble from doubleObj  32978\nfloat from doubleObj  32978\nint from doubleObj  329\nlong from doubleObj  329\nJava 8 added some methods like sum  max  and min  in some of the numeric wrapper classes such \nas Integer  Long  Float  and Double  For example Integersum10 20  simply returns the result of 10  20 \nAt first you might think Did the wrapper class designers not have any useful things to do instead of adding \nthese trivial methods Did we forget to use the addition operator  to add two numbers so we will use the \nIntegersum10 20  Your assumption is wrong These methods have been added for a greater purpose \nThey are not intended to be used as Integersum10 20  They are meant to be used as method references \nworking with collectionsChapter 12  Wrapper Classes\n439Your program may receive numbers as strings You may want to obtain primitive values or wrapper \nobjects from those strings Sometimes the integer values in a string may be encoded in different bases also \ncalled radix for example decimal binary hexadecimal etc Wrapper classes help in working with strings \ncontaining primitive values\n\t Use the valueOf  methods to convert strings into wrapper objects\n\t Use the parseXxx  methods to convert strings into primitive values\nThe Byte  Short  Integer  Long  Float  and Double  classes contain parseByte  parseShort  \nparseInt  parseLong  parseFloat  and parseDouble  methods to parse strings into primitive \nvalues respectively\nThe following snippet of code converts a string containing an integer in binary format into an Integer  \nobject and an int value\nString str  01111111\nint radix  2\n Creates an Integer object from the string\nInteger intObject  IntegervalueOfstr radix\n Extracts the int value from the string\nint intValue  IntegerparseIntstr 2\nSystemoutprintlnstr    str\nSystemoutprintlnintObject    intObject\nSystemoutprintlnintValue    intValue\nstr  01111111\nintObject  127\nintValue  127\nJava 9 added a few methods in the Integer  and Long  classes to parse a string whose contents are not all \nintegers The following is a list of such methods in the Integer  class Method names in the Long  class end \nwith Long  and these methods return long  All these methods throw a NumberFormatException \n\tint parseIntCharSequence s int beginIndex int endIndex int radix\n\tint parseUnsignedIntCharSequence s int beginIndex int endIndex int radix\n\tint parseUnsignedIntString s\n\tint parseUnsignedIntString s int radix\nThe new version of the parseInt  method parses the CharSequence  argument such as a String  as \na signed int in the specified radix  beginning at the specified beginIndex  and extending to endIndex   1 \nThe following snippet of code shows you how to use the new parseInt  method to extract year month and \nday values as integers from a date in a string which is in the yyyymmdd  format\nString dateStr  20170729\nint year  IntegerparseIntdateStr 0 4 10\nint month  IntegerparseIntdateStr 5 7 10\nint day  IntegerparseIntdateStr 8 10 10\nSystemoutprintlnYear    year\nSystemoutprintlnMonth    month\nSystemoutprintlnDay    dayChapter 12  Wrapper Classes\n440Year  2017\nMonth  7\nDay  29\nThe three versions of the parseInt  method parse strings as signed integers whereas the three \nversions of the parseUnsignedInt  method parse digits in a string as an unsigned integer in the specified \nradix\nAll numeric wrapper classes contain several useful constants Their MINVALUE  and MAXVALUE  \nconstants represent the minimum and maximum values that can be represented by their corresponding \nprimitive type For example the ByteMINVALUE  constant is 128 and the ByteMAXVALUE  constant is 127 \nwhich are the minimum and maximum values that can be stored in a byte  They also have a SIZE  constant \nthat represents the size in bits that a variable of the corresponding primitive type occupies For example \nByteSIZE  is 8 and IntegerSIZE  is 32\nTypically you receive strings from external sources for example a file If strings cannot be converted \nto numbers wrapper classes will throw a NumberFormatException  It is common to place the string parsing \nlogic inside a trycatch  block and handle the exceptions\nThe following snippet of code attempts to parse two strings into double  values The first string contains \na valid double  and the second one contains an invalid double  A NumberFormatException  is thrown when \nthe parseDouble  method is called to parse the second string\nString str1  12389\ntry \n    double value1  DoubleparseDoublestr1\n    Systemoutprintlnvalue1    value1\n catch NumberFormatException e \n    SystemoutprintlnError in parsing   str1\n\nString str2  78H90  An invalid double\ntry \n    double value2  DoubleparseDoublestr2\n    Systemoutprintlnvalue2    value2\n catch NumberFormatException e \n    SystemoutprintlnError in parsing   str2\n\nvalue1  12389\nError in parsing 78H90\n Note  the javamath  package contains the BigDecimal  and BigInteger  classes they are used \nto hold big decimal and integer numbers which do not fit into the primitive types double  and long  these \nclasses are mutable and they are typically not called wrapper classes Use them if you perform computations \non big numbers and you do not want to lose intermediate values that exceed the standard primitive type rangeChapter 12  Wrapper Classes\n441 The Character Wrapper Class\nAn object of the Character  class wraps a char  value The class contains several constants and methods that \nare useful while working with characters For example it contains isLetter  and isDigit  methods to \ncheck if a character is a letter or a digit The toUpperCase  and toLowerCase  methods convert a character \nto uppercase and lowercase It is worth exploring the API documentation for this class The class provides a \nconstructor and a factory valueOf  method to create objects from a char  Use the factory method for better \nperformance The charValue  method returns the char  that the object wraps The following snippet of \ncode shows how to create Character  objects and how to use some of their methods\n Using the constructor\nCharacter c1  new CharacterA\n Using the factory method   preferred\nCharacter c2  CharactervalueOf2\nCharacter c3  CharactervalueOf\n Getting the wrapped char values\nchar cc1  c1charValue\nchar cc2  c2charValue\nchar cc3  c3charValue\nSystemoutprintlnc1    c1\nSystemoutprintlnc2    c2\nSystemoutprintlnc3    c3\n Using some Character class methods on c1\nSystemoutprintlnisLowerCase c1      CharacterisLowerCasecc1\nSystemoutprintlnisDigit c1      CharacterisDigitcc1\nSystemoutprintlnisLetter c1      CharacterisLettercc1\nSystemoutprintlnLowercase of c1      CharactertoLowerCasecc1\n Using some Character class methods on c2\nSystemoutprintlnisLowerCase c2      CharacterisLowerCasecc2\nSystemoutprintlnisDigit c2      CharacterisDigitcc2\nSystemoutprintlnisLetter c2      CharacterisLettercc2\nSystemoutprintlnLowercase of c2      CharactertoLowerCasecc2\nSystemoutprintlnUppercase of c3      CharactertoUpperCasecc3\nc1  A\nc2  2\nc3  \nisLowerCase c1    false\nisDigit c1    false\nisLetter c1    true\nLowercase of c1    a\nisLowerCase c2    false\nisDigit c2    true\nisLetter c2    false\nLowercase of c2    2\nUppercase of c3    Chapter 12  Wrapper Classes\n442 The Boolean Wrapper Class\nAn object of the Boolean  class wraps a boolean  BooleanTRUE  and BooleanFALSE  are two constants of \nthe Boolean  type that represent Boolean true  and false  values You can create a Boolean  object using the \nconstructors or the valueOf  factory method When parsing a string this class treats true ignoring the \ncase of all characters as the true  and any other strings as the false  You should always use the valueOf  \nmethod of this class to create a Boolean  object because it returns the BooleanTRUE  or BooleanFALSE  \nconstant instead of creating new objects The following snippet of code shows how to use the Boolean  class \nThe variable name in each statement indicates the type of Boolean value  true  or false  represented in the \nBoolean  object\n Using constructors\nBoolean b11True  new Booleantrue\nBoolean b21True  new Booleantrue\nBoolean b31True  new BooleantRuE\nBoolean b41False  new Booleanfalse\nBoolean b51False  new Booleanhow is this  false\n Using the factory methods\nBoolean b12True  BooleanvalueOftrue\nBoolean b22True  BooleanvalueOftrue\nBoolean b32True  BooleanvalueOftRuE\nBoolean b42False  BooleanvalueOffalse\nBoolean b52False  BooleanvalueOfhow is this  false\n Getting a boolean value from a Boolean object\nboolean bbTrue  b12TruebooleanValue\n Parsing strings to boolean values\nboolean bTrue  BooleanparseBooleantrue\nboolean bFalse  BooleanparseBooleanThis string evaluates to false\n Using constants\nBoolean bcTrue      BooleanTRUE\nBoolean bcFalse  BooleanFALSE\n Printing some Boolean objects\nSystemoutprintlnbcTrue    bcTrue\nSystemoutprintlnbcFalse    bcFalse\nbcTrue  true\nbcFalse  false\n Unsigned Numeric Operations\nJava does not support unsigned primitive integer data types The byte  short  int and long  are signed data \ntypes For a signed data type half of the range of values is used for storing positive numbers and half for \nnegative numbers as 1 bit is used to store the sign of the value For example a byte  takes 8 bits its range  \nis 128 to 127 If you were to store only positive numbers in a byte its range would have been 0255\nJava 8 added a few static methods in wrapper classes that support operations treating the bits in the \nsigned values as if they were unsigned integers The Byte  class contains two static methods\n\tint toUnsignedIntbyte x\n\tlong toUnsignedLongbyte xChapter 12  Wrapper Classes\n443The methods convert the specified byte argument into an int and a long  as if the byte stored an \nunsigned value If the specified byte  argument is zero or a positive number the converted int and long  \nvalues will be the same as the argument value If the argument is a negative number the converted number \nwill be 28  x For example for an input of 10 the returned value will be 10 and for an input of 10 the \nreturned value will be 28  10 which is 246 Negative numbers are stored in 2s complement form The \nvalue 10 will be stored as 11110110 The most significant bit 1 indicates that it is a negative number The \n2s complement of the first 7 bits 1110110 would be 001010 which is 10\u00a0in decimal If you consider the \nactual bits 11110110 in a byte as an unsigned integer its value is 246 128  64  32  16  0  4  2  0 The \nfollowing snippet of code shows how to get the value stored in a byte as an unsigned integer\nbyte b  10\nint x  BytetoUnsignedIntb\nSystemoutprintlnSigned value in byte    b\nSystemoutprintlnUnsigned value in byte    x\nSigned value in byte  10\nUnsigned value in byte  246\nThe Short  class contains the same two methods as the Byte  class except they take a short  as an \nargument and convert it to an int and a long  Java 9 added a new static method compareUnsignedshort \nx short y  to the Short  class which compares two short values numerically treating the values as \nunsigned It returns 0 if x is equal to y a value less than 0 if x is less than y as unsigned values and a value \ngreater than 0 if x is greater than y as unsigned values\nThe Integer  class contains the following static methods to support unsigned operations and conversions\n\tint compareUnsignedint x int y\n\tint divideUnsignedint dividend int divisor\n\tint parseUnsignedIntString s\n\tint parseUnsignedIntString s int radix\n\tint remainderUnsignedint dividend int divisor\n\tlong toUnsignedLongint x\n\tString toUnsignedStringint i\n\tString toUnsignedStringint i int radix\nNotice that the Integer  class does not contain addUnsigned  subtractUnsigned  and \nmultiplyUnsigned  methods as the three operations are bitwise identical on two signed and two unsigned \noperands The following snippet of code shows the division operation on two int variables as if their bits \nrepresented unsigned values\n Two negative ints\nint x  10\nint y  2\n Performs signed division\nSystemoutprintlnSigned x    x\nSystemoutprintlnSigned y    y\nSystemoutprintlnSigned xy    xyChapter 12  Wrapper Classes\n444 Performs unsigned division by treating x and y holding unsigned values\nlong ux  IntegertoUnsignedLongx\nlong uy  IntegertoUnsignedLongy\nint uQuotient  IntegerdivideUnsignedx y\nSystemoutprintlnUnsigned x    ux\nSystemoutprintlnUnsigned y    uy\nSystemoutprintlnUnsigned xy    uQuotient\nSigned x  10\nSigned y  2\nSigned xy  5\nUnsigned x  4294967286\nUnsigned y  4294967294\nUnsigned xy  0\nThe Long  class contains methods to perform unsigned operations The methods are similar to the ones \nin the Integer  class Note that you cannot convert the value stored in a long  to an unsigned value as you \nwould need a bigger storage than provided by the long  data type to do so but long  is the biggest integer \ndata type provided by Java This is the reason that the Byte  and Short  classes have toUsignedInt  and \ntoUnSignedLong  methods as int and long  are bigger than byte  and short  In fact to store the value of \na signed data type X as an unsigned value in a signed data type Y the size of the data type Y needs to be at \nleast twice as big as that of X Following this storage requirement there is a toUnsignedLong  method in the \nInteger  class but no such method exists in the Long  class\n Autoboxing and\u00a0Unboxing\nAutoboxing and unboxing are used to automatically convert values between primitive data types and \ntheir corresponding wrapper classes They are implemented completely in the compiler Before we \ndefine autoboxingunboxing lets discuss an example The example is trivial but it serves the purpose \nof demonstrating the pain you had to go through before autoboxing was added in Java 5 when you were \nworking with conversion between primitive types to their wrapper objects and vice versa\nSuppose you have a method that accepts two int values adds them and returns an int value You \nmight say What is the big deal about this method It should be as simple as the following\n Only method code is shown\npublic static int addint a int b \n    return a  b\n\nThe method can be used as follows\nint a  200\nint b  300\nint result  adda b  result will get a value of 500\nAnd you are right that there is no big deal about this method at all Lets add a bit of a twist to the logic \nThink about the same method working with Integer  objects instead of int values Here is the code for the \nsame methodChapter 12  Wrapper Classes\n445public static Integer addInteger a Integer b \n    int aValue  aintValue\n    int bValue  bintValue\n    int resultValue  aValue  bValue\n    Integer result  IntegervalueOfresultValue\n    return result\n\nDid y ou notice the complexity that is involved when you changed the same method to use Integer  \nobjects You had to perform three things to add two int values in the Integer  objects\n\t Unwrap the method arguments a and b from Integer  objects to int values using \ntheir intValue  method\nint aValue  aintValue\nint bValue  bintValue\n\t Perform an addition of two int values\nint resultValue  aValue  bValue\n\t Wrap the result into a new Integer  object and return the result\nInteger result  IntegervalueOfresultValue\nreturn result\nListing 123  has the complete code to demonstrate the use of the add  method\nListing 123  Addin g Two int Values Using Integer Objects\n MathUtiljava\npackage comjdojowrapper\npublic class MathUtil \n    public static Integer addInteger a Integer b \n        int aValue  aintValue\n        int bValue  bintValue\n        int resultValue  aValue  bValue\n        Integer result  IntegervalueOfresultValue\n        return result\n    \n    public static void mainString args \n        int iValue  200\n        int jValue  300\n        int kValue\n         will hold result as int \n         Box iValue and jValue into Integer objects\n        Integer i  IntegervalueOfiValue\n        Integer j  IntegervalueOfjValue\n         Store returned value of the add method in an Integer object k\n        Integer k  MathUtiladdi j\n         Unbox Integer objects int value into kValue int variable\n        kValue  kintValueChapter 12  Wrapper Classes\n446         Display the result using int variables\n        SystemoutprintlniValue      jValue      kValue\n    \n\n200  300  500\nNote the amount of code needed just to add two int values Wrappingunwrapping an int value to an \nInteger  and vice versa is a pain for Java developers Java designers realized it though too late and they \nautomated this wrapping and unwrapping process for you\nThe automatic wrapping from a primitive data type  byte  short  int long  float  double  char  and \nboolean  to its corresponding wrapper object  Byte  Integer  Long  Float  Double  Character  and Boolean  \nis called autoboxing  The reverse unwrapping from a wrapper object to its corresponding primitive data \ntype value is called unboxing  With autoboxingunboxing the following code is valid\nInteger n  200  Boxing\nint a  n         Unboxing\nThe compiler will replace the previous statement with the following\nInteger n  IntegervalueOf200\nint a  nintValue\nThe code in the main  method of the MathUtil  class listed in Listing 123  can be rewritten as follows \nThe boxing and unboxing are done for you automatically\nint iValue  200\nint jValue  300\nint kValue  MathUtiladdiValue jValue\nSystemoutprintlniValue      jValue      kValue\n Tip autoboxingunboxing is performed when you compile the code  the JVM is completely una ware of the \nboxing and unboxing performed by the compiler\n Beware of\u00a0Null Values\nAutoboxingunboxing saves you from writing additional lines of code It also makes your code look neater \nHowever it does come with some surprises One of the surprises is getting a NullPointerException  where \nyou would not expect it to happen Primitive types cannot have a null  value assigned to them whereas \nreference types can have a null  value The boxing and unboxing happen between primitive types and \nreference types Look at the following snippet of code\nInteger n  null  n can be assigned a null value\nint a  n          will throw NullPointerException at run timeChapter 12  Wrapper Classes\n447In this snippet of code suppose you do not control the assignment of null  to n You might get a null \nInteger  object as a result of a method call for example int a  getSomeValue  where getSomeValue  \nreturns an Integer  object A NullPointerException  in such places may be a surprise for you However \nit will happen because int a  n  is converted to int a  nintValue  and n is null  in this case This \nsurprise is a part of the advantage you get from autoboxingunboxing and you need to be aware of it\n Overloaded Methods and\u00a0AutoboxingUnboxing\nYou have a few surprises when you call an overloaded method and want to rely on the autoboxingunboxing \nfeature Suppose you have two methods in a class\npublic void testInteger iObject \n    SystemoutprintlnInteger  iObject\n\npublic void testint iValue \n    Systemoutprintlnint  iValue\n\nSuppose you make two calls to the test  method\ntest101\ntestIntegervalueOf101\nWhich of the following will be the output\nint101\nInteger101\nor\nInteger101\nint101\nThe rule for a method invocation that uses autoboxingunboxing follows a twostep process\n 1 If the act ual argument being passed is a primitive type as in test10 \n a Try to find a method with the primitivetype argument If there is no exact match try \nwidening the primitive type to find a match\n b If the pr evious step fails box the primitive type and try to find a match\n 2 If the act ual argument being passed is a reference type  \nas in testIntegervalueOf101 \n a Try to find a method with the referencetype argument If there is a match call that method \nIn this case a match does not have to be exact It should follow the subtype and supertype \nassignment rule\n b If the pr evious step fails unbox the reference type to the corresponding primitive type and \ntry to find an exact match or widen the primitive type and find a matchChapter 12  Wrapper Classes\n448If you apply these rules to the previous snippet of code it will print this\nint101\nInteger101\nSuppose you have the following two test  methods\npublic void testInteger iObject \n    SystemoutprintlnInteger  iObject\n\npublic void testlong iValue \n    Systemoutprintlnlong  iValue\n\nWhat will be printed if you use the following code\ntest101\ntestIntegervalueOf101\nIt will print this\nlong101\nInteger101\nThe first call of test101  will try to find an exact match for an int argument It does not find a method \ntestint  so it widens the int data type finds a match testlong  and calls this method Suppose you \nhave two test  methods as follows\npublic void testLong lObject \n    SystemoutprintlnLong  lObject\n\npublic void testlong lValue \n    Systemoutprintlnlong  lValue\n\nWhat will be printed if you execute the following code\ntest101\ntestIntegervalueOf101\nIt will print this\nlong101\nlong101Chapter 12  Wrapper Classes\n449Are you surprised by looking at this output Apply the rules that I have listed and you will find \nthat this output followed those rules The call to test101  is clear because it widens 101 from int to \nlong  and executes the testlong  method To call testIntegervalueOf101  it looks for a method \ntestInteger  and it does not find one That is an Integer  is never widened to Long  Therefore it unboxes \nthe Integer  to int and looks for a testint  method which it does not find Now it widens the int and \nfinds testlong  and executes it\nConsider the following three test  methods I added a testNumber nObject  method in the previous \nlist of methods\npublic void testLong lObject \n    SystemoutprintlnLong  lObject\n\npublic void testNumber nObject \n    SystemoutprintlnNumber  nObject\n\npublic void testlong lValue \n    Systemoutprintlnlong  lValue\n\nWhat will be printed if you execute the following code\ntest101\ntestIntegervalueOf101\nIt will print the following\nlong101\nNumber101\nAre you surprised again by looking at the output Apply the rules that I have listed The call to \ntest101  is clear To call testIntegervalueOf101  it looks for a method testInteger  and it does \nnot find one It tries to widen the Integer  argument to a Number  or an Object  per rule 2a in the list of rules \nRecall that all numeric wrapper classes are inherited from the Number  class So an Integer  can be assigned to \na Number type variable It finds a match in the second testNumber nObject  method and executes it\nI have one more surprise for you Consider the following two test  methods\npublic void testLong lObject \n    SystemoutprintlnLong  lObject\n\npublic void testObject obj \n    SystemoutprintlnObject  obj\n\nWhat will be printed when you execute the following code\ntest101\ntestIntegervalueOf101Chapter 12  Wrapper Classes\n450This time you will get the following output\nObject101\nObject101\nDoes it make sense Not really Here is the explanation When it calls test101  it has to box int to an \nInteger  because there is no match for testint  even after widening the int value So test101  becomes \ntestIntegervalueOf101  Now it does not find any testInteger  either Note that Integer  is a \nreference type and it inherits the Number  class which in turn inherits the Object  class Therefore an Integer  \nis always an Object  and Java allows you to assign an object of subtype Integer  to a variable of supertype \nObject  This is the reason that the testObject  is called in this case The second call testInteger\nvalueOf101  works the same way It tries for the testInteger  method When it does not find it the \nnext match for it is testObject  based on the subtype and supertype assignment rule for reference types\n Comparison Operators and\u00a0AutoboxingUnboxing\nThis section discusses the comparison operations     and  Only  logical equality operator can \nbe used with both reference types and primitive types The other operators must be used only with primitive \ntypes\nLets look at the easy ones      and  first If a numeric wrapper object is used with these \ncomparison operators it must be unboxed and the corresponding primitive type must be used in the \ncomparison Consider the following snippet of code\nInteger a  100\nInteger b  100\nSystemoutprintlna    a\nSystemoutprintlnb    b\nSystemoutprintlna  b   a  b\nSystemoutprintlna  b   a  b\nSystemoutprintlna  b   a  b\nSystemoutprintlna  b   a  b\na  100\nb  100\na  b false\na  b true\na  b false\na  b true\nThere is no surprise in this output If you mix the two types reference and primitive with these \ncomparison operators you still get the same results First the reference type is unboxed and a comparison \nwith the two primitive types takes place for example\nif 101  IntegervalueOf100 \n     Do something\n\nis converted toChapter 12  Wrapper Classes\n451if101  IntegervalueOf100intValue \n     Do something\n\nNow lets discuss the  operator and the autoboxing rules If both operands are primitive types they \nare compared as primitive types using a value comparison If both operands are reference types their \nreferences are compared In these two cases no autoboxingunboxing takes place When one operand is a \nreference type and another is a primitive type the reference type is unboxed to a primitive type and a value \ncomparison takes place Lets see examples of each type\nConsider the following snippet of code It is an example of using both primitivetype operands for the  \noperator\nint a  100\nint b  100\nint c  505\nSystemoutprintlna  b  will print true\nSystemoutprintlna  c  will print false\nConsider the following snippet of code\nInteger aa  IntegervalueOf100\nInteger bb  new Integer100\nInteger cc  new Integer505\nSystemoutprintlnaa  bb  will print false\nSystemoutprintlnaa  cc  will print false\nIn this snippet of code no autoboxingunboxing takes place Here aa  bb  and aa  cc  compare \nthe references of aa bb and cc not their values Every object created with the new operator has a unique \nreference Now heres a surprise consider the following snippet of code This time you are relying on \nautoboxing\nInteger aaa  100                Boxing   IntegervalueOf100\nInteger bbb  100                Boxing   IntegervalueOf100\nInteger ccc  505                Boxing   IntegervalueOf505\nInteger ddd  505                Boxing   IntegervalueOf505\nSystemoutprintlnaaa  bbb  will print true\nSystemoutprintlnaaa  ccc  will print false\nSystemoutprintlnccc  ddd  will print false\nYou used aaa bbb ccc and ddd as reference types How is aaa  bbb true  whereas ccc  ddd \nfalse  All right This time there is no surprise coming from the autoboxing feature Rather it is coming from \nthe IntegervalueOf  method For all values between 128 and 127 the Integer  class caches Integer  \nobject references The cache is used when you call its valueOf  method For example if you call Integer\nvalueOf100  twice you get the reference of the same Integer  object from the cache that represents the int \nvalue of 100 However if you call IntegervalueOfn  where n is outside the range 128 to 127 a new object \nis created for every call This is the reason that aaa and bbb have the same reference from the cache whereas \nccc and ddd have different references Byte  Short  Character  and Long  classes also cache object references \nfor values in the range 128 to 127Chapter 12  Wrapper Classes\n452 Collections and\u00a0AutoboxingUnboxing\nAutoboxingunboxing helps you work with collections Collections work only with reference types You \ncannot use primitive types in collections If you want to store primitive types in a collection you must wrap \nthe primitive value before storing it and unwrap it after retrieving it Suppose you have a List  and you want \nto store integers in it This is how you do it\nList list  new ArrayList\nlistaddIntegervalueOf101\nInteger a  Integer listget0\nint aValue  aintValue\nYou are back to square one The add  and get  methods of the List  interface work with the Object  type \nand you have to resort to wrapping and unwrapping the primitive types again The autoboxingunboxing may \nhelp you in wrapping the primitive type to a reference type and this code may be rewritten as follows\nList list  new ArrayList\nlistadd101                      Autoboxing will work here\nInteger a  Integer listget0\nint aValue  aintValue\nint aValue  listget0       autounboxing wont compile\nBecause the return type of the get  method is Object  the last statement in this snippet of code would not \nwork Note that unboxing happens from a primitive wrapper type such as Integer  to its corresponding primitive \ntype such as int If you try to assign an Object  reference type to an int primitive type the autounboxing does \nnot happen In fact your code would not even compile because Object toint conversion is not allowed\nTry the following code\nListInteger list  new ArrayList\nlistadd101              autoboxing will work\nint aValue  listget0  autounboxing will work too\nAll collection classes are generic They declare formal type parameters Specifying the Integer  type in \nangle brackets  Integer  while creating the List  object tells the compiler that the List  will hold an object \nof only Integer  type This gives the compiler freedom to wrap and unwrap your primitive int values while \nyou work with the List  object\n Summary\nFor each primitive data type Java provides a class to represent values of the primitive data type as objects \nJava does not support unsigned primitive numeric data types and unsigned numeric operations Java 8 added \nlimited support for unsigned operations on primitive data types by adding some methods in the wrapper \nclasses Java 9 added a few methods in the Integer  and Long  classes to parse a string as an unsigned integer \nJava 9 also added a method in the Short  class to compare two short  values as unsigned short  valuesChapter 12  Wrapper Classes\n453Java does not allow mixing of primitivetype and referencetype values in the same expression It is \ninconvenient to convert the primitive values to their wrapper objects and vice versa Java 5 added support for \nautomatically converting the primitive values to wrapper objects and vice versa depending on the context \nThis feature is called autoboxingunboxing For example it allows assigning an integer 25 to a reference of \nthe Integer  object the compiler automatically boxes the integer 25\u00a0in a wrapper object using the expression \nIntegervalueOf25 \nQUESTIONS AND EXERCISES\n 1 What are wrapper classes in Java Name the wrapper classes for the following \nprimitive types byte  int long  and char \n 2 Using the wra pper class Integer  print the maximum and minimum values of the \nint data type\n 3 What is the name of the superclass of the numeric wrapper classes\n 4 suppose you have a string 1969  Complete the following snippet of code to store \nthe integer value in the string into an int variable and an Integer  object\nString str  1969\nint value   Your code goes here \nInteger object   Your code goes here \n 5 You have a string 7B1  which contains an integer in hexadecimal format Use the \nInteger  class to parse and store its value in an int variable\n 6 Will the follo wing snippet of code compile If it will describe the rulesreasons\nInteger x  19\n 7 You have an integer value of 1969 and you want to print its value in hexadecimal \nformat Complete the following snippet of code that achieves this\nint x  1969\nString str  Integer your code goes here \nSystemoutprintln1969  in hex is   str\n 8 Why does the follo wing statement not compile\nDouble x  1969\nand the following statement does\ndouble y  1969\nMake sure you understand the reasons behind these statements being invalid and valid \nDescribe how the following statement compiles\nNumber x  1969Chapter 12  Wrapper Classes\n454 9 What will be the output of the following snippet of code explain your answer\nNumber x  1969\nSystemoutprintlnxgetClassgetSimpleName\n 10 What will be the output when the following snippet of code is run\nDouble x  1285\nSystemoutprintlnxintValue\nSystemoutprintlnxbyteValue455\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307413CHAPTER 13\nException Handling\nIn this chapter you will learn\n\t Error handling in Java using exceptions\n\t How to use trycatch  blocks to handle exceptions\n\t How to use finally  blocks to clean up resources\n\t The difference between checked and unchecked exceptions\n\t How to create a new exception type and use it\n\t How to use autocloseable resources using a trycatchresources  block\n\t How to access the stack frames of a thread\n\t How to get the class name of the caller of a method\nAll classes in this chapter are a member of a jdojoexception  module as declared in Listing 131 \nListing 131  The D eclaration of a jdojoexception Module\n moduleinfojava\nmodule jdojoexception \n    exports comjdojoexception\n\n What Is an\u00a0Exception\nAn exception  is a condition that may arise during the execution of a Java program when a normal path of \nexecution is not defined For example a Java program may encounter a numeric expression that attempts to \ndivide an integer by zero Such a condition may occur during the execution of the following snippet of code\nint x  10 y  0 z\nz  x  y  DividebyzeroChapter 13  exCeption handling\n456The statement z  x  y  attempts to divide x by y Because y is zero the result of x  y  is not defined \nin Java Note that dividing a floatingpoint number by zero for example 95  00  is defined and it is \ninfinity In generic terms the abnormal condition such as dividing an integer by zero can be phrased as \nfollows\nAn error occurs when a Java program attempts to divide an integer by zero\nThe Java programming language describes the previous error condition differently In Java it is said\nAn exception is thrown when a Java program attempts to divide an integer by zero\nPractically both statements mean the same thing They mean that an abnormal condition in a program \nhas occurred What happens after the abnormal condition occurs in a program You need to handle such an \nabnormal condition One of the ways to handle it is to check for all possibilities that may lead to an abnormal \ncondition before performing the action You may rewrite the previous code as follows\nint x  10 y  0 z\nif y  0 \n     Report the abnormalerror condition here\n else \n     Perform division here\n    z  x  y\n\nYou may observe that this snippet of code does two things it handles the error condition and  \nperforms the intended action It mixes the code for performing error handling and the action One line of \ncode z  x  y  has bloated to at least five lines of code This is a simple example You may not fully realize \nthe real problem when the error handling code is mixed with the actual code performing actions\nTo make this problem clear consider another example Suppose you want to write Java code that will \nupdate an employees salary An employees records are stored in a database The pseudocode might look as \nfollows\nConnect to the database\nFetch the employee record\nUpdate the employee salary\nCommit the changes\nThe actual code would perform these four actions Any of the four actions may result in an error For \nexample you may not be able to connect to the database because the database is down you may not be able \nto commit the changes because some validations failed You need to perform error checking after an action \nis performed and before the subsequent action is started The pseudocode with error checking may look as \nfollows\n Connect to the database\nif connected to the database successfully \n     Fetch the employee record\n    if employee record fetched \n         Update the employee salary\n        if update is successful \n             Commit the changes\n            if commit was successful  \n                 Employee salary was saved successfullyChapter 13  exCeption handling\n457             else \n                 An error Save failed\n            \n         else \n            An error Salary could not be updated\n        \n     else \n         An error Employee record does not exist\n    \n else \n     An error Could not connect to the database\n\nNotice that when you added error handling to your four lines of pseudocode the code bloated to over \n20 lines The worst thing about this code is that the code that performs the action has been cluttered with \nerror handling code It has also introduced many nested ifelse  statements resulting in spaghetti code\nIn the last two examples you saw that the way of handling errors that uses ifelse  statements is not \nelegant and maintainable Java has a better way to handle errors by separating the code that performs \nactions from the code that handles errors In Java we use the phrase exception instead of error to \nindicate an abnormal condition in a program the phrase exception handling is used instead of the phrase \nerror handling  In general we say that an error occurs and you handle it In Java we say that an exception \nis thrown and you catch it This is the reason that exception handling  is also called catching  an exception  \nThe code that handles the exception is known as an exception handler  You could rewrite the previous \npseudocode using Java syntax not fullfledged Java code though as follows\ntry \n     Connect to the database\n     Fetch employee record\n     Update employee salary\n     Commit the changes\n catchDbConnectionException e1\n     Handle DB Connection exception here\n catchEmpNotFoundException e2\n     Handle employee not found exception here\n catchUpdateFailedException e3\n     Handle update failed exception here\n catchCommitFailedException e4\n     Handle commit failed exception here\n\nYou do not need to understand the previous pseudocode fully We will discuss the details shortly You \nneed to observe the structure of the code which allows for separation of the code that performs actions from \nthe code that handles exceptions The code that performs the actions is placed inside a try block and the \ncode that handles the exception is placed inside a catch  block You will observe that this code is much better \nin terms of elegance and maintainability compared to the previous attempt in which you had to write many \nifelse  statements to achieve the same effectChapter 13  exCeption handling\n458 Tip in Ja va an exception is thrown and caught Catching an exception is the same as handling the \nexception the code tha t performs the action may throw an exception and the code that handles the exception \ncatches the thrown exception this style of exception handling allo ws you to separate the code that performs \nactions from the code that handles the exceptions that may arise while performing the actions\n An Exception Is an\u00a0Object\nHow does the exception handling part of the code know about the exception that occurs in another part \nof the code When an exception occurs Java creates an object with all pieces of information about the \nexception eg type of exception line number in the code where the exception occurred etc and passes \nit to the appropriate exception handler The term exception is used to mean one of two thingsthe \nexceptional condition and the Java object to represent the exceptional condition The meaning of the term \nwill be clear from the context When we talk about throwing an exception we are talking about three things\n\t Occurrence of an exceptional condition\n\t Creation of a Java object to represent the exceptional condition\n\t Throwing or passing the exception object to the exception handler\nThe throwing of an exception is the same as passing an object reference to a method Here you may \nimagine the exception handler as a method that accepts a reference of an exception object The exception \nhandler catches the exception object and takes appropriate action You can think of catching an exception \nby the exception handler as a method call without the return where the exception objects reference is the \nactual parameter to the method Java also lets you create your own object that represents an exception and \nthen throw it\n Tip an exception in Ja va is an object that encapsulates the details of an error in the program\n Using a\u00a0trycatch Block\nBefore we discuss the trycatch  block lets write a Java program that attempts to divide an integer by zero \nas shown in Listing 132 \nListing 132  A Ja va Program Attempting to Divide an Integer by Zero\n DivideByZerojava\npackage comjdojoexception\npublic class DivideByZero \n    public static void mainString args \n        int x  10 y  0 z\n        z  x  y\n        Systemoutprintlnz    z\n    \nChapter 13  exCeption handling\n459Exception in thread main javalangArithmeticException  by zero\n    at comjdojoexceptionDivideByZeromainDivideByZerojava7\nWere you expecting this output from Listing 132  It indicates an exception has occurred when you ran \nthe DivideByZero  class The output contains four pieces of information\n\t It includes the name of the thread in which the exception occurred The name of the \nthread is main \n\t It includes the type of the exception that has occurred The type of an exception is \nindicated by the name of the class of the exception object In this case javalang\nArithmeticException  is the name of the class of the exception The Java runtime \ncreates an object of this class and passes its reference to the exception handler\n\t It includes a message that describes the exceptional condition in the code that \ncaused the error In this case the message is  by zero read divide by zero\n\t It includes the location where the exception occurred The second line in the \noutput indicates that the exception has occurred inside the main  method of \nthe comjdojoexceptionDivideByZero  class The source code is contained in \nthe DivideByZerojava  file The line number in the source code that caused the \nexception is 7\nYou may notice that in just two lines of output the Java runtime has printed enough pieces of \ninformation to help you track down the error in your code\nWhen z  x  y  at line 7 is executed the Java runtime detects the exceptional condition which is \nan attempt to divide an integer by zero It creates a new object of the class ArithmeticException  with all \nrelevant pieces of information about the exception and then throws or passes this object to an exception \nhandler Who caught or handled the exception in this case You did not specify any exception handler \nin the code In fact you do not even know how to specify an exception handler at this point Because you \ndid not specify an exception handler in this case the Java runtime handled the exception for you Does the \nJava runtime handle all exceptions that are thrown in a Java program The answer is yes The Java runtime \nhandles all exceptions in a Java program However it handles an exception only when you do not handle it \nyourself\nIf an exception occurs and the Java runtime does not find a programmerdefined exception handler to \nhandle it such an exception is called an uncaught exception  All uncaught exceptions are handled by the Java \nruntime Because an uncaught exception is always handled by the Java runtime why should you even worry \nabout providing any exception handler in your program This is an interesting point Why do you need to \nworry about doing something that would be done by the Java runtime for you If you are too lazy to clean up \nyour own mess handling your own error condition there is bad news for you You should not expect too \nmuch from the Java runtime You may not like the way the runtime handles exceptions for you It catches the \nuncaught exception prints the error stack on the standard error and halts your Java application In other \nwords if you let the Java runtime handle all your exceptions your program stops executing at the point \nwhere the exception occurs Is this what you want to do The answer is no Sometimes after you handle \nthe exception you may want to proceed with executing the rest of your program rather than halting the \nprogram When you ran the DivideByZero  class the expression x  y  in the statement z  x  y  resulted \nin an exception Java did not finish executing the statement z  x  y  Sometimes this situation is phrased \nas The statement z  x  y  completed abnormally  The runtime handled the exception but it stopped \nexecuting the whole program This is the reason that you do not see the output of the following statement in \nyour program\nSystemoutprintlnz    zChapter 13  exCeption handling\n460Now you know that letting the runtime handle your exception is not always a good idea If you want to \nhandle exceptions yourself you need to place your code in a try block A try block looks like the following\ntry \n     Code for the try block goes here\n\nA try block starts with the keyword try followed by an opening brace and a closing brace The code for \nthe try block is placed inside the opening and the closing braces\nA try block cannot be used just by itself It must be followed by one or more catch  blocks or one \nfinally  block or a combination of both To handle an exception that might be thrown by the code inside \na try block you need to use a catch  block One catch  block can be used to handle multiple types of \nexceptions For now Ill focus on handling only one type of exception in a catch  block Ill cover how to \nhandle multiple exceptions in a catch  block in a separate section The syntax for a catch  block is similar to \nthe syntax for a method\ncatch ExceptionClassName parameterName \n     Exception handling code goes here\n\nNote that a catch  blocks declaration is like a method declaration It starts with the keyword catch  \nfollowed by a pair of parentheses Within the parentheses you declare a parameter as you do in a method \nThe parameter type is the name of the exception class that it is supposed to catch The parameterName  is a \nusergiven name Parentheses are followed by an opening brace and a closing brace The exception handling \ncode is placed within the braces When an exception is thrown the reference of the exception object is \ncopied to the parameterName  You can use the parameterName  to get information from the exception object \nIt behaves exactly like a formal parameter of a method\nYou can associate one or more catch  blocks to a try block The general syntax for a trycatch  block is \nas follows The following snippet of code shows a try block which has three catch  blocks associated with it \nYou can associate as many catch  blocks to a try block as you want\ntry \n     Your code that may throw an exception goes here\n catch ExceptionClass1 e1\n     Handle exception of ExceptionClass1 type\n catch ExceptionClass2 e2\n     Handle exception of ExceptionClass2 type\n catch ExceptionClass3 e3\n     Handle exception of ExceptionClass3 type\n\nLets use a trycatch  block to handle the possible dividebyzero exception in your code Listing 133  \nshows the complete code\nListing 133  Handlin g an Exception Using a trycatch Block\n DivideByZeroWithTryCatchjava\npackage comjdojoexception\npublic class DivideByZeroWithTryCatch \n    public static void mainString args \n        int x  10 y  0 z\n        try Chapter 13  exCeption handling\n461            z  x  y\n            Systemoutprintlnz    z\n         catch ArithmeticException e \n             Get the description of the exception\n            String msg  egetMessage\n             Print a custom error message\n            SystemoutprintlnAn error has occurred The error is   msg\n        \n        SystemoutprintlnAt the end of the program\n    \n\nAn exception has occurred The error is  by zero\nAt the end of the program\nThe output of Listing 133  is nicer than that of Listing 132  It tells you exactly what happened when the \nprogram was executed Notice that the program did not terminate when the exception occurred because \nyou handled the exception The program executed the last statement that printed the At the end of the \nprogram  message\n Transfer of\u00a0Control\nYou need to understand very precisely the flow of control when an exception is thrown in a try block First \nthe Java runtime creates an object of the appropriate class to represent the exception that has occurred The \nfirst catch  block following the try block is checked If the exception object can be assigned to the parameter \nfor the catch  block the parameter of the catch  block is assigned the reference of the exception object and \nthe control is transferred to the body of the catch  block When the catch  block finishes executing its body \nthe control is transferred to the point following the trycatch  block It is very important to note that after \nexecuting the catch  block the control is not transferred back to the try block Rather it is transferred to the \ncode that follows the trycatch  block If a try block has many catch  blocks associated with it a maximum \nof one catch  block is executed Figure\u00a0 131  shows the transfer of control in a typical Java program when an \nexception occurs in a try blockChapter 13  exCeption handling\n462In this example assume that when trystatement2  is executed it throws an exception of type Exception2  \nWhen the exception is thrown the control is transferred to the second catch  block and catchstatement21  \nand catchstatement22  are executed After catchstatement22  is executed control is transferred outside the \ntrycatch  block and statement1  starts executing It is very important to understand that trystatement3  is \nnever executed when trystatement2  throws an exception Among three catch  blocks a maximum of one will \nbe executed when a statement inside the try block throws an exception\n Exception Class Hierarchy\nThe Java class library contains many exception classes Figure\u00a0 132  shows a few exception classes Note that \nthe Object  class does not belong to the family of exception classes It is shown in the figure as an ancestor of \nthe Throwable  class in the inheritance hierarchyFigure 131  Transfer of control when an exception occurs in a try blockChapter 13  exCeption handling\n463The exception class hierarchy starts at the javalangThrowable  class Recall that the Object  class is \nthe superclass for all classes in Java It is also the superclass of the Throwable  class This is the reason that the \nfigure shows the Object  class at the top of the class hierarchy It is to be emphasized that the Java exception \nclass family starts at the Throwable  class not at the Object  class\nWhen an exception is thrown it must be an object of the Throwable  class or any of its subclasses \nThe parameter of the catch  block must be of type Throwable  or one of its subclasses such as Exception  \nArithmeticException  IOException  etc The following catch  blocks are not valid catch  blocks because \ntheir parameters are not a Throwable  or a subclass of Throwable \n A compiletime error The Object class is not a throwable class\ncatchObject e1 \n\n A compiletime error The String class is not a throwable class\ncatchString e1 \n\nThe following catch  blocks are valid because they specify throwable types as a parameter which are the \nThrowable  class or its subclasses\n Throwable is a valid exception class\ncatchThrowable t \n\nFigure 132  A few c lasses in the exception class hierarchyChapter 13  exCeption handling\n464 Exception is a valid exception class because it is a subclass of Throwable\ncatchException e \n\n IOException class is a valid exception class because it is a subclass of Throwable\ncatchIOException t \n\n ArithmeticException is a valid exception class because it is a subclass of Throwable\ncatchArithmeticException t \n\nYou can also create your own exception classes by inheriting your classes from one of the exception \nclasses Figure\u00a0 132  shows only a few of the hundreds of exception classes that are available in the Java class \nlibrary We discuss how to inherit a class from another class in Chapter 20\n Arranging Multiple catch Blocks\nA reference variable of the Object  class can refer to any type of object Assuming AnyClass  is a class the \nfollowing is a valid statement\nObject obj  new AnyClass\nThe rule behind the previous assignment is that the reference of an object of a class can be assigned \nto a reference variable of its own type or its superclass Because the Object  class is the superclass direct \nor indirect of all classes in Java it is valid to assign a reference of any object to a reference variable of \nthe Object  class This assignment rule is not limited to just a reference variable of the Object  class It is \napplicable to any object It is stated as follows\nA reference variable of class T can refer to an object of class S if S is the same as T or  \nS is a subclass of T\u00a0 The following statements are always valid in Java assuming S is a \nsubclass of T\nT t1  new T\nT t2  new S\nThis rule implies that any objects reference can be stored in a reference variable of the Object  type \nYou can apply this rule to the exception class hierarchy Because the Throwable  class is the superclass of all \nexception classes a reference variable of the Throwable  class can refer to an object of any exception class All \nof the following statements are valid\nThrowable e1  new Exception\nThrowable e2  new IOException\nThrowable e3  new RuntimeException\nThrowable e4  new ArithmeticException\nWith this rule of assignment in mind consider the following trycatch  block\ntry \n    statement1\n    statement2  Exception of class MyException is thrown here\n    statement3\n catch Exception1 e1 Chapter 13  exCeption handling\n465     Handle Exception1\n catchException2 e2 \n     Handle Exception2\n\nWhen the previous snippet of code is executed statement2  throws an exception of the MyException  \ntype Suppose the runtime creates an object of MyException  as follows\nnew MyException\nNow the runtime selects the appropriate catch  block which can catch the exception object It starts \nlooking for the appropriate catch  clock sequentially starting from the first catch block that is associated \nwith the try block The process to check if a catch  block can handle an exception is very simple Take the \nparameter type and parameter name of the catch block and place them to the left of an assignment operator \nand place the exception object that is thrown to the right If the statement thus formed is a valid Java \nstatement that catch  block will handle the exception Otherwise the runtime will repeat this check with \nthe next catch  block To check if the first catch  block can handle the MyException  in the previous snippet of \ncode Java will form the following statement\n Catch parameter declaration  thrown exception object reference\nException1 e1  new MyException\nThe previous statement is a valid Java statement only if the MyException  class is a subclass of the \nException1  class or MyException  and Exception1  are the same class If the previous statement is valid the \nruntime will assign the reference of the MyException  object to e1 and then execute the code inside the first \ncatch  block If the previous statement is not a valid statement the runtime will apply the same check for the \nsecond catch  block by using the following statement\n Catch parameter declaration  thrown exception object reference\nException2 e2  new MyException\nIf the previous statement is valid the MyException  object is assigned to e2 and the body of the catch  \nblock is executed If the previous statement is not valid the runtime did not find a matching catch  block \nfor the exception thrown in the try block and then a different execution path is chosen which we discuss \nshortly\nTypically you add a catch  block after a try block for every type of exception that can be thrown from \nthe try block Suppose there is a try block and it can throw three kinds of exceptions which are represented \nby three classes Exception1  Exception2  and Exception3  Suppose Exception1  is the superclass of \nException2  and Exception2  is the superclass of Exception3  The class hierarchy for the three exception \nclasses is shown in Figure\u00a0 133 Chapter 13  exCeption handling\n466\nFigure 133  The class hierarchy for Exception1 Exception2 and Exception3 exception classes\nConsider the following trycatch  block\ntry \n     Exception1 Exception2 or Exception 3 could be thrown here\n catch Exception1 e1 \n     Handle Exception1\n catch Exception2 e2 \n     Handle Exception2\n catch Exception3 e3 \n     Handle Exception3\n\nIf you try to apply the steps to find an appropriate catch  block the previous snippet of code would \nalways execute the first catch  block irrespective of the type of exception thrown  Exception1  Exception2  \nor Exception3  from the try block This is because Exception1  is the directindirect superclass of \nException2  and Exception3  The previous snippet of code shows a logical mistake made by the developer \nThe Java compiler is designed to handle this kind of logical mistake that you might make and it generates a \ncompiletime error To fix the error you need to reverse the sequence of these three catch  blocks You must \napply the following rule for arranging multiple catch  blocks for a try blockChapter 13  exCeption handling\n467Multiple catch  blocks for a try block must be arranged from the most specific exception \ntype to the most generic exception type Otherwise a compiletime error occurs The first \ncatch  block should handle the most specific exception type and the last the most generic \nexception type\nThe following snippet of code uses a valid sequence of multiple catch  blocks The \nArithmeticException  class is a subclass of the RuntimeException  class If both of these exceptions are \nhandled in catch  blocks for the same try block the most specific type which is ArithmeticException  must \nappear before the most generic type which is RuntimeException \ntry \n     Do something which might throw Exception\n catchArithmeticException e1 \n     Handle ArithmeticException first\n catchRuntimeException e2 \n     Handle RuntimeException after ArithmeticException\n\n A Multicatch Block\nYou can use a multicatch block to handle multiple types of exceptions in a single catch  block You can \nspecify multiple exception types in a multi catch  block Multiple exceptions are separated by a vertical bar \n The following is the syntax\ntry \n     May throw ExceptionA ExceptionB or ExceptionC\n catch ExceptionA  ExceptionB  ExceptionC   e \n     Handle ExceptionA ExceptionB and ExceptionC\n\nIn a multi catch  block it is not allowed to have alternative exceptions that are related by subclassing \nThat is ExceptionA  ExceptionB  and ExceptionC  cannot be related by being subclass or superclass of each \nother For example the following multi catch  block is not allowed because ExceptionA  and ExceptionB  are \nsubclasses of Throwable  In fact all exception classes are a direct or indirect subclass of Throwable \ntry \n     May throw ExceptionA ExceptionB or ExceptionC\n catch ExceptionA  ExceptionB  Throwable   e \n     Handle Exceptions here\n\nThe previous snippet of code will generate the following compiletime error\nerror Alternatives in a multicatch statement cannot be related by subclassing\n         catchExceptionA  ExceptionB  Throwable e \n                                          \n  Alternative ExceptionA is a subclass of alternative Throwable\n1 errorChapter 13  exCeption handling\n468 Checked and\u00a0Unchecked Exceptions\nBefore we look at checked and unchecked exceptions lets look at a Java program that reads a character \nfrom the standard input You have been using the Systemoutprintln  method to print messages on the \nstandard output which is typically the console You can use the Systeminread  method to read a byte \nfrom the standard input which is typically the keyboard It returns the value of the byte as an int between \n0 and 255 It returns 1 if the end of input is reached Listing 134  contains the code for a ReadInput  class \nwhose readChar  method reads a byte from the standard input and returns the byte as a character It \nassumes that the language you are using has all alphabets whose Unicode values are between 0 and 255 The \nreadChar  method contains the main code for reading To read a character from the standard input you \nneed to use the ReadInputreadChar  method\nListing 134  Reading Input from Standard Input\n ReadInputjava\npackage comjdojoexception\npublic class ReadInput \n    public static char readChar \n        char c  u0000\n        int input  Systeminread\n        if input  1 \n            c  charinput\n        \n        return c\n    \n\nCompile the ReadInput  class Oops The compiler generated the following error\nReadInputjava unreported exception javaioIOException must be caught or declared to be \nthrown at line 7 column 31\nThe error is pointing to line 7\u00a0in the source code\nint input  Systeminread\nThere is something missing in this statement The error also tells you that there is an uncaught \nexception which must be caught or declared You know about catching an exception using a trycatch  \nblock However you probably do not understand how to declare an exception You will learn about declaring \nan exception in the next section\nThe Systeminread  method invocation may throw a javaioIOException  The error is telling you \nto place this method call in a trycatch  block so you can handle the exception If you do not catch this \nexception you need to include in the declaration of the readChar  method that it might throw a java\nioIOException  You learned in the previous sections that the runtime handles all uncaught exceptions So \nwhy cant the Java runtime handle javaioIOException  in this case You need to learn about checked and \nunchecked exceptions to fully understand this error Three kinds of exceptional conditions may occur in a \nJava program\n\t Checked  In the first category are exceptions that have a higher potential to occur \nand you can handle them For example when you read from a file it is more likely \nthat an IO error may occur It is better to handle these kinds of exceptions in your \nprogram Classes in the exception class hierarchy refer to Figure\u00a0 132  that are Chapter 13  exCeption handling\n469subclasses of the Exception  class including the Exception  class itself and excluding \nRuntimeException  and all its subclasses fall into this category If a method or \nconstructor may throw an exception that falls in this category you must take an \nappropriate action to handle that exception in your code that calls the method or \nconstructor What is that appropriate action that you need to take to handle these \nkinds of exceptions You may take one of the following two actions\n\t You can place the code that can throw the exception in a trycatch  block One \nof the catch  blocks must be capable of handling the type of exception that may \nbe thrown\n\t You can specify in the calling methodconstructor declaration that it may throw \nan exception You accomplish this by using a throws  clause in the method\nconstructor declaration\n\t Errors  In the second category are the exceptions that may occur during the course \nof the execution of a Java program and there is little you can do to handle it For \nexample you will receive a javalangOutOfMemoryError  exception when the \nruntime is out of memory You cannot do anything to recover from an outof\nmemory error It is better for you to let the application crash and then look at ways \nto manage the memory more efficiently in your program Classes in the exception \nclass hierarchy refer to Figure\u00a0 132  that are subclasses of the Error  class and the \nError  class itself fall into this category of exception If a piece of code may throw \nan exception that falls in this category the compiler does not insist on taking an \naction on your part If an exception of this kind is thrown at runtime the runtime will \nhandle it for you by displaying a detailed error message and halting the application\n\t Unchecked  In the third category are exceptions that may occur at runtime and \nyou may be able to recover from the exceptional condition if you handle it yourself \nThere are numerous exceptions in this category However if you feel that it is more \nlikely that an exception of this kind may be thrown you should handle it in your \ncode If you attempt to handle them by using trycatch  blocks your code tends to \nget cluttered Classes in the exception class hierarchy refer to Figure\u00a0 132  that are \nsubclasses of the RuntimeException  class and the RuntimeException  class itself \nfall into this category of exception If a piece of code may throw an exception that \nfalls in this category the compiler does not insist on taking an action on your part If \nan exception of this kind is thrown at runtime the runtime will handle it for you by \ndisplaying a detailed error message and halting the program\nExceptions in the first category are known as checked exceptions The Throwable  class also falls under \nchecked exceptions The Throwable  class the Exception  class and subclasses of the Exception  class \nexcluding the RuntimeException  class and its subclasses are called checked exceptions They are called \nchecked exceptions because the compiler checks that they are handled in the code\nAll exceptions that are not checked exceptions are called unchecked exceptions The Error  class all \nsubclasses of the Error  class the RuntimeException  class and all its subclasses are unchecked exceptions \nThey are called unchecked exceptions because the compiler does not check if they are handled in the code \nHowever you are free to handle them The program structure for handling a checked or an unchecked \nexception is the same The difference between them is in the way the compiler forces or does not force you \nto handle them in the code\nLets fix the compiletime error for the ReadInput  class Now you know that javaioIOException  is \na checked exception and the compiler will force you to handle it You will handle it by using a trycatch  \nblock Listing 135  shows the code for the ReadInput  class This time you have handled the IOException  in \nits readChar  method and the code will compile fineChapter 13  exCeption handling\n470Listing 135  A Re adInput Class Whose readChar Method Reads One Character from the Standard Input\n ReadInputjava\npackage comjdojoexception\nimport javaioIOException\npublic class ReadInput \n    public static char readChar \n        char c  u0000\n        int input  0\n        try \n            input  Systeminread\n            if input  1 \n                c  charinput\n            \n         catch IOException e \n            SystemoutprintIOException occurred while reading input\n        \n        return c\n    \n\nHow do you use the ReadInput  class You can use it the same way you use other classes in Java You \nneed to call the ReadInputreadChar  static method if you want to capture the first character entered by \nthe user Listing 136  contains the code that shows how to use the ReadInput  class It prompts the user to \nenter some text The first character of the entered text is shown on the standard output\nListing 136  A Pro gram to Test the ReadInput Class\n ReadInputTestjava\npackage comjdojoexception\npublic class ReadInputTest \n    public static void mainString args \n        SystemoutprintEnter some text and press Enter key \n        char c  ReadInputreadChar\n        SystemoutprintlnFirst character you entered is   c\n    \n\nEnter some text and press Enter key Hello\nFirst character you entered is H\n Checked Exception Catch or Declare\nIf a piece of code may throw a checked exception you must do one of the following\n\t Handle the checked exception by placing the piece of code inside a trycatch  block\n\t Specify in your methodconstructor declaration that it throws the checked exception\nThe call to the Systeminread  method in the readChar  method of the ReadInput  class see  \nListing 135  throws a checked exception of the IOException  type You applied the first option in this case \nand handled the IOException  by placing the call to the Systeminread  method in a trycatch  blockChapter 13  exCeption handling\n471Lets assume that you are writing a method m1  for a class that has three statements Suppose three \nstatements may throw checked exceptions of types Exception1  Exception2  and Exception3  respectively \nThe code for the method may look as follows\n Will not compile\npublic void m1 \n    statement1  May throw Exception1\n    statement2  May throw Exception2\n    statement3  May throw Exception3\n\nYou cannot compile the code for the m1  method in this form You must either handle the exception \nusing a trycatch  block or include in its declaration that it may throw the three checked exceptions If you \nwant to handle the checked exceptions in the m1  methods body your code may look as follows\npublic void m1 \n    try \n        statement1  May throw Exception1\n        statement2  May throw Exception2\n        statement3  May throw Exception3\n     catchException1 e1 \n         Handle Exception1 here\n     catchException2 e2 \n         Handle Exception2 here\n     catchException3 e3 \n         Handle Exception3 here\n    \n\nThe previous code assumes that when one of the three exceptions is thrown you do not want to execute \nthe remaining statements\nIf you want to use different logic you might need more than one trycatch  block For example if your \nlogic states that you must attempt to execute all three statements even if the previous statement throws an \nexception your code would look as follows\npublic void m1 \n    try \n        statement1  May throw Exception1\n     catchException1 e1 \n         Handle Exception1 here\n    \n    try \n        statement2  May throw Exception2\n     catchException2 e2 \n         Handle Exception2 here\n    \n    try \n        statement3  May throw Exception3\n     catchException3 e3 \n         Handle Exception3 here\n    \nChapter 13  exCeption handling\n472The second way to get rid of the compiletime error is to specify in the m1  methods declaration that \nit throws three checked exceptions This is accomplished by using a throws  clause in the m1  methods \ndeclaration The general syntax for specifying a throws  clause is as follows\nmodifiers returntype methodnameparameters throws listofexceptions \n     Method body goes here\n\nThe keyword throws  is used to specify a throws  clause The throws  clause is placed after the closing \nparenthesis of the methods parameters list The throws  keyword is followed by a commaseparated list \nof exception types Recall that an exception type is nothing but the name of a Java class which is in the \nexception class hierarchy You can specify a throws  clause in the declaration of the m1  method as follows\npublic void m1 throws Exception1 Exception2 Exception3 \n    statement1  May throw Exception1\n    statement2  May throw Exception2\n    statement3  May throw Exception3\n\nYou can also mix the two options in the same method when a piece of code throws more than one \nchecked exception You can handle some of them using a trycatch  block and declare some using a throws  \nclause in the methods declaration The following code handles Exception2  using a trycatch  block and \nuses a throws  clause to declare exceptions Exception1  and Exception3 \npublic void m1 throws Exception1 Exception3 \n     statement1      May throw Exception1\n    try \n        statement2  May throw Exception2\n     catchException2 e\n         Handle Exception2 here\n    \n    statement3       May throw Exception3\n\nLets get back to the ReadInput  class example Listing 133  fixed the compiletime error by adding a \ntrycatch  block Lets now use the second option include a throws  clause in the readChar  methods \ndeclaration Listing 137  contains another version of the ReadInput  class which is called ReadInput2 \nListing 137  Using a throws Clause in a Methods Declaration\n ReadInput2java\npackage comjdojoexception\nimport javaioIOException\npublic class ReadInput2 \n    public static char readChar throws IOException  \n        char c  u0000\n        int input  0\n        input  Systeminread\n        if input  1 Chapter 13  exCeption handling\n473            c  char input\n        \n        return c\n    \n\nListing 138  contains the code for a ReadInput2Test  class that tests the readChar  method of the \nReadInput2  class\nListing 138  Testing a throws Clause in a Methods Declaration\n ReadInput2Testjava\npackage comjdojoexception\npublic class ReadInput2Test \n    public static void mainString args \n        SystemoutprintEnter some text and then press Enter key \n        char c  ReadInput2readChar\n        SystemoutprintThe first character you entered is   c\n    \n\nNow compile the ReadInput2Test  class Oops Compiling the ReadInput2Test  class generates the \nfollowing error\nError611 unreported exception class javaioIOException must be caught or declared to \nbe thrown\nThe compiler error may not be very clear to you at this point The readChar  method of the \nReadInput2  class declares that it may throw an IOException  The IOException  is a checked exception \nTherefore the following piece of code in the main  method of ReadInput2Test  may throw a checked \nIOException \nchar c  ReadInput2readChar\nRecall the rules about handling the checked exceptions which were covered at the beginning of this \nsection If a piece of code may throw a checked exception you must use one of the two options place that \npiece of code inside a trycatch  block to handle the exception or specify the checked exception using a \nthrows  clause in the method or constructors declaration Now you must apply one of these two options \nfor the ReadInput2readChar  methods call in the main  method Listing 139  uses the first option and \nplaces the call to ReadInput2readChar  method inside a trycatch  block Note that you have placed three \nstatements inside the try block which is not necessary You need to place inside the try block only the code \nthat may throw the checked exception\nListing 139  A Pro gram to Test the ReadInput2readChar Method\n ReadInput2Test2java\npackage comjdojoexception\nimport javaioIOException\npublic class ReadInput2Test2 \n    public static void mainString args \n        char c  u0000\n        try Chapter 13  exCeption handling\n474            SystemoutprintEnter some text and then press Enter key\n            c  ReadInput2readChar\n            SystemoutprintlnThe first character you entered is   c\n         catch IOException e \n            SystemoutprintlnError occurred while reading input\n        \n    \n\nYou can also use the second option to fix the compiler error Listing 1310  contains the code using the \nsecond option declaring the exception thrown\nListing 1310  A Pro gram to Test the Throws Declaration for ReadInput2readChar Method\n ReadInput2Test3java\npackage comjdojoexception\nimport javaioIOException\npublic class ReadInput2Test3 \n    public static void mainString args throws IOException \n        SystemoutprintEnter some text and then press Enter key \n        char c  ReadInput2readChar\n        SystemoutprintlnThe first character you entered is   c\n    \n\nThe program includes a throws  clause with an IOException  for the main  method Can you run the \nReadInput2Test3  class as you have been running other classes using the java  command Yes You can run \nthe ReadInput2Test3  class the same way you run other classes in Java The requirement to run a class is that \nit should include a main  method which is declared as public static void mainString args  The \nrequirement does not specify anything about a throws  clause A main  method which is used to run a class \nas a starting point may or may not contain a throws  clause\nSuppose you run the ReadInput2Test3  class and the call to the Systeminread  method in the \nreadChar  method of the ReadInput2  class throws an IOException  How will the IOException  be handled \nand who will handle it When an exception is thrown in a method body the runtime checks if the code \nthrowing the exception is inside a trycatch  block If the exceptionthrowing code is inside a trycatch  \nblock the Java runtime looks for the catch  block that can handle the exception If it does not find a catch  \nblock that can handle the exception or the method call is not inside a trycatch  block the exception is \npropagated up the method call stack That is the exception is passed to the caller of the method In your \ncase the exception is not handled in the readChar  method of the ReadInput2  class Its caller is the piece \nof code in the main  method of the ReadInput2Test2  class In this case the same exception is thrown at the \npoint where the ReadInput2readChar  method call is made inside the ReadInput2Test2main  method \nThe runtime applies the same checks to handle the exception If you run the ReadInput2Test2  class and \nan IOException  is thrown the runtime finds that the call to ReadInput2readChar  is inside a trycatch  \nblock which can handle the IOException  Therefore it will transfer the control to the catch  block which \nhandles the exception and the program continues in the main  method of the ReadInput2Test2  class It is \nvery important to understand that the control does not go back to the ReadInput2readChar  method after \nit throws an exception and the exception is handled inside the ReadInput2Test2main  method\nWhen you run the ReadInput2Test3  class the call to the ReadInput2readChar  method is not inside a \ntrycatch  block In this case the Java runtime will have to propagate the exception up the method call stack The \nmain  method is the beginning of the method call stack for a Java application This is the method where all Java \napplications start If the main  method throws an exception the runtime handles it Recall that if the runtime \nhandles an exception for you it prints the call stack details on the standard error and exits the applicationChapter 13  exCeption handling\n475Recall that a catch  block with an exception type can handle an exception of the same type or any of its \nsubclass types For example a catch  block with the Throwable  exception type is capable of handling all types \nof exceptions in Java because the Throwable  class is the superclass of all exception classes This concept is \nalso applicable to the throws  clause If a method throws a checked exception of Exception1  type you can \nmention the Exception1  type in its throws  clause or any of the superclasses of Exception1  The reasoning \nbehind this rule is that if the caller of the method handles an exception that is the superclass of Exception1  \nthe same handler can also handle Exception1 \n Tip the Ja va compiler forces you to handle a checked exception either by using a trycatch  block or \nby using a throws  clause in the method or constructor declaration if a method thro ws an exception it should \nbe handled somewhere in the call stack that is if a method throws an exception its caller can handle it or its \ncallers caller can handle it and so on if an exception is not handled by an y callers in the call stack it is known \nas an uncaught exception or an unhandled exception an uncaught exception is finally handled by the Ja va \nruntime which prints the exception stack trace on the standard error and exits the Java application a different \nbeha vior may be specified for uncaught exceptions in a thread that is not the main thread\nThe compiler is very particular about checked exceptions being handled by programmers If the code in \na try block cannot throw a checked exception and its associated catch  blocks catch checked exceptions the \ncompiler will generate an error Consider the code in Listing 1311  which uses a trycatch  block The catch  \nblock specifies an IOException  which is a checked exception However the corresponding try block does \nnot throw an IOException \nListing 1311  Catching a Checked Exception That Is Never Thrown in the try Block\n CatchNonExistentExceptionjava\npackage comjdojoexception\nimport javaioIOException\n Will not compile\npublic class CatchNonExistentException \n    public static void mainString args \n        int x  10 y  0 z  0\n        try \n            z  x  y\n         catchIOException e \n             Handle the exception\n        \n    \n\nWhen you compile the code for the CatchNonExistentException  class you would get the following \ncompiler error\nError12   exception javaioIOException is never thrown in body of corresponding try \nstatement\nThe error message is selfexplanatory It states that IOException  is never thrown in the try block \nTherefore the catch  block must not catch it One way to fix this error is to remove the trycatch  block \naltogether Listing 1312  shows another interesting way but not a good way to mention a generic catch  blockChapter 13  exCeption handling\n476Listing 1312  Catching a Exception That Is Never Thrown in the try Block\n CatchNonExistentException2java\npackage comjdojoexception\n Will compile fine\npublic class CatchNonExistentException2 \n    public static void mainString args \n        int x  10 y  0 z  0\n        try \n            z  x  y\n         catchException e \n             Handle the exception\n        \n    \n\nException  is also a checked exception type in Java as is IOException  If a catch  block should not \ncatch a checked exception unless it is thrown in the corresponding try block how does the code for \nCatchNonExistentException2  compile fine Should it not generate the same compiletime error At first \nthought you are right It should fail compilation for the same reason the CatchNonExistentException  \nclass failed There are two checked exception classes that are exceptions to this rule Those two exception \nclasses are Exception  and Throwable  The Exception  class is the superclass of IOException  and other \nexceptions which are checked exceptions It is also the superclass of RuntimeException  and all subclasses \nof RuntimeException  which are unchecked exceptions Recall the rule that a superclass exception type \ncan also handle a subclass exception type Therefore you can use the Exception  class to handle checked \nexceptions as well as unchecked exceptions The rule of checking catch  blocks for unthrown exceptions \napplies only to checked exceptions Exception  and Throwable  classes in a catch  block can handle checked \nas well as unchecked exceptions because they are superclasses of both types This is the reason that the \ncompiler will let you use these two checked exception types in a catch  block even though the associated try \nblock does not throw any checked exceptions\n Ti p a ll rules about the compiler check for exceptions being handled or thrown are applicable only to \nchecked exceptions Java does not force you to handle the unchecked exceptions in your code however you \nare free to handle them as you feel appropriate\n Checked Exceptions and\u00a0Initializers\nYou cannot throw a checked exception from a static  initializer If a piece of code in a static  initializer throws a \nchecked exception it must be handled using a trycatch  block inside the initializer itself The static  initializer \nis called only once for a class and the programmer does not have a specific point in code to catch it This is the \nreason that a static  initializer must handle all possible checked exceptions that it may throw\npublic class Test \n    static \n         Must use trycatch blocks to handle all checked exceptions\n    \nChapter 13  exCeption handling\n477The rule is different for instance initializers An instance initializer is called as part of a constructor \ninvocation for the class It may throw checked exceptions However all those checked exceptions must be \nincluded in the throws  clause of all constructors for that class This way the compiler can make sure all \nchecked exceptions are taken care of by programmers when any of the constructors are called The following \ncode for the Test  class assumes that the instance initializer throws a checked exception of a CException  \ntype The compiler will force you to add a throws  clause with CException  to all constructors of Test \npublic class Test \n      Instance initializer\n    \n      Throws a checked exception of type CException\n    \n     All constructors must specify that they throw CException\n     because the instance initializer throws CException\n    public Test throws CException \n         Code goes here\n    \n    public Testint x throws CException \n         Code goes here\n    \n     Rest of the code goes here\n\nYou must handle the CException  when you create an object of the Test  class using any of its \nconstructors as follows\nTest t  null\ntry \n    t  new Test\n catch CException e \n     Handle the exception here\n\nIf you do not handle the CException  using a trycatch  block you must use a throws  clause to specify \nthat the constructor of the Test  class may throw CException \nIf an instance initializer throws a checked exception you must declare a constructor for your class The \ncompiler will add a default constructor to your class if you do not add one However the compiler will not \nadd a throws  clause to the default constructor which will break the previous rule The following code will \nnot compile\npublic class Test123 \n    \n         Throws CException which is a checked exception\n        throw new CException\n    \nChapter 13  exCeption handling\n478When the Test123  class is compiled the compiler adds a default constructor and the class Test123  will \nlook as follows\npublic class Test123 \n    \n         Throws CException which is a checked exception\n        throw new CException\n    \n    public Test123 \n         An empty body The compiler did not add a throws clause\n    \n\nNote that the default constructor which was added by the compiler does not contain a throws  clause to \ninclude CException  which is thrown by the instance initializer This is the reason that the Test123  class will \nnot compile To make the Test123  class compile you must add at least one constructor explicitly and use a \nthrows  clause to specify that it may throw CException \n Throwing an\u00a0Exception\nA Java exception is not something that is always thrown by the runtime You can also throw an exception in \nyour code using a throw  statement The syntax for a throw  statement is\nthrow athrowableobjectreference\nHere throw  is a keyword which is followed by a reference to a throwable object A throwable object is \nan instance of a class which is a subclass of the Throwable  class or the Throwable  class itself The following \nis an example of a throw  statement that throws an IOException \n Create an object of IOException\nIOException e1  new IOExceptionFile not found\n Throw the IOException\nthrow e1\nRecall that the new operator returns the reference of the new object You can also create a throwable \nobject and throw it in one statement\n Throw an IOException\nthrow new IOExceptionFile not found\nThe same rules for handling exceptions apply when you throw an exception in your code If you throw a \nchecked exception you must handle it by placing the code in a trycatch  block or by using a throws  clause \nin the method or constructor declaration that contains the throw  statement These rules do not apply if you \nthrow an unchecked exceptionChapter 13  exCeption handling\n479 Creating an\u00a0Exception Class\nYou can also create your own exception classes They must extend or inherit from an existing exception \nclass We cover how to extend a class in detail in Chapter 20 on inheritance This section explains the \nnecessary syntax to extend a class The keyword extends  is used to extend a class as shown\nmodifiers class classname extends superclassname  \n     Body for classname goes here\n\nHere classname  is your exception class name and superclassname  is an existing exception \nclass name which is extended by your class\nSuppose you want to create a MyException  class which extends the javalangException  class The \nsyntax would be as follows\npublic class MyException extends Exception \n     Body for MyException class goes here\n\nHow does the body of an exception class look An exception class is like any other classes in Java \nTypically you do not add any methods to your exception class Many useful methods that can be used to \nquery an exception objects state are declared in the Throwable  class and you can use them without re\ndeclaring them Typically you include four constructors to your exception class All constructors will call \nthe corresponding constructor of its superclass using the super  keyword Listing 1313  shows the code for a \nMyException  class with four constructors\nListing 1313  A MyE xception Class That Extends the Exception Class\n MyExceptionjava\npackage comjdojoexception\npublic class MyException extends Exception \n    public MyException \n        super\n    \n    public MyExceptionString message \n        supermessage\n    \n    public MyExceptionString message Throwable cause \n        supermessage cause\n    \n    public MyExceptionThrowable cause \n        supercause\n    \n\nThe first constructor creates an exception with null  as its detailed message The second constructor \ncreates an exception with a detailed message The third and fourth constructors let you create an exception \nby wrapping another exception withwithout a detailed message\nYou can throw an exception of type MyException  as follows\nthrow new MyExceptionYour message goes hereChapter 13  exCeption handling\n480You can use the MyException  class in a throws  clause in a methodconstructor declaration or as a \nparameter type in a catch  block The following snippet of code shows that\nimport comjdojoexceptionMyException\n\npublic void m1 throws MyException \n     Code for m1 body goes here\n\ntry \n     Code for the try block goes here\n catchMyException e \n     Code for the catch block goes here\n\nTable 131  shows some of the commonly used methods of the Throwable  class Note that the Throwable  \nclass is the superclass of all exception classes in Java All of the methods shown in this table are available in \nall exception classes\nTable 131  A Pa rtial List of Methods of the Throwable Class\nMethod Description\nThrowable getCause This method was added in Java 14 It returns the cause of the exception \nIf the cause of the exception is not set it returns null \nString getMessage It returns the detailed message of the exception\nStackTraceElement \ngetStackTraceThis method was added in Java 14 It returns an array of stack trace \nelements Each element in the array represents one stack frame The \nfirst element of the array represents the top of the stack and the last \nelement of the array represents the bottom of the stack The top of the \nstack is the methodconstructor where the exception object is created \nThe object of StackTraceElement  class holds information such as class \nname method name file name line number etc\nThrowable initCauseThrowable \ncauseThis method was added in Java 14 There are two ways to set \nan exception as the cause of an exception One way is to use the \nconstructor which accepts the cause as a parameter Another way is to \nuse this method\nvoid printStackTrace It prints the stack trace on the standard error stream The output \nprints the description of the exception object itself as the first line and \nthen the description of each stack frame Printing stack trace for an \nexception is very useful for the debugging purpose\nvoid \nprintStackTracePrintStream sIt prints the stack trace to the specified PrintStream  object\nvoid \nprintStackTracePrintWriter sIt prints the stack trace to the specified PrintWriter  object\nString toString It returns a short description of the exception object The description \nof an exception object contains the name of the exception class and \nthe detailed messageChapter 13  exCeption handling\n481Listing 1314  demonstrates the use of the printStackTrace  method for an exception class The \nmain  method calls the m1  method which in turn calls the m2  method The stack frame for this call \nstarts with the main  method which will be at the bottom of the stack The top of the stack contains the \nm2  method The output shows that the printStackTrace  method prints the stack information from top \nto bottom Each stack frame contains the name of the class the method name the source file name and the \nline number The first line of the printStackTrace  method prints the class name of the exception object \nwith a detailed message\nListing 1314  Prin ting the Stack Trace of an Exception\n StackTraceTestjava\npackage comjdojoexception\npublic class StackTraceTest \n    public static void mainString args \n        try \n            m1\n         catch MyException e \n            eprintStackTrace  Print the stack trace\n        \n    \n    public static void m1 throws MyException \n        m2\n    \n    public static void m2 throws MyException \n        throw new MyExceptionSome error has occurred\n    \n\ncomjdojoexceptionMyException Some error has occurred\n        at jdojoexceptioncomjdojoexceptionStackTraceTestm2StackTraceTestjava18\n        at jdojoexceptioncomjdojoexceptionStackTraceTestm1StackTraceTestjava14\n        at jdojoexceptioncomjdojoexceptionStackTraceTestmainStackTraceTestjava7\nListing 1314  demonstrates how to print the stack trace of an exception on the standard error \nSometimes you may need to save the stack trace in a file or in a database You may need to get the stack trace \ninformation as a string in a variable Another version of the printStackTrace  method lets you do this \nListing 1315  shows how to use the printStackTracePrintWriter s  method to print the stack trace of an \nexception object to a String  object The program is the same as Listing 1314  with one difference It stores \nthe stack trace in a string and then prints that string on the standard output The method getStackTrace  \nwrites the stack trace to a string and returns that string\nListing 1315  Writin g Stack Trace of an Exception to a String\n StackTraceAsStringTestjava\npackage comjdojoexception\nimport javaioStringWriter\nimport javaioPrintWriter\npublic class StackTraceAsStringTest \n    public static void mainString args \n        try \n            m1Chapter 13  exCeption handling\n482         catch MyException e \n            String str  getStackTracee\n             Print the stack trace to the standard output\n            Systemoutprintlnstr\n        \n    \n    public static void m1 throws MyException \n        m2\n    \n    public static void m2 throws MyException \n        throw new MyExceptionSome error has occurred\n    \n    public static String getStackTraceThrowable e \n        StringWriter strWriter  new StringWriter\n        PrintWriter printWriter  new PrintWriterstrWriter\n        eprintStackTraceprintWriter\n         Get the stack trace as a string\n        String str  strWritertoString\n        return str\n    \n\ncomjdojoexceptionMyException Some error has occurred\n      at jdojoexceptioncomjdojoexceptionStackTraceAsStringTest\nm2StackTraceAsStringTestjava24\n      at jdojoexceptioncomjdojoexceptionStackTraceAsStringTest\nm1StackTraceAsStringTestjava20\n      at jdojoexceptioncomjdojoexceptionStackTraceAsStringTest\nmainStackTraceAsStringTestjava10\n The finally Block\nYou have seen how to associate one or more catch blocks to a try block A try block can also have zero or \none finally  block A finally  block is never used by itself It is always used with a try block The syntax for \nusing a finally  block is\nfinally \n     Code for finally block goes here\n\nA finally  block starts with the keyword finally  which is followed by an opening brace and a closing \nbrace The code for a finally  block is placed inside the braces\nThere are two possible combinations of try catch  and finally  blocks trycatchfinally  or try\nfinally  A try block may be followed by zero or more catch  blocks A try block can have a maximum of one \nfinally  block The syntax for a trycatchfinally  block is\ntry \n     Code for try block goes here\n catchException1 e1 Chapter 13  exCeption handling\n483     Code for catch block goes here\n finally \n     Code for finally block goes here\n\nThe syntax for a tryfinally  block is\ntry \n     Code for try block goes here\n finally \n     Code for finally block goes here\n\nWhen you use a trycatchfinally  block your intention is to execute the following logic\nTry executing the code in the try block If the code in the try block throws any exception \nexecute the matching catch block Finally execute the code in the finally  block no matter \nhow the code in the try and catch  blocks finish executing\nWhen you use a tryfinally  block your intention is to execute the following logic\nTry executing the code in the try block When the code in the try block finishes execute the \ncode in the finally  block\n Tip a finally  block is guaranteed to be executed no matter what happens in the associated try andor \ncatch  block there are two exceptions to this rule the finally  block may not be executed if the thread that \nis executing the try or catch  block dies or a Java application may exit for example by calling the System\nexit  method inside the try or catch  block\nWhy do you need to use a finally  block Sometimes you want to execute two sets of statements say \nset1  and set2  The condition is that set2  should be executed no matter how the statements in set1  \nfinish executing For example statements in set1  may throw an exception or may complete normally You \nmay be able to write the logic which will execute set2  after set1  is executed without using a finally  \nblock However the code may not be as clean You may end up repeating the same code in multiple places \nand writing spaghetti ifelse  statements For example set1  may use constructs which make the control \njump from one point of the program to another It may use constructs like break  continue  return  throw  \netc If set1  has many points of exit you will need to repeat the call to set2  before exiting at many places It \nis difficult and ugly to write logic that will execute set1  and set2  The finally  block makes it easy to write \nthis logic All you need to do is place the set1  code in a try block and the set2  code in a finally  block \nOptionally you can also use catch  blocks to handle exceptions that may be thrown from set1  You can \nwrite Java code to execute set1  and set2  as follows\ntry \n     Execute all statements in set1\n catchMyException e1 \n     Handle any exceptions here that may be thrown by set1\n finally \n     Execute statements in set2\nChapter 13  exCeption handling\n484If you structure your code to execute set1  and set2  this way you get cleaner code with guaranteed \nexecution of set2  after set1  is executed\nTypically you use a finally  block to write cleanup code For example you may obtain some resources \nin your program that must be released when you are done with them A tryfinally  block lets you \nimplement this logic Your code structure would look as follows\ntry \n     Obtain and use some resources here\n finally \n     Release the resources that were obtained in the try block\n\nYou write tryfinally  blocks frequently when you write programs that perform database transactions \nand file inputoutput You obtain and use a database connection in the try block and release the connection \nin the finally  block When you work with a databaserelated program you must release the database \nconnection which you obtained at the beginning no matter what happens to the transaction It is similar to \nexecuting statements in set1  and set2  as described previously Listing 1316  demonstrates the use of a \nfinally  block in four different situations\nListing 1316  Using a finally Block\n FinallyTestjava\npackage comjdojoexception\npublic class FinallyTest \n    public static void mainString args \n        int x  10 y  0 z\n        try \n            SystemoutprintlnBefore dividing x by y\n            z  x  y\n            SystemoutprintlnAfter dividing x by y\n         catch ArithmeticException e \n            SystemoutprintlnInside catch block   1\n         finally \n            SystemoutprintlnInside finally block   1\n        \n        Systemoutprintln\n        try \n            SystemoutprintlnBefore setting z to 2449\n            z  2449\n            SystemoutprintlnAfter setting z to 2449\n         catch Exception e \n            SystemoutprintlnInside catch block   2\n         finally \n            SystemoutprintlnInside finally block   2\n        \n        Systemoutprintln\n        try \n            SystemoutprintlnInside try block   3\n         finally \n            SystemoutprintlnInside finally block   3\n        Chapter 13  exCeption handling\n485        Systemoutprintln\n        try \n            SystemoutprintlnBefore executing Systemexit\n            Systemexit0\n            SystemoutprintlnAfter executing Systemexit\n         finally \n             This finally block will not be executed\n             because application exits in try block\n            SystemoutprintlnInside finally block   4\n        \n    \n\nBefore dividing x by y\nInside catch block   1\nInside finally block   1\n\nBefore setting z to 2449\nAfter setting z to 2449\nInside finally block   2\n\nInside try block   3\nInside finally block   3\n\nBefore executing Systemexit\nThe first trycatchfinally  block attempts to perform a dividebyzero operation on an integer \nThe expression x  y  throws an ArithmeticException  and control is transferred to the catch  block The \nfinally  block is executed after the catch  block finishes Note that the second message in the try block is not \nprinted because once an exception is thrown the control jumps to the nearest matching catch  block and \nthe control never goes back to the try block again\nThe second trycatchfinally  block is an example where the try block finishes normally without \nthrowing an exception After the try block finishes the finally  block is executed\nThe third tryfinally  block is simple The try block finishes normally and then the finally  block is \nexecuted\nThe fourth tryfinally  block demonstrates an exceptional case where a finally  block is not executed \nThe try block exits the application by executing the Systemexit  method The application stops executing \nwhen the Systemexit  method is called without executing the associated finally  block\n Rethrowing an\u00a0Exception\nAn exception that is caught can be rethrown You may want to rethrow an exception for different reasons \nOne of the reasons could be to take an action after catching it but before propagating it up the call stack \nFor example you may want to log the details about the exception and then rethrow it to the client Another \nreason is to hide the exception typelocation from the client You are not hiding the exceptional condition Chapter 13  exCeption handling\n486itself from the client Rather you are hiding the type of the exceptional condition You may want to hide the \nactual exception type from clients for two reasons\n\t The client may not be ready to handle the exception that is thrown\n\t The exception that is thrown does not make sense to the client\nRethrowing an exception is as simple as using a throw  statement The following code snippet catches \nthe exception prints its stack trace and rethrows the same exception When the same exception object is \nrethrown it preserves the details of the original exception\ntry \n     Code that might throw MyException\n catchMyException e \n    eprintStackTrace  Print the stack trace\n     Rethrow the same exception\n    throw e\n\nWhen an exception is thrown from a catch  block another catch  block in the same group is not \nsearched to handle that exception If you want to handle the exception thrown from a catch  block you need \nto enclose the code that throws the exception inside another trycatch  block Another way to handle it is \nto enclose the whole trycatch  block inside another trycatch  block The following snippet of code shows \nthe two ways of arranging nested trycatch  to handle Exception1  and Exception2  The actual arrangement \nof nested trycatch  depends on the situation at hand If you do not enclose the code that may throw an \nexception inside a try block or the try block does not have a matching associated catch  block that can catch \nthe exception the runtime will propagate the exception up the call stack provided the method is defined \nwith a throws  clause\n 1  Arranging nested trycatch\ntry \n     May throw Exception1\n catchException1 e1 \n     Handle Exception1 here\n    try \n         May throw Exception2\n     catchException2 e2 \n         Handle Exception2 here\n    \n\n 2  Arranging nested trycatch \ntry        try          May throw Exception1\n        catchException1 e1 \n         Handle Exception1 here\n         May throw Exception2\n    \n catchException2 e2 \n     Handle Exception2 here\nChapter 13  exCeption handling\n487The following snippet of code shows how to catch an exception of one type and rethrow an exception of \nanother type\ntry \n     Code that might throw a MyException\n catchMyException e \n    eprintStackTrace  Print the stack trace\n     Rethrow a RuntimeException\n    throw new RuntimeExceptionegetMessage\n\nThe catch  block catches the MyException  prints its stack trace and rethrows a RuntimeException  In \nthe process it loses the details of the original exception that was thrown When the RuntimeException  is \ncreated it packages the information of stack frames from the point where it was created The client gets the \ninformation about the rethrown RuntimeException  from the point it was created not about the original \nMyException  In the previous code you have hidden both the type and the location of the original exception \nfrom the client\nYou can also rethrow another type of exception and use the original exception as the cause of the \nrethrown exception It is as if the new exception were a wrapper for the original exception You can set \nthe cause of an exception using one of the constructors of the new exception type that accepts a cause as \na parameter You can also use the initCause  method to set the cause of the exception The following \nsnippet of code rethrows a RuntimeException  setting MyException  as its cause\ntry \n     Code that might throw a MyException\n catchMyException e \n    eprintStackTrace  Print the stack trace\n     Rethrow a RuntimeException using the original exception as its cause\n    throw new RuntimeExceptionegetMessage e\n\nYou also have the option just to hide the location of the exception from the client when you rethrow an \nexception The fillInStackTrace  method of the Throwable  class fills in the stack trace information in an \nexception object from the point where this method is called You need to call this method on the exception \nyou catch and want to rethrow to hide the location of the original exception The following snippet of code \nshows how to rethrow an exception by hiding the location of the original exception\ntry \n     Code that might throw MyException\n catchMyException e \n     Repackage the stack frames in the exception object\n    efillInStackTrace\n     Rethrow the same exception\n    throw e\n\nListing 1317  demonstrates how to rethrow an exception by hiding the location of the original exception \nThe MyException  is thrown inside the m2  method The m1  method catches the exception refills the stack \ntrace and rethrows it The main  method receives the exception as if the exception were thrown inside \nm1  not inside m2 Chapter 13  exCeption handling\n488Listing 1317  Rethrowing an Exception to Hide the Location of the Original Exception\n RethrowTestjava\npackage comjdojoexception\npublic class RethrowTest \n    public static void mainString args \n        try \n            m1\n         catch MyException e \n             Print the stack trace\n            eprintStackTrace\n        \n    \n    public static void m1 throws MyException \n        try \n            m2\n         catch MyException e \n            efillInStackTrace\n            throw e\n        \n    \n    public static void m2 throws MyException \n        throw new MyExceptionAn error has occurred\n    \n\nomjdojoexceptionMyException An error has occurred\n      at jdojoexceptioncomjdojoexceptionRethrowTestm1RethrowTestjava19\n      at jdojoexceptioncomjdojoexceptionRethrowTestmainRethrowTestjava8\n Analysis of\u00a0Rethrown Exceptions\nJava 7 improved the mechanism of rethrowing exceptions Consider the following snippet of code for a \nmethod declaration\npublic void test throws Exception \n    try \n         May throw Exception1 or Exception2\n     catch Exception e \n         Rethrow the caught exception\n        throw e\n    \n\nThe try block may throw Exception1  or Exception2  The catch  block specifies Exception  as its \nparameter and it rethrows the exception it catches Prior to Java 7 the compiler saw the catch  block \nthrowing an exception of Exception  type and it insisted that in the throws  clause the test  method must \nspecify that it threw an exception of the Exception  type or the supertype of the Exception  typeChapter 13  exCeption handling\n489Since the try block can throw exceptions of only Exception1  and Exception2  types the catch  block \nwill rethrow an exception that is always of these two types Java performs this analysis when an exception \nis rethrown It lets you specify the throws  clause of the test  method accordingly Starting Java 7 you can \nspecify more specific exception types Exception1  and Exception2  in the test  methods throws  clause  \nas follows\npublic void test throws Exception1 Exception2 \n    try \n         May throw Exception1 Exception2 or Exception3\n     catch Exception e \n         Rethrow the caught exception\n        throw e\n    \n\n Throwing Too Many Exceptions\nThere is no limit on the number of exception types that a methodconstructor can list in its throws  \nclause However it is better to keep the number low The client that uses a method has to deal with all the \nexceptions that the method may throw in one way or another It is also important to keep in mind that a \nmethod should not throw a new type of exception once it has been designed implemented and released \nto the public If a method starts throwing a new type of exception after its public release all client code \nthat calls this method must change It indicates poor design if a method throws too many exceptions or a \nnew exception is added after its public release You can avoid these issues with your method by catching \nall lowerlevel exceptions inside your method and rethrowing a higherlevel exception The exception that \nyou throw may contain the lowerlevel exception as its cause Consider the following snippet of code for a \nmethod m1  that throws three exceptions  Exception1  Exception2  and Exception3 \npublic void m1 throws Exception1 Exception2 Exception3 \n     Code for m1 method goes here\n\nYou can redesign the m1  method to throw only one exception say MyException  as follows\npublic void m1 throws MyException \n    try \n         Code for m1 method goes here\n     catchException1 e\n        throw new MyExceptionMsg1 e\n     catchException2 e\n        throw new MyExceptionMsg2 e\n     catchException3 e\n        throw new MyExceptionMsg3 e\n    \n\nThe redesigned method throws only one exception which is of type MyException  The detailed message \nfor the exception is specific to the lowerlevel exception that is thrown and caught inside the method The \nlowerlevel exception is also propagated to the client as the cause of the higherlevel exception If the m1  \nmethod needs to throw a new exception in the future you can still fit the new exception in the old design Chapter 13  exCeption handling\n490You need to add a catch  block to catch the new exception and rethrow MyException  This design keeps the \nthrows  clause of the m1  method stable It also allows for more exception types to be included in its body in \nthe future\n Tip do not thro w a generic exception from your method such as Throwable  Exception  Error  \nRuntimeException  etc do not specify a generic exception type in a catch  block the purpose of exception \nthrowing or handling is to know exactly the error condition that occurred and take appropriate action it helps \nyou understand the cause of an error by giving specific error messa ges to users genera ting a specific error \nmessage is made easier when you handle exceptions using specific exception types\n Accessing the\u00a0Stack of\u00a0a\u00a0Thread\nThe stack is an area of memory that is used to store temporary data It uses the lastin firstout LIFO style \nto add and remove data A stack resembles a stack in everyday life such as a stack of books The bottom of \nthe stack has the first book that was placed on it The top of the stack has the last book that was placed on it \nWhen a book has to be removed from the stack the last book that was placed on the stack will be removed \nfirst This is the reason a stack is also called lastin firstout memory Figure\u00a0 134  shows the arrangement of \na stack\nFigure 134  Memor y arrangement in a stack\nThe figure shows three books placed on a stack Book1  was placed first Book2  second and Book3  \nthird Book3  which is added last onto the stack represents the top of the stack Book1  which is added first \nonto the stack represents the bottom of the stack Adding an element to a stack is called a push  operation \nand removing an element from a stack is called a pop  operation Initially a stack is empty and the first \noperation is the push operation When a stack is being discarded it must perform an equal number of push \nand pop operations so it is empty again\nEach thread in Java is allocated a stack to store its temporary data A thread stores the state of a method \ninvocation onto its stack The state of a Java method comprises the parameters values local variables any \nintermediate computed values and the methods return value if any A Java stack consists of stack frames \nEach frame stores the state of one method invocation A new frame is pushed onto a threads stack for a \nmethod invocation The frame is popped from a threads stack when the method completesChapter 13  exCeption handling\n491Suppose a thread starts at the m1  method The m1  method calls the m2  method which in turn calls \nthe m3  method Figure\u00a0 135  shows the frames on the stack of a thread when methods m1  m2  and m3  \nare called Note that the figures show the frames when the method m3  is called from the method m2  \nwhich in turn is called from the method m1 \nYou can get some pieces of information about the stack of a thread at a specific point in time Note that \nthe state of a threads stack is always changing as the program executes Therefore you get a snapshot of the \nstack of a thread as it existed at the time you requested it An object of the javalangStackTraceElement  \nclass represents a stack frame You can query four pieces of information about a stack frame class name file \nname method name and line number To get the stack information you need to call the getStackTrace  \nmethod of a Throwable  object It returns an array of StackTraceElement  objects The first element of the \narray represents the top stack frame The last element of the array represents the bottom stack frame When \nyou create an object of the Throwable  class or any exception class in Java it captures the stack of the thread \nthat is executing\n Tip Java introduced a Stack Walking api since Ja va 9 that is covered in detail in the second volume of this \nseries traversing a stack trace and getting the reference of the caller c lass inside a method is much easier \nusing the new Stack Walking api\nListing 1318  demonstrates how to get to the stack frames of a thread A Throwable  object captures the \nstack of the thread at the point it is created If you have a Throwable  object and want to capture the snapshot Figure 135  State of the stack of a thread when methods m1 m2 and m3 are calledChapter 13  exCeption handling\n492of the stack of a thread at a different point from where the Throwable  object was created you can call the \nfillInStackTrace  method of the Throwable  class It captures the current state of stack for the current \nthread at the point you call this method\nListing 1318  A Sample Program That Prints the Details of the Stack Frames of a Thread\n StackFrameTestjava\npackage comjdojoexception\npublic class StackFrameTest \n    public static void mainString args \n        m1\n    \n    public static void m1 \n        m2\n    \n    public static void m2 \n        m3\n    \n    public static void m3 \n         Create a Throwable object that will hold the stack state\n         at this point for the thread that executes the following statement\n        Throwable t  new Throwable\n         Get the stack trace elements\n        StackTraceElement frames  tgetStackTrace\n         Print details about the stack frames\n        printStackDetailsframes\n    \n    public static void printStackDetailsStackTraceElement frames \n        SystemoutprintlnFrame count   frameslength\n        for int i  0 i  frameslength i \n             Get frame details\n            int frameIndex  i  i  0 means top frame\n            String fileName  framesigetFileName\n            String className  framesigetClassName\n            String methodName  framesigetMethodName\n            int lineNumber  framesigetLineNumber\n             Print frame details\n            SystemoutprintlnFrame Index   frameIndex\n            SystemoutprintlnFile Name   fileName\n            SystemoutprintlnClass Name   className\n            SystemoutprintlnMethod Name   methodName\n            SystemoutprintlnLine Number   lineNumber\n            Systemoutprintln\n        \n    \nChapter 13  exCeption handling\n493Frame count 4\nFrame Index 0\nFile Name StackFrameTestjava\nClass Name comjdojoexceptionStackFrameTest\nMethod Name m3\nLine Number 21\n\nFrame Index 1\nFile Name StackFrameTestjava\nClass Name comjdojoexceptionStackFrameTest\nMethod Name m2\nLine Number 15\n\nFrame Index 2\nFile Name StackFrameTestjava\nClass Name comjdojoexceptionStackFrameTest\nMethod Name m1\nLine Number 11\n\nFrame Index 3\nFile Name StackFrameTestjava\nClass Name comjdojoexceptionStackFrameTest\nMethod Name main\nLine Number 7\n\nNow that you have access to the stack frames of a thread you may want to know what you can do with \nthis information The information about a threads stack lets you know the location in the program where \nthe code is executing Typically you log this information for debugging purposes If you compare the output  \nof the printStackTrace  method with the output of Listing 1318  you would observe that they are similar \nexcept they print the same information in different formats\n The trywithresources Block\nBefore trywithresources was added to Java when you worked with a resource such as a file a SQL \nstatement etc you had to use a finally  block and write a few lines of boilerplate code to close the resource \nThe typical code to work with a resource looked as follows\nAnyResource aRes\ntry \n    aRes  create the resource\n     Work with the resource here\n finally \n     Let us try to close the resource\n    try \n        if aRes  null \n            aResclose  Close the resource\n        Chapter 13  exCeption handling\n494     catchException e \n        eprintStackTrace\n    \n\nWith a trywithresources  block the previous code can be written as follows\ntry AnyResource aRes  create the resource \n     Work with the resource here The resource will be closed automatically\n\nWow You could write the same logic in just three lines of code using a trywithresources  block \nwhen it used to take 14 lines of code The trywithresources  block automatically closes the resources \nwhen the program exits the block A trywithresource  block may have one or more catch  blocks andor a \nfinally  block\nOn the surface the trywithresources  block is as simple as it seems in the previous example \nHowever it comes with some subtleties that we need to discuss in detail\nYou can specify multiple resources in a trywithresources  block Two resources must be separated \nby a semicolon The last resource must not be followed by a semicolon The following snippet of code shows \nsome usage of a trywithresources  block to use one and multiple resources\ntry AnyResource aRes1  getResource1 \n     Use aRes1 here\n\ntry AnyResource aRes1  getResource1 AnyResource aRes2  getResource2 \n     Use aRes1 and aRes2 here\n\nThe resources that you specify in a trywithresources  are implicitly final You can declare the \nresources final even though it is redundant to do so\ntry final AnyResource aRes1  getResource1 \n     Use aRes1 here\n\nA resource that you specify in a trywithresources  must be of the type javalangAutoCloseable  \nThe AutoCloseable  interface has a close  method When the program exits the trywithresources  \nblock the close  method of all the resources is called automatically In the case of multiple resources the \nclose  method is called in the reverse order in which the resources are specified\nConsider a MyResource  class as shown in Listing 1319  It implements the AutoCloseable  interface and \nprovides implementation for the close  method If the exceptionOnClose  instance variable is set to true  \nits close  method throws a RuntimeException  Its use  method throws a RuntimeException  if the level  \nis zero or less Now we can use the MyResource  class to demonstrate various rules in using the trywith\nresources  block\nListing 1319  An Aut oCloseable Resource Class\n MyResourcejava\npackage comjdojoexception\npublic class MyResource implements AutoCloseable \n    private int level\n    private boolean exceptionOnCloseChapter 13  exCeption handling\n495    public MyResourceint level boolean exceptionOnClose \n        thislevel  level\n        thisexceptionOnClose  exceptionOnClose\n        SystemoutprintlnCreating MyResource Level    level\n    \n    public void use \n        if level  0 \n            throw new RuntimeExceptionLow in level\n        \n        SystemoutprintlnUsing MyResource level   thislevel\n        level\n    \n    Override\n    public void close \n        if exceptionOnClose \n            throw new RuntimeExceptionError in closing\n        \n        SystemoutprintlnClosing MyResource\n    \n\nListing 1320  shows a simple case of using a MyResource  object in a trywithresources  block The \noutput demonstrates that the trywithresources  block automatically calls the close  method of the \nMyResource  object\nListing 1320  A Sim ple Use of a MyResource Object in a trywithresources Block\n SimpleTryWithResourcejava\npackage comjdojoexception\npublic class SimpleTryWithResource \n    public static void mainString args \n         Create and use a resource of MyResource type\n         Its close method will be called automatically\n        try MyResource mr  new MyResource2 false \n            mruse\n            mruse\n        \n    \n\nCreating MyResource Level  2\nUsing MyResource level 2\nUsing MyResource level 1\nClosing MyResource\nWhen a resource is being closed automatically an exception may be thrown If a trywithresources  \nblock completes without throwing an exception and the call to the close  method throws the exception \nthe runtime reports the exception thrown from the close  method If a trywithresources  block throws \nan exception and the call to the close  method also throws an exception the runtime suppresses the \nexception thrown from the close  method and reports the exception thrown from the trywithresources  \nblock The following snippet of code demonstrates this ruleChapter 13  exCeption handling\n496 Create a resource of MyResource type with two levels which can throw exception on\n closing and use it thrice so that its use method throws an exception\ntry MyResource mr  new MyResource 2 true  \n    mruse\n    mruse\n    mruse  Will throw a RuntimeException\n catchException e \n    SystemoutprintlnegetMessage\n\nCreating MyResource Level  2\nUsing MyResource level 2\nUsing MyResource level 1\nLow in level\nThe third call to the use  method throws an exception In the previous snippet of code the automatic \nclose  method call will throw a RuntimeException  because you pass true  as the second argument \nwhen you create the resource The output of Low in level shows that the catch  block received the \nRuntimeException  that was thrown from the use  method not from the close  method\nYou can retrieve the suppressed exceptions by using the getSuppressed  method of the Throwable  \nclass this method was added in Java 7 It returns an array of Throwable  objects Each object in the \narray represents a suppressed exception The following snippet of code demonstrates the use of the \ngetSuppressed  method to retrieve the suppressed exceptions\ntry MyResource mr  new MyResource 2 true  \n    mruse\n    mruse\n    mruse  Throws an exception\n catchException e \n    SystemoutprintlnegetMessage\n     Display messages of suppressed exceptions\n    SystemoutprintlnSuppressed exception messages are\n    forThrowable t  egetSuppressed \n        SystemoutprintlntgetMessage\n    \n\nCreating MyResource Level  2\nUsing MyResource level 2\nUsing MyResource level 1\nLow in level\nSuppressed exception messages are\nError in closing\n Ti p Before Ja va 9 the variable referencing the resource used in a trywithresources  block had to be \ndeclared in the same trywithresources  block this restriction was lifted in Java 9 which allows a final or \neffectively final resource variable to be used in a trywithresources  blockChapter 13  exCeption handling\n497Until Java 9 the trywithresources  block had a limitation that you must declare the variable \nreferencing the resource in the same trywithresources  block If you received a resource reference as an \nargument in a method you would not be able to write your logic like this\nvoid useItMyResource res \n    tryres \n         Work with res here\n    \n\nJDK 9 removed this restriction that you must declare fresh variables for resources that you want \nto manage using a trywithresource  block Now you can use a final  or effectively final  variable that \nreferences a resource to be managed by a trywithresources  block A variable is final if it is explicitly \ndeclared using the final  keyword\n res is explicitly final\nfinal MyResource res  new MyResource2 false\nA variable is effectively final if its value is never changed after it is initialized In the following snippet \nof code the res variable is effectively final even though it is not declared final It is initialized and is never \nchanged again\nvoid doSomething \n     res is effectively final\n    MyResource res  new MyResource2 false\n    resuse\n\nUsing an already declared variable with try you can write something like this\nMyResource res  new MyResource2 false\ntry res \n     Work with res here\n\nIf you have multiple resources that you want to manage using a trywithresources  block you can do \nit like this\nMyResource res1  new MyResource2 false\nMyResource res2  new MyResource3 false\ntry res1 res2 \n     Use res1 and res2 here\n\nYou can mix both approaches in the same trywithresources  block The following snippet of code uses \ntwo predeclared effectively final variables and one freshly declared variable in a trywithresources  block\nMyResource res1  new MyResource2 false\nMyResource res2  new MyResource3 false\ntry res1 res2 MyResource res3  new MyResource5 false \n     Use res1 res2 and res3 here\nChapter 13  exCeption handling\n498Variables declared inside a trywithresource  block are implicitly final  The following snippet of \ncode explicitly declares such a variable final  and is equivalent to the previous code example\nMyResource res1  new MyResource2 false\nMyResource res2  new MyResource3 false\n Declare res3 explicitly final\ntry res1 res2 final MyResource res3  new MyResource5 false \n     Use res1 res2 and res3 here\n\nListing 1321  contains the code for a ResourceTest  class that demonstrates a fully working example \nof how to manage resources using trywithresources  blocks using final or effectively final variables that \nreference those resources\nListing 1321  A Res ourceTest Class to Demonstrate the Use of trywithresources Blocks in Java\n ResourceTestjava\npackage comjdojoexception\npublic class ResourceTest \n    public static void mainString args \n        MyResource r1  new MyResource1 false\n        MyResource r2  new MyResource2 false\n        try r1 r2 \n            r1use\n            r2use\n            r2use\n        \n        useResourcenew MyResource3 false\n    \n    public static void useResourceMyResource res \n        try res MyResource res4  new MyResource4 false \n            resuse\n            res4use\n        \n    \n\nCreating MyResource Level  1\nCreating MyResource Level  2\nUsing MyResource level 1\nUsing MyResource level 2\nUsing MyResource level 1\nClosing MyResource\nClosing MyResource\nCreating MyResource Level  3\nCreating MyResource Level  4\nUsing MyResource level 3\nUsing MyResource level 4\nClosing MyResource\nClosing MyResourceChapter 13  exCeption handling\n499 Summary\nAn exception is the occurrence of an abnormal condition in a Java program where a normal path of \nexecution is not defined Java lets you separate the code that performs the actions from the code that handles \nexceptions that may occur when the actions are performed\nUse a trycatch  block to place your actionperforming code in the try block and exception handling \ncode in the catch  block A try block may also have a finally  block which is typically used to clean up \nresources used in the try block You can have a combination of trycatch  trycatchfinally  or try\nfinally  blocks\nThe trywithresources  block comes in handy to close resources automatically You can use \nAutoCloseable  resources in a trywithresources  block When the block exits the close  method of \nthose resources is called automatically Before Java 9 the variable referencing the resource used in a try\nwithresources  block must be declared in the same trywithresources  block Java allows an effectively \nfinal resource variable to be used in a trywithresources  block\nThere are two types of exceptions checked exceptions and unchecked exceptions The compiler makes \nsure that all checked exceptions are handled in the program or the program declares them in a throws  \nclause Handling or declaring unchecked exceptions is optional\nEXERCISES\n 1 What is an exception in Java name the two types of exceptions that Java \nsupports\n 2 What is the superclass of all exception classes in Java\n 3 What type of statementblock would you use to place your code if a piece of code \nmay throw an exception\n 4 how many exceptions can you catch in one catch  block\n 5 Can you thro w an exception from inside a catch  block\n 6 name two constructs in Java that you may use to clean up resources after  \ntheir use\n 7 What are checked and unchecked exceptions in Java is javalang\nArithmeticException  a checked exception is javaioIOException  a \nchecked exception\n 8 What keyword do you use in a methods declaration to declare that the method \nthrows an exception\n 9 What keyword do you use to throw an exception\n 10 Will the follo wing statement compile\nthrow null\nif this statement compiles what will happen when it is executed\n 11 Can you thro w a runtime exception from a method without specifying the exception \nin the throws  clause of the methods declarationChapter 13  exCeption handling\n500 12 Will the follo wing method declaration compile if not describe the reason\npublic void test \n    throw new RuntimeExceptionAn error has occurred\n    SystemoutprintlnEverything is cool\n\n 13 Complete the follo wing snippet of code so the error message associated with the \nexception is printed on the standard output\ntry \n    int x  100  0\n catch ArithmeticException e \n    String errorMessage  e You code goes here \n    SystemoutprintlnerrorMessage\n\n 14 What method of the Throwable  class do you use to print the stack trace of the \nexception object\n 15 describe the reason why the following trycatch  block does not compile\ntry \n     The following statement throws NumberFormatException\n    int luckNumber  IntegerparseIntHello\n catch Exception e \n     Handle the exception here\n catch NumberFormatException e \n     Handle the exception here\n\n 16 Consider the follo wing code inside a method assuming that MyResource  is a \nclass that implements the AutoCloseable  interface the code does not compile \ndescribe the reason why the code does not compile and fix it so it compiles\nMyResource res  new MyResource1 false\ntry res \n    resuse\n\nres  null501\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307414CHAPTER 14\nAssertions\nIn this chapter you will learn\n\t What an assertion is in Java\n\t How to use assertions in Java programs\n\t How to enable and disable assertions\n\t How to check the status of an assertion\nAll classes in this chapter are members of a jdojoassertion  module as declared in Listing 141 \nListing 141  The D eclaration of a jdojoassertion Module\n moduleinfojava\nmodule jdojoassertion \n    exports comjdojoassertion\n\n What Is an\u00a0Assertion\nThe literal meaning of an assertion is to state something in a strong confident and forceful way When you \nassert something  you believe that something to be true Note that asserting something does not make that \nsomething always true It simply means that chances are very high or you are very confident that something \nis true Sometimes you may be wrong and that something may be false even if you assert it to be true\nThe meaning of an assertion in Java is similar to its literal meaning It is a statement in a Java program \nIt lets programmers assert a condition to be true at a specific point in the program Consider the following \nsnippet of code which has two statements with one comment in between\nint x  10  15\n We assert that value of x is 25 at this point \nint z  x  12\nThe first statement uses two hardcoded integer values 10 and 15 and assigns their sum to the variable \nx You can assert that the value of variable x is 25 after the first statement is executed Note the use of \ncomments to make the assertion in this case What is the probability that the value of x will be other than \n25 in this code You may think that the probability of x having a value other than 25 is zero It means your \nassertion will be true all the time So what was the point in adding a comment which asserts that the value of \nx is 25 when it is obvious by just looking at the code In programming what seems obvious at one time may \nnot be obvious at other timesChapter 14  assertions\n502Consider the following snippet of code assuming that a getPrice  method exists\nint quantity  15\ndouble unitPrice  getPrice\n We assert that unitPrice is greater than 00 at this point \ndouble totalPrice  quantity  unitPrice\nIn this code you have made an assertion that the value of the variable unitPrice  will be greater than \n00 after the second statement is executed What is the probability that the value of unitPrice  will be greater \nthan 00 after the second statement is executed It is difficult to answer this question by just looking at the \ncode However you assume for the code to work correctly that your assertion the value of unitPrice  is \ngreater than 00 must be true Otherwise your code will indicate a serious bug in the getPrice  method\nIt may be obvious for a customer that the price for an item will always be greater than zero However \nit is not so obvious to a programmer because they have to depend on the correct implementation of the \ngetPrice  method If the getPrice  method has a bug the programmers assertion will be false If the \nprogrammers assertion is false they need to know about the failure of their assertion and they need to fix \nthe bug If the assertion was false they would not want to proceed with the price computations You have \nused a comment to state your assertion A comment is not executable code Even if the value of unitPrice  is \nnot greater than zero your comment is not going to report this error condition or halt the program You need \nto use the assertion facility in such cases to receive a detailed error message and halt the program\nYou can make an assertion in Java using an assert  statement The syntax for an assert  statement \ncomes in two forms\n\tassert booleanAssertionExpression\n\tassert booleanAssertionExpression  errorMessageExpression\nAn assert  statement starts with the assert  keyword which is followed by a Boolean assertion \nexpression that is the condition that a programmer believes to be true If the assertion expression evaluates \nto true  no action is taken If the assertion expression evaluates to false  the runtime throws a javalang\nAsssertionError \nThe second form of the assert  statement syntax allows you to specify a custom error message \nexpression when the assertion error is thrown The assertion condition and the custom message are \nseparated by a colon The errorMessageExpression  does not have to be a string It could be an expression \nthat may evaluate to any data type except the void  data type The runtime will convert the result of the error \nmessage expression to a string You can rewrite the code shown previously to take advantage of the assert  \nstatement like so\nint x  10  15\nassert x  25  Uses the first form of the assert statement\nint z  x  12\nHere you replaced the comment with an assert  statement All you need to specify is the condition \nyou assert to be true You used the first form of the assert  statement You did not use any custom message \nwhen your assertion fails When the assertion fails the Java runtime provides you with all details such as line \nnumber source code file name etc about the error\nIn most cases the first form of the assert  statement is sufficient If you think some values from the \nprogram at the time of the error may help you diagnose the problem better you should use the second form \nof the assert  statement Suppose you want to print the value of x when the assertion fails You can use the \nfollowing snippet of codeChapter 14  assertions\n503int x  10  15\nassert x  25 x    x  Uses the second form of the assert statement\nint z  x  12\nIf you want just the value of x and nothing else you can use the following snippet of code\nint x  10  15\nassert x  25 x  Uses the second form of the assert statement\nint z  x  12\nNote that the errorMessageExpression  in the second form of the assert  statement could be of any data \ntype This snippet of code provides x as the value of errorMessageExpression  which evaluates to an int \nThe runtime will use the string representation of the value of x when it throws an AssertionError \nAt this point you may be tempted to test the assert  statement Lets discuss some more details before \nyou compile and run Java classes with assert  statements However you will use Java code with an assert  \nstatement as shown in Listing 142 \nListing 142  A Sim ple Test Class to Test the assert Statement\n AssertTestjava\npackage comjdojoassertion\npublic class AssertTest \n    public static void mainString args \n        int x  10  15\n        assert x  100    x    x  should throw an AssertionError\n    \n\nThe code for the AssertTest  class is simple It assigns a value of 25 to the variable x and asserts that \nthe value of x should be 100 When you run the AssertTest  class you expect that it would always throw an \nAssertionError  but it needs to be run the correct way which we will cover next\n Testing Assertions\nIt is time to see the assert  statement in action Try to run the AssertTest  class in NetBeans or using the \nfollowing command on a command prompt\nCJavaFunjava modulepath dist module jdojoassertioncomjdojoassertionAssertTest\nThis command finishes without any output Did you not expect an error message on the standard \noutput Is your assertion x  100  not false The value of x is 25 not 100 You need to perform one more \nstep before you can see the assert  statement in action Try the following command to run the AssertTest  \nclass\nCJavaFunjava ea modulepath dist module jdojoassertioncomjdojoassertion\nAssertTest\nException in thread main javalangAssertionError x  25\n        at jdojoassertioncomjdojoassertionAssertTestmainAssertTestjava7Chapter 14  assertions\n504You can also enable assertions in a NetBeans project Rightclick the project name in NetBeans and \nspecify ea as the VM option under the Run category as shown in Figure\u00a0 141  Once assertion is enabled \nrunning the AssertTest  class in NetBeans will generate the same error\nAn AssertionError  was generated with  x  25  as the error message when you ran the \nAssertTest  class This is what happens when an assertion fails in your code The Java runtime throws an \nAssertionError  Because you used the second form of the assert  statement in your code the error message \nalso contains your custom assertion message which prints the value of x Note that the assertion error by \ndefault contains the line number and the source code file name where the assertion fails This error message \nstates that the assertion failed at line 7\u00a0in the AssertFilejava  source file\nSo what is the magic behind using the ea switch with the java  command By default assert  \nstatements are not executed by the Java runtime In other words the assertion is disabled by default You \nmust enable the assertion when you run your class so your assert  statements are executed The ea switch \nenables the assertion at runtime This is the reason that you received the expected error message when you \nused the ea switch to run the AssertTest  class We discuss enablingdisabling assertion in detail in the next \nsection\nFigure 141   Enabling assertion in a NetBeans projectChapter 14  assertions\n505 EnablingDisabling Assertions\nThe goal in using assertions is to detect logic errors in programs Typically assertions should be enabled in \ndevelopment and test environments Assertions help programmers find the location and type of problems in \ncode quickly Once an application is tested it is very unlikely that the assertions will fail Java designers kept \nin mind the performance penalty that you may incur by using assertions in the production environment \nThis is the reason that assertions are disabled at runtime by default Although it is not desirable to enable \nassertions in a production environment you have options to do so\nJava provides commandline options or switches to enable assertions at runtime at various levels For \nexample you have options to enable assertions in all userdefined classes all system classes all classes in \na package and its subpackages just for one class etc Table\u00a0 141  lists all switches that you can use on the \ncommand line to enabledisable assertions at runtime Each switch has a long form and a short form\nTwo switches ea and da let you control the enabling and disabling of assertions at various levels \nYou can pass an argument to these switches to control the level at which assertions should be enabled or \ndisabled Note that you cannot pass any arguments to esa  and dsa  switches They enable and disable \nassertions in all system classes If you pass an argument to the ea or da switch the switch and the \nargument must be separated by a colon as shown next Table\u00a0 142  lists the possible arguments that can be \nused with these switches\n\teaargument\n\tdaargumentTable 141  Com mandLine Switches to EnableDisable Assertions at Runtime\nCommandLine Switch Description\nenableassertions ea Used to enable assertions at runtime for system classes as well as \nuserdefined classes You can pass an argument to this switch to \ncontrol the level at which assertions are enabled\ndisableassertions da Used to disable assertions at runtime for system classes as well as \nuserdefined classes You can pass an argument to this switch to \ncontrol the level at which assertions are disabled\nenablesystemassertions esa Used to enable assertions in all system classes You cannot pass any \narguments to this switch\ndisablesystemassertions dsa Used to disable assertions in all system classes You cannot pass any \narguments to this switchChapter 14  assertions\n506The following are examples of using assertion switches with different arguments All examples assume \nthat you are enabling assertions when you are running the comjdojoassertionAssertTest  class The \nexamples show you only how to enable assertions By default all assertions are disabled\n Enable assertions in all system classes \nCJavaFunjava esa modulepath dist module jdojoassertioncomjdojoassertion\nAssertTest\n Enable assertions in all userdefined classes \nCJavaFunjava ea modulepath dist module jdojoassertioncomjdojoassertion\nAssertTest\n Enable assertions in comjdojo package and its subpackages \nCJavaFunjava eacomjdojo modulepath dist module    jdojoassertioncomjdojo\nassertionAssertTest\nCJavaFunjava ea modulepath dist module jdojoassertioncomjdojoassertion\nAssertTest\n Enable assertions in comjdojoassertionAssertTest class \nCJavaFunjava eacomjdojoassertionAssertTest modulepath dist module jdojo\nassertioncomjdojoassertionAssertTest\nYou can use multiple ea or da switches in one command to achieve finer granularity in enabling\ndisabling assertions All switches are processed from left to right in the order they are specified\n Enable assertions in the p1 package and all its subpackages and disable assertion for\n  the p1p2MyClass class\n \nCJavaFunjava eap1 dap1p2MyClass modulepath dist module jdojoassertioncom\njdojoassertionAssertTestTable 142  List of Arguments That Can Be Passed to ea and da Switches\nArgument for ea and da Switches Description\nno argument Enables or disables assertions in all userdefined classes Note that \nto enabledisable assertions in all system classes you need to use \nthe esa  and dsa  switches respectively with no argument\npackageName Note the three dots after the packageName  It enablesdisables \nassertions in the specified packageName  and any of its sub\npackages It can also be used to enabledisable assertions in \nsystem packages\n This argument value is three dots It enablesdisables assertions in \nthe unnamed package in the current working directory\nclassName Enablesdisables assertions in the specified className  It can also \nbe used to enabledisable assertions in system classesChapter 14  assertions\n507 Ti p a ssertions for a class are enabled or disabled when a class is loaded the assertion status for a class \ncannot be changed after it is set there is one exception to this rule if an assert  statement is executed before \na class has been initialized the Java runtime executes it as if assertions were enabled this situation arises \nwhen two classes refer to each other in their static  initializers by calling the constructors or the methods of \nanother class\n Using Assertions\nConfusion may arise as to when to use assertions in a program An assertion is implemented in Java by \nadding a new class javalangAssertionError  into the existing exception class hierarchy Sometimes \nprogrammers mistake an assertion as another exception This may be true when you just look at the class \nhierarchy and you may say that it is just another class in the existing exception class hierarchy However the \nsimilarity between exceptions and assertions stops right there in the class hierarchy The main difference \nlies in the reason behind their usage An exception is used to handle a users error and business rule \nimplementation If it is possible to recover from exceptional conditions you want to recover from them and \nproceed with the application An assertion is used to detect programming errors made by programmers \nYou do not want to recover from a programming error and proceed with the application Assertions are used \nto verify that what a programmer assumes about their program at a specific point in their code is true You \nshould never use an assertion to handle a users error or to validate data because assertions are not meant \nto be enabled in the production environment\nAssertions should not be used to validate data arguments for public methods The following snippet \nof code is for a credit  method of a BankAccount  class which uses assertion to validate the amount being \ncredited\n An incorrect implementation\npublic void creditdouble amount \n    assert amount  00  Invalid credit amount   amount\n     Other code goes here\n\nThe code for the credit  method depends on enabling an assertion to validate the amount of credit \nto an account Most likely the assertion will be disabled in the production environment which will allow a \ncredit of even a negative number Such validations for a public methods arguments should be performed \nusing exceptions as shown\n A correct implementation\npublic void creditdouble amount \n    if amount    00 \n        throw new IllegalArgumentExceptionInvalid credit amount  amount\n    \n     Other code goes here\n\nYou can use assertions to validate arguments for a nonpublic method A nonpublic method cannot \nbe called by clients directly If parameters for a nonpublic method are incorrect it indicates programmer \nerrors and use of assertions is appropriateChapter 14  assertions\n508You should not use an assertion that has side effects such as an assertion that modifies the state of an \nobject Consider the following snippet of code in a method assuming that reComputeState  alters the state \nof the object of the class\nassert reComputeState\nWhen this assert  statement is executed it will alter the state of the object The subsequent interaction \nwith the object depends on its altered state If the assertions are disabled this code will not execute and the \nobject will not behave properly\nYou can use assertions to implement class invariants Class invariants are conditions that always hold \ntrue about the values that determine the state of an object of a class Class invariants may not be true for \nbrief moments when an object is transitioning from one state to another Suppose you have a BankAccount  \nclass with four instance variables name  dob startDate  and balance  The following class invariants must be \ntrue for a BankAccount  object\n\t The name  on the account must not be null \n\t The dob on the account must not be null  and must not be a date in the future\n\t The startDate  on the account must not be null \n\t The startDate  on the account must not be before dob\n\t The balance  on the account must be greater than zero\nYou can pack all these condition checks into one method say the validAccount  method\nprivate boolean validAccount \n    boolean valid  false\n     Check for class invariants here Return true if it is true Otherwise return false\n    return valid\n\nYou can use the following assertion in methods and constructors to make sure that the class invariants \nare enforced You assume that the toString  method of the BankAccount  class returns enough pieces of \ninformation to help programmers debug the error\nassert validAccount thistostring\nYou can use this assert  statement in the beginning of every method and before you return from the \nmethod You do not need to check for class invariants inside a method if it does not modify the objects state \nYou should use it only at the end in a constructor because class invariants will not hold when the constructor \nstarts executing\n Checking for\u00a0Assertion Status\nHow do you know in your program if assertions are enabled It is easy to check for the assertion status using \nan assert  statement Consider the following snippet of code\nboolean enabled  false\nassert enabled  true\n Check the value of enabled here Chapter 14  assertions\n509This code uses the first form of the assert  statement Note that it uses the assignment operator   \nnot the equality comparison operator   in the expression enabled  true  The expression will assign \ntrue  to the enabled  variable and it will evaluate to true  Note that the enabled  variable has been initialized \nto false  If assertion is enabled the enabled  variable will have a value of true  after the assert  statement \nis executed If assertion is disabled the variable enabled  will have a value of false  Therefore checking \nfor the value of the enabled  variable after the assert  statement will give you a clue whether assertions are \nenabled for your class Listing 143  shows the complete code for checking if assertions are enabled for the \nAssertionStatusTest  class Note that assertion can be enabled or disabled on a class basis too If assertions \nare enabled for a specific class it does not guarantee that they are also enabled for all other classes\nListing 143  A Pro gram to Check Whether Assertion Is Enabled\n AssertionStatusTestjava\npackage comjdojoassertion\npublic class AssertionStatusTest \n    public static void mainString args   \n        boolean enabled  false\n        assert enabled  true\n        if enabled \n            SystemoutprintlnAssertion is enabled\n         else \n            SystemoutprintlnAssertion is disabled\n        \n    \n\n Summary\nAssertions are a feature of the Java programming language that let you assert in your program for \nsome conditions to hold The keyword assert  is used to write an assert statement Assertions are used \nfor detecting logical errors in a program and they are typically enabled in development and testing \nenvironments Assertions can be enabled and disabled for packages and classes They should not be used to \nvalidate users inputs or business rules Assertions do not replace exceptions Rather they complement each \nother\nQUESTIONS AND EXERCISES\n 1 What is an assertion in Ja va What statement do you use to add assertions to your \nprograms\n 2 Describe two forms of the assert  statement\n 3 is assertion enabled by default if your ans wer is no how do you enable it\n 4 in which of the follo wing environments are you supposed to enable assertion \ndevelopment test and productionChapter 14  assertions\n510 5 What are the commandline options that you use to enable and disable assertions \nin all system classes\n 6 Complete the assert  statement in the following snippet of code assuming that x \nmust be greater than 10\nint x  getValue\nassert  Your code goes here   x must be greater than 10\n 7 You are writing code for a public method and you want to validate the methods \narguments Will you use assertion or exception to achieve it Describe your \nresponse511\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307415CHAPTER 15\nStrings\nIn this chapter you will learn\n\t What is a String  object\n\t How to create String  objects\n\t How to use String  literals\n\t How to manipulate String s\n\t How to use String s in a switch  statement or switch expression\n\t How to use StringBuilder  and StringBuffer  objects to construct strings\n\t How to create multiline strings\nAll classes in this chapter are members of a jdojostring  module as declared in Listing 151 \nListing 151  The D eclaration of a jdojostring Module\n moduleinfojava\nmodule jdojostring \n    exports comjdojostring\n\n What Is a\u00a0String\nA sequence of zero or more characters is known as a string In Java programs a string is represented by an \nobject of the javalangString  class The String  class is immutable That is the contents of a String  object \ncannot be modified after it has been created The String  class has two companion classes javalang\nStringBuilder  and javalangStringBuffer  The companion classes are mutable You should use them \nwhen the contents of your string can be modified\nPrior to Java 9 the implementation of the String  class stored characters in a char  array using 2 bytes \nfor each character in the string Most String  objects contain only Latin1 characters requiring only 1 byte \nto store one character in the string So in most cases half of the space in the char  arrays of such String  \nobjects is not used Java 9 changed the internal implementation of the String  class to use a byte  array to \nstore the contents of the String  object it also stores an encoding flag to indicate if each character in the \nString  takes 1 byte or 2 bytes This was done to have efficient use of the memory used by String  objects As \na developer you do not need to know anything new to use strings in your programs since no public interface \nwas changed for the String  classChapter 15  String S\n512 String Literals\nA string literal consists of a sequence of zero or more characters enclosed in double quotes All string literals \nare objects of the String  class Examples of string literals are\nString s1                           An empty string\nString s2  Hello                    String literal consisting of 5 characters\nString s3  Just a string literal    String literal consisting of 21 characters\nMultiple string literals can be used to compose a single string literal\n Composed of two string literals Hello and Hi It represents one string literal \nHelloHi\nString s4  Hello  Hi\nA string literal using two double quotes cannot be broken into two lines you can do this using the text \nblock syntax covered later in this chapter\n Cannot break a string literal in multiple lines A compiletime error\nString wronStr  Hello\nIf you want to break Hello  in two lines you can break it using the string concatenation operator   \nas shown\nString s5  He  llo\nor\nString s6  He  llo\nAnother example of a multiline string literal is shown here The entire text represents a string literal\nString s7  This is a big string literal \n and it will continue in several lines \n It is also valid to insert multiple new lines as we did here  \nAdding more than one line in between two string literals  \nis a feature of Java Language syntax  \n not of string literal\n Escape Sequence Characters in\u00a0String Literals\nA string literal is composed of characters It is valid to use all escape sequence characters to form a string \nliteral For example to include a line feed character and a carriage return character in a string literal you use \nn and r as shown\nn       String literal with a line feed\nr       String literal with a carriage return\nnr     String literal with a line feed and a carriage returnChapter 15  String S\n513First linenSecond line  An embedded line feed\nTabtSeparatedtwords       An embedded tab escape character\nDouble quote  is here     Embedded double quote in string literal\n Unicode Escapes in\u00a0String Literals\nA character can also be represented as a Unicode escape in the form uxxxx  where an x is a hexadecimal \ndigit 09 or AF In a string literal the character A the first uppercase English letter can also be written \nas u0041  for example Apple  and u0041pple  are treated the same in Java Line feed and carriage \nreturn escape characters can also be represented in Unicode escape characters as u000A  and u000D  \nrespectively You cannot use Unicode escapes to embed a line feed and a carriage return character in string \nliterals In other words you cannot replace n  with u000A  and r  with u000D  in a string literal \nWhy The reason is that Unicode escapes are processed at the very beginning of the compilation process \nresulting in the conversion of  u000A  and u000D  into a real line feed and a carriage return respectively \nThis violates the rule that a string literal cannot be continued in two lines For example in the early stages of \ncompilation  Helu000Alo  is translated into the following which is an invalid string literal and generates a \ncompiletime error\nHello\n Tip it is a compiletime error to use Unicode esca pes u000A  and u000D  in a string literal to represent a \nline feed and a carriage return respectively You must use the escape sequences of n and r instead\n What Is a\u00a0CharSequence\nA CharSequence  is an interface in the javalang  package I discuss interfaces in Chapter 21 For now \nyou can think of a CharSequence  as an object that represents a readable sequence of characters String  \nStringBuffer  and StringBuilder  to name a few are instances of CharSequence  They provide readonly \nmethods to read some properties and the content of the sequence of characters represented by them \nIn the API documentation for the String  class you will see arguments of many methods declared as \nCharSequence  You can always pass a String  a StringBuilder  or a StringBuffer  where a CharSequence  is \nrequired\n Creating String Objects\nThe String  class contains many constructors that can be used to create a String  object The default \nconstructor lets you create a String  object with an empty string as its contents For example the following \nstatement creates an empty String  object and assigns its reference to the emptyStr  variable\nString emptyStr  new String\nThe String  class contains another constructor which takes another String  object as an argument\nString str1  new String\nString str2  new Stringstr1  Passing a String as an argumentChapter 15  String S\n514Now str1  represents the same sequence of characters as str2  At this point both str1  and str2  \nrepresent an empty string You can also pass a string literal to this constructor\nString str3  new String\nString str4  new StringHave fun\nAfter these two statements are executed str3  will refer to a String  object which has an empty string  \na sequence of zero characters as its contents and str4  will refer to a String  object which has  Have fun  \nas its contents\n Length of\u00a0a\u00a0String\nThe String  class contains a length  method that returns the number of characters in the String  object \nNote that the length  method returns the number of characters in the string not the number of bytes used \nby the string The return type of the method length  is int Listing 152  demonstrates how to compute the \nlength of a string The length of an empty string is zero\nListing 152  Kno wing the Length of a String\n StringLengthjava\npackage comjdojostring\npublic class StringLength \n    public static void main String args \n         Create two string objects\n        String str1  new String \n        String str2  new StringHello \n         Get the length of str1 and str2\n        int len1  str1length\n        int len2  str2length\n         Display the length of str1 and str2\n        SystemoutprintlnLength of   str1      len1\n        SystemoutprintlnLength of   str2      len2\n    \n\nLength of   0\nLength of Hello  5\n String Literals Are String Objects\nAll string literals are objects of the String  class The compiler replaces all string literals with a reference to a \nString  object Consider the following statement\nString str1  Hello\nWhen this statement is compiled the compiler encounters the string literal Hello  and it creates a \nString  object with Hello  as its content For all practical purposes a string literal is the same as a String  \nobject Wherever you can use the reference of a String  object you can also use a String  literal All methods Chapter 15  String S\n515of the String  class can be used with String  literals directly For example to compute the length of String  \nliterals you can write\nint len1    length        len1 is equal to 0\nint len2    Hellolength  len2 is equal to 5\n String Objects Are Immutable\nString  objects are immutable That is you cannot modify the content of a String  object This leads to an \nadvantage that strings can be shared without worrying about them being modified For example if you need \ntwo objects of the String  class with identical content the same sequence of characters you can create one \nString  object and you can use its reference at both places Sometimes the immutability of strings in Java is \nmisunderstood typically by beginners Consider the following piece of code\nString str\nstr  new StringJust a string\nstr  new StringAnother string\nHere str is a reference variable that can refer to any String  object In other words str can be changed \nand it is mutable However the String  object which str refers to is always immutable This scenario is \ndepicted in Figures\u00a0 151  and 152 \nFigure 151  A Str ing reference variable and a String objectChapter 15  String S\n516If you do not want str to refer to any other String  object after it has been initialized you can declare it \nfinal  like so\nfinal String str  new Stringstr cannot refer to other object\nstr  new StringLet us try  A compiletime error str is final\n Ti p i t is the String  object in memory that is immutable not the reference variable of the String  type if \nyou want a reference variable to refer to the same String  object in memory all the time you must declare the \nreference variable final \n Comparing Strings\nYou may want to compare the sequence of characters represented by two String  objects The String  class \noverrides the equals  method of the Object  class and provides its own implementation which compares \ntwo strings for equality based on their contents For example you can compare two strings for equality as \nshown\nString str1  new StringHello\nString str2  new StringHi\nString str3  new StringHello\nboolean b1 b2\nb1  str1equalsstr2  false will be assigned to b1\nb2  str1equalsstr3  true will be assigned to b2Figure 152  Assigning a different String object reference to a string variableChapter 15  String S\n517You can also compare string literals with string literals or String objects as shown\nb1  str1equalsHello    true will be assigned to b1\nb2  Helloequalsstr1    true will be assigned to b2\nb1  HelloequalsHi    false will be assigned to b1\nRecall that the  operator always compares the references of two objects in memory For example str1 \n str2  and str1  str3  will return false  because str1  str2  and str3  are references of three different \nString  objects in memory Note that the new operator always returns a new object reference\nSometimes you want to compare strings for sorting purposes You may want to sort strings based on \nUnicode values of their characters or in the order they appear in the dictionary The compareTo  method \nin the String  class and the compare  method of the javatextCollator  class let you compare strings for \nsorting purposes\nIf you want to compare two strings based on the Unicode values of their characters use the \ncompareTo  method of the String  class whose declaration is as follows\npublic int compareToString anotherString\nIt returns an integer which can be 0 zero a positive integer or a negative integer It compares the \nUnicode values of the corresponding characters of two strings If any two characters differ in their Unicode \nvalues the method returns the difference between the Unicode values of those two characters For example \nacompareTob  will return 1 The Unicode value is 97 for a and 98 for b It returns the difference \n97  98  which is 1 The following are examples of string comparisons\nabccompareToabc will return 0\nabccompareToxyz will return 23 value of a   x\nxyzcompareToabc will return 23 value of x   a\nIt is very important to note that the compareTo  method compares two strings based on the Unicode \nvalues of their characters The comparison may not be the same as the dictionary order comparison This is \nfine for English and some other languages in which the Unicode values for characters are in the same order \nas the dictionary order of characters This method should not be used to compare two strings in languages \nwhere the dictionary order of characters may not be the same as their Unicode values To perform language\nbased string comparisons you should use the compare  method of the javatextCollator  class instead \nRefer to the LanguageSensitive String Comparison section in this chapter to learn how to use the java\ntextCollator  class Listing 153  demonstrates the string comparisons\nListing 153  Com paring Strings\n StringComparisonjava\npackage comjdojostring\npublic class StringComparison \n    public static void mainString args \n        String apple  new StringApple\n        String orange  new StringOrange\n        Systemoutprintlnappleequalsorange\n        Systemoutprintlnappleequalsapple\n        Systemoutprintlnapple  apple\n        Systemoutprintlnapple  orange\n        SystemoutprintlnapplecompareToapple\n        SystemoutprintlnapplecompareToorange\n    \nChapter 15  String S\n518false\ntrue\ntrue\nfalse\n0\n14\n String Pool\nJava maintains a pool of all string literals in order to minimize the memory usage and for better \nperformance It creates a String  object in the string pool for every string literal it finds in a program When \nit encounters a string literal it looks for a String object in the string pool with the identical content If it does \nnot find a match in the string pool it creates a new String  object with that content and adds it to the string \npool Finally it replaces the string literal with the reference of the newly created String  object in the pool If \nit finds a match in the string pool it replaces the string literal with the reference of the String  object found \nin the pool Lets discuss this scenario with an example Consider the following statement\nString str1  new StringHello\nWhen Java encounters the string literal Hello  it tries to find a match in the string pool If there is \nno String  object with the content Hello  in the string pool a new String  object with Hello  content \nis created and added to the string pool The string literal Hello  will be replaced by the reference of that \nnew String  object in the string pool Because you are using the new operator Java will create another String \nobject on the heap Therefore two String  objects will be created in this case Consider the following code\nString str1  new StringHello\nString str2  new StringHello\nHow many String  objects will be created by this code Suppose when the first statement is executed \nHello  is not in the string pool Therefore the first statement will create two String  objects When the \nsecond statement is executed the string literal Hello  will be found in the string pool This time Hello  \nwill be replaced by the reference of the already existing object in the pool However Java will create a new \nString  object because you are using the new operator in the second statement The previous two statements \nwill create three String  objects assuming that Hello  is not there in the string pool If Hello  was already \nin the string pool when these statements started executing only two String  objects will be created Consider \nthe following statements\nString str1  new StringHello\nString str2  new StringHello\nString str3  Hello\nString str4  Hello\nWhat will be the value returned by str1  str2  It will be false  because the new operator always \ncreates a new object in memory and returns the reference of that new object\nWhat will be the value returned by str2  str3  It will be false  again This needs a little explanation \nNote that the new operator always creates a new object Therefore str2  has a reference to a new object in \nmemory Because Hello  has already been encountered while executing the first statement it exists in the \nstring pool and str3  refers to the String  object with content Hello  in the string pool Therefore str2  and \nstr3  refer to two different objects and str2  str3  returns false Chapter 15  String S\n519What will be the value returned by str3  str4  It will be true  Note that Hello  has already been \nadded to the string pool when the first statement was executed The third statement will assign a reference of a \nString  object from the string pool to str3  The fourth statement will assign the same object reference from the \nstring pool to str4  In other words str3  and str4  are referring to the same String  object in the string pool The \n operator compares the two references therefore str3  str4  returns true  Consider another example\nString s1  Have  Fun\nString s2  HaveFun\nWill s1  s2  return true  Yes it will return true  When a String  object is created in a compiletime \nconstant expression it is also added to the string pool Since Have  Fun  is a compiletime constant \nexpression the resulting string HaveFun  will be added to the string pool Therefore s1 and s2 will refer to \nthe same object in the string pool\nAll compiletime constant string literals are added to the string pool Consider the following examples \nto clarify this rule\nfinal String constStr  Constant    constStr is a constant\nString varStr  Variable            varStr is not a constant\n Constant is pooled will be added to the string pool\nString s1  constStr   is pooled\n Concatenated string will not be added to the string pool\nString s2  varStr   is not pooled\nAfter executing this snippet of code Constant is pooled  s1  will return true  whereas Variable \nis not pooled  s2  will return false \n Ti p a ll string literals and string literals resulting from compiletime constant expressions are added to the \nstring pool\nYou can add a String  object to the string pool using its intern  method The intern  method returns \nthe reference of the object from the string pool if it finds a match Otherwise it adds a new String  object to \nthe string pool and returns the reference of the new object For example in the previous snippet of code s2 \nrefers to a String  object which has the content Variable is not pooled  You can add this String  object \nto the string pool by writing\n Will add the content of s2 to the string pool and return the reference\n of the string object from the pool\ns2  s2intern\nNow Variable is not pooled  s2  will return true  because you have already called the intern  \nmethod on s2 and its content has been pooled\n Ti p the String  class maintains a pool of strings internally all string literals are added to the pool \nautomatically You can add your own strings to the pool by invoking the intern  method on the String  \nobjects You cannot access the pool directly there is no way to remove String objects from the pool except by \nexiting and restarting the appChapter 15  String S\n520 String Operations\nThis section describes some of the frequently used operations on String  objects\n Getting the\u00a0Character at\u00a0an\u00a0Index\nYou can use the charAt  method to get a character at a particular index from a String  object The index \nstarts at zero Table\u00a0 151  shows indexes of all characters in the string HELLO \nNote that the index of the first character H is 0 zero the second character E is 1 and so on The index of \nthe last character O is 4 which is equal to the length of the string Hello  minus 1\nThe following snippet of code will print the index value and the character at each index in a string of \nHELLO \nString str  HELLO\n Get the length of string\nint len  strlength\n Loop through all characters and print their indexes\nfor int i  0 i  len i \n    SystemoutprintlnstrcharAti   is at index   i\n\nH is at index 0\nE is at index 1\nL is at index 2\nL is at index 3\nO is at index 4\n Testing Strings for\u00a0Equality\nIf you want to compare two strings for equality and ignore their cases you can use the equalsIgnoreCase  \nmethod If you want to perform a casesensitive comparison for equality you need to use the equals  \nmethod instead as previously described\nString str1  Hello\nString str2  HELLO\nif str1equalsIgnoreCasestr2 \n    Systemoutprintln Ignoring case str1 and str2 are equal\n else \n    SystemoutprintlnIgnoring case str1 and str2 are not equal\n\nif str1equalsstr2 \n    Systemoutprintlnstr1 and str2 are equalTable 151  Indexes of All Characters in the String HELLO\nIndex  0 1 2 3 4\nCharacter  H E L L OChapter 15  String S\n521 else \n    Systemoutprintlnstr1 and str2 are not equal\n\nIgnoring case str1 and str2 are equal\nstr1 and str2 are not equal\n Testing a\u00a0String to\u00a0Be\u00a0Empty\nSometimes you need to test whether a String  object is empty The length of an empty string is zero There \nare three ways to check for an empty string\n\t Use the isEmpty  method\n\t Use the equals  method\n\t Get the length of the String  and check if it is zero\nThe following snippet of code shows how to use all three methods\nString str1  Hello\nString str2  \n Using the isEmpty method\nboolean empty1  str1isEmpty      Assigns false to empty1\nboolean empty2  str2isEmpty      Assigns true to empty1\n Using the equals method\nboolean empty3  equalsstr1     Assigns false to empty3\nboolean empty4  equalsstr2     Assigns true to empty4\n Comparing length of the string with 0\nboolean empty5  str1length  0  Assigns false to empty5\nboolean empty6  str2length  0  Assigns true to empty6\nWhich of these methods is the best The first method may seem more readable as the method name \nsuggests what is intended However the second method is preferred as it handles the comparison with null  \ngracefully The first and third methods throw a NullPointerException  if the string is null  The second \nmethod returns false  when the string is null  for example equalsnull  returns false \n Changing the\u00a0Case\nTo convert the content of a string to lower and uppercase you can use the toLowerCase  method and the \ntoUpperCase  method respectively For example HellotoUpperCase  will return the string HELLO  \nwhereas HellotoLowerCase  will return the string hello \nRecall that String  objects are immutable When you use the toLowerCase  or toUpperCase  method \non a String  object the content of the original object is not modified Rather Java creates a new String  \nobject with the identical content as the original String  object and with the cases of the original characters \nchanged The following snippet of code creates three String  objects\nString str1  new StringHello  str1 contains Hello\nString str2  str1toUpperCase    str2 contains HELLO\nString str3  str1toLowerCase    str3 contains helloChapter 15  String S\n522 Searching for\u00a0a\u00a0String\nYou can get the index of a character or a string within another string using the indexOf  and lastIndexOf  \nmethods for example\nString str  Apple\nint index  strindexOfp    index will have a value of 1\nindex  strindexOfpl       index will have a value of 2\nindex  strlastIndexOfp    index will have a value of 2\nindex  strlastIndexOfpl  index will have a value of 2\nindex  strindexOfk        index will have a value of 1\nThe indexOf  method starts searching for the character or the string from the start of the string and \nreturns the index of the first match The lastIndexOf  method matches the character or the string from \nthe end and returns the index of the first match If the character or string is not found in the string these \nmethods return 1\n Representing Values as\u00a0Strings\nThe String  class has an overloaded valueOf  static method It can be used to get the string representation \nof the values of any primitive data type or any object for example\nString s1  StringvalueOfC    s1 has C\nString s2  StringvalueOf10  s2 has 10\nString s3  StringvalueOftrue  s3 has true\nString s4  StringvalueOf1969  s4 has 1969\n Getting a\u00a0Substring\nYou can use the substring  method to get a part of a string This method is overloaded as follows\n\t String substringint beginIndex\n\t String substringint beginIndex int endIndex\nThe first version returns a string that begins at the character at index beginIndex  and extends to the \nend of this string The second version returns a string that begins at the character at index beginIndex  and \nextends to the character at index endIndex   1 Both methods throw an IndexOutOfBoundsException  if the \nspecified indexes are outside the range of the string The following are examples of using these methods\nString s1  Hellosubstring1      s1 has ello\nString s2  Hellosubstring1 4  s2 has ell\n Trimming a\u00a0String\nYou can use the trim  method to remove all leading and trailing whitespace and control characters from \na string In fact the trim  method removes all leading and trailing characters which have Unicode values \nless than u0020  decimal 32 from the string For exampleChapter 15  String S\n523\t hello trim  will return hello\n\thello trim  will return hello\n\tn r t hellonnnrr  will return hello\nNote that the trim  method removes only leading and trailing whitespace It does not remove any \nwhitespace or control characters if they appear in the middle of the string for example\n\t henllo trim  will return henllo  because n is inside the string\n\th ellotrim  will return h ello  because the space is inside the string\n Replacing Part of\u00a0a\u00a0String\nThe String  class contains the following methods that let you create a new string by replacing part of the old \nstring with a different character or string\n\tString replacechar oldChar char newChar\n\tString replaceCharSequence target CharSequence replacement\n\tString replaceAllString regex String replacement\n\tString replaceFirstString regex String replacement\nThe replacechar oldChar char newChar  method returns a new String  object by replacing all \noccurrences of oldChar  with newChar  Here is an example\n Both os in tooth will be replaced by two e str will contain teeth\nString str  toothreplaceo e\nThe replaceCharSequence target CharSequence replacement  method works with CharSequence  \nIt returns a new String  object by replacing all occurrences of target  with replacement  Here is an example\n oo in tooth will be replaced by ee str will contain teeth\nString str  toothreplaceoo ee\nThe replaceAllString regex String replacement  method uses a regular expression in regex  \nto find matches It returns a new String  object by replacing each match with replacement  A regular \nexpression to match a digit is d I cover regular expressions in Chapter 18 Here is an example\n Replace all digits with an  str contains Born on Sept  \nString str  Born on Sept 19 1969replaceAlld \nThe replaceFirstString regex String replacement  method works the same as the \nreplaceAll  method except that it replaces only the first match with replacement  Here is an example\n Replace the first digit with an  str contains Born on Sept 9 1969\nString str  Born on Sept 19 1969replaceFirstd Chapter 15  String S\n524 Matching the\u00a0Start and\u00a0End of\u00a0a\u00a0String\nThe startsWith  method checks if the string starts with the specified argument whereas endsWith  \nchecks if the string ends with the specified string argument Both methods return a boolean  value Here are \nexamples of using these methods\nString str  This is a Java program\n Test str if it starts with This\nif strstartsWithThis\n    SystemoutprintlnString starts with This\n else \n    SystemoutprintlnString does not start with This\n\n Test str if it ends with program\nif strendsWithprogram \n    SystemoutprintlnString ends with program\n else \n    SystemoutprintlnString does not end with program\n\nString starts with This\nString ends with program\n Splitting and\u00a0Joining Strings\nIt is often useful to split a string around a specified delimiter and join multiple strings into one string using a \nspecified delimiter\nUse the split  method to split a string into multiple strings Splitting is performed using a delimiter \nThe split  method returns an array of String  You will learn about arrays in Chapter 19 However you will \nuse it in this section just to complete the operations of strings\n Note  the split  method takes a regular expression that defines a pattern as a delimiter\nString str  ALFLNYCAGA\n Split str using a comma as the delimiter\nString parts  strsplit\n Print the the string and its parts\nSystemoutprintlnstr\nforString part  parts \n    Systemoutprintlnpart\nChapter 15  String S\n525ALFLNYCAGA\nAL\nFL\nNY\nCA\nGA\nJava 8 added a static join  method to the String  class that joins multiple strings into one string It is \noverloaded\n\tString joinCharSequence delimiter CharSequence elements\n\tString joinCharSequence delimiter Iterable extends CharSequence \nelements\nThe first version takes a delimiter and a sequence of strings to be joined The second argument is a var\nargs so you can also pass an array to this method\nThe second version takes a delimiter and an Iterable  for example a List  or Set The following snippet \nof code uses the first version to join a few strings\n Join some strings using a comma as the delimiter\nString str  Stringjoin AL FL NY CA GA\nSystemoutprintlnstr\nALFLNYCAGA\n Strings in\u00a0a\u00a0switch Statement\nWe discussed the switch  statement in Chapter 6 You can also use strings in a switch  statement The switch  \nexpression uses a String  type If the switch  expression is null  a NullPointerException  is thrown The case  \nlabels must be String  literals or constants You cannot use String  variables in the case  labels The following \nis an example of using a String  in a switch  statement which will print Turn on  on the standard output\nString status  on\nswitchstatus \n    case on\n        SystemoutprintlnTurn on  Will execute this\n        break\n    case off\n        SystemoutprintlnTurn off\n        break\n    default\n        SystemoutprintlnUnknown command\n        break\n\nThe switch  statement for strings compares the switch  expression with case  labels as if the equals  \nmethod of the String  class had been invoked In the previous example statusequalson  will be invoked \nto test if the first case  block should be executed Note that the equals  method of the String  class performs a \ncasesensitive string comparison It means that the switch  statement that uses strings is case sensitiveChapter 15  String S\n526The following switch  statement will print Unknown command  on the standard output because the \nswitch  expression ON  in uppercase will not match the first case  label on  in lowercase\nString status  ON\nswitchstatus \n    case on\n        SystemoutprintlnTurn on\n        break\n    case off\n        SystemoutprintlnTurn off\n        break\n    default\n        SystemoutprintlnUnknown command  Will execute this\n        break\n\nAs a g ood programming practice you need to do the following two things before executing a switch  \nstatement with strings\n\t Check if the switch  value for the switch  statement is null  If it is null  do not \nexecute the switch  statement\n\t If you want to perform a caseinsensitive comparison in a switch  statement you \nneed to convert the switch  expression to lowercase or uppercase and use lowercase \nor uppercase in the case  labels accordingly\nYou can rewrite the previous switch  statement example as shown in Listing 154  which takes care of \nthe two suggestions\nListing 154  Using Strings in a switch Statement\n StringInSwitchjava\npackage comjdojostring\npublic class StringInSwitch \n    public static void mainString args \n        operateon\n        operateoff\n        operateON\n        operateNothing\n        operateOFF\n        operatenull\n    \n    public static void operateString status \n         Check for null\n        if status  null \n            Systemoutprintlnstatus cannot be null\n            return\n        \n         Convert to lowercase\n        switch statustoLowerCase \n            case on\n                SystemoutprintlnTurn on\n                breakChapter 15  String S\n527            case off\n                SystemoutprintlnTurn off\n                break\n            default\n                SystemoutprintlnUnknown command\n                break\n        \n    \n\nTurn on\nTurn off\nTurn on\nUnknown command\nTurn off\nstatus cannot be null\n Testing a\u00a0String for\u00a0Palindrome\nIf you are an experienced programmer you may skip this section This is meant to serve as a simple exercise \nfor beginners\nA palindrome is a word a verse a sentence or a number that reads the same in forward and backward \ndirections For example  Able was I ere I saw Elba and 1991 are examples of palindromes Lets write a \nmethod that will accept a string as an argument and test if that string is a palindrome The method will \nreturn true  if the string is a palindrome Otherwise it will return false  You will use some methods of the \nString  class that you learned in the previous sections The following is the description of the steps to be \nperformed inside the method\nAssume that the number of characters in the input string is n You need to compare the characters at \nindexes 0 and n\u00a0 1 1 and n\u00a0 2 2 and n\u00a0 3 and so on Note that if you continue the comparison in the \nend you will compare the character at index n\u00a0 1 with the character at index 0 which you have already \ncompared in the beginning You need to compare the characters only halfway through If all comparisons for \nequality return true  the string is a palindrome\nThe number of characters in a string may be odd or even Comparing characters only halfway works \nin both cases The middle of a string varies depending on whether the length of the string is odd or even \nFor example the middle of the string FIRST  is the character R What is the middle character in the \nstring SECOND  You can say there is no middle character in it as its length is even For this purpose it is \ninteresting to note that if the number of characters in the string is odd you do not need to compare the \nmiddle character with any other character\nYou need to continue the character comparison up to half of the strings length if the number of \ncharacters in the string is even and up to half of the strings length minus one  if the number of characters \nis odd You can get the numbers of comparisons to be done in both the cases by dividing the length of \nthe string by 2 Note that the length of a string is an integer and if you divide an integer by 2 the integer \ndivision will discard the fraction part if any which will take care of cases with an odd number of characters \nListing\u00a0 155  contains the complete codeChapter 15  String S\n528Listing 155  Testing a String for a Palindrome\n Palindromejava\npackage comjdojostring\nimport javautilObjects\npublic class Palindrome \n    public static void mainString args \n        String str1  hello\n        boolean b1  PalindromeisPalindromestr1\n        Systemoutprintlnstr1   is a palindrome   b1\n        String str2  noon\n        boolean b2  PalindromeisPalindromestr2\n        Systemoutprintlnstr2   is a palindrome   b2\n    \n    public static boolean isPalindromeString inputString \n        ObjectsrequireNonNullinputString String cannot be null\n         Get the length of string\n        int len  inputStringlength\n         In case of an empty string and one character strings we do not need to\n         do any comparisons They are always palindromes\n        if len  1 \n            return true\n        \n          Convert the string into uppercase so we can make the comparisons case \ninsensitive\n        String newStr  inputStringtoUpperCase\n         Initialize the result variable to true\n        boolean result  true\n         Get the number of comparisons to be done\n        int counter  len  2\n         Do the comparison\n        for int i  0 i  counter i \n            if newStrcharAti  newStrcharAtlen   1  i \n                 It is not a palindrome\n                result  false\n                 Exit the loop\n                break\n            \n        \n        return result\n    \n\nhello is a palindrome false\nnoon is a palindrome trueChapter 15  String S\n529 StringBuilder and\u00a0StringBuffer\nStringBuilder  and StringBuffer  are companion classes for the String  class Unlike a String  they \nrepresent a mutable sequence of characters That is you can change the content of StringBuilder  and \nStringBuffer  without creating a new object You might wonder why two classes exist to represent the same \nthinga mutable sequence of characters The StringBuffer  class has been part of the Java library since \nthe beginning whereas the StringBuilder  class was added in Java 5 The difference between the two lies \nin thread safety StringBuffer  is threadsafe and StringBuilder  is not threadsafe Most of the time you \ndo not need thread safety and using StringBuffer  in those cases has a performance penalty This is the \nreason that StringBuilder  was added later Both classes have the same methods except that all methods in \nStringBuffer  are synchronized We will discuss only StringBuilder  in this section Using StringBuffer  in \nyour code would be just a matter of changing the class name\n Ti p Use StringBuilder  when no thread safety is needed for example manipulating a sequence of \ncharacters in a local variable in a method or constructor Otherwise use StringBuffer  thread safety and \nsynchronization are described in the second volume of this series\nYou can use objects of the StringBuilder  class instead of the String  class in situations where \ncontent of a string changes frequently Recall that because of the immutability of the String  class string \nmanipulations using a String  object result in many new String  objects which in turn degrade the \nperformance A StringBuilder  object can be thought of as a modifiable string It has many methods to \nmodify its contents The StringBuilder  class contains four constructors\n\tStringBuilder\n\tStringBuilderCharSequence seq\n\tStringBuilderint capacity\n\tStringBuilderString str\nThe noargs constructor creates an empty StringBuilder  with a default capacity of 16\nThe second constructor takes a CharSequence  object as an argument It creates a StringBuilder  object \nwhose content is the same as the specified CharSequence \nThe third constructor takes an int as argument it creates an empty StringBuilder  object whose initial \ncapacity is the same as the specified argument The capacity of a StringBuilder  is the number of characters it \ncan hold without allocating more space The capacity is adjusted automatically when additional space is needed\nThe fourth constructor takes a String  and creates a StringBuilder  that has the same content as the \nspecified String  The following are some examples of creating StringBuilder  objects\n Create an empty StringBuilder with a default initial capacity of 16 characters\nStringBuilder sb1  new StringBuilder\n Create a StringBuilder from of a string\nStringBuilder sb2  new StringBuilderHere is the content\n Create an empty StringBuilder with 200 characters as the initial capacity\nStringBuilder sb3  new StringBuilder200\nThe append  method lets you add text to the end of the StringBuilder  It is overloaded It takes many \ntypes of arguments Refer to the API documentation for the class for the complete list of all overloaded \nappend  methods It has other methods for example insert  and delete  that let you modify its \ncontent tooChapter 15  String S\n530The StringBuilder  class has two properties length  and capacity  At a given point in time their values \nmay not be the same Its length refers to the length of its content whereas its capacity refers to the maximum \nnumber of characters it can hold without needing new memory to be allocated Its length can be at most \nequal to its capacity at any time The length  and capacity  methods return its length and capacity \nrespectively for example\nStringBuilder sb  new StringBuilder200    Capacity200 length0\nsbappendHello                           Capacity200 length5\nint len  sblength                        len is assigned 5\nint capacity  sbcapacity                 capacity is assigned 200\nCapacity of a StringBuilder  is controlled by the runtime whereas its length is controlled by the content \nyou place in it The runtime adjusts the capacity as its content is modified\nYou can get the content of a StringBuilder  as a String  by using its toString  method\n Create a String object\nString s1  new StringHello\n Create a StringBuilder from of the String object s1\nStringBuilder sb  new StringBuilders1\n Append  Java to the StringBuilders content\nsbappend Java  Now sb contains Hello Java\n Get a String from the StringBuilder\nString s2  sbtoString  s2 contains Hello Java\nUnlike String  StringBuilder  has a setLength  method which takes its new length as an argument \nIf the new length is greater than the existing length the extra positions are filled with null  characters a null \ncharacter is u0000  If the new length is less than the existing length its content is truncated to fit in the new \nlength\n Length is 5\nStringBuilder sb  new StringBuilderHello\n Now the length is 7 with last two characters as null character u0000\nsbsetLength7\n Now the length is 2 and the content is He\nsbsetLength2\nThe StringBuilder  class has a reverse  method which replaces its contents with the same sequence \nof characters but in reverse order Listing 156  illustrates some of the methods of the StringBuilder  class\nListing 156  Using a StringBuilder Object\n StringBuilderTestjava\npackage comjdojostring\npublic class StringBuilderTest \n    public static void mainString args \n         Create an empty StringBuilder\n        StringBuilder sb  new StringBuilder\n        printDetailssb\n         Append blessings\n        sbappendblessings\n        printDetailssb\n         Insert Good  in the beginningChapter 15  String S\n531        sbinsert0 Good \n        printDetailssb\n         Delete the first o\n        sbdeleteCharAt1\n        printDetailssb\n         Append  be with you\n        sbappend be with you\n        printDetailssb\n         Set the length to 3\n        sbsetLength3\n        printDetailssb\n         Reverse the content\n        sbreverse\n        printDetailssb\n    \n    public static void printDetailsStringBuilder sb \n        SystemoutprintlnContent   sb  \n        SystemoutprintlnLength   sblength\n        SystemoutprintlnCapacity   sbcapacity\n         Print an empty line to separate results\n        Systemoutprintln\n    \n\nContent \nLength 0\nCapacity 16\nContent blessings\nLength 9\nCapacity 16\nContent Good blessings\nLength 14\nCapacity 16\nContent God blessings\nLength 13\nCapacity 16\nContent God blessings be with you\nLength 25\nCapacity 34\nContent God\nLength 3\nCapacity 34\nContent doG\nLength 3\nCapacity 34Chapter 15  String S\n532 String Concatenation Operator \nThere are three ways to concatenate strings\n\t Using the concatString str  method of the String  class\n\t Using the  string concatenation operator\n\t Using a StringBuilder  or a StringBuffer\nThe concat  method takes a String  as an argument which means you can use it to concatenate \nstrings only If you want to concatenate values of different data types into a string use the concatenation \noperator for example\n Assigns hi there to s1\nString s1  hi concat there\n Assign XY1256 to s2\nString s2  X  Y  1256\n Assign XY1256 to s3\nString s3  new StringBuilderappendXappendYappend1256toString\n Multiline Strings\nMultiline string support was added to Java in version 15 and above via text blocks A text block must start \nwith three quotation marks and a new line and is a more convenient way to define a string that spans \nmultiple lines Previously in Java you would need to explicitly supply line break  new line  characters within \na string using n if you wanted to define a string with a line break or multiple lines in it\nFor example using a text block you can define a multiline string like the following\nString text  \n     First line\n     Second line\n     Third line\n          \nJava ignores the whitespace space or tabs in the front of each line This makes it possible to define a \nmultiline string while keeping all the text indented\nPreviously without text blocks you would need to define the same string in the following way\nString text  First linen \n     Second linen \n     Third linen\nDont forget to include three quotation marks and a new line when defining a multiline string The \nfollowing syntax will not work for example since it does not include the new line after three quotations\nString text  First line\n      Second line\n      Third line\n          Chapter 15  String S\n533You dont need to escape quotation marks within a text block Otherwise the rules for defining strings \nremain the same for text blocks as for normal strings Listing 157  shows text blocks in action\nListing 157  Multiline S trings\n TextBlocksjava\npublic class TextBlocks \n    public static void mainString args \n         String text  \n         First line\n         Second line\n         Third line\n         \n         Systemoutprinttext\n    \n\nFirst line\nSecond line\nThird line\nThis program demonstrates defining a multiline string containing quotation marks and prints out the \nresult\nText blocks make it much easier to define multiline SQL queries or JSON bodies within Java programs\n LanguageSensitive String Comparison\nThe String  class compares strings based on the Unicode values of their characters Sometimes you may \nwant to compare strings based on the dictionary order instead\nUse the compare  method of the javatextCollator  class to perform languagesensitive dictionary \norder string comparisons The method takes two strings to be compared as arguments It returns 0 if two \nstrings are the same 1 if the first string comes after the second and 1 if the first string comes before the \nsecond Listing 158  illustrates the use of the Collator  class\nListing 158  Lang uageSensitive String Comparisons\n CollatorStringComparisonjava\npackage comjdojostring\nimport javatextCollator\nimport javautilLocale\npublic class CollatorStringComparison \n    public static void mainString args \n         Create a Locale object for US\n        Locale USLocale  new Localeen US\n         Get a Collator instance for US\n        Collator c  CollatorgetInstanceUSLocale\n        String str1  cat\n        String str2  Dog\n        int diff  ccomparestr1 str2\n        SystemoutprintComparing using Collator class Chapter 15  String S\n534        printdiff str1 str2\n        SystemoutprintComparing using String class \n        diff  str1compareTostr2\n        printdiff str1 str2\n    \n    public static void printint diff String str1 String str2 \n        if diff  0 \n            Systemoutprintlnstr1   comes after   str2\n         else if diff  0 \n            Systemoutprintlnstr1   comes before   str2\n         else \n            Systemoutprintlnstr1   and   str2   are the same\n        \n    \n\nComparing using Collator class cat comes before Dog\nComparing using String class cat comes after Dog\nThe program also shows the comparison of the same two strings using the String  class Note that the \nword cat  comes before the word Dog  in the dictionary order The Collator  class uses their dictionary \norders to compare them However the String  class compares the Unicode values of the first character of \ncat  which is 99 and the first character of Dog  which is 68 Based on these two values the String  class \ndetermines that Dog  comes before cat  The output confirms the two different ways of comparing strings\n Summary\nIn this chapter you learned about the String  StringBuilder  and StringBuffer  classes A String  \nrepresents an immutable sequence of characters whereas StringBuilder  and StringBuffer  represent a \nmutable sequence of characters StringBuilder  and StringBuffer  work the same way except the latter is \nthreadsafe and the former is not\nThe String  class provides several methods to operate on its content Whenever you obtain a part of \nthe content from a String  a new String  object is created The String  class compares two strings based on \nthe Unicode values of their characters Java added support for text blocks using three quotation marks plus \na new line to denote the start and the text can be indented Use the javatextCollator  class to compare \nstrings in dictionary order From Java 7 onward you can use strings in a switch  statement\nQUESTIONS AND EXERCISES\n 1 What is a string in Java Can you change the contents of a String  object after it is \ncreated\n 2 What is a string literal\n 3 What is the difference between the String  class and the StringBuilder  class\n 4 What is the difference between the StringBuffer  class and the StringBuilder  \nclassChapter 15  String S\n535 5 Write the output when the follo wing snippet of code is executed\nString s1  Hello\nString s2  Hello\nSystemoutprintlns1    s1\nSystemoutprintlns2    s2\n 6 Write the output when the follo wing snippet of code is executed\nString s1  Whonknows\nSystemoutprintlns1    s1\n 7 Write the output when the follo wing snippet of code is executed\nString s1  Having fun with strings\nint len  s1length\nchar c  s1charAt4\n 8 Write the output when the follo wing snippet of code is executed\nString s1  Fun\nString s2  new StringFun\nSystemoutprintlns1  s2\nSystemoutprintlns1equalss2\nSystemoutprintlnFun  Fun\n 9 Write the output when the follo wing snippet of code is executed\nStringBuilder sb  new StringBuilder200\nsbappendHelloappendfalse\nSystemoutprintlnlength    sblength\nSystemoutprintlncapacity    sbcapacity\nSystemoutprintlnsbtoString\n 10 Write the output when the follo wing snippet of code is executed\nString s1  10  20    what\nString s2  10  StringvalueOf20    what\nSystemoutprintlns1\nSystemoutprintlns2\n 11 Complete the code for a method named equalsContents  as declared here \nthe method should return true  if both arguments have the same contents after \nremoving leading and trailing whitespace and ignoring cases if both arguments are \nnull it should return true  Otherwise it should return false \npublic static boolean equalsContentsString s1 String s2 \n     your code goes here\n\n 12 Complete the follo wing code so that the year month and day are printed as 1969  \n09 and 19\nString date  19690919\nString year  dateyour code goes hereChapter 15  String S\n536String month  dateyour code goes here\nString day  dateyour code goes here\nSystemoutprintlnyear    year\nSystemoutprintlnmonth    month\nSystemoutprintlnday    day\n 13 Complete the follo wing snippet of code so it prints the expected output which is \nshown after the snippet\nString s1  noon and spoon\nString s2  s1Your code goes here\nSystemoutprintlns1\nSystemoutprintlns2\nexpected  output is as follows\nnoon and spoon\nnun and spun\n 14 Complete the follo wing snippet of code so it prints the expected output which is \nshown after the snippet\nString s1  noon and spoon\nString s2  s1Your code goes here\nSystemoutprintlns1\nSystemoutprintlns2\nexpected  output is as follows\nnoon and spoon\nnn and spn\n 15 Complete the code for a reverseString str  method it takes a string \nand returns the reverse of that string Do not use the StringBuilder  or \nStringBuffer  class\npublic static String reverseString str \n     Your code goes here \n\n 16 What is the value of the expression abccompareToabc 537\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307416CHAPTER 16\nDates and\u00a0Times\nIn this chapter you will learn\n\t What the Java DateTime API is\n\t The design principles behind the DateTime API\n\t The evolution of timekeeping time zones and Daylight Savings Time DST\n\t The ISO8601 standard for date time and datetime keeping\n\t How to represent date time and datetime using the DateTime API classes and how \nto query adjust format and parse them\n\t How to use the legacy Date API\n\t How to interoperate between the legacy and new DateTime APIs\nThe DateTime API was introduced in Java 8 and has been enhanced since then with a lot of new \nmethods in several interfaces and classes This chapter covers a comprehensive coverage of the Date\nTime API\u00a0The API consists of packages starting with  javatime   which are in the javabase  module All \nexample programs in this chapter are a member of a jdojodatetime  module as declared in Listing 161 \nListing 161  The D eclaration of a jdojodatetime Module\n moduleinfojava\nmodule jdojodatetime \n    exports comjdojodatetime\n\n The DateTime API\nJava 8 introduced a new DateTime API to work with date and time In this chapter we refer to the date and \ntimerelated classes available before Java 8 as the legacy DateTime API\u00a0The legacy DateTime API includes \nclasses like Date  Calendar  GregorianCalendar  etc They are in the javautil  and javasql  packages The \nDate  class has existed since the inception of the JDK others were added in JDK 11Chapter 16  Dates an D\u00a0times\n538Why did we need a new DateTime API The simple answer is that the designers of the legacy Date\nTime API did not get it right in two attempts To list a few some of the issues with the legacy DateTime API \nare as follows\n\t A date always had two components a date and a time If you needed just a date \nwithout any time information you had no choice Developers used to set the time \nto midnight in a date object to represent a dateonly date which was incorrect for \nseveral reasons The same argument is valid for storing only time\n\t A datetime was simply stored as the number of milliseconds elapsed since January 1 \n1970 midnight UTC\n\t Manipulating dates was as complex as you can think the year  field in a Date  object \nwas stored as an offset from 1900 months ran from 0 to 11 not from 1 to 12 as \nhumans are used to conceptualizing them\n\t Legacy datetime classes were mutable and therefore not threadsafe\nIs the third time the charm Here is the third attempt to provide a correct powerful and extensible \nDateTime API\u00a0The Java DateTime API is not a free ride however It has a steep learning curve if you want \nto use its full potential It consists of about 80 classes Do not worry about the big number of classes They \nhave been carefully designed and named Once you understand the thoughts behind its design its relatively \neasy to figure out the name of a class and the methods that you need to use in a particular situation As a \ndeveloper you need to understand about 15 classes to use the Java DateTime API effectively in your daily \nprogramming\n Design Principles\nBefore you start learning the details of the Java DateTime API you will need to understand a few basic \nconcepts about dates and times The DateTime API is based on ISO8601 datetime standards A Java \ndatetime framework named JodaTime inspired this DateTime API which was added in Java 8 If you have \nused JodaTime before you will be able to learn the DateTime API quickly You can find the details of the \nJodaTime project at wwwjodaorgjoda  time \nThe DateTime API makes a distinction between how dates and times are used by machines and \nhumans Machines deal with time as continual ticks as a single incrementing number measured in seconds \nmilliseconds etc Humans use a calendar system to deal with time in terms of year month day hour \nminute and second The DateTime API has a separate set of classes to deal with machinebased time and \ncalendarbased human time It lets you convert machinebased time to humanbased time and vice versa\nThe legacy DateTime API has been around for over 15 years It is possible that you will encounter \nlegacy datetime classes while working with existing applications The legacy datetime classes have been \nretrofitted to work seamlessly with the new classes When you write new code use the new DateTime API \nclasses When you receive objects of legacy classes as input convert the legacy objects into new datetime \nobjects and use the new DateTime API\nThe Java DateTime API consists of mostly immutable classes Because the API is extensible you are \nadvised to create immutable classes whenever possible to extend the API\u00a0An operation on a datetime \nobject creates a new datetime object This pattern makes it easy to chain method calls\nClasses in the DateTime API do not provide public constructors They allow you to create their \nobjects by providing static factory methods named of  ofXxx  and from  The API uses a welldefined \nnaming convention for naming methods Each class in the API has several methods Knowing the method \nnaming convention lets you find the right method for your purpose easily We discuss the method naming \nconvention shortly in a separate sectionChapter 16  Dates an D\u00a0times\n539 A Quick Example\nLets look at an example of working with dates and times using the Java DateTime API\u00a0An instance of the \nLocalDate  class represents a local date without a time an instance of the LocalTime  class represents a local \ntime without a date an instance of the LocalDateTime  class represents a local date and time an instance of \nthe ZonedDateTime  class represents date and time with a time zone\nA LocalDate  and a LocalTime  are also called partials  as they do not represent an instant on the \ntimeline they are also not aware of changes in Daylight Savings Time A ZonedDateTime  represents a point in \ntime in a given time zone that can be converted to an instant on the timeline it is aware of Daylight Savings \nTime For example adding 4 hours to a LocalTime  of 100 AM will give you another LocalTime  of 500 AM \nirrespective of the date and location However if you add 4 hours to a ZonedDateTime  representing 100 AM \non March 9 2014 in the ChicagoAmerica time zone it will give you 600 AM time on March 9 2014 in the \nsame time zone as the clock is moved forward by 1 hour at 200 AM on that day because of Daylight Savings \nTime For example airline applications would use instances of the ZonedDateTime  class to store departure \ntime and arrival time of flights\nIn the DateTime API classes representing date time and datetime have a now  method that returns \nthe current date time or datetime respectively The following snippet of code creates datetime objects \nrepresenting a date a time and a combination of them with and without a time zone\nLocalDate dateOnly  LocalDatenow\nLocalTime timeOnly  LocalTimenow\nLocalDateTime dateTime  LocalDateTimenow\nZonedDateTime dateTimeWithZone  ZonedDateTimenow\nA LocalDate  is not time zoneaware It will be interpreted differently in different time zones at the same \nmoment of time A LocalDate  object is used for storing a date value when the time and time zone are not \nimportant to give a meaning to the date value such as a birth date the publication date of a book etc\nYou can specify the components of a datetime object using the static factory method of  The \nfollowing snippet of code creates a LocalDate  by specifying the year month and day components of a date\n Create a LocalDate representing January 12 1968\nLocalDate myBirthDate  LocalDateof1968 JANUARY 12\n Tip a LocalDate  stores a dateonly value without a time and time zone When you obtain a LocalDate  \nusing the static method now  the system default time zone is used to get the date value\nListing 162  shows how to get the current date time datetime and datetime with the time zone It also \nshows how to construct a date from year month of year and day of month You may get a different output as \nit prints the current values for date and time\nListing 162  Obtainin g Current Date Time and Datetime and Constructing a Date\n CurrentDateTimejava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalTime\nimport javatimeLocalDateTime\nimport javatimeZonedDateTime\nimport static javatimeMonthJANUARYChapter 16  Dates an D\u00a0times\n540public class CurrentDateTime \n    public static void mainString args \n         Get current date time and datetime\n        LocalDate dateOnly  LocalDatenow\n        LocalTime timeOnly  LocalTimenow\n        LocalDateTime dateTime  LocalDateTimenow\n        ZonedDateTime dateTimeWithZone  ZonedDateTimenow\n        SystemoutprintlnCurrent Date   dateOnly\n        SystemoutprintlnCurrent Time   timeOnly\n        SystemoutprintlnCurrent Date and Time   dateTime\n        SystemoutprintlnCurrent Date Time and Zone   dateTimeWithZone\n         Construct a birth date and time from datetime components\n        LocalDate myBirthDate  LocalDateof1968 JANUARY 12\n        LocalTime myBirthTime  LocalTimeof7 30\n        SystemoutprintlnMy Birth Date   myBirthDate\n        SystemoutprintlnMy Birth Time   myBirthTime\n    \n\nCurrent Date 20210804\nCurrent Time 084829402753900\nCurrent Date and Time 20210804T084829402753900\nCurrent Date Time and Zone 20210804T0848294037542000500AmericaChicago\nMy Birth Date 19680112\nMy Birth Time 0730\nThe program uses four classes to get a local date a time a datetime and a datetime with a time zone In \nthe legacy DateTime API you could have gotten a similar result using only the Calendar  class\nThe DateTime API is comprehensive It spans about 80 classes and about 1000 methods It lets you \nrepresent and manipulate dates and times using different scales and different calendar systems Several \nlocal standards and one universal standard ISO8601 have been in use for timekeeping To take full \nadvantage of the DateTime API you need to understand the history of timekeeping The next few sections \ngive you a brief overview of different ways to measure time using calendar systems and ISO8601 date and \ntime standards If you have a good understanding of these topics you may skip these sections and continue \nfrom the Exploring the DateTime API section\n Evolution of\u00a0Timekeeping\nA scale is used to measure the quantity of physical things such as length of a string in meters weight of a \nperson in pounds volume of water in liters etc Here meters pounds and liters are units of measurement \non a particular scale\nHow do we measure time Time is not a physical thing To measure time we link it to a periodic \nphysical phenomenon for example swinging of a pendulum rotation of Earth on its axis revolution of Earth \naround the sun oscillations of an electromagnetic signal associated with a quantum transition between two \nenergy levels in an atom etc Thus a time scale is an arrangement of events to define the duration of time\nIn ancient times events such as sunrise and sunset which are generated because of the rotation of \nEarth on its axis were used as a time scale the unit of the time scale was a day Duration between two \nconsecutive sunrises counted as 1 dayChapter 16  Dates an D\u00a0times\n541As human civilization progressed devices for timekeeping were developed Some of those were\n\t A sundial based on the position of the sun\n\t A mechanical clock based on periodic movement of a pendulum\n\t Finally an atomic clock based on the properties of the caesium133 atom\nA clock is a timekeeping device that consists of two components a frequency standard and a counter \nThe frequency standard in a clock is a component to obtain equally spaced periodic events to measure the \nlength of a desired time interval The counter also called an accumulator or adder counts the number of \noccurrences of the periodic event For example in a pendulum clock the occurrence of a complete cycle \nof a pendulum indicates a time interval of 1 second gears count the number of seconds and the face of the \nclock displays the time Even in ancient times there was the concept of twopart clocks for timekeeping The \nrotation of Earth provided the first component of the clock in terms of the periodic events of sunrise and \nsunset a calendar provided the second component of the clock to count days months and years\nBased on Earths rotation on its axis several time scales known as Universal Time UT have been \nused Earths motion around its axis and the sun is irregular Because of the irregularities in Earth motion \nthe length of the day from day to day and the number of the fractional days in a year from year to year vary \nA solar day also called an apparent or true solar day is the length of time measured by observing two \nconsecutive passes of the sun at noon local time If you use a perfect clock to observe the sun at a local \nmeridian at noon every day you would find that throughout the year the position of the sun in the sky \nvaries about four degrees about 16 minutes in time EastWest of the local meridian This implies that on a \nparticular day during a year there could be up to 16 minutes of difference between the time when it is noon \nshown by the clock and when the sun passes the local meridian The difference between the clock time and \nthe sun time which arises because of the tilt of the Earth rotation axis relative to its orbital plane and its \nelliptical orbit around the sun is known as the equation of time The time that is measured using the solar \nday is called apparent solar time\nThe time obtained by applying corrections to the solar time to account for the equation of time is known \nas Universal Time Zero UT0 or mean solar time Midnight at the prime meridian zero degree longitude \nwhich passes through Greenwich England is defined as 00 hours for UT0 The second is defined as 186400 \nof a mean solar day\nThe wobbling of Earth relative to its axis of rotation is known as polar motion UT0 corrected for polar \nmotion yields another time scale which is called UT1 Earths rotational speed is not uniform UT1 corrected \nfor the seasonal variation in the rotational speed of Earth yields another time scale which is called UT2\nThe irregular spin rate of Earth led to another time scale known as Ephemeris Time ET ET was based \non the period of one revolution of Earth around the sun and motion of other celestial bodies On ET scale \nthe ephemeris second was defined as the fraction 1315569259747 of the tropical year for 1900 January 0 at \n12 hours ephemeris time ET was replaced by Terrestrial Dynamical Time TDT and Barycentric Dynamical \nTime TDB in the early 1980s\nThe International Atomic Time also known as TAI for the French name Temps Atomique \nInternational scale is an atomic time scale The atomic second the unit of time in the TAI scale is defined \nas the duration of 9192631770 periods of the radiation corresponding to the transition between the two \nhyperfine levels of the ground state of the cesium133 atom In 1967 the definition of the atomic second \nbecame the definition of the International System of Units SI second The International Bureau of Weights \nand Measures BIPM is the official timekeeper of atomic time There are 65 laboratories with over 230 \natomic clocks contributing to the TAI scale Each clock contributing to TAI is assigned a weighting factor \nbased on its performance The weighted average of all the contributing atomic clocks gives TAI\nWhy do we use many atomic clocks to measure TAI One clock may fail and stop measuring time \nEven atomic clocks are affected by environmental changes To avoid such failures and inaccuracies several \natomic clocks are used to track TAIChapter 16  Dates an D\u00a0times\n542On January 1 1972 Coordinated Universal Time UTC was adopted as the official time scale for the \nworld for all civil purposes UTC and atomic clocks run at the same rate As BIPM counts the seconds on the \nTAI scale astronomers continue to measure time using the rotation of Earth on its axis Astronomical time is \ncompared to UTC and if they differ by more than 09 seconds a leap second is added to or subtracted from \nUTC to keep the time scales UT0 and UTC as close as possible The International Earth Rotation Service \nIERS makes the decision to introduce a leap second to UTC\nAt any time UTC differs from TAI by an integral number of seconds The relation between UTC and TAI \nmay be given as follows\nUTC  TAI   algebraic sum of leap seconds\nAs of August 2021 37 leap seconds have been added to UTC\u00a0So far no leap second has been subtracted \nfrom UTC\u00a0Therefore in August 2021 and until another leap second is introduced UTC and TAI are related \nas follows\nUTC  TAI   37\nYou might think because we have been adding leap seconds to UTC UTC should be ahead of TAI \nThat is not true Adding a leap second to UTC makes that hour on UTC scale 61 seconds long instead of 60 \nseconds TAI is a continuous time scale it keeps ticking all the time When UTC completes the 61st second of \nthe hour TAI has moved to the first second in the next hour Thus UTC lags TAI when a leap second is added \nto it Similar logic but in reverse order applies when a leap second is subtracted from UTC\u00a0If at any time \nin the future the leap seconds added to and subtracted from UTC become equal UTC and TAI will read the \nsame time\nUTC represents the time of day at the prime meridian zero degree longitude on Earth which passes \nthrough Greenwich England UTC is based on a 24hour clock with the day starting at 00 hours midnight \nUTC is also known as Zulu time The ISO8601 standard uses the letter Z as the UTC of day designator for \nexample the UTC of day 19 minutes and 23 seconds past 15 hours is written as 151923Z\nYoure not done with UTC yet We discuss two more versions of UTC Simplified UTC and UTC with \nSmoothed Leap Seconds UTCSLS\nHumans are used to understanding a solar day in terms of a 24hour period each hour consisting of 60 \nminutes and each minute consisting of 60 seconds A solar day consists of 86400 seconds On the UTC scale \na solar day may also consist of 86399 or 86401 seconds because of a leap second For easier understanding \nfor the common user most computer systems ignore the leap seconds on the UTC scale The UTC scale that \nignores the leap seconds is called a simplified UTC scale\n Ti p t o meet the expecta tions of most users the new Java Date time api uses simplified U tC where leap \nseconds are ignored making all days have the same number of 86400 seconds\nWhen a leap second is added to or subtracted from UTC it creates a gap or overlap of 1 second in the \ntime scale at the end of the day UTCSLS is a proposed standard for handling a UTC leap second Instead \nof introducing a leap second at the end of a day UTCSLS proposes to perform a smooth adjustment of 1 \nsecond over the last 1000 seconds of the day by changing the rate of the clock by 01 On a day when a leap \nsecond is added to UTC UTCSLS will make the last 1000 seconds of that day 1001 milliseconds long thus \nreducing the rate of the UTCSLS clock from 234321 to 240000 by 01 On a day when a leap second is \nadded to UTC UTCSLS will make the last 1000 seconds of that day as 999 milliseconds long thus increasing \nthe rate of the UTCSLS clock from 234319 to 240000 by 01\nFinally there are proposals to have universal and monotonous civil time by getting rid of the leap \nseconds from UTC\u00a0Some have also proposed to replace the UTC leap seconds by leap hoursChapter 16  Dates an D\u00a0times\n543 Time Zones and\u00a0Daylight Savings Time\nWhen it was midnight of April 20 2021 UTC what local time was it in New Delhi India and Chicago USA \nIt was 530\u00a0in the morning of April 20 2021 in New Delhi India and 700\u00a0in the evening of April 19 2021 in \nChicago USA\u00a0How do we determine local time at a place Wouldnt it be nice to have only one time for the \nentire world If it is midnight UTC it is midnight everywhere in the world Maybe this would have been a \ngood idea in the past as human minds are capable of getting used to new ideas over time through practice \nLocal time in a region is set such that a day starts at 00 hours which is midnight Therefore 00 hours is \nmidnight in New Delhi as well as Chicago\nGeographically the world may be divided into 24 longitudinal bands each covering a 15degree range \nof longitude starting at the prime meridian each band represents a 1hour time zone The area covered by a \ntime zone will observe the same time\nHumans are divided more politically than geographically In this world our political differences always \noverride the geographical similarity Sometimes an imaginary border separating two countries or states \nmakes people observe different times on each side of the border\nIn practice time zones have been divided based on political regions countries and regions within \ncountries Local time in each time zone is an offset from UTC\u00a0The offset the difference in UTC and local \ntime in a time zone is called a zone offset The regions east of the prime meridian use a positive zone offset \nA negative zone offset is used for regions west of the prime meridian The zone offset is expressed in hours \nand minutes such as 530 hours 1000 hours etc For example India uses a zone offset of 530 hours \ntherefore you can add 5 hours and 30 minutes to UTC to get Indian local time You may think that the value \nfor a zone offset is fixed for a time zone Alas if only we the civilized and advanced humans were so simple \nin timekeeping\nSome countries have more than one time zone For example USA has five time zones Alaska Pacific \nMountain Central and Eastern India has only one time zone In the USA when the local time in Mobile \nAlabama Central time zone is 700 AM it is 500 AM local time in Los Angeles California Pacific time \nzone Every part of India because of only one time zone observes the same time\nThe zone offset for some time zones varies in a year For example in Chicago USA called Central time \nzone the zone offset is 500 hours in summer and 600 hours in winter Most countries use a fixed zone \noffset For example India uses a 530 hours fixed zone offset The rules for a time zone governing the time \nwhen the zone offset changes and by how much it changes are decided by the government These rules are \nknown as time zone rules\nThe zone offset ranges between 1400 hours to 1200 hours If there are only 24 hours in a day how do \nwe have 14 as a zone offset The range 14 to 12 makes it a 26hour day Note that some countries consist \nof several small islands situated far apart on two sides of the International Date Line making them a day \napart This posed problems in official communication among the islands of these countries as they observed \nonly four common weekdays They extended the zone offset beyond 1200 thus moving the International \nDate Line for their country to keep the whole country on one side of the International Date Line Examples \nof countries using 1300 and 1400 hours of zone offsets are Kiribati pronounced kirbas Samoa and \nTokelau\nDaylight Savings Time is used to make better use of the daylight in the evening by moving the clocks \nforward usually by 1 hour in spring Clocks are set back by the same amount of time in fall The period of \nthe year during which DST is observed is called summer the other part of the year is called winter Not all \ncountries observe DST\u00a0The government of a country decides whether the country or only some locations \nwithin a country observes DST if it does the government decides the dates and times to move the clocks \nforward and backward For example zones observing DST in the USA moved the clocks 1 hour forward at \n200 AM local time on March 11 2021 thus creating a gap of 1 hour Note that on March 11 2021 the local \ntime between 200 AM and 300 AM did not exist in those zones in the USA\u00a0In fall when clocks are moved \nback a time overlap of the equal amount is created India and Thailand are two among several countries that \ndo not observe DST\u00a0DST changes the zone offset of the DSTobserving locations from UTC twice a yearChapter 16  Dates an D\u00a0times\n544 Calendar Systems\nHumans use calendars to work with time The time units used in calendars are year month day hour \nminute and second In this sense a calendar is a system of tracking time past and future for humans in a \nmeaningful way for social political legal religious and other purposes\nTypically a calendar system does not keep track of the time of day it works in terms of day month \nand year Broadly speaking in a calendar a day is based on the rotation of Earth on its axis a month on the \nrevolution of the moon around Earth and a year on the revolution of Earth around the sun Sometimes a \ncalendar system is based on weeks which is based on a nonastronomical cycle\nThroughout the history of humankind different civilizations have been known to use different calendar \nsystems Most of the ancient calendar systems have been based on astronomical cycles generated by solar \nmotion lunar motion or both thus giving rise to three types of calendric systems solar lunar and lunisolar \ncalendars\nA solar calendar is designed to align with a tropical year also called a solar year which is the mean \ninterval between the vernal equinoxes An equinox occurs twice a year when the center of the sun is in \nthe same plane as the equator of Earth The term equinox means equal night on an equinox day and \nnight are almost of the same length A vernal equinox occurs during spring around March 21 an autumnal \nequinox occurs during autumn around September 22 The Gregorian calendar which is the most used \ncalendar worldwide for civil purposes is an example of a solar calendar\nA lunar calendar is based on the lunar phase cycle It is not aligned to a tropical year In a year it drifts \nby 1112 days from a tropical year A lunar calendar takes about 33 years to catch up with a tropical year to \ndrift again for another 33 years A lunar month which is also called a synodic month is the interval of time \nbetween new moons that is equal to 29 days 12 hours 44 minutes and 28 seconds The Islamic calendar is \nan example of a lunar calendar\nA lunisolar calendar computes months based on the lunar phase cycle like a lunar calendar However \nit intercalates in a 2year or 3year period a month to keep itself aligned with a tropical year The Buddhist \nHindu Chinese and Hebrew calendars are some examples of lunisolar calendars\n The Julian Calendar\nThe Julian calendar is a solar calendar introduced in the year 45 by Julius Caesar It was widely used by the \nEuropean civilization until year 1582 when the Gregorian calendar was introduced\nAn ordinary year consists of 365 days Every 4 years a day is intercalated between February 28 and \nMarch 1 which is designated as February 29 to make the year 366 days which is called a leap year The year \n0 1 BC is considered a leap year The average length of a Julian calendar year is 36525 days that is close to \nthe length of a tropical year known in those days\nA year consists of 12 months Months are fixed in lengths Table\u00a0 161  lists the order and name of and \nnumber of days in months in the Julian calendar\nTable 161  Order  Name and Number of Days in Months in the \nJulian and Gregorian Calendar\nOrder Month Name Number of Days\n1 January 31\n2 February 28 29\u00a0in a leap year\n3 March 31\n4 April 30\ncontinued Chapter 16  Dates an D\u00a0times\n545 The Gregorian Calendar\nThe Gregorian calendar is the most widely used calendar in the world for civil purposes It follows the rules \nof the Julian calendar for number of months in a year and number of days in months However it changed \nthe rule for computing a leap year a year is a leap year if it is exactly divisible by 4 A year exactly divisible by \n100 is not a leap year unless it is also divisible by 400\nFor example 4 8 12 400 and 800 are known as leap years and 1 2 3 5 300 and 100 are known as \ncommon years Year 0 1 BC is considered a leap year With a new definition of a leap year the average \nlength of a year in the Gregorian calendar is 3652425 days which is very close to the length of a tropical year \nThe Gregorian calendar repeats every 400 years If you save your paper calendar for 2014 your nth great\ngrandchildren will be able to reuse it in the year 2414\nThe Gregorian calendar was introduced on Friday October 15 1582 The day before the Gregorian \ncalendar started it was Thursday October 4 1582 according to the existing Julian calendar Note that the \nintroduction of the Gregorian calendar left the cycle of weekdays unaffected however it left a discontinuity \nof 10 days between the two calendars that is called the cutover Dates before the cutover are Julian dates \ndates after the cutover are Gregorian dates and dates during the cutover do not exist\nThe Gregorian calendar did not exist before October 15 1582 How do we assign dates to the events \nbefore the start of the Gregorian calendar The Gregorian calendar applied to the dates when it was not in \neffect is called a proleptic Gregorian calendar Therefore October 14 1582 exists in a proleptic Gregorian \ncalendar which is the same as October 4 1582 in the Julian calendar\nWhy was the first day of the Gregorian calendar Friday October 15 1582 and not Friday October 5 \n1582 According to Doggett Calendars  nd in the Julian calendar the date of Easter a Christian festival \nwas computed based on an assumption that March 21 is the date for vernal equinox Later it was realized \nthat the vernal equinox had been drifting from March 21 hence the date of Easter drifts from the seasonal \nspringtime To keep the date of Easter synchronized with springtime the adjustment of 10 days was \nmade in the start date of the Gregorian calendar so the vernal equinox in the year 1583 and later occurs \napproximately on March 21\n Ti p t he main difference between the Julian and Gregorian calendars is the rule for determining a leap year \nthe mean length of a year in the Gregorian calendar is closer to the length of the tropical year than that of in the \nJulian calendarOrder Month Name Number of Days\n5 May 31\n6 June 30\n7 July 31\n8 August 31\n9 September 30\n10 October 31\n11 November 30\n12 December 31Table 161  continuedChapter 16  Dates an D\u00a0times\n546 ISO8601 Standards for\u00a0Datetime\nThe new DateTime API has extensive support for ISO8601 standards This section is intended to present \na brief and limited overview of the datetime components and their textual representations included in the \nISO8601 standards A datetime in ISO8601 consists of three components date time and zone offset that \nare combined in the following format\ndateTtimezone offset\nA date component consists of three calendar fields year month and day Two fields in a date are \nseparated by a hyphen\nyearmonthday\nFor example 20210430 represents the 30th day in April of 2021\nSometimes humans deal with dates that may not contain complete information to identify a specific \nday in a calendar For example December 25 makes sense as a Christmas day without specifying the year \npart of the date To identify a specific Christmas day in a calendar we must also specify the year A date with \nsome missing parts is known as a partial 2021 202105 0529 etc are examples of partials ISO8601 \nallows omitting parts in a date only from the right end That is it allows omitting day or month and day The \nDateTime API allows three types of partials year yearmonth and monthday\nDate and time components are separated by a T character A time component consists of fields hour \nminute and second A colon separates two fields in a time component A time is represented in this format\nhourminutesecond\nISO8601 uses a 24hour timekeeping system The hour element can be between 00 and 24 The hour \n24 is used to denote the end of a calendar day The value for the minute element ranges from 00 to 59 The \nsecond element may range from 00 to 60 The value 60 for the second element indicates a positive leap \nsecond For example 152056 represents a local time of 20 minutes and 56 seconds past 15 hours after \nmidnight When reduced accuracy is allowed second or second and minute elements may be omitted from \na time For example 1519 denotes 19 minutes past 15 hours and 07 denotes 07 hours from midnight\nMidnight is the start of a calendar day It is represented by 000000 or 0000 The start of a calendar \nday coincides with the end of the previous calendar day Therefore midnight of a calendar day may also be \nrepresented by 240000 or 2400\nWhen a date time or datetime is specified without a zone offset it is considered a local date time or \ndatetime respectively Examples of a local date time and datetime are 20210501 135205 and 202105\n01T135205 respectively\nUsing a zone offset you can represent a time component relative to UTC of day The zone offset \nrepresents a fixed difference between a local time and UTC\u00a0It starts with a plus or minus sign  or  \nfollowed by hour and minute elements which are separated by a colon Some examples of zone offset are \n0530 0600 1000 530 etc The character Z is used as a zone offset designator to denote the UTC time \nof day For example 102040Z represents the UTC of day 20 minutes and 40 seconds past 10\u00a0in the morning \n122040200 represents a local time of day 20 minutes and 40 seconds past 12\u00a0in the afternoon which is 2 \nhours ahead of UTC\u00a0Both times 102040Z and 122040200 represent the same point in time\n Ti p is O8601 specifies standards for using a fixed zone offset from the U tC component in time \nrepresentation recall that a zone offset may vary for time zones that observe Daylight savings time in addition \nto isO8601 standards the Date time api supports a variable zone offset as wellChapter 16  Dates an D\u00a0times\n547An example of a datetime having all three components fully specified is the following\n20210501T1630000600\nThis datetime represents May 1 2021 30 minutes past 16 hours from midnight that is 6 hours behind \nUTC\nISO8601 includes standards for several other date and timerelated concepts such as instant duration \nperiod time interval etc The DateTime API provides classes whose objects directly represent most but not \nall ISO date and time concepts\nThe toString  methods of all date and time classes in the DateTime API return a textual \nrepresentation of date and time in ISO formats The API includes classes to let you format a date and time in \nnonISO formats\nThe ISO standards include formats for specifying an amount of time known as duration ISO8601 \ndefines duration as a nonnegative quantity However the DateTime API also allows a negative quantity \ntreated as duration The ISO format for representing duration is as follows\nPnnYnnMnnDTnnHnnMnnS\nIn this format P is a duration designator nn denotes a number Y M D H M and S denote year month \nday hour month and second respectively and T is a time designator that is present only if the duration \ninvolves hour minute and second The following are examples of textual representations of some durations \nInline comments describe the duration\nP12Y       A duration of 12 years\nPT1530    A duration of 15 hours and 30 minutes\nPT20S      A duration of 20 seconds\nP4Y2MT30M  A duration of 4 years 2 months and 30 minutes\n Tip the Da tetime api provides Duration  and Period  classes to deal with an amount of time a \nDuration  represents an amount of time on the machinescale timeline a Period  represents an amount of \ntime on a humanscale timeline\n Exploring the\u00a0DateTime API\nAt first exploring the DateTime API is intimidating as it contains many classes with numerous methods \nLearning the naming convention of methods will help understand the API tremendously The DateTime \nAPI has been designed carefully to keep the names of classes and their methods consistent and intuitive \nMethods starting with the same prefix do similar work For example an of  method in a class is used as a \nstatic factory method to create an object of that class\nAll classes interfaces and enums for the DateTime API are in the javatime  package and four of its \nsubpackages as listed in Table\u00a0 162 Chapter 16  Dates an D\u00a0times\n548The following sections explain the prefixes used in method names in the DateTime API with their \nmeanings and examples\n The ofXxx Methods\nClasses in the DateTime API do not provide public constructors to create their objects They let you \ncreate objects through static factory methods named of or  ofXxx where Xxx is replaced by a \ndescription of the parameters  The following snippet of code shows how to create objects of the \nLocalDate  class\nLocalDate ld1  LocalDateof2021 5 2            20210502\nLocalDate ld2  LocalDateof2021 MonthJULY 4  20210704\nLocalDate ld3  LocalDateofEpochDay2002          19750626\nLocalDate ld4  LocalDateofYearDay2014 40       20140209\n The from Methods\nA from  method is a static factory method similar to an of  method that is used to derive a datetime \nobject from the specified argument Unlike an of  method a from  method requires data conversion on \nthe specified argument\nTo understand what a from  method does think of it named as a deriveFrom  method Using a \nfrom  method you derive a new datetime object from the specified argument The following snippet of \ncode shows how to derive a LocalDate  from a LocalDateTime \nLocalDateTime ldt  LocalDateTimeof2021 5 2 15 30  20210502T1530\nLocalDate ld  LocalDatefromldt                         20210502\n The withXxx Methods\nMost classes in the DateTime API are immutable They do not have setXxx  methods If you want to \nchange a field of a datetime object for example the year value in a date you need to look for a method with \na prefix  with   A withXxx  method returns a copy of the object with the specified field changedTable 162  Packages and Subpackages of the DateTime API\nPackage Description\njavatime Contains frequently used classes The LocalDate  LocalTime  LocalDateTime  \nZonedDateTime  Period  Duration  and Instant  classes are in this package \nClasses in this package are based on ISO standards\njavatimechrono Contains classes supporting nonISO calendar systems for example Hijrah \ncalendar Thai Buddhist calendar etc\njavatimeformat Contains classes for formatting and parsing dates and times\njavatimetemporal Contains classes for accessing components of dates and times It also contains \nclasses that act like datetime adjusters\njavatimezone Contains classes supporting time zones and zone rulesChapter 16  Dates an D\u00a0times\n549Assume that you have a LocalDate  object and you want to change its year You need to use the \nwithYearint newYear  method of the LocalDate  class The following snippet of code shows how to obtain \na LocalDate  from another LocalDate  with the year changed\nLocalDate ld1  LocalDateof2021 MonthMAY 2  20210502\nLocalDate ld2  ld1withYear2014                 20140502\nYou can obtain a new LocalDate  from an existing LocalDate  by changing multiple fields by chaining the \nwithXxx  method calls The following snippet of code creates a new LocalDate  from an existing LocalDate  \nby changing the year and month\nLocalDate ld3  LocalDateof2021 5 2  20210502\nLocalDate ld4  ld3withYear2024\n                   withMonth7           20240702\n The getXxx Methods\nA getXxx  method returns the specified element of the object For example the getYear  method in \nthe LocalDate  class returns the year part of the date The following snippet of code shows how to get year \nmonth and day from a LocalDate  object\nLocalDate ld  LocalDateof2021 5 2\nint year  ldgetYear         2021\nMonth month  ldgetMonth     MonthMAY\nint day  ldgetDayOfMonth    2\n The toXxx Methods\nA toXxx  method converts an object to a related Xxx type For example the toLocalDate  method in the \nLocalDateTime  class returns a LocalDate  object with the date in the original LocalDateTime  object Here are \nsome examples of using toXxx  methods\nLocalDate ld  LocalDateof2021 8 29  20210829\n Convert the date to epoch days The epoch days is the number of days from\n 19700101 to a date A date before 19700101 returns a negative integer\nlong epochDays  ldtoEpochDay           18868\n Convert a LocalDateTime to a LocalTime using the toLocalTime method\nLocalDateTime ldt  LocalDateTimeof2021 8 29 16 30\nLocalTime lt  ldttoLocalTime           1630\n The atXxx Methods\nAn atXxx  method lets you build a new datetime object from an existing datetime object by supplying some \nadditional pieces of information Contrast the use of an atXxx  method with that of a withXxx  method \nthe former lets you create a new type of object by providing additional information whereas the latter lets \nyou create a copy of an object by changing its fieldsChapter 16  Dates an D\u00a0times\n550Suppose you have the date 20210502 If you want to create a new date of 20210702 with month \nchanged to 7 you would use a withXxx  method If you want to create a datetime of 20210502T1530 \nby adding time 1530 you would use an atXxx  method Some examples of using atXxx  methods are \nshown here\nLocalDate ld  LocalDateof2021 5 2    20210502\nLocalDateTime ldt1  ldatStartOfDay     20210502T0000\nLocalDateTime ldt2  ldatTime15 30     20210502T1530\nThe atXxx  methods support the builder pattern The following snippet of code shows how to use a \nbuilder pattern to build a local date\n Use a builder pattern to build a date 20210522\nLocalDate d1  Yearof2021atMonth5atDay22\n Use an of factory method to build a date 20210522\nLocalDate d2  LocalDateof2021 5 22\n The plusXxx and\u00a0minusXxx Methods\nA plusXxx  method returns a copy of an object by adding a specified value For example the \nplusDayslong days  method in the LocalDate  class returns a copy of the LocalDate  object by adding the \nspecified number of days\nA minusXxx  method returns a copy of an object by subtracting a specified value For example the \nminusDayslong days  method in the LocalDate  class returns a copy of the LocalDate  object by subtracting \nthe specified number of days\nLocalDate ld  LocalDateof2021 5 2  20210502\nLocalDate ld1  ldplusDays5            20210507\nLocalDate ld2  ldplusMonths3          20210802\nLocalDate ld3  ldplusWeeks3           20210523\nLocalDate ld4  ldminusMonths7        20111002\nLocalDate ld5  ldminusWeeks3          20210411\n The multipliedBy dividedBy and\u00a0negated Methods\nMultiplication division and negation do not make sense on dates and times They are applicable to the \ndatetime types that denote an amount of time such as Duration  and Period  Durations and periods can be \nadded and subtracted The DateTime API supports negative durations and periods\nDuration d  DurationofSeconds200  PT3M20S 3 minutes and 20 seconds\nDuration d1  dmultipliedBy2        PT6M40S 6 minutes and 40 seconds\nDuration d2  dnegated              PT3M20S 3 minutes and 20 seconds\n Instants and\u00a0Durations\nA timeline or a time axis is a mathematical representation of the passage of time in terms of instantaneous \nevents along a unique axis A machinescale timeline represents the passage of time as a single incrementing \nnumber as shown in Figure\u00a0 161 Chapter 16  Dates an D\u00a0times\n551An instant is a point representing a unique moment in time on a timeline An epoch is an instant on a \ntimeline that is used as a reference point or the origin to measure other instants\nAn object of the Instant  class represents an instant on the timeline It uses a timeline to represent \nsimplified UTC to a nanosecond precision That is the time interval or duration between two consecutive \ninstants on the timeline is one nanosecond The timeline uses 19700101T000000Z as the epoch Instants \nafter the epoch have positive values instants before the epoch have negative values The instant at the epoch \nis assigned a zero value\nThere are different ways you can create an instance of the Instant  class Using its now  method you \ncan get the current instant using the system default clock\n Get the current instant\nInstant i1  Instantnow\nYou can obtain an instance of the Instant  class using an amount of time in different units from the \nepoch The following snippet of code creates an Instant  object to represent 19 seconds from the epoch \nwhich represents 19700101T000019Z\n An instant 19 seconds from the epoch\nInstant i2  InstantofEpochSecond19\nAn object of the Duration  class represents an amount of time between two instants on the timeline \nThe Duration  class supports a directed duration That is it allows a positive as well as negative duration \nFigure\u00a0 161  shows durations with arrows to signify that they are directed durations\nYou can create an instance of the Duration  class using one of its ofXxx  static factory methods\n A duration of 2 days\nDuration d1  DurationofDays2\n A duration of 25 minutes\nDuration d2  DurationofMinutes25\n Tip the toString  method of the instant c lass returns a textual representation of the Instant  in the \nisO8601 forma t yyyyMMddTHHmmssSSSSSSSSSZ  the toString  method of the Duration  class \nreturns a textual representation of the duration in PTnHnMnS  format where n is the number of hours minutes \nor secondsFigure 161  A timeline r epresenting the passage of machinescale timeChapter 16  Dates an D\u00a0times\n552What can you do with instants and durations Typically they are used for recording timestamps and \nelapsed time between two events Two instants can be compared to know whether one occurs before or \nafter the other You can add and subtract a duration to an instant to obtain another instant Adding two \ndurations results in another duration Classes in the DateTime API are Serializable  You can use Instant  \nto store timestamps in databases\nInstant  and Duration  classes store second and nanosecondofsecond parts of their values \nseparately The Duration  class has getSeconds  and getNano  methods whereas the Instant  class has \ngetEpochSecond  and getNano  methods to get the two values The following is an example of getting \nsecond and nanosecond of an Instant \n Get the current instant\nInstant i1  Instantnow\n Get seconds and nanoseconds\nlong seconds  i1getEpochSecond\nint nanoSeconds  i1getNano\nSystemoutprintlnCurrent Instant   i1\nSystemoutprintlnSeconds   seconds\nSystemoutprintlnNanoseconds   nanoSeconds\nYou may get a different output\nCurrent Instant 20210822T001242337685118Z\nSeconds 1629591162\nNanoseconds 337685118\nListing 163  demonstrates use of some operations that can be performed on instants and durations\nListing 163  Using Instant and Duration Classes\n InstantDurationTestjava\npackage comjdojodatetime\nimport javatimeDuration\nimport javatimeInstant\npublic class InstantDurationTest \n    public static void mainString args \n        Instant i1  InstantofEpochSecond20\n        Instant i2  InstantofEpochSecond55\n        Systemoutprintlni1  i1\n        Systemoutprintlni2  i2\n        Duration d1  DurationofSeconds55\n        Duration d2  DurationofSeconds17\n        Systemoutprintlnd1  d1\n        Systemoutprintlnd2  d2\n         Compare instants\n        Systemoutprintlni1isBeforei2  i1isBeforei2\n        Systemoutprintlni1isAfteri2  i1isAfteri2\n         Add and subtract durations to instants\n        Instant i3  i1plusd1\n        Instant i4  i2minusd2\n        Systemoutprintlni1plusd1  i3\n        Systemoutprintlni2minusd2  i4\n         Add two durationsChapter 16  Dates an D\u00a0times\n553        Duration d3  d1plusd2\n        Systemoutprintlnd1plusd2  d3\n    \n\ni119700101T000020Z\ni219700101T000055Z\nd1PT55S\nd2PT17S\ni1isBeforei2true\ni1isAfteri2false\ni1plusd119700101T000115Z\ni2minusd219700101T000112Z\nd1plusd2PT38S\nSeveral useful methods were added in Java 9 to the Duration  class that can be put into the following \nthree categories\n\t Methods to divide a duration by another duration\n\t Methods to get a duration in terms of a specific time unit and methods to get a \nspecific part of a duration such as days hours seconds etc\n\t Methods to truncate a duration to a specific time unit\nWe present examples of using these methods in the following sections In the examples we use a \nduration of 23 days 3 hours 45 minutes and 30 seconds The following snippet of code creates this as a \nDuration  object and stores its reference in a variable named compTime \n Create a duration of 23 days 3 hours 45 minutes and 30 seconds\nDuration compTime  DurationofDays23\n                            plusHours3\n                            plusMinutes45\n                            plusSeconds30\nSystemoutprintlnDuration   compTime\nDuration PT555H45M30S\nAfter the days are converted to hours by multiplying them by 24 as the output shows this duration \nrepresents 555 hours 45 minutes and 30 seconds\n Dividing a\u00a0Duration by Another Duration\nThere is only one method in this category\nlong dividedByDuration divisorChapter 16  Dates an D\u00a0times\n554The dividedBy  method lets you divide a duration by another duration It returns the number of times \nthe specific divisor  occurs within the duration on which the method is called To know how many whole \nweeks are in this duration you call the dividedBy  method using 7 days as the duration The following \nsnippet of code shows you how to compute number of whole days weeks and hours in a duration\nlong wholeDays  compTimedividedByDurationofDays1\nlong wholeWeeks  compTimedividedByDurationofDays7\nlong wholeHours  compTimedividedByDurationofHours7\nSystemoutprintlnNumber of whole days   wholeDays\nSystemoutprintlnNumber of whole weeks   wholeWeeks\nSystemoutprintlnNumber of whole hours   wholeHours\nNumber of whole days 23\nNumber of whole weeks 3\nNumber of whole hours 79\n Converting and\u00a0Retrieving Duration Parts\nThere are several methods in the Duration  class in this category\n\tlong toDaysPart\n\tlong toDays\n\tint toHoursPart\n\tlong toHours\n\tint toMillisPart\n\tlong toMillis\n\tint toMinutesPart\n\tlong toMinutes\n\tint toNanosPart\n\tlong toNanos\n\tint toSecondsPart\n\tlong toSeconds\nThe Duration  class contains two sets of methods They are named toXxx  and toXxxPart  where Xxx \nmay be Days  Hours  Minutes  Seconds  Millis  and Nanos \nMethods named toXxx  convert the duration to the Xxx time unit and return the whole part Methods \nnamed toXxxPart  break down the duration in parts as dayshoursminutessecondsmillisnanos  and \nreturn the Xxx part from it In this example toDays  will convert the duration to days and return the whole \npart which will be 23 The toDaysPart  will break down the duration to 23Days3Hours45Minutes30S\neconds0Millis0Nanos  and return the first part which is 23 Lets apply the same rules to toHours  and \ntoHoursPart  methods The toHours  method will convert the duration to hours and return the whole \nnumber of hours which will be 555 The toHoursPart  method will break the duration into parts and \nreturn the hours part which is 3 The following snippet of code shows you a few examplesChapter 16  Dates an D\u00a0times\n555SystemoutprintlntoDays   compTimetoDays\nSystemoutprintlntoDaysPart   compTimetoDaysPart\nSystemoutprintlntoHours   compTimetoHours\nSystemoutprintlntoHoursPart   compTimetoHoursPart\nSystemoutprintlntoMinutes   compTimetoMinutes\nSystemoutprintlntoMinutesPart   compTimetoMinutesPart\nDuration PT555H45M30S\ntoDays 23\ntoDaysPart 23\ntoHours 555\ntoHoursPart 3\ntoMinutes 33345\ntoMinutesPart 45\n Truncating a\u00a0Duration\nThere is only one method in the Duration  class in this category\nDuration truncatedToTemporalUnit unit\nThe truncatedTo  method returns a copy of the duration with conceptual time units smaller than the \nspecified unit  truncated The temporal unit specified must be DAYS  or smaller Specifying a temporal unit \ngreater than DAYS  such as WEEKS  and YEARS  throws a runtime exception\n Ti p a truncatedToTemporalUnit unit  method also exists in the LocalTime  and Instant  \nclasses\nThe following snippet of code shows you how to use this method\nSystemoutprintlnTruncated to DAYS   compTimetruncatedToChronoUnitDAYS\nSystemoutprintlnTruncated to HOURS   compTimetruncatedToChronoUnitHOURS\nSystemoutprintlnTruncated to MINUTES   compTimetruncatedToChronoUnitMINUTES\nTruncated to DAYS PT552H\nTruncated to HOURS PT555H\nTruncated to MINUTES PT555H45M\nThe duration is 23Days3Hours45Minutes30Seconds0Millis0Nanos  When you truncate this to \nDAYS  all parts smaller than days are dropped and it returns 23 days which is the same as 552 hours as \nshown in the output When you truncate to HOURS  it drops all parts smaller than hours and returns 555 \nhours Truncating it to MINUTES  keeps parts up to minutes and drops all smaller parts such as seconds and \nmillisecondsChapter 16  Dates an D\u00a0times\n556 HumanScale Time\nIn the previous section we discussed the use of Instant  and Duration  classes whose instances are more \nsuited to dealing with machinescale time Humans deal with time in terms of fields such as year month \nday hour minute and second Recall the following ISO8601 format for specifying date and time\ndateTtimezone offset\nThe DateTime API provides several classes listed in Table\u00a0 163  to represent all fields and their \ncombinations of humanscale time A Yes or No in the component column for a class indicates whether an \ninstance of the class stores that component or not We will discuss all of these classes in detail shortly\n The ZoneOffset Class\nAn instance of the ZoneOffset  class represents a fixed zone offset from UTC time zone for example 0530 \n0600 etc It is a period of time that a time zone differs from the UTC\u00a0A ZoneOffset  is not aware of the \nchanges in zone offset because of the observed Daylight Savings Time The ZoneOffset  class declares three \nconstants\n\tUTC\n\tMAX\n\tMIN\nUTC is the time zone offset constant for UTC MAX and MIN are the maximum and minimum supported \nzone offsets\n Tip Z  not 0000  or 0000  is used as the zone offset designator for the U tC time zone\nThe ZoneOffset  class provides methods to create its instances using a combination of hour minute \nand second Listing 164  demonstrates how to create instances of the ZoneOffset  classTable 163  Hum anScale Date and Time Classes and Their Components\nClass Name Date Time Zone Offset Zone Rule\nLocalDate Yes No No No\nLocalTime No Yes No No\nLocalDateTime Yes Yes No No\nOffsetTime No Yes Yes No\nOffsetDateTime Yes Yes Yes No\nZonedDateTime Yes Yes Yes Yes\nZoneOffset No No Yes No\nZoneId No No Yes YesChapter 16  Dates an D\u00a0times\n557Listing 164  Creating Instances of the ZoneOffset Class\n ZoneOffsetTestjava\npackage comjdojodatetime\nimport javatimeZoneOffset\npublic class ZoneOffsetTest \n    public static void mainString args \n         Create zone offset using hour minute and second\n        ZoneOffset zos1  ZoneOffsetofHours6\n        ZoneOffset zos2  ZoneOffsetofHoursMinutes5 30\n        ZoneOffset zos3  ZoneOffsetofHoursMinutesSeconds8 30 45\n        Systemoutprintlnzos1\n        Systemoutprintlnzos2\n        Systemoutprintlnzos3\n         Create zone offset using offset ID as a string\n        ZoneOffset zos4  ZoneOffsetof0500\n        ZoneOffset zos5  ZoneOffsetofZ  Same as ZoneOffsetUTC\n        Systemoutprintlnzos4\n        Systemoutprintlnzos5\n         Print the values for zone offset constants\n        SystemoutprintlnZoneOffsetUTC     ZoneOffsetUTC\n        SystemoutprintlnZoneOffsetMIN     ZoneOffsetMIN\n        SystemoutprintlnZoneOffsetMAX     ZoneOffsetMAX\n    \n\n0600\n0530\n083045\n0500\nZ\nZoneOffsetUTC Z\nZoneOffsetMIN 1800\nZoneOffsetMAX 1800\nAccording to ISO8601 standards a zone offset may include hours and minutes or hours only The new \nDateTime API also allows seconds in a zone offset You can use the compareTo  method of the ZoneOffset  \nclass to compare a zone offset to another zone offset Zone offsets are compared in descending order that is \nthe order in which they occur in the time of the day for example a zone offset of 530 occurs before a zone \noffset of 500 ISO8601 standards support zone offsets between 1200 and 1400 However to avoid  \nany problems in the future if the zone offset gets extended the DateTime API supports zone offsets  \nbetween 1800 and 1800\n The ZoneId Class\nAn instance of the ZoneId  class represents a combination of a zone offset and the rules for changing the zone \noffset for observed Daylight Savings Time Not all time zones observe Daylight Savings Time To simplify \nyour understanding about the ZoneId  you can think of it as follows\nZoneId  ZoneOffset  ZoneRulesChapter 16  Dates an D\u00a0times\n558 Tip a ZoneOffset  represents a fixed zone offset from U tC time zone  whereas a ZoneId  represents a \nvariable zone offset the varia tion the time in the year when the zone offset is changed and the amount of \nchange are all controlled by the time zone rules the ZoneOffset  class inherits from the ZoneId  class\nA time zone has a unique textual ID which can be specified in three formats\n\t In this format the zone ID is specified in terms of zone offset which can be in one of \nthe following formats h hh hhmm  hhmm  hhmm  hhmm  hhmmss  hhmmss  \nhhmmss  and hhmmss  where h m and s denote a single digit of hours minutes and \nseconds respectively Z is used for UTC\u00a0An example of a zone offset is 0600 \n\t In this format the zone ID is prefixed with UTC GMT or UT and followed by a zone \noffset for example UTC0600 \n\t In this format the zone ID is specified by using a region for example America\nChicago \nUsing the first two forms of zone IDs you create a ZoneId  with a fixed zone offset You can create a \nZoneId  using the of  factory method\nZoneId usChicago  ZoneIdofAmericaChicago\nZoneId bdDhaka  ZoneIdofAsiaDhaka\nZoneId fixedZoneId  ZoneIdof0600\nThe ZoneId  class provides access to all known time zone IDs Its getAvailableZoneIds  static method \nreturns a SetString  containing all available zone IDs Listing 165  shows how to print all zone IDs A \npartial list of zone IDs is shown in the output\nListing 165   Prin ting All Available Zone IDs\n PrintAllZoneIdsjava\npackage comjdojodatetime\nimport javatimeZoneId\nimport javautilSet\npublic class PrintAllZoneIds \n    public static void mainString args \n        SetString zoneIds  ZoneIdgetAvailableZoneIds\n        for String zoneId zoneIds \n             SystemoutprintlnzoneId\n        \n    \n\nAsiaAden\nAfricaCairo\nPacificHonolulu\nAmericaChicago\nEuropeAthens\nChapter 16  Dates an D\u00a0times\n559A ZoneId  object gives you access to zone rules for the time zone represented by the ZoneId  You can \nuse the getRules  method of the ZoneId  class to get an instance of the ZoneRules  class to work with rules \nsuch as transitions for Daylight Savings Time the zone offset for a specified datetime the amount of daylight \nsavings etc Typically you will not use zone rules directly in your code As a developer you would use a \nZoneId  to create a ZonedDateTime  which is discussed shortly The program in Listing 166  shows how to \nquery the ZoneRules  object to get information about the time offset and time changes for a ZoneId  The list \nof time transitions is very big and it is shown partially in the output\nListing 166  Kno wing the Time Change Rules the ZoneRules for a ZoneId\n ZoneRulesTestjava\npackage comjdojodatetime\nimport javatimeLocalDateTime\nimport javatimeZoneId\nimport javatimeZoneOffset\nimport javatimezoneZoneOffsetTransition\nimport javatimezoneZoneRules\nimport javautilList\npublic class ZoneRulesTest \n    public static void mainString args \n        LocalDateTime now  LocalDateTimenow\n        SystemoutprintlnCurrent Date Time   now\n        ZoneId fixedZoneId  ZoneIdof0600\n        ZoneId bdDhaka  ZoneIdofAsiaDhaka\n        ZoneId usChicago  ZoneIdofAmericaChicago\n         Print some zone rules for ZoneIds\n        printDetailsfixedZoneId now\n        printDetailsbdDhaka now\n        printDetailsusChicago now\n    \n    public static void printDetailsZoneId zoneId LocalDateTime now \n        SystemoutprintlnZone ID   zoneIdgetId\n        ZoneRules rules  zoneIdgetRules\n        boolean isFixedOffset  rulesisFixedOffset\n        SystemoutprintlnisFixedOffset   isFixedOffset\n        ZoneOffset offset  rulesgetOffsetnow\n        SystemoutprintlnZone offset   offset\n        ListZoneOffsetTransition transitions  rulesgetTransitions\n        Systemoutprintlntransitions\n    \n\nCurrent Date Time 20210820T201008836642261\nZone ID 0600\nisFixedOffset true\nZone offset 0600\n\nZone ID AsiaDhaka\nisFixedOffset false\nZone offset 0600Chapter 16  Dates an D\u00a0times\n560TransitionOverlap at 18900101T0000060140 to 055320  TransitionOverlap at \n20100101T00000700 to 0600\nZone ID AmericaChicago\nisFixedOffset false\nZone offset 0500\nTransitionOverlap at 18831118T120924055036 to 0600  TransitionOverlap at \n20081102T02000500 to 0600\nSeveral organizations and groups provide a set of time zone rules as a database that contains the code \nand data for all time zones in the world Each provider is given a unique group ID\u00a0One of the standard rules \nproviders is a TZ database that is identified by a TZDB group ID\u00a0Refer to wwwtwinsuncomtztz  linkhtm  \nfor more details on the TZ database\nAs the rules for a time zone change over time a group provides multiple versions of rules data for \ndifferent regions Typically a region represents a time zone where the time zone rules are the same Each \ngroup has its own naming scheme for the versions and regions\nThe TZDB stores region names in a areacity  format Examples of some region names are Africa\nTunis AmericaChicago AsiaKolkata AsiaTokyo EuropeIstanbul EuropeLondon and EuropeMoscow\nThe DateTime API uses the TZDB as the default time zone rules provider If you are using a region\nbased zone ID from the TZDB use the region name as the zone ID\u00a0The region name should be prefixed \nwith the group ID of the provider in the form of groupregion if a group other than the TZDB is used for \nzone rules For example if you are using the International Air Transport Association IATA provider use \nIATACHI for the Chicago region Refer to the ZoneRulesProvider  class in the javatimezone  package \nfor more details on how to register your own zone rules provider\n Useful DatetimeRelated Enums\nBefore we discuss classes that represent different combinations of date and time it is worth discussing some \nenums representing constants for date and time components\n\tMonth\n\tDayOfWeek\n\tChronoField\n\tChronoUnit\nMost of the time you will use the constants in these enums directly as arguments to methods or receive \nthem as return values from methods Some enums include methods to compute useful date time values \nusing the constant itself as input\n Representing Months\nThe Month  enum has 12 constants to represent the 12 months of the year The constant names are JANUARY  \nFEBRUARY  MARCH  APRIL  MAY JUNE  JULY  AUGUST  SEPTEMBER  OCTOBER  NOVEMBER  and DECEMBER  Months are \nnumbered sequentially from 1 to 12 January being 1 and December being 12 The Month enum provides \nsome useful methods such as of  to get an instance of Month  from an int value  from  to get the Month  \nfrom any date object getValue  to get the int value of the Month  etcChapter 16  Dates an D\u00a0times\n561For better readability use an enum constant if and when available in the DateTime API instead of an \ninteger value For example for the month of July use MonthJULY  in your code not integer 7 Sometimes the \nAPI provides two versions of a method one takes the Month  enum argument and another the int value of the \nmonth An example of such methods is the static factory method of  in the LocalDate  class\n\tstatic LocalDate ofint year int month int dayOfMonth\n\tstatic LocalDate ofint year Month month int dayOfMonth\nListing 167  demonstrates some uses of the Month  enum\nListing 167  Using the Month Enum\n MonthTestjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeMonth\npublic class MonthTest \n    public static void mainString args \n         Use MonthJULY as a method argument\n        LocalDate ld1  LocalDateof2021 MonthJULY 1\n         Derive a Month from a local date\n        Month m1  Monthfromld1\n         Create a Month from an int value 2\n        Month m2  Monthof2\n         Get the next month from m2\n        Month m3  m2plus1\n         Get the Month from a local date\n        Month m4  ld1getMonth\n         Convert an enum constant to an int\n        int m5  m2getValue\n        Systemoutformats s s s dn m1 m2 m3 m4 m5\n    \n\nJULY FEBRUARY MARCH JULY 2\n Representing the\u00a0Day of\u00a0the\u00a0Week\nThe DayOfWeek  enum has seven constants to represent seven days of the week The constants are MONDAY  \nTUESDAY  WEDNESDAY  THURSDAY  FRIDAY  SATURDAY  and SUNDAY  Its getValue  method returns an int value \n1 for Monday 2 for Tuesday and so on which follows ISO8601 standards The DayOfWeek  enum is in the \njavatime  package Here are some examples of using the DayOfWeek  enum and its methods\nLocalDate ld  LocalDateof2021 5 10\n Extract the dayofweek from a LocalDate\nDayOfWeek dw1  DayOfWeekfromld  THURSDAY\n Get the int value of the dayofweek\nint dw11  dw1getValue            4\n Use the method of the LocalDate class to get dayofweek\nDayOfWeek dw12  ldgetDayOfWeek  THURSDAYChapter 16  Dates an D\u00a0times\n562 Obtain a DayOfWeek instance using an int value\nDayOfWeek dw2  DayOfWeekof7      SUNDAY\n Add one day to the dayofweek to get the next day\nDayOfWeek dw3  dw2plus1          MONDAY\n Get the dayofweek two days ago\nDayOfWeek dw4  dw2minus2         FRIDAY\n Representing Datetime Fields\nMost fields in datetime can be represented as a numeric value for example year month day hour etc An \ninstance of the TemporalField  interface represents a field of datetime for example year month of year \nminutes of hour etc The ChronoField  enum implements the TemporalField  interface and provides several \nconstants to represent datetime fields The ChronoField  enum contains a long list of constants Some of \nthem are as follows AMPMOFDAY  CLOCKHOUROFAMPM  CLOCKHOUROFDAY  DAYOFMONTH  DAYOFWEEK  \nDAYOFYEAR  ERA HOUROFAMPM  HOUROFDAY  INSTANTSECONDS  MINUTEOFHOUR  MONTHOFYEAR  \nSECONDOFMINUTE  YEAR  and YEAROFERA \nTypically you use a TemporalField  to get the value of the field from a datetime All datetime classes \nhave a get  method that returns an int value for the specified TemporalField  If the value for a field is \npotentially too large to be stored in an int use the companion getLong  method to get the value in a long \nNot all datetime classes support all types of fields For example a LocalDate  does not support the \nMINUTEOFHOUR  field Use the isSupported  method of the datetime classes to check whether they support \na specific type of field Use the isSupportedBy  method of ChronoField  to check if a field is supported by a \ndatetime class\n Ti p Constants for some da tetime fields that are specific to the isO8601 calendar system are declared in \nthe IsoFields  class For example IsoFieldsDAYOFQUARTER  represents isO8601based day of quarter\nThe following snippet of code demonstrates how to use a ChronoField  to extract a field value from a \ndatetime and whether the datetime supports the field\nimport javatimeLocalDate\nimport javatimeLocalDateTime\nimport javatimetemporalChronoField\n\nLocalDateTime now  LocalDateTimenow\nSystemoutprintlnCurrent Date Time   now\nSystemoutprintlnYear   nowgetChronoFieldYEAR\nSystemoutprintlnMonth   nowgetChronoFieldMONTHOFYEAR\nSystemoutprintlnDay   nowgetChronoFieldDAYOFMONTH\nSystemoutprintlnHourofday   nowgetChronoFieldHOUROFDAY\nSystemoutprintlnHourofAMPM   nowgetChronoFieldHOUROFAMPM\nSystemoutprintlnAMPMofday   nowgetChronoFieldAMPMOFDAY\nLocalDate today  LocalDatenow\nSystemoutprintlnCurrent Date    today\nSystemoutprintlnLocalDate supports year   todayisSupportedChronoFieldYEAR\nSystemoutprintln\nLocalDate supports hourofday   todayisSupportedChronoFieldHOUROFDAY\nSystemoutprintlnYear is supported by LocalDate   ChronoFieldYEARisSupportedBytodayChapter 16  Dates an D\u00a0times\n563Systemoutprintln\nHourofday is supported by LocalDate   ChronoFieldHOUROFDAYisSupportedBytoday\nCurrent Date Time 20210820T201125739544947\nYear 2021\nMonth 8\nDay 20\nHourofday 20\nHourofAMPM 8\nAMPMofday 1\nCurrent Date  20210820\nLocalDate supports year true\nLocalDate supports hourofday false\nYear is supported by LocalDate true\nHourofday is supported by LocalDate false\nThe value for the AMPMOFDAY  field can be 0 or 1 0 indicates AM and 1 indicates PM\n Representing the\u00a0Units of\u00a0Datetime Fields\nTime is measured in units such as years months days hours minutes seconds weeks etc An instance of \nthe TemporalUnit  interface in the javatimetemporal  package represents a unit of time The ChronoUnit  \nin the same package contains the following constants to represent units of time CENTURIES  DAYS  DECADES  \nERAS  FOREVER  HALFDAYS  HOURS  MICROS  MILLENNIA  MILLIS  MINUTES  MONTHS  NANOS  SECONDS  WEEKS  and \nYEARS \nThe ChronoUnit  enum implements the TemporalUnit  interface Therefore all constants in the enum are \nan instance of the TemporalUnit \n Ti p Constants for some da tetime units that are specific to the isO8601 calendar system are declared in \nthe IsoFields  class For example IsoFieldsQUARTERYEARS  and IsoFieldsWEEKBASEDYEARS  \nrepresent isO8601based quarteryear 3 months and weekbased year 52 or 53 weeks respectively the \nisO8601 standard considers a 7day period as a week a week starts on a monday the first calendar week of \nthe year is the one that includes the first thursday of the year the first week of a year may start in the previous \nyear and the last week of a year may end in the succeeding year this may result in 53 weeks in a year For \nexample the first week of 2009 started on December 29 2008 and the last week on December 29 2009 \nmaking 2009 a 53week year\nDatetime classes provide two methods minus  and plus  They take an amount of time and the unit \nof time to return a new datetime by subtracting and adding the specified time Convenience methods such \nas minusDays  minusHours  plusDays  plusHours  etc are also provided by the applicable classes to \nsubtract and add time The following snippet of code illustrates the use of the ChronoUnit  enum constants \nwith these methods\nimport javatimeLocalDateTime\nimport javatimetemporalChronoUnit\nChapter 16  Dates an D\u00a0times\n564LocalDateTime now  LocalDateTimenow\n Get the date time 4 days ago\nLocalDateTime ldt2  nowminus4 ChronoUnitDAYS\n Use the minusDays method to get the same result\nLocalDateTime ldt3  nowminusDays4\n Get date and time 4 hours later\nLocalDateTime ldt4  nowplus4 ChronoUnitHOURS\n Use the plusHours method to get the same result\nLocalDateTime ldt5  nowplusHours4\nSystemoutprintlnCurrent Datetime   now\nSystemoutprintln4 days ago   ldt2\nSystemoutprintln4 days ago   ldt3\nSystemoutprintln4 hours after   ldt4\nSystemoutprintln4 hours after   ldt5\nCurrent Datetime 20210820T201339453109419\n4 days ago 20210816T201339453109419\n4 days ago 20210816T201339453109419\n4 hours after 20210821T001339453109419\n4 hours after 20210821T001339453109419\n Local Date Time and\u00a0Datetime\nAn instance of the LocalDate  class represents a date without a time or time zone Several methods in the \nclass let you convert a LocalDate  to other datetime objects and manipulate its fields year month and day \nto obtain another LocalDate  The following snippet of code creates some LocalDate  objects\n Get the current local date\nLocalDate ldt1  LocalDatenow\n Create a local date May 10 2021\nLocalDate ldt2  LocalDateof2021 MonthMAY 10\n Create a local date which is 10 days after the epoch date 19700101\nLocalDate ldt3  LocalDateofEpochDay10  19700111\nThe LocalDate  class contains two constants MAX and MIN that are the maximum and minimum \nsupported LocalDate  respectively The value for LocalDateMAX  is 9999999991231 and LocalDateMIN \nis 9999999990101 \nAn instance of the LocalTime  class represents a time without a date or time zone Time is represented to  \na nanosecond precision It contains MIN MAX MIDNIGHT  and NOON  constants that represent time constants of  \n0000 235959999999999 0000 and 1200 respectively Several methods in this class let you create manipulate \nand compare times in different ways The following snippet of code creates some LocalTime  objects\n Get the current local time\nLocalTime lt1  LocalTimenow\n Create a local time 0730\nLocalTime lt2  LocalTimeof7 30\n Create a local time 073050\nLocalTime lt3  LocalTimeof7 30 50\n Create a local time 073050000005678\nLocalTime lt4  LocalTimeof7 30 50 5678Chapter 16  Dates an D\u00a0times\n565An instance of the LocalDateTime  class represents a date and a time without a time zone It provides \nseveral methods to create manipulate and compare datetimes You can think of a LocalDateTime  as a \ncombination of LocalDate  and LocalTime \nLocalDateTime  LocalDate  LocalTime\nThe following snippet of code creates some LocalDateTime  objects in different ways\n Get the current local datetime\nLocalDateTime ldt1  LocalDateTimenow\n A local datetime 20210510T161432\nLocalDateTime ldt2  LocalDateTimeof2021 MonthMAY 10 16 14 32\n Construct a local datetime from a local date and a local time\nLocalDate ld1  LocalDateof2021 5 10\nLocalTime lt1  LocalTimeof16 18 41\nLocalDateTime ldt3  LocalDateTimeofld1 lt1  20210510T161841\nRefer to the online API documentation for these classes for a complete list of methods Make \nsure to read the Exploring the DateTime API section in this chapter before exploring the online API \ndocumentation You will find over 60 methods just in one class LocalDateTime  Without knowing \nthe pattern behind those method names looking at the API documentation for these classes will be \noverwhelming Remember that you can achieve the same results using different methods in the API\nListing 168  demonstrates some ways to create and perform operations on a local date time and datetime\nListing 168  Using a Local Date Time and Datetime\n LocalDateTimeTestjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalDateTime\nimport javatimeLocalTime\nimport javatimeMonth\npublic class LocalDateTimeTest \n    public static void mainString args \n         Create a local date and time\n        LocalDate ld  LocalDateof2021 MonthMAY 11\n        LocalTime lt  LocalTimeof8 52 23\n        Systemoutprintlnld   ld\n        SystemoutprintlnldisLeapYear   ldisLeapYear\n        Systemoutprintlnlt   lt\n         Create a local datetime from the local date and time\n        LocalDateTime ldt  LocalDateTimeofld lt\n        Systemoutprintlnldt   ldt\n         Add 2 months and 25 minutes to the local datetime\n        LocalDateTime ldt2  ldtplusMonths2plusMinutes25 \n        Systemoutprintlnldt2   ldt2\n         Derive the local date and time from the localdatetime\n        LocalDate ld2  LocalDatefromldt2\n        LocalTime lt2  LocalTimefromldt2\n        Systemoutprintlnld2   ld2\n        Systemoutprintlnlt2   lt2\n    \nChapter 16  Dates an D\u00a0times\n566ld 20210511\nldisLeapYear false\nlt 085223\nldt 20210511T085223\nldt2 20210711T091723\nld2 20210711\nlt2 091723\nYou can add years months and days to a LocalDate  What would be the result if you add one month to \n20240131 If the DateTime API simply adds the month to the month field the result would be 20240231 \nwhich is an invalid date After adding the month the result is checked if it is a valid date If it is not a valid \ndate the day of month is adjusted to the last day of the month In this case the result would be 20240229\nLocalDate ld1  LocalDateof2024 MonthJANUARY 31\nLocalDate ld2  ld1plusMonths1\nSystemoutprintlnld1\nSystemoutprintlnld2\n20240131\n20240229\nIf you add days to a LocalDate  the month  and year  fields are adjusted to keep the result a valid date \nLocalDate ld1  LocalDateof2024 MonthJANUARY 31\nLocalDate ld2  ld1plusDays30\nLocalDate ld3  ld1plusDays555\nSystemoutprintlnld1\nSystemoutprintlnld2\nSystemoutprintlnld3\n20240131\n20240301\n20250808\nHow will you get\u00a0all dates in a specific year that fall on Sunday How will you get\u00a0all dates in the next \n5 years that fall on the 13th of the month and fall on Friday These kinds of computations are possible in \nJava using a sequential loop to generate all such dates and check for specific conditions for each date but \nJava 9 made such computations very easy by providing a datesUntil  method in the LocalDate  class The \nmethod is overloaded with two variations as follows\n\tStreamLocalDate datesUntilLocalDate endExclusive\n\tStreamLocalDate datesUntilLocalDate endExclusive Period stepChapter 16  Dates an D\u00a0times\n567These methods produce a sequential ordered Stream of LocalDate s The first element in the Stream \nis the LocalDate  on which the method is called The datesUntilLocalDate endExclusive  method \nincrements the dates in the Stream one day at a time The datesUntilLocalDate endExclusive Period \nstep  method increments dates by the specified step  The specified end date is exclusive not included \nThere are several useful computations that you can do on the returned streams\n Ti p s teams were added in Java 8 and are a very useful concept in Java which are used in many places \nin the JDK including LocalDate the stream interface and supporting classes and interfaces are located in the \njavautilstream package a steam represents a sequence of objects it supports chainable methods like map \nfilter count and reduce and executes lazily By lazily we mean it will not do anything until a terminal operation \nis used such as count or for each the for each method can accept a lambda expression or method reference \nas input and performs an action for every object in the stream We cover streams in detail in More Java 17 \nThe following snippet of code counts the number of Sundays in 2021 Note that the code uses January 1 \n2022 as the last date which is exclusive and that will make the stream return all dates in 2021\nlong sundaysIn2021  LocalDateof2021 1 1\n                              datesUntilLocalDateof2022 1 1\n                              filterld  ldgetDayOfWeek  DayOfWeekSUNDAY\n                              count\nSystemoutprintlnNumber of Sundays in 2021   sundaysIn2021\nNumber of Sundays in 2021 52\nThe following snippet of code prints all dates between January 1 2020 inclusive and January 1 2025 \nexclusive that are Fridays and fall on the 13th of the month\nSystemoutprintlnFridays that fall on 13th of the month between 2020   2024 \nLocalDateof2020 1 1\n         datesUntilLocalDateof2025 1 1\n         filterld  ldgetDayOfMonth  13  ldgetDayOfWeek  DayOfWeekFRIDAY\n         forEachSystemoutprintln\nFridays that fall on 13th of the month between 2020   2024 inclusive\n20200313\n20201113\n20210813\n20220513\n20230113\n20231013\n20240913\n20241213Chapter 16  Dates an D\u00a0times\n568The following snippet of code prints the last day of each month in 2021\nSystemoutprintlnLast Day of months in 2021\nLocalDateof2021 1 31\n         datesUntilLocalDateof2022 1 1 PeriodofMonths1\n         mapld  ldformatDateTimeFormatterofPatternEEE MMM dd yyyy\n         forEachSystemoutprintln\nLast Day of months in 2021\nSun Jan 31 2021\nSun Feb 28 2021\nWed Mar 31 2021\nFri Apr 30 2021\nMon May 31 2021\nWed Jun 30 2021\nSat Jul 31 2021\nTue Aug 31 2021\nThu Sep 30 2021\nSun Oct 31 2021\nTue Nov 30 2021\nFri Dec 31 2021\nHow do you convert an Instant  to a LocalDate  a LocalTime  and a LocalDateTime  In Java 8 the \nLocalDateTime  class contained a static method named ofInstant Instant instant ZoneId zone  that \nlet you convert an Instant to a LocalDateTime  by supplying a ZoneId  However there were no such methods \nin the LocalDate  and LocalTime  classes Java 9 bridged this gap by providing an ofInstant  method in \nthese two classes The following snippet of code shows you how to convert an Instant  to a LocalDate  and a \nLocalTime  using both methods\n Without using ofInstant \n Get an Instant\nInstant now  Instantnow\n Get the system default time zone\nZoneId zone  ZoneIdsystemDefault\n Convert the Instant to a ZonedDateTime\nZonedDateTime zdt  nowatZonezone\n Get the LocalDate from the ZonedDateTime\nLocalDate ld1  zdttoLocalDate\n Get the LocalTime from the ZonedDateTime\nLocalTime lt1  zdttoLocalTime\nSystemoutprintlnIn Java 8\nSystemoutprintlnInstant   now\nSystemoutprintlnLocal Date   ld1\nSystemoutprintlnLocal Time   lt1\n Using ofInstant \n Get a LocalDate from the Instant\nLocalDate ld2  LocalDateofInstantnow zone\n Get the LocalTime from the Instant\nLocalTime lt2  LocalTimeofInstantnow zoneChapter 16  Dates an D\u00a0times\n569SystemoutprintlnnIn Java 9\nSystemoutprintlnInstant   now\nSystemoutprintlnLocal Date   ld2\nSystemoutprintlnLocal Time   lt2\nHow do you compute the number of days hours etc between two dates and times The DateTime \nAPI has different ways to compute the period between two dates and times We defer the discussion on such \ncomputations until the section called Period Between Two Dates and Times \n Offset Time and\u00a0Datetime\nAn instance of the OffsetTime  and OffsetDateTime  classes represents a time and a datetime  \nrespectively with a fixed zone offset from UTC\u00a0An offset time and datetime have no knowledge of a time \nzone Examples of an offset time and an offset datetime in the ISO8601 format are 105011530 and  \n20210511T105011530 respectively\n Tip there is no OffsetDate  class it was part of the initial design  Later it was dropped\nThe relationships between local and offset dates and times can be represented follows\nOffsetTime  LocalTime  ZoneOffset\nOffsetDateTime  LocalDateTime  ZoneOffset\nWorking with an offset time and datetime is similar to working with their local counterparts except that \nyou have to use a zone offset You can always extract a LocalXxx  from an OffsetXxx  An OffsetDateTime  \nstores an instant on the timeline and hence conversion between OffsetDateTime  and Instant  is \nsupported\nListing 169  shows examples of creating offset time and datetime When you get the current offset time \nand datetime using the now  method the system default time zone is used to obtain the zone offset value \nYou will get a different output for current time and datetime\nListing 169  Using Offset Dates Times and Datetimes\n OffsetDateTimeTestjava\npackage comjdojodatetime\nimport javatimeInstant\nimport javatimeLocalDate\nimport javatimeLocalTime\nimport javatimeOffsetDateTime\nimport javatimeOffsetTime\nimport javatimeZoneId\nimport javatimeZoneOffset\npublic class OffsetDateTimeTest \n    public static void mainString args \n         Get the current offset time\n        OffsetTime ot1  OffsetTimenow\n        SystemoutprintlnCurrent offset time   ot1\n         Create a zone offset 0530\n        ZoneOffset offset  ZoneOffsetofHoursMinutes5 30Chapter 16  Dates an D\u00a0times\n570         Create an offset time\n        OffsetTime ot2  OffsetTimeof16 40 28 0 offset\n        SystemoutprintlnAn offset time   ot2\n         Get the current offset datetime\n        OffsetDateTime odt1  OffsetDateTimenow\n        SystemoutprintlnCurrent offset datetime   odt1\n         Create an offset datetime\n        OffsetDateTime odt2  OffsetDateTimeof2021 5 11 18 10 30 0 offset\n        SystemoutprintlnAn offset datetime   odt2\n         Get the local date and time from the offset datetime\n        LocalDate ld1  odt1toLocalDate\n        LocalTime lt1  odt1toLocalTime\n        SystemoutprintlnCurrent Local Date   ld1\n        SystemoutprintlnCurrent Local Time   lt1\n         Get the instant from the offset datetime\n        Instant i1  odt1toInstant\n        SystemoutprintlnCurrent Instant   i1\n         Create an offset datetime from the instant\n        ZoneId usChicago  ZoneIdofAmericaChicago\n        OffsetDateTime odt3  OffsetDateTimeofInstanti1 usChicago\n        SystemoutprintlnOffset datetime from instant   odt3\n    \n\nCurrent offset time 2106127722275620400\nAn offset time 1640280530\nCurrent offset datetime 20210820T2106129827378320400\nAn offset datetime 20210511T1810300530\nCurrent Local Date 20210820\nCurrent Local Time 210612982737832\nCurrent Instant 20210821T010612982737832Z\nOffset datetime from instant 20210820T2006129827378320500\n Zoned Datetime\nAn instance of the ZonedDateTime  class represents a datetime with time zone rules The time zone rules \ninclude a zone offset and rules for its variation because of Daylight Savings Time There are no ZonedDate  \nand ZonedTime  they do not make sense The relationships between a ZonedDateTime  and a LocalDateTime  \ncan be represented as follows\nZonedDateTime  LocalDateTime  ZoneId\nThe following is an example of creating a ZonedDateTime  from a LocalDateTime \nZoneId usCentral  ZoneIdofAmericaChicago\nLocalDateTime ldt  LocalDateTimeof2021 MonthMAY 11 7 30\nZonedDateTime zdt  ZonedDateTimeofldt usCentral\nSystemoutprintlnzdtChapter 16  Dates an D\u00a0times\n57120210511T07300500AmericaChicago\nNot all combinations of a LocalDateTime  and a ZoneId  result in a valid ZonedDateTime  There may \nbe a gap or overlap on the local timeline in a time zone because of the Daylight Savings Time change For \nexample in the AmericaChicago time zone on March 10 2013 at 0200 the clock was moved an hour \nforward thus leaving a gap of 1 hour on the local timeline the time between 0200 and 0259 did not exist \nIn the same AmericaChicago time zone on November 3 2013 at 0200 the clock was moved an hour \nbackward thus creating an overlap of 1 hour on the local timeline the time between 0100 and 0159 existed \ntwice The DateTime API has welldefined rules to handle such gaps and overlaps\n\t If the local datetime falls in the middle of the gap the time is moved forward by the \nsame amount as the gap For example if you want to construct a zoned datetime for \nthe time zone AmericaChicago for March 10 2013 at 023000 you will get March \n10 2013 at 33000 The time is moved forward by an hour which is equal to the gap \nof an hour\n\t If the local datetime falls in the middle of the overlap the time is valid In the \ngap two zone offsets exist one the earlier offset that existed before moving \nthe clock backward and one the later offset that exists after moving the clock \nbackward By default for the time in the gap the zone offset that existed earlier \nis used The ZonedDateTime  class contains withEarlierOffsetAtOverlap  and \nwithLaterOffsetAtOverlap  which let you select the desired zone offset if the \ntime falls in the overlap\nThe following snippet of code demonstrates the results of ZonedDateTime  with the time falling in the \ngap and overlap\nZoneId usChicago  ZoneIdofAmericaChicago\n 20130310T0230 did not exist in AmericaChicago time zone\nLocalDateTime ldt  LocalDateTimeof2013 MonthMARCH 10 2 30\nZonedDateTime zdt  ZonedDateTimeofldt usChicago\nSystemoutprintlnzdt\n 20131003T0130 existed twice in AmericaChicago time zone\nLocalDateTime ldt2  LocalDateTimeof2013 MonthNOVEMBER 3 1 30\nZonedDateTime zdt2  ZonedDateTimeofldt2 usChicago\nSystemoutprintlnzdt2\n Try using the two rules for overlaps one will use the earlier\n offset 0500 the default and another the later offset 0600\nSystemoutprintlnzdt2withEarlierOffsetAtOverlap\nSystemoutprintlnzdt2withLaterOffsetAtOverlap\n20130310T03300500AmericaChicago\n20131103T01300500AmericaChicago\n20131103T01300500AmericaChicago\n20131103T01300600AmericaChicagoChapter 16  Dates an D\u00a0times\n572The ZonedDateTime  class contains a static factory method ofLocalLocalDateTime localDateTime \nZoneId zone ZoneOffset preferredOffset  You can use this method to create a ZonedDateTime  by \nspecifying the preferred zone offset in case there are two zone offsets available for the local time in the \nspecified zone  If the specified preferred zone offset is invalid the earlier zone offset for the overlap is used \nThe following snippet of code demonstrates the use of this method When we provide an invalid preferred \noffset 0700 the earlier offset 0500 is used\nZoneId usChicago  ZoneIdofAmericaChicago\nZoneOffset offset5  ZoneOffsetof0500\nZoneOffset offset6  ZoneOffsetof0600\nZoneOffset offset7  ZoneOffsetof0700\n At 20131003T0130 0500 and 0600 offsets were valid for\n the time zone AmericaChicago\nLocalDateTime ldt  LocalDateTimeof2013 MonthNOVEMBER 3 1 30\nZonedDateTime zdt5  ZonedDateTimeofLocalldt usChicago offset5\nZonedDateTime zdt6  ZonedDateTimeofLocalldt usChicago offset6\nZonedDateTime zdt7  ZonedDateTimeofLocalldt usChicago offset7\nSystemoutprintlnWith offset   offset5     zdt5\nSystemoutprintlnWith offset   offset6     zdt6\nSystemoutprintlnWith offset   offset7     zdt7\nWith offset 0500 20131103T01300500AmericaChicago\nWith offset 0600 20131103T01300600AmericaChicago\nWith offset 0700 20131103T01300500AmericaChicago\nThe ZonedDateTime  class contains several methods to convert it to local and offset date time and \ndatetime representations compare its instances and obtain its new instances by changing some of its fields \nListing 1610  shows how to work with zoned datetimes You will get a different output for the current date \nand time\nListing 1610  Using the ZonedDateTime Class\n ZonedDateTimeTestjava\npackage comjdojodatetime\nimport javatimeInstant\nimport javatimeLocalDateTime\nimport javatimeMonth\nimport javatimeOffsetDateTime\nimport javatimeZoneId\nimport javatimeZoneOffset\nimport javatimeZonedDateTime\npublic class ZonedDateTimeTest \n    public static void mainString args \n         Get the current zoned datetime for the system default time zone\n        ZonedDateTime zdt1  ZonedDateTimenow\n        SystemoutprintlnCurrent zoned datetime  zdt1\n         Create a local datetime\n        LocalDateTime ldt  LocalDateTimeof2021 MonthMARCH 11 7 30\n         Create some zoned datetimes\n        ZoneId usCentralZone  ZoneIdofAmericaChicago\n        ZonedDateTime zdt2  ZonedDateTimeofldt usCentralZoneChapter 16  Dates an D\u00a0times\n573        Systemoutprintlnzdt2\n         Get zone offset and zone id\n        ZoneOffset offset  zdt2getOffset\n        ZoneId zone  zdt2getZone\n        SystemoutprintlnOffset  offset   Zone  zone\n         Subtract 10 hours Zoneoffset changes from 0500 to 0600\n        ZonedDateTime zdt3  zdt2minusHours10\n        Systemoutprintlnzdt3\n         Create a datetime in AsiaKolkata time zone\n        ZoneId indiaKolkataZone  ZoneIdofAsiaKolkata\n        ZonedDateTime zdt4  ZonedDateTimeofldt indiaKolkataZone\n        Systemoutprintlnzdt4\n         Perform some conversions on zoned date time\n        LocalDateTime ldt2  zdt4toLocalDateTime\n        OffsetDateTime odt  zdt4toOffsetDateTime\n        Instant i1  zdt4toInstant\n        SystemoutprintlnTo local datetime   ldt2\n        SystemoutprintlnTo offset datetime   odt\n        SystemoutprintlnTo instant   i1\n    \n\nCurrent zoned datetime20210820T2114152071580170400AmericaNewYork\n20210311T07300600AmericaChicago\nOffset0600 ZoneAmericaChicago\n20210310T21300600AmericaChicago\n20210311T07300530AsiaKolkata\nTo local datetime 20210311T0730\nTo offset datetime 20210311T07300530\nTo instant 20210311T020000Z\n Same Instant Different Times\nSometimes you want to convert a datetime in a time zone to a datetime in another time zone It is similar \nto asking the date and time in India when it is May 14 2021 1630\u00a0in Chicago You can get this in several \nways You can use the toInstant  method of the ZonedDateTime  class to get the instant from the first \nzoned datetime and use the ofInstant  method to create the second zoned datetime You can also use the \nwithZoneSameInstantZoneId newZoneId  method of the ZonedDateTime  class as shown in Listing 1611  \nto achieve the same result\nListing 1611  Con verting a Datetime in a Time Zone to Another Time Zone\n DateTimeZoneConversionjava\npackage comjdojodatetime\nimport javatimeLocalDateTime\nimport javatimeMonth\nimport javatimeZoneId\nimport javatimeZonedDateTimeChapter 16  Dates an D\u00a0times\n574public class DateTimeZoneConversion \n    public static void mainString args \n        LocalDateTime ldt  LocalDateTimeof2021 MonthMAY 14 16 30\n        ZoneId usCentral  ZoneIdofAmericaChicago\n        ZonedDateTime zdt  ZonedDateTimeofldt usCentral\n        SystemoutprintlnIn US Central Time Zone  zdt\n        ZoneId asiaKolkata  ZoneIdofAsiaKolkata\n        ZonedDateTime zdt2  zdtwithZoneSameInstantasiaKolkata\n        SystemoutprintlnIn AsiaKolkata Time Zone  zdt2\n        ZonedDateTime zdt3  zdtwithZoneSameInstantZoneIdofZ\n        SystemoutprintlnIn UTC Time Zone  zdt3\n    \n\nIn US Central Time Zone20210514T16300500AmericaChicago\nIn AsiaKolkata Time Zone20210515T03000530AsiaKolkata\nIn UTC Time Zone20210514T2130Z\n Clocks\nThe Clock  class is an abstraction for the realworld clock It provides access to the current instant date and \ntime in a time zone You can obtain a clock for the system default time zone\nClock clock  ClocksystemDefaultZone\nYou can also get a clock for a specified time zone\n Get a clock for AsiaKolkata time zone\nZoneId asiaKolkata  ZoneIdofAsiaKolkata\nClock clock2  ClocksystemasiaKolkata\nTo get the current instant date and time from a clock you can use the nowClock c  method of the \ndatetimerelated classes\n Get the system default clock\nClock clock  ClocksystemDefaultZone\n Get the current instant of the clock\nInstant instant1  clockinstant\n Get the current instant using the clock and the Instant class\nInstant instant2  Instantnowclock\n Get the local date using the clock\nLocalDate ld  LocalDatenowclock\n Get the zoned datetime using the clock\nZonedDateTime zdt  ZonedDateTimenowclock\nThe now  method without arguments in all date time and datetime classes uses the system default \nclock for the default time zone The following two statements use the same clock\nLocalTime lt1  LocalTimenow\nLocalTime lt2  LocalTimenowClocksystemDefaultZoneChapter 16  Dates an D\u00a0times\n575The systemUTC  method of the Clock  class returns a clock for the UTC time zone You can also obtain \na fixed clock that always returns the same time A fixed clock is useful in testing when you want your test \ncases to use the same current time and not depend on the current time of the system clock You can use the \nfixedInstant fixedInstant ZoneId zone  static method of the Clock  class to get a clock with a fixed \ninstant in a specified time zone The Clock  class also lets you obtain a clock that gives the time at a fixed \noffset from another clock\nA clock is always aware of its time zone You can obtain the system default time zone using the Clock  \nclass as follows\nZoneId defaultZone  ClocksystemDefaultZonegetZone\n Ti p t he default implementation of the Clock  class ignores the leap seconds You can also extend the \nClock  class to implement your own clock\nThe Clock  class contains many static factory methods that let you create a clock that ticks at a specified \ninterval Those methods are as follows\n\tstatic Clock tickClock baseClock Duration tickDuration\n\tstatic Clock tickMillisZoneId zone\n\tstatic Clock tickMinutesZoneId zone\n\tstatic Clock tickSecondsZoneId zone\nThe tick  method lets you specify the granularity of the tick in the form of a Duration  The clock \nreturned by this method uses the clock specified as the first argument The returned clock makes the \nspecified clock tick in the specified duration as the second argument The following snippet of code gets a \nclock for the system default time zone that ticks every 1 millisecond\nClock clock  ClocktickClocksystemDefaultZone DurationofMillis1\nOther tickXxx  methods return the best available clock for the specified time zone that ticks at Xxx \ninterval For example the clock returned by the tickSeconds  method ticks every second\n Ti p the tickMillis  method was added to the Clock  class in Java 9\n Periods\nA period is an amount of time defined in terms of calendar fields years  months  and days  A duration is also \nan amount of time measured in terms of seconds and nanoseconds Negative periods are supported\nWhat is the difference between a period and a duration A duration represents an exact number of \nnanoseconds whereas a period represents an inexact amount of time A period is for humans what a \nduration is for machines\nSome examples of periods are 1 day 2 months 5 days 3 months and 2 days etc When someone \nmentions a 2month period you do not know the exact amount of nanoseconds in that 2 months A 2month \nperiod may mean a different number of days and hence different nanoseconds depending on when Chapter 16  Dates an D\u00a0times\n576that period starts For example a 2month period from midnight January 1 may represent 59 or 60 days \ndepending on whether the year is a leap year or not Similarly a period of 1 day may represent 23 24 or 25 \nhours depending on the day whether that day observes the startend of Daylight Savings Time or not\nAn instance of the Period  class represents a period Use one of the following static factory methods to \ncreate a Period \n\tstatic Period ofint years int months int days\n\tstatic Period ofDaysint days\n\tstatic Period ofMonthsint months\n\tstatic Period ofWeeksint weeks\n\tstatic Period ofYearsint years\nThe following snippet of code creates some instances of the Period  class\nPeriod p1  Periodof2 3 5    2 years 3 months and 5 days\nPeriod p2  PeriodofDays25     25 days\nPeriod p3  PeriodofMonths3  3 months\nPeriod p4  PeriodofWeeks3     3 weeks 21 days\nSystemoutprintlnp1\nSystemoutprintlnp2\nSystemoutprintlnp3\nSystemoutprintlnp4\nP2Y3M5D\nP25D\nP3M\nP21D\nYou can perform additions subtractions multiplications and negation on a period The division \noperation performs an integer division for example 7 divided by 3 is 2 The following snippet of code shows \nsome of the operations and their results on periods\nPeriod p1  PeriodofDays15    P15D\nPeriod p2  p1plusDays12      P27D\nPeriod p3  p1minusDays12     P3D\nPeriod p4  p1negated         P15D\nPeriod p5  p1multipliedBy3  P45D\nUse the plus  and minus  methods of the Period  class to add one period to another and to subtract \none period from another Use the normalized  method of the Period  class to normalize the years and \nmonths The method ensures that the month  value stays within 011 For example a period of 2 years and 15 \nmonths will be normalized to 3 years and 3 months\nPeriod p1  Periodof2 3 5\nPeriod p2  Periodof1 15 28\nSystemoutprintlnp1   p1\nSystemoutprintlnp2   p2\nSystemoutprintlnp1plusp2   p1plusp2Chapter 16  Dates an D\u00a0times\n577Systemoutprintlnp1plusp2normalized   p1plusp2normalized\nSystemoutprintlnp1minusp2   p1minusp2\np1 P2Y3M5D\np2 P1Y15M28D\np1plusp2 P3Y18M33D\np1plusp2normalized P4Y6M33D\np1minusp2 P1Y12M23D\nThere is a big difference in the way the DateTime API treats computations based on periods and \ndurations Computations including periods behave the way humans would expect For example when you \nadd a period of 1 day to a ZonedDateTime  the date component changes to the next day keeping the time the \nsame irrespective of how many hours the day had 23 24 or 25 hours However when you add a duration \nof a day it will always add 24 hours Lets walk through an example to clarify this\nOn 20210311T0200 the clocks in the US Central time zone were moved forward by 1 hour making \n20210311 a 23hour day Suppose you give a person a datetime of 20210310T0730\u00a0in the US Central time \nzone If you ask them what would be the datetime after a day their answer would be 20210311T0730 Their \nanswer is natural because for humans adding one day to the current datetime gives the next day with the \nsame time Lets ask the same question of a machine Ask the machine to add 24 hours which is considered \nthe same as 1 day to 20210310T0730 The machines response would be 20210311T0830 because it will \nadd exactly 24 hours to the initial datetime knowing that the hour between 0200 and 0300 did not exist \nListing 1612  demonstrates this discussion using a Java program\nListing 1612  Difference in A dding a Period and Duration to a Datetime\n PeriodTestjava\npackage comjdojodatetime\nimport javatimeDuration\nimport javatimeLocalDateTime\nimport javatimeMonth\nimport javatimePeriod\nimport javatimeZoneId\nimport javatimeZonedDateTime\npublic class PeriodTest \n    public static void mainString args \n        ZoneId usCentral  ZoneIdofAmericaChicago\n        LocalDateTime ldt  LocalDateTimeof2021 MonthMARCH 10 7 30\n        ZonedDateTime zdt1  ZonedDateTimeofldt usCentral\n        Period p1  PeriodofDays1\n        Duration d1  DurationofHours24\n         Add a period of 1 day and a duration of 24 hours\n        ZonedDateTime zdt2  zdt1plusp1\n        ZonedDateTime zdt3  zdt1plusd1\n        SystemoutprintlnStart Datetime   zdt1\n        SystemoutprintlnAfter 1 Day period   zdt2\n        SystemoutprintlnAfter 24 Hours duration   zdt3\n    \nChapter 16  Dates an D\u00a0times\n578Start Datetime 20210310T07300600AmericaChicago\nAfter 1 Day period 20210311T07300500AmericaChicago\nAfter 24 Hours duration 20210311T08300500AmericaChicago\n Period Between Two Dates and\u00a0Times\nIt is a common requirement to compute the amount of time elapsed between two dates times and \ndatetimes For example you may need to compute the number of days between two local dates or the \nnumber of hours between two local datetimes The DateTime API provides methods to compute the \nelapsed period between two dates and times There are two ways to get the amount of time between two \ndates and times\n\t Use the between  method on one of the constants in the ChronoUnit  enum\n\t Use the until  method on one of the datetimerelated classes for example \nLocalDate  LocalTime  LocalDateTime  ZonedDateTime  etc\nThe ChronoUnit  enum has a between  method which takes two datetime objects and returns a long  \nThe method returns the amount of time elapsed from the first argument to the second argument If the \nsecond argument occurs before the first one it returns a negative amount The returned amount is the \ncomplete number of units between two dates and times For example if you call HOURSbetweenlt1 lt2  \nwhere lt1 and lt2 are 0700 and 0930 respectively it will return 2 not 25 However if you call MINUTES\nbetweenlt1 lt2  it will return 150\nThe until  method takes two parameters The first parameter is the end date or time The second \nparameter is the time unit in which to compute the elapsed time The program in Listing 1613  shows how to \nuse both methods to compute the amount of time between two dates and times\nListing 1613  Com puting the Amount of Time Elapsed Between Two Dates and Times\n TimeBetweenjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalTime\nimport javatimeMonth\nimport static javatimetemporalChronoUnitDAYS\nimport static javatimetemporalChronoUnitHOURS\nimport static javatimetemporalChronoUnitMINUTES\npublic class TimeBetween \n    public static void mainString args \n        LocalDate ld1  LocalDateof2022 MonthJANUARY 7\n        LocalDate ld2  LocalDateof2022 MonthMAY 18\n        long days  DAYSbetweenld1 ld2\n        LocalTime lt1  LocalTimeof7 0\n        LocalTime lt2  LocalTimeof9 30\n        long hours  HOURSbetweenlt1 lt2\n        long minutes  MINUTESbetweenlt1 lt2\n        SystemoutprintlnUsing between days   days\n        SystemoutprintlnUsing between hours   hours\n        SystemoutprintlnUsing between minutes   minutes\n         Using the until methodChapter 16  Dates an D\u00a0times\n579        long days2  ld1untilld2 DAYS\n        long hours2  lt1untillt2 HOURS\n        long minutes2  lt1untillt2 MINUTES\n        SystemoutprintlnUsing until days   days2\n        SystemoutprintlnUsing until hours   hours2\n        SystemoutprintlnUsing until minutes   minutes2\n    \n\nUsing between days 131\nUsing between hours 2\nUsing between minutes 150\nUsing until days 131\nUsing until hours 2\nUsing until minutes 150\nIt is not always possible to compute the amount of time elapsed between two dates and times For \nexample you cannot tell the number of hours between a LocalDate  and a LocalDateTime  as the LocalDate  \ndoes not store a time component If such parameters are passed to the methods a runtime exception is \nthrown The rule is that the specified end datetime should be convertible to the start datetime\n Partials\nA partial is a date time or datetime that does not fully specify an instant on a timeline but still makes \nsense to humans With some more information a partial may match multiple instants on the timeline For \nexample December 25 is not a complete date that can be determined uniquely on a timeline however it \nmakes sense when we talk about Christmas Similarly January 1 makes sense as New Years Day\nYou must have a date time and time zone to identify an instant uniquely on the timeline If you have \nsome but not all of the three pieces of information you have a partial You cannot obtain an Instant  from a \npartial without supplying some more pieces of information We already discussed some partials in previous \nsections\nLocalDate  LocalTime  LocalDateTime  and OffsetTime  are examples of partials OffsetDateTime  and \nZonedDateTime  are not partials they have information to identify an instant on the timeline uniquely We \ndiscuss three more partials in this section\n\tYear\n\tYearMonth\n\tMonthDay\nThe names of these partials easily describe them A Year  represents a year for example 2021 2013 \netc A YearMonth  represents a valid combination of a year and a month for example 202105 201309 \netc A MonthDay  represents a valid combination of a month and a day of month for example 1215 \nListing 1614  shows some of the operations you can perform on these partialsChapter 16  Dates an D\u00a0times\n580Listing 1614   Using Year YearMonth and MonthDay Partials\n Partialsjava\npackage comjdojodatetime\nimport javatimeMonth\nimport javatimeMonthDay\nimport javatimeYear\nimport javatimeYearMonth\npublic class Partials \n    public static void mainString args \n         Use Year\n        Year y1  Yearof2021      2021\n        Year y2  y1minusYears1  2020\n        Year y3  y1plusYears1    2022\n        Year y4  Yearnow         current year\n        if y1isLeap \n            Systemoutprintlny1   is a leap year\n         else \n            Systemoutprintlny1   is not a leap year\n        \n         Use YearMonth\n        YearMonth ym1  YearMonthof2021 MonthMAY  202105\n         Get the number of days in the month\n        int monthLen  ym1lengthOfMonth  31\n        SystemoutprintlnDays in month in   ym1     monthLen\n         Get the number of days in the year\n        int yearLen  ym1lengthOfYear  365\n        SystemoutprintlnDays in year in   ym1     yearLen\n         Use MonthDay\n        MonthDay md1  MonthDayofMonthDECEMBER 25\n        MonthDay md2  MonthDayofMonthFEBRUARY 29\n        if md2isValidYear2020 \n            Systemoutprintlnmd2   occurred in 2020\n         else \n            Systemoutprintlnmd2   did not occur in 2020\n        \n    \n\n2021 is not a leap year\nDays in month in 202105 31\nDays in year in 202105 365\n0229 occurred in 2020\nFinally Listing 1615  contains an example of combining two partials to get another partial Its the \ncomplete program to compute Christmas days for 5 years starting from the year in which the program is run \nYou may get a different outputChapter 16  Dates an D\u00a0times\n581Listing 1615  Com bining a Year and MonthDay to get a LocalDate\n ChristmasDayjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeMonth\nimport javatimeMonthDay\nimport javatimeYear\nimport javatimeformatTextStyle\nimport javautilLocale\npublic class ChristmasDay \n    public static void mainString args \n        MonthDay dec25  MonthDayofMonthDECEMBER 25\n        Year year  Yearnow\n         Construct and print Christmas days in next five years\n        for int i  0 i  5 i \n            LocalDate ld  yearplusYearsiatMonthDaydec25\n            int yr  ldgetYear\n            String weekDay  ldgetDayOfWeek\n                               getDisplayNameTextStyleFULL LocalegetDefault\n            SystemoutformatChristmas in d is on sn yr weekDay\n        \n    \n\nChristmas in 2021 is on Saturday\nChristmas in 2022 is on Sunday\nChristmas in 2023 is on Monday\nChristmas in 2024 is on Wednesday\nChristmas in 2025 is on Thursday\nThe program creates a MonthDay  partial for December 25 and keeps combining a year to it to get a \nLocalDate  You can rewrite the program in Listing 1615  using the LocalDate  class as shown here It shows \nthe versatility of the DateTime API which allows you to achieve the same result in different ways\nLocalDate ld  LocalDateofYearnowgetValue MonthDECEMBER 25\nfor int i  0 i  5 i \n    LocalDate newDate  ldwithYearldgetYear  i\n    int yr  newDategetYear\n    String weekDay  newDategetDayOfWeek\n                            getDisplayNameTextStyleFULL LocalegetDefault\n    SystemoutformatChristmas in d is on sn yr weekDay\n\n Adjusting Dates\nSometimes you want to adjust a date and time to have a particular characteristic for example the first \nMonday of the month the next Tuesday etc You can perform adjustments to a date and time using an \ninstance of the TemporalAdjuster  interface The interface has one method adjustInto  that takes a \nTemporal  and returns a Temporal  The DateTime API provides several commonly used datetime adjusters If \nthey do not suit your needs you can roll out your own adjusters We discuss examples of bothChapter 16  Dates an D\u00a0times\n582A TemporalAdjusters  class is provided It consists of all static methods that return different types of \npredefined date adjusters The datetimerelated classes contain a withTemporalAdjuster adjuster  \nmethod You need to pass the returned object from one of the methods of the TemporalAdjusters  class to \nthe with  method The with  method will return a copy of the original datetime object by adjusting its \ncomponents using the logic in the adjuster The following snippet of code computes the first Monday after \nJanuary 1 2022\nimport javatimeDayOfWeek\nimport javatimeLocalDate\nimport javatimeMonth\nimport javatimetemporalTemporalAdjusters\n\nLocalDate ld1  LocalDateof2022 MonthJANUARY 1\nLocalDate ld2  ld1withTemporalAdjustersnextDayOfWeekMONDAY\nSystemoutprintlnld1\nSystemoutprintlnld2\n20220101\n20220103\nThe method names are selfexplanatory as you can see in Table\u00a0 164 \nTable 164  Useful Methods in the TemporalAdjusters Class\nMethod Description\nnextDayOfWeek dayOfWeek Returns an adjuster that adjusts the date to be the first specified day \nof week after the date being adjusted\nnextOrSameDayOfWeek dayOfWeek Returns an adjuster that adjusts the date to be the first specified day \nof week after the date being adjusted If the date being adjusted is \nalready on the specified day of week it returns the same date\npreviousDayOfWeek dayOfWeek Returns an adjuster that adjusts the date to be the first specified day \nof week before the date being adjusted\npreviousOrSameDayOfWeek \ndayOfWeekReturns an adjuster that adjusts the date to be the first specified day \nof week before the date being adjusted If the date being adjusted is \nalready on the specified day of week it returns the same date\nfirstInMonthDayOfWeek \ndayOfWeek  lastInMonth \nDayOfWeek dayOfWeekEach returns an adjuster that adjusts the date to be the firstlast \nrespectively specified day of week in the month represented by \nthe date being adjusted\ndayOfWeekInMonthint ordinal \nDayOfWeek dayOfWeekReturns an adjuster that adjusts the date to be the specified ordinal  \nday of week in the month represented by the date being adjusted \nIt is suitable for computing dates like the third Monday in January \n2022\nfirstDayOfMonth\nlastDayOfMonthEach returns an adjuster that adjusts the date to be the firstlast day \nof the month represented by the date being adjusted\ncontinued Chapter 16  Dates an D\u00a0times\n583The TemporalAdjusters  class provides a dayOfWeekInMonth  method This method returns a date \nadjuster that adjusts a date to the specified ordinal  day of week for example the first Sunday of month \nthe third Friday of month etc The specified ordinal  value may be between 1 and 5 If the ordinal  is 5 and \nthe month does not have a fifth specified dayOfWeek  it returns the first specified dayOfWeek  from the next \nmonth The following snippet of code requests the date adjuster the fifth Sunday in June 2021 The date \nadjuster returns the first Sunday in July 2021 because June 2021 does not have a fifth Sunday\nLocalDate ld1  LocalDateof2021 MonthJUNE 22\nLocalDate ld2  ld1withTemporalAdjustersdayOfWeekInMonth6 DayOfWeekSUNDAY\nSystemoutprintlnld1\nSystemoutprintlnld2\n20210622\n20210704\nYou can use a date adjuster with other methods to perform a complex adjustment You can obtain the \ndate for the second Friday of month after 3 months and 14 days from today as follows\nLocalDate date  LocalDatenow\n                          plusMonths3\n                          plusDays14\n                          withDateAdjustersdayOfWeekInMonth2 DayOfWeekFRIDAY\nYou can use the ofDateAdjuster  method to create your own date adjuster for a LocalDate  The \nfollowing snippet of code creates a date adjuster and uses it The adjuster adds 3 months and 2 days to the \ndate being adjusted Note that we have used a lambda expression to create the adjuster which we discussed \nbriefly in Chapter 11\n Create an adjuster that returns a date after 3 months and 2 days\nTemporalAdjuster adjuster \n    TemporalAdjustersofDateAdjusterLocalDate date  dateplusMonths3plusDays2\n Use the adjuster\nLocalDate today  LocalDatenow\nLocalDate dayAfter3Mon2Day  todaywithadjuster\nSystemoutprintlnToday   today\nSystemoutprintlnAfter 3 months and 2 days   dayAfter3Mon2DayMethod Description\nfirstDayOfYear\nlastDayOfYearEach returns an adjuster that adjusts the date to be the firstlast day \nof the year represented by the date being adjusted\nfirstDayOfNextMonth Returns an adjuster that adjusts the date to be the first day of the \nnext month represented by the date being adjusted\nfirstDayOfNextYear Returns an adjuster that adjusts the date to be the first day of the \nnext year represented by the date being adjusted\nofDateAdjusterUnaryOperator\nLocalDate dateBasedAdjusterA convenient method for developers to write their own LocalDate\nbased  adjustersTable 164  continuedChapter 16  Dates an D\u00a0times\n584Today 20210820\nAfter 3 months and 2 days 20211122\nListing 1616  demonstrates how to adjust dates\nListing 1616  Adjusting Dates and Times\n AdjustDatesjava\npackage comjdojodatetime\nimport javatimeDayOfWeek\nimport javatimeLocalDate\nimport javatimetemporalTemporalAdjuster\nimport javatimetemporalTemporalAdjusters\npublic class AdjustDates \n    public static void mainString args \n        LocalDate today  LocalDatenow\n        SystemoutprintlnToday   today\n         Use a DateAdjuster to adjust todays date to the next Monday\n        LocalDate nextMonday  todaywithTemporalAdjustersnextDayOfWeekMONDAY\n        SystemoutprintlnNext Monday   nextMonday\n         Use a DateAdjuster to adjust todays date to the last day of month\n        LocalDate lastDayOfMonth  todaywithTemporalAdjusterslastDayOfMonth\n        SystemoutprintlnLast day of month   lastDayOfMonth\n         Create an adjuster that returns a date after 3 months and 2 days\n        TemporalAdjuster adjuster  TemporalAdjustersofDateAdjuster\n                LocalDate date  dateplusMonths3plusDays2\n        LocalDate dayAfter3Mon2Day  todaywithadjuster\n        SystemoutprintlnDate after adding 3 months and 2 days   dayAfter3Mon2Day\n    \n\nToday 20210820\nNext Monday 20210823\nLast day of month 20210831\nDate after adding 3 months and 2 days 20211122\nLets create a custom date adjuster If the date being adjusted is on weekends or Friday 13 it returns \nthe next Monday Otherwise it returns the original date That is the adjuster will return only weekdays \nexcept Friday 13 Listing 1617  contains the complete code for the adjuster The adjuster has been defined \nas a constant in the class Using the adjuster is as easy as passing the CustomAdjustersWEEKDAYSWITHNO\nFRIDAY13  constant to the with  method of the datetime classes that can supply a LocalDate \nLocalDate ld  LocalDateof2013 MonthDECEMBER 13                        Friday\nLocalDate ldAdjusted  ldwithCustomAdjustersWEEKDAYSWITHNOFRIDAY13  Next MondayChapter 16  Dates an D\u00a0times\n585Listing 1617  Creating a Custom Date Adjuster\n CustomAdjustersjava\npackage comjdojodatetime\nimport javatimeDayOfWeek\nimport static javatimeDayOfWeekFRIDAY\nimport static javatimeDayOfWeekMONDAY\nimport static javatimeDayOfWeekSATURDAY\nimport static javatimeDayOfWeekSUNDAY\nimport javatimeLocalDate\nimport javatimetemporalTemporalAdjuster\nimport javatimetemporalTemporalAdjusters\npublic class CustomAdjusters \n    public final static TemporalAdjuster WEEKDAYSWITHNOFRIDAY13\n             TemporalAdjustersofDateAdjusterCustomAdjustersgetWeekDayNoFriday13\n     No public constructor as it is a utility class\n    private CustomAdjusters \n    \n    private static LocalDate getWeekDayNoFriday13LocalDate date \n         Initialize the new date with the original one\n        LocalDate newDate  date\n        DayOfWeek day  dategetDayOfWeek\n         if day  SATURDAY  day  SUNDAY  day  FRIDAY  dategetDayOfMonth  \n13 \n             Return next Monday\n            newDate  datewithTemporalAdjustersnextMONDAY\n        \n        return newDate\n    \n\nListing 1618  demonstrates how to use the custom date adjuster August 12 2021 was on Thursday \nYou use the adjuster to adjust August 12 13 and 14\u00a0in 2021 August 12 2021 is returned without any \nadjustments The other two dates are adjusted to next Monday which is August 16 2021 Note that the \nadjuster can be used on any datetime object that can supply a LocalDate  The program uses it to adjust a \nZonedDateTime \nListing 1618  Using the Custom Date Adjuster\n CustomAdjusterTestjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalTime\nimport javatimeMonth\nimport javatimeZoneId\nimport javatimeZonedDateTime\npublic class CustomAdjusterTest \n    public static void mainString args \n        LocalDate ld1  LocalDateof2021 MonthAUGUST 12  Thursday\n        LocalDate ld2  LocalDateof2021 MonthAUGUST 13  Friday\n        LocalDate ld3  LocalDateof2021 MonthAUGUST 14  Saturday\n        LocalDate ld1Adjusted  ld1withCustomAdjustersWEEKDAYSWITHNOFRIDAY13Chapter 16  Dates an D\u00a0times\n586        Systemoutprintlnld1   adjusted to   ld1Adjusted\n        LocalDate ld2Adjusted  ld2withCustomAdjustersWEEKDAYSWITHNOFRIDAY13\n        Systemoutprintlnld2   adjusted to   ld2Adjusted\n        LocalDate ld3Adjusted  ld3withCustomAdjustersWEEKDAYSWITHNOFRIDAY13\n        Systemoutprintlnld3   adjusted to   ld3Adjusted\n         Use it to adjust a ZonedDateTime\n        ZonedDateTime zdt\n                 ZonedDateTimeofld2 LocalTimeof8 45 ZoneIdofAmericaChicago\n        ZonedDateTime zdtAdjusted  zdtwithCustomAdjustersWEEKDAYSWITHNOFRIDAY13\n        Systemoutprintlnzdt   adjusted to   zdtAdjusted\n    \n\n20210812 adjusted to 20210812\n20210813 adjusted to 20210816\n20210814 adjusted to 20210816\n20210813T08450500AmericaChicago adjusted to 20210816T08450500America\nChicago\n Querying Datetime Objects\nAll datetime classes support queries A query is a request for information Note that you can obtain the \ncomponents of a datetime object for example the year from a LocalDate  using the getTemporalField \nfield  method of the datetime object Use a query to request information that is not available as \ncomponents For example you can query a LocalDate  whether it is a Friday 13 The result of a query can be \nof any type\nAn instance of the TemporalQueryR  interface represents a query All datetime classes contain a \nquery  method which takes a TemporalQuery  as a parameter and returns a result\nTemporalQueries  is a utility class that contains several predefined queries as its static methods as \nshown in Table\u00a0 165  If a datetime object does not have the information sought in the query the query \nreturns null For example the query for a LocalDate  from a LocalTime  object returns null  Chronology is an \ninterface that is used to identify and manipulate dates in a calendar system\nTable 165  Util ity Methods in the TemporalQueries Class\nMethod Return Type Description\nchronology TemporalQueryChronology A query to get the chronology\nlocalDate TemporalQueryLocalDate A query to get the LocalDate \nlocalTime TemporalQueryLocalTime A query to get the LocalTime \noffset TemporalQueryZoneOffset A query to get the ZoneOffset \nprecision TemporalQueryTemporalUnit A query to get the smallest supported unit\nzone TemporalQueryZoneId A query to get the ZoneId  If the ZoneId  is not available \nit queries for ZoneOffset  It returns null if both are not \navailable for example a LocalDate  has neither\nzoneId TemporalQueryZoneId A query to get the ZoneId  If ZoneId  is not available it \nreturns nullChapter 16  Dates an D\u00a0times\n587The program in Listing 1619  shows how to use predefined queries It uses queries to get the precision \nand LocalDate  from a LocalDate  a LocalTime  and a ZonedDateTime  The program uses the current date so \nyou may get a different output\nListing 1619  Quer ying Datetime Objects\n QueryTestjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalTime\nimport javatimeZonedDateTime\nimport javatimetemporalTemporalQueries\nimport javatimetemporalTemporalQuery\nimport javatimetemporalTemporalUnit\npublic class QueryTest \n    public static void mainString args \n         Get references of the precision and local date queries\n        TemporalQueryTemporalUnit precisionQuery  TemporalQueriesprecision\n        TemporalQueryLocalDate localDateQuery  TemporalQuerieslocalDate\n         Query a LocalDate\n        LocalDate ld  LocalDatenow\n        TemporalUnit precision  ldqueryprecisionQuery\n        LocalDate queryDate  ldquerylocalDateQuery\n        SystemoutprintlnPrecision of LocalDate   precision\n        SystemoutprintlnLocalDate of LocalDate   queryDate\n         Query a LocalTime\n        LocalTime lt  LocalTimenow\n        precision  ltqueryprecisionQuery\n        queryDate  ltquerylocalDateQuery\n        SystemoutprintlnPrecision of LocalTime   precision\n        SystemoutprintlnLocalDate of LocalTime   queryDate\n         Query a ZonedDateTime\n        ZonedDateTime zdt  ZonedDateTimenow\n        precision  zdtqueryprecisionQuery\n        queryDate  zdtquerylocalDateQuery\n        SystemoutprintlnPrecision of ZonedDateTime   precision\n        SystemoutprintlnLocalDate of ZonedDateTime   queryDate\n    \n\nPrecision of LocalDate Days\nLocalDate of LocalDate 20210820\nPrecision of LocalTime Nanos\nLocalDate of LocalTime null\nPrecision of ZonedDateTime Nanos\nLocalDate of ZonedDateTime 20210820Chapter 16  Dates an D\u00a0times\n588Creating and using a custom query is easy You can create a custom query in two ways\n\t Create a class that implements the TemporalQuery  interface and use instances of the \nclass as a query\n\t Use any method reference as a query The method should take a TemporalAccessor  \nand return an object The return type of the method defines the result type for the \nquery\nListing 1620  contains the code for a Friday13Query  class The class implements the TemporalQuery  \ninterface The queryFrom  method is part of the interface implementation The method returns true if the \ndatetime object contains a date that falls on Friday 13 Otherwise it returns false The query returns false if \nthe datetime object does not contain a day of month and day of week information for example a LocalTime  \nobject The class defines a constant ISFRIDAY13  that can be used as a query\nListing 1620  A Cl ass Implementing the TemporalQuery Interface\n Friday13Queryjava\npackage comjdojodatetime\nimport javatimeDayOfWeek\nimport javatimetemporalTemporalAccessor\nimport javatimetemporalTemporalQuery\nimport static javatimetemporalChronoFieldDAYOFMONTH\nimport static javatimetemporalChronoFieldDAYOFWEEK\nimport static javatimeDayOfWeekFRIDAY\npublic class Friday13Query implements TemporalQueryBoolean \n    public final static Friday13Query ISFRIDAY13  new Friday13Query\n     Prevent outside code from creating objects of this class\n    private Friday13Query \n    \n    Override\n    public Boolean queryFromTemporalAccessor temporal \n        if temporalisSupportedDAYOFMONTH  temporalisSupportedDAYOFWEEK \n            int dayOfMonth  temporalgetDAYOFMONTH\n            int weekDay  temporalgetDAYOFWEEK\n            DayOfWeek dayOfWeek  DayOfWeekofweekDay\n            if dayOfMonth  13  dayOfWeek  FRIDAY \n                return BooleanTRUE\n            \n        \n        return BooleanFALSE\n    \n\nThe following snippet of code uses the Friday13Query  with three datetime objects The first LocalDate  \nfalls on Friday 13 and as you can see in the output the query returns true\nLocalDate ld1  LocalDateof2021 8 13\nBoolean isFriday13  ld1queryFriday13QueryISFRIDAY13\nSystemoutprintlnDate   ld1   isFriday13   isFriday13\nLocalDate ld2  LocalDateof2022 1 10\nisFriday13  ld2queryFriday13QueryISFRIDAY13\nSystemoutprintlnDate   ld2   isFriday13   isFriday13\nLocalTime lt  LocalTimeof7 30 45Chapter 16  Dates an D\u00a0times\n589isFriday13  ltqueryFriday13QueryISFRIDAY13\nSystemoutprintlnTime   lt   isFriday13   isFriday13\nDate 20210813 isFriday13 true\nDate 20220110 isFriday13 false\nTime 073045 isFriday13 false\nListing 1621  contains the code for a CustomQueries  class The class contains a static method \nisFriday13  The method reference for the isFriday13  method can be used as a query\nListing 1621  A Cus tomQueries Class with a IsFriday13 Method That Can Be Used a Query\n CustomQueriesjava\npackage comjdojodatetime\nimport javatimeDayOfWeek\nimport static javatimeDayOfWeekFRIDAY\nimport static javatimetemporalChronoFieldDAYOFMONTH\nimport static javatimetemporalChronoFieldDAYOFWEEK\nimport javatimetemporalTemporalAccessor\npublic class CustomQueries \n    public static Boolean isFriday13TemporalAccessor temporal \n        if temporalisSupportedDAYOFMONTH  temporalisSupportedDAYOFWEEK \n            int dayOfMonth  temporalgetDAYOFMONTH\n            int weekDay  temporalgetDAYOFWEEK\n            DayOfWeek dayOfWeek  DayOfWeekofweekDay\n            if dayOfMonth  13  dayOfWeek  FRIDAY \n                return BooleanTRUE\n            \n        \n        return BooleanFALSE\n    \n\nThe following snippet of code uses the method reference of the isFriday13  method in the \nCustomQueries  class as a query The code uses the same datetime objects as in the previous example and \nyou get the same result\nLocalDate ld1  LocalDateof2021 8 13\nBoolean isFriday13  ld1queryCustomQueriesisFriday13\nSystemoutprintlnDate   ld1   isFriday13   isFriday13\nLocalDate ld2  LocalDateof2022 1 10\nisFriday13  ld2queryCustomQueriesisFriday13\nSystemoutprintlnDate   ld2   isFriday13   isFriday13\nLocalTime lt  LocalTimeof7 30 45\nisFriday13  ltqueryCustomQueriesisFriday13\nSystemoutprintlnTime   lt   isFriday13   isFriday13\nDate 20210813 isFriday13 true\nDate 20220110 isFriday13 false\nTime 073045 isFriday13 falseChapter 16  Dates an D\u00a0times\n590It is typical of the DateTime API to provide multiple choices to perform the same task Lets consider \na task of getting the LocalTime  from a ZonedDateTime  The program in Listing 1622  shows five ways of \nachieving this\nListing 1622  Multiple W ays of Getting the LocalTime from a ZonedDateTime\n LocalTimeFromZonedDateTimejava\npackage comjdojodatetime\nimport javatimeLocalTime\nimport javatimeZonedDateTime\nimport javatimetemporalTemporalQueries\npublic class LocalTimeFromZonedDateTime \n    public static void mainString args \n        ZonedDateTime zdt  ZonedDateTimenow\n         Use the toLocalTime method of the ZonedDateTime class preferred\n        LocalTime lt1  zdttoLocalTime\n         Use the from method of the LocalTime class\n        LocalTime lt2  LocalTimefromzdt\n         Use the localTime query\n        LocalTime lt3  zdtqueryTemporalQuerieslocalTime\n         Use the LocalTimefrom method as a query\n        LocalTime lt4  zdtqueryLocalTimefrom\n         Get all time components and construct a LocalTime\n        int hours  zdtgetHour\n        int minutes  zdtgetMinute\n        int seconds  zdtgetSecond\n        int nanos  zdtgetNano\n        LocalTime lt5  LocalTimeofhours minutes seconds nanos\n         Print all LocalTimes\n        Systemoutprintlnzdt   zdt\n        Systemoutprintlnlt1   lt1\n        Systemoutprintlnlt2   lt2\n        Systemoutprintlnlt3   lt3\n        Systemoutprintlnlt4   lt4\n        Systemoutprintlnlt5   lt5\n    \n\nzdt 20210804T2111425474404000500AmericaChicago\nlt1 211142547440400\nlt2 211142547440400\nlt3 211142547440400\nlt4 211142547440400\nlt5 211142547440400\nWhich method is the correct way Most of the time all methods will execute the same logic However \nsome methods are more readable than others In this case the code calling the toLocalTime  method \nof the ZonedDateTime  class should be used as it is straightforward and most readable At least you should \nnot extract the time components from the ZonedDateTime  to construct the LocalTime  as shown in the fifth \nmethod in the exampleChapter 16  Dates an D\u00a0times\n591 NonISO Calendar Systems\nThe date classes such as LocalDate  use the ISO calendar system which is the Gregorian calendar The \nDateTime API also lets you use other calendars such as the Thai Buddhist calendar Hijrah calendar \nMinguo calendar and Japanese calendar The nonISO calendarrelated classes are in the javatimechrono  \npackage\nThere is an XxxChronology  and XxxDate  class for each of the available nonISO calendar systems The \nXxxChronology  class represents the Xxx calendar system whereas the XxxDate  class represents a date in the \nXxx calendar system Each XxxChronology  class contains an INSTANCE  constant that represents a singleton \ninstance of that class For example HijrahChronology  and HijrahDate  are classes that you will be using to \nwork with the Hijrah calendar system The following snippet of code shows two ways to get the current date \nin the Thai Buddhist calendar You may get a different output\nimport javatimechronoThaiBuddhistChronology\nimport javatimechronoThaiBuddhistDate\n\nThaiBuddhistChronology thaiBuddhistChrono  ThaiBuddhistChronologyINSTANCE\nThaiBuddhistDate now  thaiBuddhistChronodateNow\nThaiBuddhistDate now2  ThaiBuddhistDatenow\nSystemoutprintlnCurrent Date in Thai Buddhist   now\nSystemoutprintlnCurrent Date in Thai Buddhist   now2\nCurrent Date in Thai Buddhist ThaiBuddhist BE 25640820\nCurrent Date in Thai Buddhist ThaiBuddhist BE 25640820\nYou can also convert dates in one calendar system to another Conversion from ISO dates to nonISO \ndates is also allowed Converting dates from one calendar system to another is just a matter of calling the \nfrom  static method of the target date class and passing the source date object as its parameter Listing 1623  \nshows how to convert ISO date to Thai Buddhist date and vice versa You may get a different output\nListing 1623  Using the Thai Buddhist and ISO Calendars\n InterCalendarDatesjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimechronoThaiBuddhistDate\npublic class InterCalendarDates \n    public static void mainString args \n        ThaiBuddhistDate thaiBuddhistNow  ThaiBuddhistDatenow\n        LocalDate isoNow  LocalDatenow\n        SystemoutprintlnThai Buddhist Current Date   thaiBuddhistNow\n        SystemoutprintlnISO Current Date   isoNow\n         Convert Thai Buddhist date to ISO date and vice versa\n        ThaiBuddhistDate thaiBuddhistNow2  ThaiBuddhistDatefromisoNow\n        LocalDate isoNow2  LocalDatefromthaiBuddhistNow\n        SystemoutprintlnThai Buddhist Current Date from ISO   thaiBuddhistNow2\n        SystemoutprintlnISO Current Date from Thai Buddhist   isoNow2\n    \nChapter 16  Dates an D\u00a0times\n592Thai Buddhist Current Date ThaiBuddhist BE 25640820\nISO Current Date 20210820\nThai Buddhist Current Date from ISO ThaiBuddhist BE 25640820\nISO Current Date from Thai Buddhist 20210820\n Formatting Dates and\u00a0Times\nAn object of the DateTimeFormatter  class lets you format and parse a datetime object By formatting I mean \nrepresenting a datetime object in a userdefined textual form for example representing a LocalDate  May \n24 2021 as 05242021  Sometimes formatting is also referred to as printing because formatting features \nalso let you print or output a textual representation of a datetime object to an Appendable  object such as a \nStringBuilder \nParsing is the reverse of formatting It lets you construct a datetime object from a textual representation \nof a datetime Creating a LocalDate  object from the text 05242021 to represent May 24 2021 is an \nexample of parsing\nDifferent ways of formatting and parsing datetimes exist Learning how to format datetimes may be \ndifficult if you do not learn it the right way The most important point to keep in mind is that formatting and \nparsing are always performed by an object of the DateTimeFormatter  class The difference lies in how you \ncreate that object The DateTimeFormatter  class does not provide any public constructors You must obtain \nits object indirectly In the beginning the confusion lies in how to get its object Use one of the following two \nmethods of the DateTimeFormatter  class to format a date time or datetime\n\tString formatTemporalAccessor temporal\n\tvoid formatToTemporalAccessor temporal Appendable appendable\nThe format  method takes a date time or datetime object and returns a textual representation of the \nobject based on the rules of the formatter The formatTo  method lets you write the textual representation \nof the object to an Appendable  for example a file a StringBuilder  etc\nTo format a datetime object a formatter needs two pieces of information a format pattern and a locale \nSometimes one or both pieces of information are defaulted for you sometimes you provide them\nYou can perform formatting in several ways They all use directly or indirectly a DateTimeFormatter  \nobject\n\t Using predefined standard datetime formatters\n\t Using the format  method of the datetime classes\n\t Using userdefined patterns\n\t Using the DateTimeFormatterBuilder  class\n Using Predefined Formatters\nPredefined formatters are defined as constants in the DateTimeFormatter  class They are listed in Table\u00a0 166  \nMost of the formatters use ISO datetime formats some formatters use a slightly modified version of ISO formatsChapter 16  Dates an D\u00a0times\n593Using the predefined formatters is easy just pass the datetime object to the format  The \nfollowing snippet of code uses the ISODATE  formatter to format a LocalDate  an OffsetDateTime  and a \nZonedDateTime  You may get a different output as it formats and prints the current date\nimport javatimeLocalDate\nimport javatimeOffsetDateTime\nimport javatimeZonedDateTime\nimport static javatimeformatDateTimeFormatterISODATE\nTable 166  Predefined Datetime Formatters\nFormatter Description Example\nBASICISODATE An ISO date formatter to format and \nparse a date without using a separator \nbetween two date components20140109 201401090600\nISODATE \nISOTIME \nISODATETIMEDate time and datetime formatters \nto format and parse dates times and \ndatetimes using the ISO separators20140109 201401090600\n153832927 1538329430600\n20140109T1520077470600 \n20140109T152007825\n0600AmericaChicago\nISOINSTANT An instant formatter to format and \nparse an instant or a datetime object \nrepresenting an instant such as a \nZonedDateTime  in UTC format20140109T212356870Z\nISOLOCALDATE \nISOLOCALTIME \nISOLOCALDATETIMEDate time and datetime formatters \nto format or parse dates times and \ndatetimes without an offset20140109 153014352  \n20140109T152911384\nISOOFFSETDATE \nISOOFFSETTIME \nISOOFFSETDATETIMEDate time and datetime formatters \nto format and parse dates times and \ndatetimes with an offset using ISO \nformat201401090600\n1534298510600\n20140109T15330707060\nISOZONEDDATETIME A datetime formatter to format and \nparse a datetime with a zone ID if \navailable20140109T1545491120600 \n20140109T1545491280600 \nAmericaChicago\nISOORDINALDATE A date formatter to format and parse a \ndate with year and day of year2014009\nISOWEEKDATE A date formatter to format and parse \nweekbased dates The format is \nyearweekofyeardayofweek For \nexample 2014W024 means the fourth \nday of the second week in 20142014W024\n2014W0240600\nRFC1123DATETIME A datetime formatter to format and \nparse datetimes for emails using the \nRFC1123 specificationThu 9 Jan 2014 155044 0500Chapter 16  Dates an D\u00a0times\n594 Format dates using the ISODATE formatter\nString ldStr  ISODATEformatLocalDatenow\nString odtStr  ISODATEformatOffsetDateTimenow\nString zdtStr  ISODATEformatZonedDateTimenow\nSystemoutprintlnLocal Date   ldStr\nSystemoutprintlnOffset Datetime   odtStr\nSystemoutprintlnZoned Datetime   zdtStr\nLocal Date 20210820\nOffset Datetime 202108200400\nZoned Datetime 202108200400\nPay attention to the names of the predefined formatters The datetime object being formatted must \ncontain the components as suggested by their names For example the ISODATE  formatter expects the \npresence of the date components and hence it should not be used to format timeonly objects such as a \nLocalTime  Similarly the ISOTIME  formatter should not be used to format a LocalDate \n A runtime error as a LocalTime does not contain date components\nString ltStr  ISODATEformatLocalTimenow\n Using the\u00a0format Method of\u00a0Datetime Classes\nYou can format a datetime object using its format  method The format  method takes an object of the \nDateTimeFormatter  class The following snippet of code uses this approach The ISODATE  formatter is used\nimport javatimeLocalDate\nimport javatimeOffsetDateTime\nimport javatimeZonedDateTime\nimport static javatimeformatDateTimeFormatterISODATE\n\nLocalDate ld  LocalDatenow\nString ldStr  ldformatISODATE\nSystemoutprintlnLocal Date   ldStr\nOffsetDateTime odt  OffsetDateTimenow\nString odtStr  odtformatISODATE\nSystemoutprintlnOffset Datetime   odtStr\nZonedDateTime zdt  ZonedDateTimenow\nString zdtStr  zdtformatISODATE\nSystemoutprintlnZoned Datetime   zdtStr\nLocal Date 20210820\nOffset Datetime 202108200400\nZoned Datetime 202108200400Chapter 16  Dates an D\u00a0times\n595 Using UserDefined Patterns\nOne of the most commonly used methods in the DateTimeFormatter  class is the ofPattern  method \nwhich returns a DateTimeFormatter  object with the specified format pattern and locale\n\tstatic DateTimeFormatter ofPatternString pattern\n\tstatic DateTimeFormatter ofPatternString pattern Locale locale\nThe following snippet obtains two formatters to format a date in Month day Year format The first \nformatter formats the datetime in the default locale and the second one in the German locale\n Get a formatter for the default locale\nDateTimeFormatter fmt1  DateTimeFormatterofPatternMMMM dd yyyy\n Get a formatter for the German locale\nDateTimeFormatter fmt2  DateTimeFormatterofPatternMMMM dd yyyy LocaleGERMAN\nSometimes you have a DateTimeFormatter  object for a pattern and a locale You want to use the same \npattern to format a datetime in another locale The DateTimeFormatter  class has a withLocale  method \nthat returns a DateTimeFormatter  object for the specified locale that uses the same pattern In the previous \nsnippet of code you could have replaced the second statement with the following one\n Get a formatter for the German locale using the same pattern as fmt1\nDateTimeFormatter fmt2  fmt1withLocaleLocaleGERMAN\n Tip Use the getLocale  method of the DateTimeFormatter  class to know the locale that it will use to \nformat datetimes\nDatetime formatting is performed based on a pattern A formatting pattern is a sequence of characters \nthat have special meanings For example MMMM in a pattern uses the fully spelled name of a month such \nas January February etc MMM uses the short form of a month name such as Jan Feb etc MM uses a two\ndigit month number such as 01 02 etc M uses a one or twodigit month number such as 1 2 10 11 etc\nIn a format pattern some characters have special meanings and some are used literally Characters \nwith special meanings will be interpreted by the formatter and they will be replaced with datetime \ncomponents A formatter outputs the literal characters as they appear in the pattern All letters AZ and az \nare reserved as pattern letters although not all are used If you want to include a literal string in a pattern \nyou need to enclose it in single quotes To output a single quote you need to use two consecutive single \nquotes\nA datetime formatter outputs any nonletter characters other than   and a single quote directly \nHowever it is recommended that you enclose them in single quotes Suppose you have a local date of May \n29 2021 Both patterns of 1997 MMMM dd yyyy and 1997 MMMM dd yyyy will output 1997 May 29 \n2021 however the latter which uses single quotes around the literal 1997 is recommended\nTable 167  lists the symbols used in patterns and their meanings All examples in the table use \n20210729T0730127890500AmericaChicago as the input datetimeChapter 16  Dates an D\u00a0times\n596Table 167  Datetime Formatting Symbols and Descriptions with Examples\nSymbol Description Examples\nPattern Output\nG Era G AD\nGGGG Anno Domini\nGGGGG A\nu Year\nIt can be a positive or negative number After an era start \ndate it is a positive number Before an era start date it is a \nnegative number For example the year value for 2014 AD is \n2014 and the year value for 2014 BC is 2014uuuuuuuu 2021\nuu 12\nuuuuu 02021\ny Year of era\nIt counts the year forward or backward from the era start \ndate It is always a positive number For example the year \nvalue for 2014 AD is 2014 and the year value for 2014 BC is \n2015 In Common Era year 0 is 1 BCyyyyyyyy 2021\nyy 12\nyyyyy 02021\nD Day of year 1\u00a0 366 D 150\nML Month of year M 5\nMM 05\nMMM Jul\nMMMM July\nd Day of month d 5 29\ndd 05 29\ng Modified Julian day\nadded in Java 9g 57796\nggg 57796\ngggggg 057796\nQq Quarter of year Q 3\nQQ 03\nQQQ Q3\nQQQQ 3rd quarter\nY Weekbased year Y 2021\nYY 12\nYYYYYYY 2021\nw Week of weekbased year w 31\nW Week of month W 5\ncontinued Chapter 16  Dates an D\u00a0times\n597Table 167  continued\nSymbol Description Examples\nPattern Output\nE Day of week E 7\nEE 07\nEEE Sun\nEEEE Sunday\nF Day of week in month F 1\na AMPM of day a AM\nh Clock hour of AMPM 112 h 7\nK Hour of AMPM 011 K 7\nk Clock hour of AMPM 124 k 7\nH Hour of day 023 H 7\nHH 07\nm Minute of hour mm 30\ns Second of minute ss 12\nS Fraction of second SSSSSSSSS 000000789\nA Millisecond of day A 27012000\nn Nanosecond of second n 789\nN Nanosecond of day N 27012000000789\nV Time zone ID VV America\nChicago\nv Generic nonlocation zone name\nadded in Java 9v CT\nvvvv Central Time\nz Time zone name z CDT\nZ Zone offset\nWhen the zone offset is zero it outputs 0000 or 0000 \ndepending on whether you use Z ZZ or ZZZZ 0500\nZZ 0500\nZZZ 0500\nZZZZ GMT0500\nO Localized zone offset O GMT5\ncontinued Chapter 16  Dates an D\u00a0times\n598You can have optional sections in a pattern string The symbols  and  denote the start and the end of \nan optional section respectively A pattern enclosed within an optional section is output only if information \nis available for all its elements Otherwise an optional section is skipped An optional section may be \nnested inside another optional section Listing 1624  shows how to use an optional section in a pattern The \noptional section contains time information When you format a date the optional section is skipped\nListing 1624  Using an Optional Section in a Datetime Formatting Pattern\n OptionalSectionTestjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalDateTime\nimport javatimeLocalTime\nimport javatimeMonthTable 167  continued\nSymbol Description Examples\nPattern Output\nX Zone offset\nUnlike the symbol Z it prints Z for the zone offset Zero X \noutputs only the hour if minutes and seconds are zero such \nas 09 XX outputs the hour and minutes without a colon \nsuch as 0830 XXX outputs the hour and minutes with a \ncolon such as 0830 XXXX outputs the hour minutes and \noptional seconds without a colon such as 083045 and \nXXXXX outputs the hour minutes and optional seconds \nwith a colon such as 083045X 0530\nXX 0530\nXXX 0530\nXXXX 053045\nXXXXX 053045\nx Same as X except that it prints 00 for the zone offset zero \nnot Zxx 0500\np Pad next\nIt pads the output of the pattern following it with spaces \nFor example if mm outputs 30 pppmm will output  30  and \nppppmm will output   30  The number of ps determines the \nwidth of the outputpppmm  30\nSingle quotes \nhave been \nshown to \ndisplay the \npadding with a \nspace\n Escape for text\nText within single quotes is output directly To output a \nsingle quote use two consecutive single quotesHello Hello\nHello MMMM Hello July\n A single quote Hello \nMMMMHello July\n  An optional section\nRefer to the discussion for an example\n   These are reserved for future useChapter 16  Dates an D\u00a0times\n599import javatimeformatDateTimeFormatter\npublic class OptionalSectionTest \n    public static void mainString args \n         A pattern with an optional section\n        String pattern  MMddyyyy at HHmmss\n        DateTimeFormatter fmt  DateTimeFormatterofPatternpattern\n        LocalDate ld  LocalDateof2021 MonthMAY 30\n        LocalTime lt  LocalTimeof17 30 12\n        LocalDateTime ldt  LocalDateTimeofldlt\n         Format a date Optional section will be skipped because a\n         date does not have time HH mm and ss information\n        String str1  fmtformatld\n        Systemoutprintlnstr1\n         Format a datetime Optional section will be output\n        String str2  fmtformatldt\n        Systemoutprintlnstr2\n    \n\n05302021\n05302021 at 173012\nListing 1625  shows how to use different patterns to format dates and times\nListing 1625  Using Patterns to Format Dates and Times\n FormattingDateTimejava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalTime\nimport javatimeMonth\nimport javatimeZoneId\nimport javatimeZonedDateTime\nimport javatimeformatDateTimeFormatter\nimport javatimetemporalTemporal\nimport javautilLocale\npublic class FormattingDateTime \n    public static void mainString args \n        LocalDate ld  LocalDateof2021 MonthAPRIL 30\n        SystemoutprintlnFormatting date   ld\n        formatld Mdyyyy\n        formatld MMddyyyy\n        formatld MMM dd yyyy\n        formatld MMMM dd yyyy\n        formatld EEEE MMMM dd yyyy\n        formatld Month q in QQQ\n        formatld MMddyyyy at HHmmss\n        LocalTime lt  LocalTimeof16 30 5 78899\n        SystemoutprintlnnFormatting time  lt\n        formatlt HHmmss\n        formatlt KKmmss aChapter 16  Dates an D\u00a0times\n600        formatlt MMddyyyy at HHmmss\n        ZoneId usCentral  ZoneIdofAmericaChicago\n        ZonedDateTime zdt  ZonedDateTimeofld lt usCentral\n        SystemoutprintlnnFormatting zoned datetime  zdt\n        formatzdt MMddyyyy HHmmssXXX\n        formatzdt MMddyyyy VV\n        formatzdt MMddyyyy at HHmmss\n    \n    public static void formatTemporal co String pattern \n        DateTimeFormatter fmt  DateTimeFormatterofPatternpattern LocaleUS\n        String str  fmtformatco\n        Systemoutprintlnpattern     str\n    \n\nFormatting date 20210430\nMdyyyy 4302021\nMMddyyyy 04302021\nMMM dd yyyy Apr 30 2021\nMMMM dd yyyy April 30 2021\nEEEE MMMM dd yyyy Monday April 30 2021\nMonth q in QQQ Month 2  in Q2\nMMddyyyy at HHmmss 04302021\nFormatting time163005000078899\nHHmmss 163005\nKKmmss a 043005 PM\nMMddyyyy at HHmmss   at 163005\nFormatting zoned datetime20210430T1630050000788990500AmericaChicago\nMMddyyyy HHmmssXXX 04302021 1630050500\nMMddyyyy VV 04302021 AmericaChicago\nMMddyyyy at HHmmss 04302021 at 163005\n Using LocaleSpecific Formats\nThe DateTimeFormatter  class has several methods that return a DateTimeFormatter  with a predefined \nformatting pattern suitable for humans to read Use the following methods to obtain a reference to such \nformatters\n\tDateTimeFormatter ofLocalizedDateFormatStyle dateStyle\n\tDateTimeFormatter ofLocalizedDateTimeFormatStyle dateTimeStyle\n\tDateTimeFormatter ofLocalizedDateTimeFormatStyle dateStyle FormatStyle \ntimeStyle\n\tDateTimeFormatter ofLocalizedTimeFormatStyle timeStyle\nThese methods accept an argument of FormatStyle  enum type which has four constants SHORT  \nMEDIUM  LONG  and FULL  These constants are used to output formatted date and time with a varying degree of \ndetail The details in the output are localespecific The methods use the system default locale For a different \nlocale use the withLocal  method to obtain a new DateTimeFormatter  with the specified locale\nListing 1626  shows how to use some predefined localespecific formats It formats dates and times in \nUS default German and Indian localesChapter 16  Dates an D\u00a0times\n601Listing 1626  Using Predefined Format Patterns\n LocalizedFormatsjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalDateTime\nimport javatimeLocalTime\nimport javatimeMonth\nimport javatimeformatDateTimeFormatter\nimport static javatimeformatFormatStyleFULL\nimport static javatimeformatFormatStyleLONG\nimport static javatimeformatFormatStyleMEDIUM\nimport static javatimeformatFormatStyleSHORT\nimport javautilLocale\npublic class LocalizedFormats \n    public static void mainString args \n        LocalDate ld  LocalDateof2021 MonthAPRIL 19\n        LocalTime lt  LocalTimeof16 30 20\n        LocalDateTime ldt  LocalDateTimeofld lt\n        DateTimeFormatter fmt  DateTimeFormatterofLocalizedDateSHORT\n        SystemoutprintlnFormatter Default Locale   fmtgetLocale\n        SystemoutprintlnShort Date   fmtformatld\n        fmt  DateTimeFormatterofLocalizedDateMEDIUM\n        SystemoutprintlnMedium Date   fmtformatld\n        fmt  DateTimeFormatterofLocalizedDateLONG\n        SystemoutprintlnLong Date   fmtformatld\n        fmt  DateTimeFormatterofLocalizedDateFULL\n        SystemoutprintlnFull Date   fmtformatld\n        fmt  DateTimeFormatterofLocalizedTimeSHORT\n        SystemoutprintlnShort Time   fmtformatlt\n        fmt  DateTimeFormatterofLocalizedDateTimeSHORT\n        SystemoutprintlnShort Datetime   fmtformatldt\n        fmt  DateTimeFormatterofLocalizedDateTimeMEDIUM\n        SystemoutprintlnMedium Datetime   fmtformatldt\n         Use German locale to format the datetime in medius style\n        fmt  DateTimeFormatterofLocalizedDateTimeMEDIUM\n                               withLocaleLocaleGERMAN\n        SystemoutprintlnGerman Medium Datetime   fmtformatldt\n         Use IndianEnglish locale to format datetime in short style\n        fmt  DateTimeFormatterofLocalizedDateTimeSHORT\n                               withLocalenew Localeen IN\n        SystemoutprintlnIndianen Short Datetime   fmtformatldt\n         Use IndianEnglish locale to format datetime in medium style\n        fmt  DateTimeFormatterofLocalizedDateTimeMEDIUM\n                               withLocalenew LocaleenIN\n        SystemoutprintlnIndianen Medium Datetime   fmtformatldt\n    \nChapter 16  Dates an D\u00a0times\n602Formatter Default Locale enUS\nShort Date 41921\nMedium Date Apr 19 2021\nLong Date April 19 2021\nFull Date Thursday April 19 2021\nShort Time 430 PM\nShort Datetime 41921 430 PM\nMedium Datetime Apr 19 2021 43020 PM\nGerman Medium Datetime 19042021 163020\nIndianen Short Datetime 190421 430 PM\nIndianen Medium Datetime 19Apr2021 43020 PM\n Using the\u00a0DateTimeFormatterBuilder Class\nInternally all datetime formatters are obtained using DateTimeFormatterBuilder  Typically you will not \nneed to use this class The previously discussed methods are sufficient in almost all use cases The class \nhas a noargs constructor and many appendXxx  methods You create an instance of the class and call \nthose appendXxx  methods to build the desired formatter Finally call the toFomatter  method to get a \nDateTimeFormatter  object The following snippet of code builds a DateTimeFormatter  object to format a \ndate in the format Christmas in YEAR  is on WEEKDAY \nimport javatimeLocalDate\nimport javatimeformatDateTimeFormatter\nimport javatimeformatDateTimeFormatterBuilder\nimport static javatimeformatTextStyleFULLSTANDALONE\nimport static javatimetemporalChronoFieldDAYOFWEEK\nimport static javatimetemporalChronoFieldYEAR\n\nDateTimeFormatter formatter  new DateTimeFormatterBuilder\n                              appendLiteralChristmas in \n                              appendValueYEAR\n                              appendLiteral is on \n                              appendTextDAYOFWEEK FULLSTANDALONE\n                              toFormatter\nLocalDate ld  LocalDateof2020 12 25\nString str  ldformatformatter\nSystemoutprintlnstr\nChristmas in 2020 is on Friday\nYou can create the same formatter using a pattern which is a lot easier to write and read than the \nprevious code using the DateTimeFormatterBuilder \nLocalDate ld  LocalDateof2020 12 25\nString pattern  Christmas in yyyy is on EEEE\nDateTimeFormatter formatter  DateTimeFormatterofPatternpatternChapter 16  Dates an D\u00a0times\n603String str  ldformatformatter\nSystemoutprintlnstr\nChristmas in 2020 is on Friday\n Parsing Dates and\u00a0Times\nParsing is the process of creating a date time or datetime object from a string Like formatting parsing is \nalso handled by a DateTimeFormatter  Refer to the previous section Formatting Dates and Times  for \ndetails on how to get an instance of the DateTimeFormatter  class The same symbols used for formatting are \nalso used as parsing symbols There are two ways to parse a string into a datetime object\n\t Using the parse  method of the datetime class\n\t Using the parse  method of the DateTimeFormatter  class\n Ti p a DateTimeParseException  is thrown if the text cannot be parsed it is a runtime exception the \nclass contains two methods to provide the error details the getErrorIndex  method returns the index in \nthe text where the error occurred the getParsedString  method returns the text being parsed it is good \npractice to handle this exception while parsing a datetime\nEach datetime class has two overloaded versions of the parse  static method The return type of the \nparse  method is the same as the defining datetime class The following are the two versions of the parse  \nmethod in the LocalDate  class\n\tstatic LocalDate parseCharSequence text\n\tstatic LocalDate parseCharSequence text DateTimeFormatter formatter\nThe first version of the parse  method takes the textual representation of the datetime  object in ISO \nformat For example for a LocalDate  the text should be in the yyyymmdd format The second version \nlets you specify a DateTimeFormatter  The following snippet of code parses two strings into two LocalDate  \nobjects\n Parse a LocalDate in ISO format\nLocalDate ld1  LocalDateparse20220110\n Parse a LocalDate in MMddyyyy format\nDateTimeFormatter formatter  DateTimeFormatterofPatternMMddyyyy\nLocalDate ld2  LocalDateparse01102022 formatter\nSystemoutprintlnld1   ld1\nSystemoutprintlnld2   ld2\nld1 20220110\nld2 20220110Chapter 16  Dates an D\u00a0times\n604The DateTimeFormatter  class contains several parse  methods to facilitate parsing of strings into \ndatetime objects The DateTimeFormatter  class does not know the type of datetime object that can be \nformed from the strings Therefore most of them return a TemporalAccessor  object that you can query to get \nthe datetime components You can pass the TemporalAccessor  object to the from  method of the datetime \nclass to get the specific datetime object The following snippet of code shows how to parse a string in MM\nddyyyy format using a DateTimeFormatter  object to construct a LocalDate \nimport javatimeLocalDate\nimport javatimeformatDateTimeFormatter\nimport javatimetemporalTemporalAccessor\n\nDateTimeFormatter formatter  DateTimeFormatterofPatternMMddyyyy\nTemporalAccessor ta  formatterparse01102022\nLocalDate ld  LocalDatefromta\nSystemoutprintlnld\n20220110\nAnother version of the parse  method takes a TemporalQuery  that can be used to parse the string \ndirectly into a specific datetime object The following snippet of code uses this version of the parse  \nmethod The second parameter is the method reference of the from  method of the LocalDate  class You \ncan think of the following snippet of code as shorthand of the previous code\nDateTimeFormatter formatter  DateTimeFormatterofPatternMMddyyyy\nLocalDate ld  formatterparse01102022 LocalDatefrom\nSystemoutprintlnld\n20220110\nThe DateTimeFormatter  class contains a parseBest  method Using this method needs little \nexplanation Suppose you receive a string as an argument to a method The argument may contain varying \npieces of information for date and time In such a case you want to parse the string using the most pieces of \ninformation Consider the following pattern\nyyyyMMddTHHmmssZ\nThis pattern has two optional sections A text with this pattern may be fully parsed to an \nOffsetDateTime  and partially parsed to a LocalDateTime  and a LocalDate  You can create a parser for this \npattern as follows\nDateTimeFormatter formatter  DateTimeFormatterofPatternyyyyMMddTHHmmssZ\nThe following snippet of code specifies OffsetDateTime  LocalDateTime  and LocalDate  as the \npreferred parsed result types\nString text  \nTemporalAccessor ta \n    formatterparseBesttext OffsetDateTimefrom LocalDateTimefrom LocalDatefromChapter 16  Dates an D\u00a0times\n605The method will try to parse the text as the specified types in order and return the first successful result \nTypically a call to the parseBest  method is followed by a series of ifelse  statements with an instanceof  \noperator to check what type of object was returned Listing 1627  shows how to use the parseBest  \nmethod Notice that the fourth text is in invalid format and parsing it throws an exception\nListing 1627  Using the parseBest Method of the DateTimeFormatter Class\n ParseBestTestjava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalDateTime\nimport javatimeOffsetDateTime\nimport javatimeformatDateTimeFormatter\nimport javatimeformatDateTimeParseException\nimport javatimetemporalTemporalAccessor\npublic class ParseBestTest \n    public static void mainString args \n        DateTimeFormatter parser\n                 DateTimeFormatterofPatternyyyyMMddTHHmmssZ\n        parseStrparser 20210531\n        parseStrparser 20210531T163012\n        parseStrparser 20210531T1630120500\n        parseStrparser 20210531Hello\n    \n    public static void parseStrDateTimeFormatter formatter String text \n        try \n            TemporalAccessor ta  formatterparseBesttext\n                    OffsetDateTimefrom\n                    LocalDateTimefrom\n                    LocalDatefrom\n            if ta instanceof OffsetDateTime \n                OffsetDateTime odt  OffsetDateTimefromta\n                SystemoutprintlnOffsetDateTime   odt\n             else if ta instanceof LocalDateTime \n                LocalDateTime ldt  LocalDateTimefromta\n                SystemoutprintlnLocalDateTime   ldt\n             else if ta instanceof LocalDate \n                LocalDate ld  LocalDatefromta\n                SystemoutprintlnLocalDate   ld\n             else \n                SystemoutprintlnParsing returned   ta\n            \n         catch DateTimeParseException e \n            SystemoutprintlnegetMessage\n        \n    \nChapter 16  Dates an D\u00a0times\n606LocalDate 20210531\nLocalDateTime 20210531T163012\nOffsetDateTime 20210531T1630120500\nText 20210531Hello could not be parsed unparsed text found at index 10\n Legacy Datetime Classes\nWe refer to the datetimerelated classes that were available before Java 8 as legacy datetime classes  The main \nlegacy classes are Date  Calendar  and GregorianCalendar  They are in the javautil  package Refer to the \nsection called Interoperability with Legacy Datetime Classes  for how to convert Date  and Calendar  objects \nto datetime objects of the new DateTime API and vice versa\n The Date Class\nAn object of the Date  class represents an instant in time A Date  object stores the number of milliseconds \nelapsed since the epoch midnight January 1 1970 UTC\n Tip the Date  class in the legacy Date time api is similar to the Instant  class in the new Date time \napi\u00a0they ha ve the precision of milliseconds and nanoseconds respectively\nMost of the constructors and methods of the Date  class have been deprecated since JDK 11 The default \nconstructor of the Date  class is used to create a Date  object with the current system datetime Listing 1628  \nillustrates the use of the Date  class You may get a different output because it prints the current date and \ntime\nListing 1628  Using the Date Class\n CurrentLegacyDatejava\npackage comjdojodatetime\nimport javautilDate\npublic class CurrentLegacyDate \n    public static void main String args \n         Create a new Date object\n        Date currentDate  new Date\n        SystemoutprintlnCurrent date   currentDate\n         Get the milliseconds value of the current date\n        long millis  currentDategetTime\n        SystemoutprintlnCurrent datetime in millis   millis\n    \n\nCurrent date Sat Aug 21 201338 EDT 2021\nCurrent datetime in millis 1629591218981Chapter 16  Dates an D\u00a0times\n607A Date  object works with a 1900based year When you call the setYear  method of this object to set \nthe year as 2017 you will need to pass 117 2017\u00a0 1900  117 Its getYear  method returns 117 for the year \n2017 Months in this class range from 0 to 11 where January is 0 February is 2  and December is 11\n The Calendar Class\nCalendar  is an abstract class An abstract class cannot be instantiated We discuss abstract classes in detail \nin Chapter 20 on inheritance The GregorianCalendar  class is a concrete class which inherits the Calendar  \nclass\nThe Calendar  class declares some final static fields to represent date fields For example Calendar\nJANUARY  can be used to specify the January month in a date The GregorianCalendar  class has a \ndefault constructor which creates an object to represent the current datetime You can also create a \nGregorianCalendar  object to represent a specific date using its other constructors It also lets you obtain the \ncurrent date in a particular time zone\n Get the current date in the system default time zone\nGregorianCalendar currentDate  new GregorianCalendar\n Get GregorianCalendar object representing March 26 2003 063045 AM\nGregorianCalendar someDate  new GregorianCalendar2003 CalendarMARCH 26 6 30 45\n Get Indian time zone which is GMT0530\nTimeZone indianTZ  TimeZonegetTimeZoneGMT0530\n Get current date in India\nGregorianCalendar indianDate  new GregorianCalendarindianTZ\n Get Moscow time zone which is GMT0300\nTimeZone moscowTZ  TimeZonegetTimeZoneGMT0300\n Get current date in Moscow\nGregorianCalendar moscowDate  new GregorianCalendarmoscowTZ\n Tip a Date  contains a datetime a GregorianCalendar  contains a datetime with a time zone\nThe month part of a date ranges from 0 to 11 That is January is 0 February is 1 and so on It is easier \nto use the constants declared for months and the other date fields in the Calendar  class rather than using \ntheir integer values For example you should use the CalendarJANUARY  constant to represent the January \nmonth in your program instead of a 0 You can get the value of a field in a datetime using the get  method \nby passing the requested field as an argument\n Create a GregorianCalendar object\nGregorianCalendar gc  new GregorianCalendar\n year will contain the current year value\nint year  gcgetCalendarYEAR\n month will contain the current month value\nint month  gcgetCalendarMONTH\n day will contain day of month of the current date\nint day  gcgetCalendarDAYOFMONTH\n hour will contain hour value\nint hour  gcgetCalendarHOUR\n minute will contain minute valueChapter 16  Dates an D\u00a0times\n608int minute  gcgetCalendarMINUTE\n second will contain second values\nint second  gcgetCalendarSECOND\nYou can set the date interpretation to be lenient or not lenient by using the setLenient  method of the \nGregorianCalendar  class By default it is lenient If the date interpretation is lenient a date such as March \n35 2003 is interpreted as April 5 2003 If date interpretation is not lenient such a date will result in an error \nYou can also compare two dates whether one date occurs before or after another by using before  and \nafter  methods There are two methods add  and roll  which need explanation They are described \nin the following sections\n The add Method\nThe add  method is used to add an amount to a particular field on a date The amount being added may \nbe negative or positive Suppose you have the date of December 1 2003 stored in a GregorianCalendar  \nobject You want to add 5 to the month field The value for the month field will be 16 which is out of range \n011 In such a case the larger date field here year is larger than month will be adjusted to accommodate \nthe overflow The date after adding 5 to the month field will be May 1 2004 The following snippet of code \nillustrates this concept\nGregorianCalendar gc  new GregorianCalendar2003 CalendarDECEMBER 1\ngcaddCalendarMONTH 5  Now gc represents May 1 2004\nThis method may result in adjusting smaller fields too Suppose you have the date of January 30 2003 \nstored in a GregorianCalendar  object You add 1 to the month field The new month field does not overflow \nHowever the resulting date February 30 2003 is not a valid date The day of month must be between 1 and \n28\u00a0in the month of February 2003 In this case the day of month field is automatically adjusted It is set to the \nnearest possible valid value which is 28 The resulting date will be February 28 2003\n The roll Method\nThe roll  method works the same as the add  method except it does not change the larger field when \nthe field being changed overflows It may adjust the smaller fields to make the date a valid date It is an \noverloaded method\n\tvoid rollint field int amount\n\tvoid rollint field boolean up\nThe second version rolls updown the specified field  by a single unit of time whereas the first version \nrolls the specified field  by the specified amount  Therefore gcrollCalendarMONTH 1  is the same as \ngcrollCalendarMONTH true  and gcrollCalendarMONTH 1  is the same as gcrollCalendar\nMONTH false  Listing 1629  illustrates the use of some of the methods of the GregorianCalendar  class You \nmay get a different output\nListing 1629  Using the GregorianCalendar Class\n GregorianDate java\npackage comjdojodatetime\nimport javautilCalendar\nimport javautilDate\nimport javautilGregorianCalendarChapter 16  Dates an D\u00a0times\n609public class GregorianDate \n    public static void mainString args \n        GregorianCalendar gc  new GregorianCalendar\n        SystemoutprintlnCurrent Date   getStrgc\n         Add 1 year\n        gcaddCalendarYEAR 1\n        SystemoutprintlnAfter adding a year   getStrgc\n         Add 15 days\n        gcaddCalendarDATE 15\n        SystemoutprintlnAfter adding 15 days   getStrgc\n        long millis  gcgetTimeInMillis\n        Date dt  gcgetTime\n        SystemoutprintlnTime in millis   millis\n        SystemoutprintlnTime as Date   dt\n    \n    public static String getStrGregorianCalendar gc \n        int day  gcgetCalendarDAYOFMONTH\n        int month  gcgetCalendarMONTH\n        int year  gcgetCalendarYEAR\n        int hour  gcgetCalendarHOUR\n        int minute  gcgetCalendarMINUTE\n        int second  gcgetCalendarSECOND\n        String str  day    month  1    year   \n                 hour    minute    second\n        return str\n    \n\nCurrent Date 2182021 81515\nAfter adding a year 2182022 81515\nAfter adding 15 days 592022 81515\nTime in millis 1662423315056\nTime as Date Mon Sep 05 201515 EDT 2022\n Interoperability with\u00a0Legacy Datetime Classes\nThe legacy datetime classes had been around for over 18 years when the new DateTime API became \navailable As a Java developer you might be tasked to maintain applications that use the legacy classes For \nthis reason interoperability between the legacy classes and the new DateTime API was also provided New \nmethods have been added to the legacy classes to convert their objects to the new datetime objects and vice \nversa Interoperability of the following legacy classes is discussed in this section\n\tjavautilDate\n\tjavautilCalendar\n\tjavautilGregorianCalendar\n\tjavautilTimeZone\n\tjavasqlDateChapter 16  Dates an D\u00a0times\n610\tjavasqlTime\n\tjavasqlTimestamp\n\tjavaniofileattributeFileTime\nTable 168  contains the list of legacy datetime classes and their new DateTime counterparts All legacy \nclasses except the Calendar  class provide twoway conversion The toXxx  methods are instance methods \nThey return an object of the new datetime class The other methods are static methods which accept an \nobject of the new datetime class and return an object of the legacy class For example the from  method \nin the javautilDate  class is a static method which takes an Instant  argument and returns a javautil\nDate  The toInstant  method is an instance method and converts a javautilDate  into an Instant \nListing 1630  shows how to convert a Date  to an Instant  and vice versa You may get a different output\nListing 1630  Con verting a Date to an Instant and Vice Versa\n DateAndInstantjava\npackage comjdojodatetime\nimport javautilDate\nimport javatimeInstant\npublic class DateAndInstant \n    public static void mainString args \n         Get the current date\n        Date dt  new Date\n        SystemoutprintlnDate   dt\n         Convert the Date to an Instant\n        Instant in  dttoInstant\n        SystemoutprintlnInstant   in\n         Convert the Instant back to a Date\n        Date dt2  Datefromin\n        SystemoutprintlnDate   dt2\n    \nTable 168  Con version Between New Datetime and Legacy Datetime Classes\nLegacy Class New Methods in Legacy Class Equivalent New Datetime Class\njavautilDate from toInstant Instant\nCalendar toInstant None\nGregorianCalendar from toZonedDateTime ZonedDateTime\nTimeZone getTimeZone toZoneId ZoneId\njavasqlDate valueOf toLocalDate LocalDate\nTime valueOf toLocalTime LocalTime\nTimestamp from toInstant Instant\nvalueOf toLocalDateTime LocalDateTime\nFileTime from toInstant InstantChapter 16  Dates an D\u00a0times\n611Date Sat Aug 21 200505 EDT 2021\nInstant 20210822T000505841Z\nDate Sat Aug 21 200505 EDT 2021\nTypically the legacy code uses GregorianCalendar  to store date time and datetime You can convert \nit to a ZonedDateTime  which can be converted to any other classes in the new DateTime API\u00a0The Calendar  \nclass provides a toInstant  method to convert its instance to an Instant  The Calendar  class is abstract \nTypically you would have an instance of its concrete subclass class for example GregorianCalendar  \nTherefore converting an Instant  to a GregorianCalendar  is a twostep process\n\t Convert the Instant  to a ZonedDateTime \n\t Use the from  static method of the GregorianCalendar  class to get a \nGregorianCalendar \nThe program in Listing 1631  shows how to convert a GregorianCalendar  to a ZonedDateTime  and vice \nversa The program also shows how to get a LocalDate  LocalTime  etc from a GregorianCalendar  You may \nget a different output because the output depends on the systems default time zone\nListing 1631  Con verting a GregorianCalendar to New Datetime Types and Vice Versa\n GregorianCalendarAndNewDateTimejava\npackage comjdojodatetime\nimport javatimeLocalDate\nimport javatimeLocalDateTime\nimport javatimeLocalTime\nimport javatimeOffsetDateTime\nimport javatimeOffsetTime\nimport javatimeZoneId\nimport javatimeZonedDateTime\nimport javautilGregorianCalendar\nimport javautilTimeZone\npublic class GregorianCalendarAndNewDateTime \n    public static void mainString args \n         Create a GC for the default time zone\n        GregorianCalendar gc  new GregorianCalendar2022 1 11 15 45 50\n        SystemoutprintlnGregorian Calendar   gcgetTime\n         Convert the GC to a LocalDate\n        LocalDate ld  gctoZonedDateTimetoLocalDate\n        SystemoutprintlnLocal Date   ld\n         Convert the GC to a LocalTime\n        LocalTime lt  gctoZonedDateTimetoLocalTime\n        SystemoutprintlnLocal Time   lt\n         Convert the GC to a LocalDateTime\n        LocalDateTime ldt  gctoZonedDateTimetoLocalDateTime\n        SystemoutprintlnLocal DateTime   ldt\n         Convert the GC to an OffsetDate\n        OffsetDateTime od  gctoZonedDateTimetoOffsetDateTime\n        SystemoutprintlnOffset Date   od\n         Convert the GC to an OffsetTime\n        OffsetTime ot  gctoZonedDateTimetoOffsetDateTimetoOffsetTime\n        SystemoutprintlnOffset Time   otChapter 16  Dates an D\u00a0times\n612         Convert the GC to an ZonedDateTime\n        ZonedDateTime zdt  gctoZonedDateTime\n        SystemoutprintlnZoned DateTime   zdt\n         Convert the ZonedDateTime to a GC  In GC month starts at 0\n         and in new API at 1\n        ZoneId zoneId  zdtgetZone\n        TimeZone timeZone  TimeZonegetTimeZonezoneId\n        SystemoutprintlnZone ID   zoneId\n        SystemoutprintlnTime Zone ID   timeZonegetID\n        GregorianCalendar gc2  GregorianCalendarfromzdt\n        SystemoutprintlnGregorian Calendar   gc2getTime\n    \n\nGregorian Calendar Fri Feb 11 154550 EST 2022\nLocal Date 20220211\nLocal Time 154550\nLocal DateTime 20220211T154550\nOffset Date 20220211T1545500500\nOffset Time 1545500500\nZoned DateTime 20220211T1545500500AmericaNewYork\nZone ID AmericaNewYork\nTime Zone ID AmericaNewYork\nGregorian Calendar Fri Feb 11 154550 EST 2022\nHow do you convert a Date  to a LocalDate  A Date  represents an instant in time so first you need to \nconvert the Date  into a ZoneDateTime  using a ZoneId  and then get a LocalDate  from the ZonedDateTime  The \nfollowing snippet of code converts the current date represented by Date  to a LocalDate  in Java\nDate dt  new Date\nLocalDate ld  dttoInstant\n                 atZoneZoneIdsystemDefault\n                 toLocalDate\nSystemoutprintlnDate   dt\nSystemoutprintlnLocalDate   ld\nDate Sat Aug 21 200735 EDT 2021\nLocalDate 20210821\nThis kind of conversion is frequently needed Java 9 added an ofInstant  method to the LocalDate  \nclass to make this kind of conversion easier The method is declared as follows\nstatic LocalDate ofInstantInstant instant ZoneId zone\nThe following snippet of code performs the same conversion using ofInstant\nDate dt  new Date\nLocalDate ld  LocalDateofInstantdttoInstant ZoneIdsystemDefault\nSystemoutprintlnDate   dt\nSystemoutprintlnLocalDate   ldChapter 16  Dates an D\u00a0times\n613Date Sat Aug 21 200926 EDT 2021\nLocalDate 20210821\n Summary\nThrough the javatime  packages Java provides a comprehensive DateTime API to work with date time \nand datetime By default most of the classes are based on the ISO8601 standards The main classes are\n\tInstant\n\tLocalDate\n\tLocalTime\n\tLocalDateTime\n\tOffsetTime\n\tOffsetDateTime\n\tZonedDateTime\nThe Instant  class represents an instant on the timeline and it is suitable for machines for example as \ntimestamps for events The LocalDate  LocalTime  and LocalDateTime  classes represent humanreadable \ndate time and datetime without a time zone The OffsetTime  and OffsetDateTime  classes represent a time \nand datetime with a zone offset from UTC\u00a0The ZoneDateTime  class represents a datetime for a time zone \nwith zone rules which will adjust the time according to the Daylight Savings Time changes in the time zone\nThe DateTime API provides classes for representing an amount of time used with machines and \nhumans The Duration  class represents an amount of time for machines whereas the Period  class \nrepresents an amount of time as perceived by humans The DateTime API provides extensive support for \nformatting and parsing dates and times through the javatimeformatDateTimeFormatter  class The Date\nTime API supports nonISO calendar systems through the javatimechrono  package Builtin supports for \nHijrah Japanese Minguo and Thai Buddhist calendars are provided The API is extensible and supports \nbuilding your own calendar systems\nEXERCISES\n 1 What class would you use to store a date without the time and time zone parts  \nin it\n 2 What class would you use to store a date and time that is aware of Daylight \nsavings time\n 3 What is the difference between a ZoneId  and ZoneOffset \n 4 What is the difference between a ZonedDateTime  and an OffsetDateTime \n 5 Write the code to convert the Instant  representing the current time in the system \ndefault time zone to a LocalDate \n 6 Write a program tha t prints all years from 2001 to 2099\u00a0in which the last day of the \nyear December 31 falls on mondayChapter 16  Dates an D\u00a0times\n614 7 Write the code tha t converts a javautilDate  to a LocalDate  in the system \ndefault time zone\n 8 Complete the follo wing snippet of code so it prints Friday January 12 \n1968  it is supposed to format the date 19680112 and print it\nLocalDate bday  LocalDateof1968 MonthJANUARY 12\nString pattern   Your code goes here \nDateTimeFormatter fmt  DateTimeFormatterofPatternpattern\n       String formattedBDay  fmtformatbday\n       SystemoutprintlnformattedBDay\n 9 Complete the follo wing snippet of code that prints the number of days between \nJanuary 12 1968 and september 19 1969 it should print 616\nLocalDate ld1  LocalDateof1968 MonthJANUARY 12\nLocalDate ld2  LocalDateof1969 MonthSEPTEMBER 19\nlong daysBetween   Your code goes here \nSystemoutprintlndaysBetween\n 10 Complete the code in the printFirstDayOfMonth  method the method takes \na LocalDate  as an argument and prints the first day of the month in which the \ndate occurs suppose the LocalDate  passed in to this method is 20170805 it \nwill print First day of AUGUST 2017 is on SATURDAY \npublic static void printFirstDayOfMonthLocalDate ld \n    LocalDate newDate  ldwith Your Code goes here \n    SystemoutprintfFirst day of s d is on sn\n        ldgetMonth ldgetYear newDategetDayOfWeek\n615\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307417CHAPTER 17\nFormatting Data\nIn this chapter you will learn\n\t How to format and parse dates and numbers\n\t How to use the printf style formatting\n\t How to create a class that uses a custom formatter\nJava provides a rich set of APIs for formatting data The data may include simple values such as \nnumbers or objects such as strings dates and other types of objects This chapter covers formatting options \nin Java for different types of values All example programs in this chapter are a member of a jdojoformat  \nmodule as declared in Listing 171 \nListing 171  The D eclaration of a jdojoformat Module\n moduleinfojava\nmodule jdojoformat \n    exports comjdojoformat\n\n Formatting Dates\nThe DateTime API was covered in Chapter 16 If you are writing new code that is related to dates and times \nyou are advised to use the DateTime API\u00a0However this section is provided in case you need to work with \nlegacy code that uses old ways of formatting dates and times\nIn this section we discuss how to format dates using the legacy Date API\u00a0We also discuss how to parse \na string to create a date object You can format dates in predefined formats or in formats of your choice The \nJava library provides two classes to format dates in the javatext package\n\tjavatextDateFormat\n\tjavatextSimpleDateFormat\nThe next two sections show you how to format dates in predefined and custom formatsChapter 17  Formatting Data\n616 Using Predefined Date Formats\nUse the DateFormat  class to format dates using a predefined format It is an abstract  class The class \nis abstract so you cannot create an instance of this class using the new operator You can call one of its \ngetXxxInstance  methods where Xxx can be Date  DateTime  or Time  to get the formatter object or just \ngetInstance  The formatted text depends on two things style and locale Use the format  method of \nthe DateFormat  class to format a date and time The style of formatting determines how much datetime \ninformation is included in the formatted text whereas the locale determines how all pieces of information \nare assembled The DateFormat  class defines five styles as constants\n\tDateFormatDEFAULT\n\tDateFormatSHORT\n\tDateFormatMEDIUM\n\tDateFormatLONG\n\tDateFormatFULL\nThe DEFAULT  format is the same as MEDIUM  unless you use getInstance  where the default is SHORT  \nTable\u00a0 171  shows the same date formatted in different styles for a US locale\nThe javautilLocale  class contains constants for some common locales For example you can use \nLocaleFRANCE  for a locale with the language fr  French and country code FR  Alternatively you can \ncreate a Locale  object for France like so\nLocale french FranceLocale  new Localefr FR \nTo create a Locale  you need to use a twoletter lowercase language code and a twoletter uppercase \ncountry code if the Locale  class does not declare a constant for that country Language codes and country \ncodes have been listed in ISO639 code and ISO3166 code Some more examples of creating locales are as \nfollows\nLocale hindiIndiaLocale  new Localehi IN\nLocale bengaliIndiaLocale  new Localebn IN\nLocale thaiThailandLocale  new Localeth TH\n Tip Use the LocalegetDefault  method to get the default Locale  for your systemTable 171  Predefined Date Format Styles and Formatted Text \nfor Locale as United States\nStyle Formatted Date Example\nDEFAULT Mar 27 2021\nSHORT 32721\nMEDIUM Mar 27 2021\nLONG March 27 2021\nFULL Thursday March 27 2021Chapter 17  Formatting Data\n617The following snippet of code prints the current date formatted in long format for the US locale\nDate today  new Date\nDateFormat formatter  DateFormatgetDateInstanceDateFormatLONG LocaleUS\nString formattedDate  formatterformattoday\nSystemoutprintlnformattedDate\nAugust 6 2021\nThe program listed in Listing 172  displays dates in short and medium formats for locales as default \nwhich is US for the JVM running this example France and Germany The program prints the current date \nIt will print different formats of the same date when you run this program You may get a different output \nbecause the program prints the current date\nListing 172  Using the Predefined Date Formats\n PredefinedDateFormatsjava\npackage comjdojoformat\nimport javatextDateFormat\nimport javautilDate\nimport javautilLocale\npublic class PredefinedDateFormats \n    public static void mainString args \n         Get the current date\n        Date today  new Date\n         Print date in the default locale format\n        Locale defaultLocale  LocalegetDefault\n        printLocaleDetailsdefaultLocale\n        printDatedefaultLocale today\n         Print date in French France format\n        printLocaleDetailsLocaleFRANCE\n        printDateLocaleFRANCE today\n         Print date in German Germany format You could also use LocaleGERMANY\n         instead of new Locale de DE\n        Locale germanLocale  new Localede DE\n        printLocaleDetailsgermanLocale\n        printDategermanLocale today\n    \n    public static void printLocaleDetailsLocale locale \n        String languageCode  localegetLanguage\n        String languageName  localegetDisplayLanguage\n        String countryCode  localegetCountry\n        String countryName  localegetDisplayCountry\n         Print the locale info\n        SystemoutprintlnLanguage   languageName  \n                 languageCode   \n                 Country   countryName\n                   countryCode  \n    Chapter 17  Formatting Data\n618    public static void printDateLocale locale Date date \n         Format and print the date in SHORT style\n        DateFormat formatter  DateFormatgetDateInstanceDateFormatSHORT locale\n        String formattedDate  formatterformatdate\n        SystemoutprintlnSHORT   formattedDate\n         Format and print the date in MEDIUM style\n        formatter  DateFormatgetDateInstanceDateFormatMEDIUM locale\n        formattedDate  formatterformatdate\n        SystemoutprintlnMEDIUM   formattedDate\n         Print a blank line at the end\n        Systemoutprintln\n    \n\nLanguage Englishen Country United StatesUS\nSHORT 12421\nMEDIUM Jan 24 2021\nLanguage Frenchfr Country FranceFR\nSHORT 240121\nMEDIUM 24 janv 2021\nLanguage Germande Country GermanyDE\nSHORT 240121\nMEDIUM 24012021\n Using Custom Date Formats\nIf you want to use custom date formats use the SimpleDateFormat  class Formatting using the \nSimpleDateFormat  class is localesensitive Its default constructor creates a formatter with the default locale \nand default date format for that locale You can create a formatter using other constructors where you can \nspecify your own date format and locale Once you have an object of the SimpleDateFormat  class you can \ncall its format  method to format the date If you want to change the date format for subsequent formatting \nyou can use the applyPattern  method by passing the new date format or pattern as an argument The \nfollowing snippet of code shows you how to format a date using the SimpleDateFormat  class\n Create a formatter with a pattern ddMMyyyy\nSimpleDateFormat simpleFormatter  new SimpleDateFormatddMMyyyy\n Get the current date\nDate today  new Date\n Format the current date\nString formattedDate  simpleFormatterformattoday\n Print the date\nSystemoutprintlnToday is ddMMyyyy   formattedDate\n Change the date format Now month will be spelled fully\nsimpleFormatterapplyPatternMMMM dd yyyy\n Format the current date\nformattedDate  simpleFormatterformattoday\n Print the date\nSystemoutprintlnToday is MMMM dd yyyy   formattedDateChapter 17  Formatting Data\n619Today is ddMMyyyy 06082021\nToday is MMMM dd yyyy August 06 2021\nNote that the output will be different when you run this code on your computer It will print the current \ndate in this format using the default locale The previous output is in the US locale\nLetters that are used to create patterns to format dates and times are listed with their meanings in \nTable\u00a0 172  The examples are shown as if the date to display were July 10 2021 at 123055\u00a0in the afternoon\nYou can embed literals inside formatted dates Suppose you have your birth date September 19 1969 \nstored in a date object and now you want to print it as I was born on the day 19 of the month September \nin 1969  Some parts in the message come from the birth date and others are literals which are intended \nto appear in the message as they are You cannot use letters such as az and AZ as literals inside a date \npattern You need to place them inside single quotes to treat them as literals not part of the formatting Table 172  List of Formatting Symbols for Formatting Date and Time\nLetter Date or Time Component Presentation Examples\nG Era designator Text AD\ny Year Year 2021 21\nY Weekbased year Year 2021 21\nM Month in year Month July Jul 07\nw Week in year Number 28\nW Week in month Number 2\nD Day in year Number 191\nd Day in month Number 10\nF Day of week in month Number 2\nE Day in week Text Saturday Sat\na AMPM marker Text PM\nH Hour in day 023 Number 12\nk Hour in day 124 Number 12\nK Hour in AMPM 011 Number 0\nh Hour in AMPM 112 Number 12\nm Minute in hour Number 30\ns Second in minute Number 55\nS Millisecond Number 978\nz Time zone General time zone Pacific Standard Time \nPST GMT0800\nZ Time zone RFC 822 time zone 0800Chapter 17  Formatting Data\n620pattern First you need a Date  object to represent September 19 1969 The Date  classs constructor which \ntakes year month and day has been deprecated Lets start with the GregorianCalendar  class and use its \ngetTime  method to get a Date  object The following snippet of code prints this message\n Create a GregorianCalendar object with September 19 1969 as date\nGregorianCalendar gc  new GregorianCalendar1969 CalendarSEPTEMBER19\n Get a Date object\nDate birthDate  gcgetTime\n Create the pattern You must place literals inside single quotes\nString pattern  I was born on the day dd of the month MMMM in yyyy\n Create a SimpleDateFormat with the pattern\nSimpleDateFormat simpleFormatter  new SimpleDateFormatpattern\n Format and print the date\nSystemoutprintlnsimpleFormatterformatbirthDate\nI was born on the Day 19 of the month September in 1969\n Parsing Dates\nIn the previous sections you have converted date objects into formatted text Lets look at converting text \ninto Date  objects This is accomplished by using the parse  method of the SimpleDateFormat  class The \nsignature of the parse  method is as follows\nDate parseString text ParsePosition startPos\nThe method takes two arguments The first argument is the text from which you want to extract the date \nThe second one is the starting position of the character in the text from where you want to start parsing The \ntext can have the date part embedded in it For example you can extract two dates from text such as First \ndate is 01011995 and second one is 12122001  Because the parser does not know where the date begins \nin the text you need to tell it using the ParsePosition  object It simply keeps track of the parsing position \nThere is only one constructor for the ParsePosition  class and it takes an int which is the position where \nparsing starts After the parse  method is successful the index for the ParsePosition  object is set to the \nindex of the last character of the date text used plus one Note that the method does not use all the text \npassed as its first argument It uses only the text as necessary to create a date object\nLets start with a simple example Suppose you have a string of 09191969  which represents the date \nSeptember 19 1969 You want to get a Date  object out of this string The following snippet of code illustrates \nthe steps\n Our text to be parsed\nString text  09191969\n Create a pattern for the date text 09191969\nString pattern  MMddyyyy\n Create a SimpleDateFormat object to represent this pattern\nSimpleDateFormat simpleFormatter  new SimpleDateFormatpattern\n Since the date part in text 09191969 start at index zero\n we create a ParsePosition object with value zero\nParsePosition startPos  new ParsePosition0Chapter 17  Formatting Data\n621 Parse the text\nDate parsedDate  simpleFormatterparsetext startPos\n Here parsedDate will have September 19 1969 as date and startPos current index\n will be set to 10 which you can get calling startPosgetIndex method\nLets parse more complex text If the text in the previous example were 09191969 Junk  you would \nhave gotten the same result because after reading 1969 the parser will not look at any more characters in \nthe text Suppose you have text XX01011999XX12312000XX  There are two dates embedded in the text \nHow would you parse these two dates Text for the first date starts at index 2 the first two Xs have indexes \n0 and 1 Once parsing is done for the first date text the ParsePosition  object will point to the third X in \nthe text You just need to increment its index by 2 to point to the first character of the second date text The \nfollowing snippet of code illustrates the steps\n Our text to be parsed\nString text  XX01011999XX12312000XX\n Create a pattern for our date text 09191969\nString pattern  MMddyyyy\n Create a SimpleDateFormat object to represent this pattern\nSimpleDateFormat simpleFormatter  new SimpleDateFormatpattern\n Set the start index at 2\nParsePosition startPos  new ParsePosition2\n Parse the text to get the first date January 1 1999\nDate firstDate  simpleFormatterparsetext startPos\n Now startPos has its index set after the last character of the first date parsed\n To set its index to the next date increment its index by 2\nint currentIndex  startPosgetIndex\nstartPossetIndexcurrentIndex  2\n Parse the text to get the second date December 31 2000\nDate secondDate  simpleFormatterparsetext startPos\nIt is left to the readers as an exercise to write a program that will extract the date in a Date  object \nfrom the text I was born on the day 19 of the month September in 1969  The date extracted should be \nSeptember 19 1969 Hint You already have the pattern for this text in one of the previous examples when \nyou worked on formatting date objects\nHeres one more example of parsing text that contains date and time Suppose you have the text 2003\n0403 091040325  which represents a timestamp in the format yearmonthday hourminutesecond\nmillisecond  You want to get the time parts of the timestamp Listing 173  shows how to get the time parts \nfrom this text\nListing 173  Parsing a Timestamp to Get Its Time Parts\n ParseTimeStampjava\npackage comjdojoformat\nimport javautilDate\nimport javautilCalendar\nimport javatextParsePosition\nimport javatextSimpleDateFormat\npublic class ParseTimeStamp \n    public static void mainString args\n        String input  20030403 091040325\n         Prepare the pattern\n        String pattern  yyyyMMdd HHmmssSSS Chapter 17  Formatting Data\n622        SimpleDateFormat sdf  new SimpleDateFormatpattern\n         Parse the text into a Date object\n        Date dt  sdfparseinput new ParsePosition0\n        Systemoutprintlndt\n         Get the Calendar instance\n        Calendar cal  CalendargetInstance\n         Set the time\n        calsetTimedt\n         Print time parts\n        SystemoutprintlnHour  calgetCalendarHOUR\n        SystemoutprintlnMinute  calgetCalendarMINUTE\n        SystemoutprintlnSecond  calgetCalendarSECOND\n        SystemoutprintlnMillisecond  calgetCalendarMILLISECOND\n    \n\nThu Apr 03 091040 CST 2003\nHour9\nMinute10\nSecond40\nMillisecond325\n Formatting Numbers\nIn this section we discuss how to format numbers We also discuss how to parse a string to create a Number  \nobject The following two classes can be used to format and parse numbers\n\tjavatextNumberFormat\n\tjavatextDecimalFormat\nThe NumberFormat  class is used to format numbers in a particular locales predefined format The \nDecimalFormat  class is used to format numbers in a format of your choice in a particular locale\n Using Predefined Number Formats\nYou can use a getXxxInstance  method of the NumberFormat  class to get an instance of a formatter object \nwhere Xxx can be replaced by Number  Currency  Integer  or Percent  or just getInstance  These methods \nare overloaded If you call them without any argument they return a formatter object for the default locale \nCall the format  method passing the number as an argument to get the formatted number as a string The \nfollowing snippet of code shows you how to get different types of number formatter for different locales It \nalso shows you how to use a currency formatter for US locale to format a salary Note that it does formatting \nonly not currency conversion\n Get a number formatter for default locale\nNumberFormat defaultFormatter  NumberFormatgetNumberInstance\n Get a number formatter for French France locale\nNumberFormat frenchFormatter  NumberFormatgetNumberInstanceLocaleFRENCH\n Get a currency formatter for USChapter 17  Formatting Data\n623NumberFormat usCurrencyFormatter  NumberFormatgetCurrencyInstanceLocaleUS\ndouble salary  1259090\nString str  usCurrencyFormatterformatsalary\nSystemoutprintlnSalary in US currency   str\nSalary in US currency 1259090\nListing 174  illustrates how to format numbers in default format for the current locale the United States \nis the default locale for this example and Indian locale\nListing 174  Formatting Numbers Using Default Formats\n DefaultNumberFormattersjava\npackage comjdojoformat\nimport javautilLocale\nimport javatextNumberFormat\npublic class DefaultNumberFormatters \n    public static void mainString args\n        double value  1566789785 \n         Default locale\n        printFormattedLocalegetDefault value\n         Indian locale\n         Rupee is the Indian currency Short form is Rs\n        Locale indianLocale  new Localeen IN\n        printFormattedindianLocale value\n    \n    public static void printFormattedLocale locale double value \n         Get number and currency formatter\n        NumberFormat nf  NumberFormatgetInstancelocale\n        NumberFormat cf  NumberFormatgetCurrencyInstancelocale\n        SystemoutprintlnFormatting value   value   for locale   locale\n        SystemoutprintlnNumber      nfformatvalue\n        SystemoutprintlnCurrency   cfformatvalue\n    \n\nFormatting value 1566789785 for locale enUS\nNumber 1566789785\nCurrency 156678978\nFormatting value 1566789785 for locale enIN\nNumber 1566789785\nCurrency Rs 156678978\n Using Custom Number Formats\nTo perform more advanced formatting you can use the DecimalFormat  class It allows you to supply your \nown format pattern Once you create an object of the DecimalFormat  class you can change the format \npattern using its applyPattern  method You can specify different patterns for positive and negative \nnumbers The two patterns are separated by a semicolonChapter 17  Formatting Data\n624The DecimalFormat  class uses roundtoeven rounding mode while formatting numbers For example \nif you have specified only two digits after the decimal point in your number format 12745 will be rounded \nto 1274 because 5 is in the middle and 4 is even 12735 will also be rounded to 1274 because 5 is in the \nmiddle and the nearest even number at the second position would be 4 and 12746 will be rounded to 1275 \nListing 175  illustrates the use of the DecimalFormat  class\nListing 175  Formatting Numbers\n DecimalFormatterjava\npackage comjdojoformat\nimport javatextDecimalFormat\npublic class DecimalFormatter \n    private static DecimalFormat formatter  new DecimalFormat\n    public static void mainString args \n        formatNumber 12745\n        formatNumber 12746\n        formatNumber00000000 12735\n        formatNumber 12735\n         Positive and negative number format\n        formatNumber 12735\n        formatNumber 12735\n    \n    public static void formatNumberString pattern double value \n         Apply the pattern\n        formatterapplyPatternpattern\n         Format the number\n        String formattedNumber  formatterformatvalue\n        SystemoutprintlnNumber   value   Pattern \n                 pattern   Formatted Number \n                 formattedNumber\n    \n\nNumber 12745 Pattern  Formatted Number 1274\nNumber 12746 Pattern  Formatted Number 1275\nNumber 12735 Pattern 00000000 Formatted Number 00127350\nNumber 12735 Pattern  Formatted Number 1273\nNumber 12735 Pattern  Formatted Number 1273\nNumber 12735 Pattern  Formatted Number 1273\n Parsing Numbers\nYou can also parse a string to a number using the parse  method of the DecimalFormat  class The parse  \nmethod returns an object of the javalangNumber  class You can use xyzValue  methods to get the \nprimitive value where xyz can be byte  double  float  int long  or short \nListing 176  illustrates the use of the DecimalFormat  class to parse a number Note that you can also use \nthe parseDouble  method of the javalangDouble  class to parse a string into a double  value However \nthe string has to be in the default number format The advantage of using the parse  method of the \nDecimalFormat  class is that the string can be in any formatChapter 17  Formatting Data\n625Listing 176  Parsing Numbers\n ParseNumberjava\npackage comjdojoformat\nimport javatextDecimalFormat\nimport javatextParsePosition\npublic class ParseNumber \n    public static void mainString args \n         Parse a string to decimal number\n        String str  XY4123983\n        String pattern  \n        DecimalFormat formatter  new DecimalFormatpattern\n         Create a ParsePosition object to specify the first digit of number\n         in the string It is 4  in XY4123983 with the index 2\n        ParsePosition pos  new ParsePosition2\n        Number numberObject  formatterparsestr pos\n        double value  numberObjectdoubleValue\n        SystemoutprintlnParsed Value is   value\n    \n\nParsed Value is 4123983\n printfStyle Formatting\nIn this section we discuss how to format objects and values using printf style formatting similar to that \nsupported by the printf  function in C\u00a0First we cover the general ideas of the printf style formatting \nsupport in Java and then cover the details of formatting all types of values\n The Big Picture\nThe javautilFormatter  class supports printf style formatting which is similar to the formatting \nsupported by the printf  function in the C programming language If you are familiar with C C and \nC it should be easier for you to understand the discussion in this section In this section you will use \nformatting strings such as 1s  14d  etc in your code without a full explanation of their meanings \nYou may not be able to understand them fully you should ignore them for now Just focus on the output \nand try to get the bigger picture of what the Formatter  class is intended to accomplish rather than trying to \nunderstand the details We discuss the details in the next section Lets start with a simple example shown in \nListing 177  You may get a slightly different output\nListing 177  Using Cs printfStyle Formatting in Java\n PrintfTestjava\npackage comjdojoformat\nimport javautilDate\npublic class PrintfTest \n    public static void mainString args \n         Formatting strings\n        Systemoutprintf1s 2s and 3s n Fu Hu LoChapter 17  Formatting Data\n626        Systemoutprintf3s 2s and 1s n Fu Hu Lo\n         Formatting numbers\n        Systemoutprintf14d 24d 34d n 1 10 100\n        Systemoutprintf14d 24d 34d n 10 100 1000\n        Systemoutprintf14d 24d 34d n 1 10 100\n        Systemoutprintf14d 24d 34d n 10 100 1000\n         Formatting date and time\n        Date dt  new Date\n        SystemoutprintfToday is tD n dt\n        SystemoutprintfToday is tF n dt\n        SystemoutprintfToday is tc n dt\n    \n\nFu Hu and Lo\nLo Hu and Fu\n1  10  100\n10 100 1000\n1  10  100\n10 100 1000\nToday is 080621\nToday is 20210806\nToday is Sun Aug 06 102903 CDT 2021\nYou have been using the Systemoutprintln  and Systemoutprint  methods to print text on the \nstandard output In fact Systemout  is an instance of the javaioPrintStream  class which has println  \nand print  instance methods The PrintStream  class contains two more methods format  and \nprintf  which can be used to write a formatted output to a PrintStream  instance Both methods work the \nsame Listing 175  uses the Systemoutprintf  method to print the formatted text to the standard output\nThe String  class contains a format  static method which returns a formatted string The formatting \nbehavior of the format printf  method of the PrintStream  class and the format  static method of the \nString  class is the same The only difference between them is that the format  or printf  method in the \nPrintStream  class writes the formatted output to an output stream whereas the format  method of the \nString  class returns the formatted output as a String \nThe format  and printf  methods of the PrintStream  class and the format  method of the String  \nclass are convenience methods They exist to make text formatting easier However the Formatter  class does \nthe real work Lets discuss the Formatter  class in detail You will use these convenience methods in the \nexamples A Formatter  is used to format text The formatted text can be written to the following destinations\n\t An Appendable eg StringBuffer StringBuilder Writer etc\n\t A file\n\t An OutputStream\n\t A PrintStream\nThe following snippet of code accomplishes the same thing as the code in Listing 177  This time you \nuse a Formatter  object to format the data When you call the format  method of the Formatter  object the \nformatted text is stored in the StringBuilder  object which you pass to the constructor of the Formatter  \nobject When you are done with formatting all text you call the toString  method of the StringBuilder  to \nget the entire formatted textChapter 17  Formatting Data\n627 Create an Appendable data storage for our formatted output\nStringBuilder sb  new StringBuilder\n Create a Formatter that will store its output to the StringBuffer\nFormatter fm  new Formattersb\n Formatting strings\nfmformat1s 2s and 3s n Fu Hu Lo\nfmformat3s 2s and 1s n Fu Hu Lo\n Formatting numbers\nfmformat14d 24d 34d n 1 10 100\nfmformat14d 24d 34d n 10 100 1000\nfmformat14d 24d 34d n 1 10 100\nfmformat14d 24d 34d n 10 100 1000\n Formatting date and time\nDate dt  new Date\nfmformatToday is tD n dt\nfmformatToday is tF n dt\nfmformatToday is tc n dt\n Display the entire formatted string\nSystemoutprintlnsbtoString\nIf you want to write all formatted text to a file you can do so using the following snippet of code You will \nneed to handle the FileNotFoundException  which may be thrown from the constructor of the Formatter  \nclass if the specified file does not exist When you are done with the Formatter  object you will need to call \nits close  method to close the output file Notice the use of a trywithresources  block in the sample \ncode so the formatter is closed automatically\nimport javaioFile\nimport javaioFileNotFoundException\nimport javautilFormatter\n\n Create a Formatter that will write the output to the file Ckishorixyztxt\ntry Formatter fm  new Formatternew FileCkishorixyztxt \n     Formatting strings\n    fmformat1s 2s and 3s n Fu Hu Lo\n    fmformat3s 2s and 1s n Fu Hu Lo\n catch FileNotFoundException e \n    eprintStackTrace\n\nThe format  method of the Formatter  class is overloaded Its declarations are as follows\n\tFormatter formatString format Object args\n\tFormatter formatLocale l String format Object args\nThe first version of the format  method uses the default locale for formatting The second version \nallows you to specify a locale The format printf  method of the PrintStream  class and the format  \nmethod of the String  class provide the same two versions of the format  method which accept the same \ntypes of arguments This discussion of the format  method of the Formatter  class equally applies to these \nconvenience methods in the PrintStream  and String  classes\nThe Formatter  class uses the localespecific formatting whenever it is applicable For example if you \nwant to format a decimal number say 1289 the number is formatted as 1289 notice a comma between \n12 and 89 in France whereas it is formatted as 1289 notice a dot between 12 and 89 in the United States Chapter 17  Formatting Data\n628The locale argument of the format  method is used to format text in a localespecific format The following \nsnippet of code demonstrates the effects of localespecific formatting Note the difference in the formatted \noutput for US and France for the same input values\nSystemoutprintfLocaleUS In US 12f n 1289\nSystemoutprintfLocaleFRANCE In France 12f n 1289\nDate dt  new Date\nSystemoutprintfLocaleUS In US tA n dt\nSystemoutprintfLocaleFRANCE In France tA n dt\nIn US 1289\nIn France 1289\nIn US Friday\nIn France vendredi\n The Details\nFormatting data using a Formatter  requires two types of inputs\n\t A format string\n\t A list of values\nThe format string is the template that defines how the output will look It contains zero or more \noccurrences of fixed texts and zero or more embedded format specifiers No formatting is applied to the fixed \ntext A format specifier serves two purposes It acts as a placeholder for the formatted data inside the format \nstring and it specifies how the data should be formatted\nLets consider the following example Suppose you want to print text with the birth date of a person The \nfollowing is an example of such a text\nJanuary 16 1970 is Johns birthday\n Note  all outputs in this section are in the US locale unless specified otherwise\nThe previous text contains fixed text and formatted text The fixed text should appear in the output \nliterally The formatted text will depend on the inputs You can convert the previous text into a template as \nshown\nmonth day year is names birthday\nYou have replaced the text that may vary with placeholders that are enclosed in angle brackets for \nexample month  day  etc You will need four input values month day year and name to use the \nprevious template to get a formatted text For example if you supply the values for month  day  year  \nand name  as January  16  1970  and John  respectively the template will produce\nJanuary 16 1970 is Johns birthdayChapter 17  Formatting Data\n629In this example you have just replaced the placeholders in your template with their actual values You \ndid not perform any formatting for the actual values The formatting that is provided by the Formatter  class \nworks in a similar fashion What we called a placeholder in this example is called a format specifier  What we \ncalled a template in this example is called a format string \nA format specifier always starts with a percent sign   You can convert your template into a format \nstring which can be used with the Formatter  class as follows\n1tB 1td 1tY is 2ss birthday\nIn this format string  1tB  1td  1tY  and 2s  are four format specifiers whereas    \n is   and s birthday  are fixed text\nThe following snippet of code uses this format string to print formatted text Note that dob and John  \nare the input values for the format string In this case the input value dob is an instance of the LocalDate  \nclass that contains the birth date\nLocalDate dob  LocalDateof1970 MonthJANUARY 16\nSystemoutprintf1tB 1td 1tY is 2ss birthday dob John\nJanuary 16 1970 is Johns birthday\nThe general syntax for a format specifier is as follows\nargumentindexflagswidthprecisionconversion\nExcept the  and conversion  parts all other parts are optional Note that there is no space between \nany two parts of a format specifier The  percent sign denotes the start of a format specifier inside a format \nstring If you want to specify  as a part of a fixed text inside a format string you need to use two consecutive \n as \nThe argumentindex  denotes the index of the argument that the format specifier refers to It consists \nof an integer in base10 format followed by a  dollar sign The first argument is referred to as 1 the \nsecond as 2 and so on You can refer to the same argument multiple times in different format specifiers \ninside the same format string\nThe flags  denotes the format of the output It is a set of characters The valid values for flags  \ndepend on the data type of the argument that the format specifier refers to\nThe width  denotes the minimum number of characters that need to be written to the output\nTypically the  precision  denotes the maximum number of characters to be written to the output \nHowever its exact meaning varies depending on the value for conversion  It is a decimal number It starts \nwith a dot  \nThe conversion  denotes how the output should be formatted Its value depends on the data type of \nthe argument which the format specifier refers to It is mandatory\nThere are two special format specifiers  and n The  format specifier outputs  a percent sign \nand n outputs a platformspecific new line character The following snippet of code demonstrates the use of \nthese two special format specifiers\nSystemoutprintfInterest rate is 10nJohnnDonna\nInterest rate is 10\nJohn\nDonnaChapter 17  Formatting Data\n630You have not supplied any arguments to the printf  method in the code because these two special \nformat specifiers do not work on any arguments Note the two new lines in the output that are generated by \nthe two n format specifiers in the format string\n Referencing an\u00a0Argument Inside a\u00a0Format Specifier\nWe have not covered the conversion part of the format specifier yet For the discussion in this section we \nuse s as the conversion character for the format specifiers The s conversion formats its argument as a string \nIn its simplest form you can use s as a format specifier Lets consider the following snippet of code and its \noutput\nSystemoutprintfs s and s Ken Lola Matt\nKen Lola and Matt\nA format specifier in a format string can refer to an argument in three ways\n\t Ordinary indexing\n\t Explicit indexing\n\t Relative indexing\n Ordinary Indexing\nWhen a format specifier does not specify an argument index value as in s it is called ordinary indexing \nIn ordinary indexing the argument index is determined by the index of the format specifier in the format \nstring The first format specifier without an argument index has the index of 1 the second has the index of \n2 and so on The format specifier with the index 1 refers to the first argument the format specifier with the \nindex 2 refers to the second argument and so on Figure\u00a0 171  shows the indexes of the format specifiers and \nthe arguments\nFigure 171  shows how indexes are mapped in the previous example The first s format specified refers \nto the first argument Ken  The second s format specified refers to the second argument Lola  And the \nthird s format specified refers to the third argument Matt Figure 171  Indexes of format specifiers in a format string and indexes of the argumentsChapter 17  Formatting Data\n631If the number of arguments is more than the number of format specifiers in the format string the extra \narguments are ignored Consider the following snippet of code and its output It has three format specifiers \nthree s and four arguments The fourth argument Lo  is an extra argument which is ignored\nSystemoutprintfs s and s Ken Lola Matt Lo\nKen Lola and Matt\nA javautilMissingFormatArgumentException  is thrown if a format specifier references a non\nexistent argument The following snippet of code will throw this exception because the number of \narguments is one less than the number of format specifiers There are three format specifiers but only two \narguments\n Compiles fine but throws a runtime exception\nSystemoutprintfs s and s Ken Lola\nNote that the last argument to the format  method of the Formatter  class is a varargs argument You \ncan also pass an array to a varargs argument The following snippet of code is valid even though it uses \nthree format specifiers and only one argument of array type The arraytype argument contains three values \nfor the three format specifiers\nString names  Ken Matt Lola\nSystemoutprintfs s and s names\nKen Matt and Lola\nThe following snippet of code is also valid because it passes four values in the arraytype argument but \nhas only three format specifiers\nString names  Ken Matt Lola Lo\nSystemoutprintfs s and s names\nKen Matt and Lola\nThe following snippet of code is not valid because it uses an arraytype argument that has only two \nelements and there are three format specifiers A MissingFormatArgumentException  will be thrown when \nthe following snippet of code is run\nString names  Ken Matt\nSystemoutprintfs s and s names  Throws an exceptionChapter 17  Formatting Data\n632 Explicit Indexing\nWhen a format specifier specifies an argument index explicitly it is called explicit indexing Note that an \nargument index is specified just after the  sign in a format specifier It is an integer in the decimal format \nand it ends with  a dollar sign Consider the following snippet of code and its output It uses three format \nspecifiers 1s  2s  and 3s  which use explicit indexing\nSystemoutprintf1s 2s and 3s Ken Lola Matt\nKen Lola and Matt\nWhen a format specifier uses explicit indexing it can refer to an argument at any index in the argument \nlist using the index of the argument Consider the following snippet of code\nSystemoutprintf3s 1s and 2s Lola Matt Ken\nKen Lola and Matt\nThis snippet of code has the same output as the snippet of code before it However in this case the \nvalues in the argument list are not in the same order The first format specifier 3s  refers to the third \nargument Ken  the second format specifier 1s  refers to the first argument Lola  and the third format \nspecifier 2s  refers to the second argument Matt \nIt is allowed to reference the same argument multiple times using explicit indexing It is also allowed \nnot to reference some arguments inside the format string In the following snippet of code the first argument \nof Lola  is not referenced and the third argument of Ken  is referenced twice\nSystemoutprintf3s 2s and 3s Lola Matt Ken\nKen Matt and Ken\n Relative Indexing\nThere is a third way to refer to an argument inside a format specifier which is called relative indexing In relative \nindexing a format specifier uses the same argument that was used by the previous format specifier Relative \nindexing does not use an argument index value Rather it uses the  character as a flag in the format specifier \nSince in relative indexing a format specifier uses the same argument that is used by the previous format \nspecifier it cannot be used with the first format specifier because there is no previous format specifier for the \nfirst format specifier Consider the following snippet of code and its output which uses relative indexing\nSystemoutprintf1s s s 2s and s Ken Matt\nKen Ken Ken Matt and Matt\nThis snippet of code uses five format specifiers 1s  s s 2s  and s It uses two arguments \nKen  and Matt  Note that it is possible to have less number of arguments than the number of format \nspecifiers if some format specifiers use relative indexing The first format specifier of 1s  uses explicit \nindexing to reference the first argument Ken  The second format specifier of s uses relative indexing Chapter 17  Formatting Data\n633notice the  flag and therefore it will use the same argument which was used by the previous format \nspecifier 1s This way both the first and the second format specifiers use the first argument Ken  This \nis confirmed by the output that displays Ken  as the first two names The third format specifier of s also \nuses relative indexing It will use the same argument as used by the previous format specifier the second \nformat specifier Since the second format specifier used the first argument Ken  the third one will also \nuse the same argument This is confirmed in the output that shows Ken  as the third name The fourth \n2s  format specifier uses explicit indexing to use the second argument of Matt  The fifth and last format \nspecifier of s uses relative indexing and it will use the same argument that is used by its previous format \nspecifier the fourth format specifier Since the fourth format specifier uses the second argument Matt  \nthe fifth format specifier will also use the second argument of Matt  This is confirmed in the output that \ndisplays Matt  as the fifth name\nThe following statement will throw a MissingFormatArgumentException  because it uses relative \nindexing for the first format specifier\nSystemoutprintfs s s 2s and s Ken Matt\nIt is possible to mix all three types of indexing to reference arguments inside different format specifiers \nin the same format string Consider the following statement and its output\nSystemoutprintf1s s s s and s Ken Matt\nKen Ken Ken Matt and Matt\nThe first format specifier uses explicit indexing to use the first argument of Ken  The second and the \nfourth format specifiers both s use ordinary indexing The third and the fifth format specifiers both s \nuse relative indexing It is clear from the rule of relative indexing that the third and fifth format specifiers \nwill use the same arguments as used by the second and the fourth format specifiers respectively Which \narguments will be used by the second and the fourth format specifiers The answer is simple When you \nhave some format specifiers that use ordinary indexing and some explicit indexing just for the purpose \nof understanding this rule ignore the format specifiers that use explicit indexing and number the format \nspecifiers that use ordinary indexing as 1 2 and so on Using this rule you can think of the previous \nstatement the same as the following one\nSystemoutprintf1s 1s s 2s and s Ken Matt\nNotice that you have replaced the first occurrence of s with 1s  and the second occurrence with 2s  \nas if they were using explicit indexing This explains the output generated by the previous statement\n Using Flags in\u00a0a\u00a0Format Specifier\nFlags act as modifiers They modify the formatted output Table\u00a0 173  lists all flags that can be used in a \nformat specifierChapter 17  Formatting Data\n634The valid use of a flag depends on the context of its use Depending on the value being formatted it is \nallowed to use multiple flags in a format specifier For example the format specifier 1012d  uses three \nflags  0 and  If 122899  is used as the argument by this format specifier it will output 000122899  The \neffects of using each flag are discussed in detail when we discuss formatting for different data types in the \nsections to follow\n Conversion Characters\nDifferent conversion characters are used to format values of different data types For example s is used to \nformat a value as a string The valid values for other parts in a format specifier are also determined by the \nconversion character and the data type of the argument that the format specifier references Formatting \ntypes based on data types can be broadly classified into in four categoriesTable 173  List of Valid Flags Their Descriptions and Examples of Their Usage\nFlag Description Examples\nFormat String Argument Formatted Text\n The result is left justified Note that the result is right \njustified when you do not use the  flag in a format \nspecifier6s Ken    Ken\n6s Ken Ken   \n The argument is formatted in alternate form \ndepending on the conversion part of the format \nspecifier The example shows the same decimal \nnumber 6270185 being formatted to a hexadecimal \nformat When the  flag is used the hexadecimal \nnumber is prefixed with 0xx 6270185 5face9\nx 6270185 0x5face9\n The result contains a  sign for positive values  \nIt applies only to numeric valuesd 105 105\nd 105 105\n  The result contains a leading space for positive \nvalues It applies only to numeric valuesd 105 105\n d 105  105\n0 The result is zero padded It applies only to  \nnumeric values6d 105   105\n06d 105 000105\n The result contains a localespecific grouping \nseparator It applies only to numeric values For \nexample a comma is used as a thousand separator \nin US locale whereas a space is used in France \nlocaled 89105 89105\nUS Locale\nd 89105 89 105\nFrance \nlocale\n The result is enclosed in parentheses for a negative \nnumber It applies only to numeric valuesd 1969 1969\nd 1969 1969\n It causes the argument for the previous format \nspecifier to be reused It is mostly used in formatting \ndates and timess and s Ken Ken and KenChapter 17  Formatting Data\n635\t General formatting\n\t Character formatting\n\t Numeric formatting\n\t Datetime formatting\nMany of the conversion characters have uppercase variants For example S is the uppercase variant of s \nThe uppercase variant converts the formatted output to uppercase as if the outputtoUpperCase  method \nwas called where output  is the reference to the formatted output string The following statement and its \noutput demonstrate the effect of using the uppercase variant S Note that s produces Ken  and S produces \nKEN  for the same input value Ken \nSystemoutprintfs and S Ken\nKen and KEN\n General Formatting\nThe general formatting can be used to format values of any data types Table\u00a0 174  has the list of conversions \nthat are available under the general formatting category\nThe general syntax for a format specifier for general formatting is as follows\nargumentindexflagswidthprecisionconversion\nThe width denotes the minimum number of characters to be written to the output If the length of the \nstring representation of the argument is less than the width value the result will be padded with spaces The \nspace padding is performed to the left of the argument value If a  flag is used space padding is performed \nto the right The value of width alone does not decide the content of the result The values of width and \nprecision together decide the final content of the resultTable 174  List of Conversion Characters for General Formatting\nConversion Uppercase\nVariantDescription\nb B It produces true  or false  based on the value of the argument It produces false  \nfor a null  argument and for a Boolean argument whose value is false Otherwise it \nproduces true \nh H It produces a string that is the hash code value in hexadecimal format of the \nargument If the argument is null  it produces null \ns S It produces a string representation of the argument If the argument is null  it \nproduces a null  string If the argument implements the Formattable  interface \nit invokes the formatTo  method on the argument and the returned value is \nthe result If the argument does not implement the Formattable  interface the \ntoString  method is invoked on the argument to get the resultChapter 17  Formatting Data\n636The precision denotes the maximum number of characters to be written to the output The precision is \napplied to the argument before the width is applied You need to understand the consequences of applying \nthe precision before the width If the precision is less than the length of the argument the argument is \ntruncated to the precision and space padding is performed to match the length of the output to the value of \nthe width Consider the following snippet of code\nSystemoutprintf41s Ken\n   K\nThe argument is Ken  and the format specifier is 41s  where 4 is the width and 1 is the precision \nFirst the precision is applied that will truncate the value Ken  to K Now the width is applied which states \nthat a minimum of four characters should be written to the output However after the precision is applied \nyou have only one character left Therefore K will be left padded with three spaces to match the width value \nof four\nConsider the following snippet of code\nSystemoutprintf14s Ken\nKen\nThe argument value is Ken  and the format specifier is 14s  where 1 is the width and 4 is the \nprecision Because the precision value of 4 is greater than the length of the argument which is 3 there is \nno effect of the precision Because the width value of 1 is less than the width of the result after precision is \napplied there is no effect of the width value on the output\nThe following are a few examples of using Boolean string and hash code formatting conversions \nNote that the hash code formatting conversion  h and H outputs the hash code value of the argument in \na hexadecimal format These examples also demonstrate the effect of using the uppercase variants of the \nconversions\n Boolean conversion\nSystemoutprintfb 5b 3bn true false true\nSystemoutprintfb 5b 3bn Ken Matt Lola\nSystemoutprintfB 5B 3Bn Ken Matt Lola\nSystemoutprintfb n 1969\nSystemoutprintfb n new Object\ntrue false tru\ntrue  true tru\nTRUE  TRUE TRU\ntrue\ntrue\n String conversion\nSystemoutprintfs 5s 3sn Ken Matt Lola\nSystemoutprintfS 5S 3Sn Ken Matt Lola\n Use  flag to leftjustify the result You must use width when you specify the  flag\nSystemoutprintfS 5S 3Sn Ken Matt LolaChapter 17  Formatting Data\n637Systemoutprintfs n 1969\nSystemoutprintfs n true\nSystemoutprintfs n new Object\nKen  Matt Lol\nKEN  MATT LOL\nKEN MATT  LOL\n1969\ntrue\njavalangObjectde6f34\n Hash Code conversion\nSystemoutprintfh 5h 3hn Ken Matt Lola\nSystemoutprintfH 5H 3Hn Ken Matt Lola\nSystemoutprintfh n 1969\nSystemoutprintfh n true\nSystemoutprintfh n new Object\n12634 247b34 243\n12634 247B34 243\n7b1\n4cf\n156ee8e\nIf you pass a value of a primitive type as an argument to the format  method of the Formatter  class \nor the printf  method of the PrintStream  class the primitivetype value is converted to a reference type \nusing an appropriate type of wrapper class using the autoboxing rules For example this statement\nSystemoutprintlns 1969\nis converted to\nSystemoutprintlns new Integer1969\n Writing a\u00a0Custom Formatter\nThe Formatter  class supports custom formatting through s and S conversions If the argument implements \nthe javautilFormattable  interface the s conversion calls the formatTo  method on the argument to \nget the formatted result The formatTo  method is passed the reference of a Formatter  object flags and \nwidth and precision values that are used in the format specifier You can apply any custom logic inside \nthe formatTo  method of the class to format the objects of your class Listing 178  contains the code for a \nFormattablePerson  class which implements the Formattable  interface\nListing 178  Implemen ting a Custom Formatter Using the Formattable Interface\n FormattablePersonjava\npackage comjdojoformat\nimport javautilFormattable\nimport javautilFormatterChapter 17  Formatting Data\n638import javautilFormattableFlags\npublic class FormattablePerson implements Formattable \n    private String firstName  Unknown\n    private String lastName  Unknown\n    public FormattablePersonString firstName String lastName \n        thisfirstName  firstName\n        thislastName  lastName\n    \n     Other code goes here \n    Override\n    public void formatToFormatter formatter int flags int width int precision \n        String str  thisfirstName     thislastName\n        int alternateFlagValue  FormattableFlagsALTERNATE  flags\n        if alternateFlagValue  FormattableFlagsALTERNATE \n            str  thislastName     thisfirstName\n        \n         Check if uppercase variant of the conversion is being used\n        int upperFlagValue  FormattableFlagsUPPERCASE  flags\n        if upperFlagValue  FormattableFlagsUPPERCASE \n            str  strtoUpperCase\n        \n         Call the format method of formatter argument\n         so our result is stored in it and the caller will get it\n        formatterformatstr\n    \n\nYour Formattable  person has a first name and a last name The logic inside the formatTo  method \nis intentionally kept simple You check for alternate flag  If this flag is used in the format specifier you \nformat the person name in the LastName FirstName  format If the alternate flag is not used you format the \nperson name in the FirstName LastName  format You also support uppercase variant S to s conversion If \nS conversion is used you format the person name in uppercase Your logic does not use other values of the \nflags width and precision The flags are passed in as an int value as bitmask To check if a flag was passed \nyou will need to use the bitwise  operator The operands to be used in the bitwise  operator are defined by \nconstants in the javautilFormattableFlags  class For example to check if the format specifier uses a left\njustify  flag you need to use the following logic\nint leftJustifiedFlagValue  FormattableFlagsLEFTJUSTIFY  flags\nif leftJustifiedFlagValue  FormattableFlagsLEFTJUSTIFY \n     Leftjustified flag  is used\n else \n     Leftjustified flag  is not used\n\nYou can use your FormattablePerson  objects with format specifiers using string conversion s and S as \nshown here\nFormattablePerson fp  new FormattablePersonKen Smith\nSystemoutprintfs n fp \nSystemoutprintfs n fp \nSystemoutprintfS n fp \nSystemoutprintfS n fp Chapter 17  Formatting Data\n639Ken Smith\nSmith Ken\nKEN SMITH\nSMITH KEN\n Character Formatting\nCharacter formatting may be applied to the values of char  primitive data type or Character  objects It \ncan also be applied to the values of byte  Byte  short  Short  int or Integer  type if their values are valid \nUnicode code points You can test if an integer value represents a valid Unicode code point by using the \nisValidCodePointint value  static method of the Character  class\nThe conversion character for character formatting is c Its uppercase variant is C The flag  and the \nprecision are not supported for character formatting The flag  and width  have the same meaning as in \nthe context of the general formatting The following snippet of code demonstrates the use of character \nformatting\nSystemoutprintfc n a\nSystemoutprintfC n a\nSystemoutprintfC n 98\nSystemoutprintf5C n 100\nSystemoutprintf5C n 100\na\nA\nB\n    D\nD    \n Numeric Formatting\nNumeric formatting can be broadly classified into two categories\n\t Integral number formatting\n\t Floatingpoint number formatting\nA lot of localespecific formatting is automatically applied when a numeric value is formatted For \nexample the numeric digits that are used for number formatting are always localespecific If the formatted \nnumber contains a decimal separator or group separators they are always replaced with localespecific \ndecimal separator or group separators respectively The following snippet of code shows the same number \n1234567890  formatted differently for three different localesUS Indian and Thailand\nLocale englishUS  new Locale en US\nLocale hindiIndia  new Locale hi IN\nLocale thaiThailand  new Locale th TH TH\nSystemoutprintfenglishUS d n 1234567890\nSystemoutprintfhindiIndia d n 1234567890\nSystemoutprintfthaiThailand d n 1234567890Chapter 17  Formatting Data\n640\n \nIntegral Number Formatting\nThe integral number formatting deals with formatting whole numbers It can be applied to format values \nof byte  Byte  short  Short  int Integer  long  Long  and BigInteger  Table\u00a0 175  contains the list of \nconversions that are available under the integral number formatting category\nThe general syntax for a format specifier for integral number formatting is as follows\nargumentindexflagswidthconversionTable 175  List of Conversions Applicable to byte Byte short Short int Integer long Long and BigInteger \nData Types\nConversion Uppercase\nVariantDescription\nd It formats the argument in\u00a0localespecific decimal integer base10 The  flag \ncannot be used with this conversion\no It formats the argument as a base8 integer without any localization If the  \nflag is used with this conversion the output always begins with a 0 a zero \nThe      and  flags cannot be used with this conversion\nx X It formats the argument as a base16 integer without any localization If the \n flag is used with this conversion the output always begins with a 0x When \nthe uppercase variant X is used with the  flag the output always begins with \n0X The      and  flags cannot be used with this conversion with \nan argument of byte Byte  short  Short  int Integer  long  and Long  data \ntypes The  flag cannot be used with this conversion with an argument of \nBigInteger  data typeChapter 17  Formatting Data\n641Note that the precision part in a format specifier is not applicable to integral number formatting The \nfollowing snippet of code demonstrates the use of the d conversion with various flags to format integers\nSystemoutprintfd n 1969\nSystemoutprintf6d n 1969\nSystemoutprintf6d n 1969\nSystemoutprintf06d n 1969\nSystemoutprintfd n 1969\nSystemoutprintfd n 1969\nSystemoutprintf d n 1969\nSystemoutprintf d n 1969\nSystemoutprintfd n 1969\nSystemoutprintfd n 1969\n1969\n  1969\n1969  \n001969\n1969\n1969\n 1969\n1969\n1969\n1969\nWhen conversions o and x are used with a negative argument of byte  Byte  short Short  int \nInteger  long  or Long  data type the argument value is first converted to an unsigned number by adding a \nnumber 2N to it where N is the number of bits used to represent the value of the data type of the argument \nFor example if the argument data type is byte  which takes 8 bits to store the value the argument value  \nof X will be converted to a positive value of X  256  by adding 256 to it The result contains the base8 or \nbase16 equivalent of the value X  256  The conversions o and x do not transform the negative argument \nvalue to an unsigned value for a BigInteger  argument type Consider the following snippet of code and the \noutput\nbyte b1  9\nbyte b2  9\nSystemoutprintfo n b1\nSystemoutprintfo n b2\n11\n367\nThe conversion o outputs the base8 integer 11 for a positive decimal integer 9 However when a \nnegative decimal integer 9 is used with the o conversion 9 is converted to a positive number 9  256  \n247  The final output contains 367 which is the base8 equivalent of the decimal 247Chapter 17  Formatting Data\n642The following snippet of code shows some more examples of o and x conversions for int and \nBigInteger  argument types\nSystemoutprintfo n 1969\nSystemoutprintfo n 1969\nSystemoutprintfo n new BigInteger1969\nSystemoutprintfo n new BigInteger1969\nSystemoutprintfx n 1969\nSystemoutprintfx n 1969\nSystemoutprintfx n new BigInteger1969\nSystemoutprintfx n new BigInteger1969\nSystemoutprintfo n 1969\nSystemoutprintfx n 1969\nSystemoutprintfo n new BigInteger1969\nSystemoutprintfx n new BigInteger1969\n3661\n37777774117\n3661\n3661\n7b1\nfffff84f\n7b1\n7b1\n03661\n0x7b1\n03661\n0x7b1\nFloatingPoint Number Formatting\nFloatingpoint number formatting deals with formatting numbers which have a whole part and a fraction \npart It can be applied to format values of the float  Float  double  Double  and BigDecimal  data types \nTable\u00a0 176  contains the list of conversions used for floatingpoint number formattingChapter 17  Formatting Data\n643The general syntax for a format specifier for floatingpoint number formatting is as follows\nargumentindexflagswidthprecisionconversion\nThe precision has different meanings The meanings depend on the conversion character By default \nthe value of precision is 6 For e and f conversions the precision is the number of digits after the decimal \nseparator For the g conversion the precision is the total number of digits in the resulting magnitude after \nrounding Precision is not applicable to a conversion\nThe following snippet of code shows how to format floatingpoint numbers with the default precision \nwhich is 6\nSystemoutprintfe n 102\nSystemoutprintff n 102\nSystemoutprintfg n 102\nSystemoutprintfe n 0000002079\nSystemoutprintff n 0000002079\nSystemoutprintfg n 0000002079\nSystemoutprintfa n 0000002079Table 176  List of Conversions Applicable to float Float double Double and BigDecimal Data Types\nConversion Uppercase\nVariantDescription\ne E It formats the argument in a localespecific computerized scientific notation \nfor example 1969919e03 The output contains one digit followed by a \ndecimal separator which is followed by the exponent part For example \n1969919 will be formatted as 1969919e03 if the precision is 6 Precision is the \nnumber of digits after the decimal separator The group separator flag  cannot \nbe used with this conversion\ng G It formats the argument in a localespecific general scientific notation \nDepending on the value of the argument it acts as e conversion or f \nconversion It applies rounding to the value of the argument depending on the \nvalue of the precision\nIf the value after rounding is greater than or equal to 104 but less than \n10precision it formats the value as if f conversion was used\nIf the value after rounding is less than 104 or greater than or equal to \n10precision it formats the value as if e conversion was used\nNote that the total number of significant digits in the result is equal to the \nvalue of the precision By default a precision of 6 is used\nf It formats the argument in a localespecific decimal format Precision is the \nnumber of digits after the decimal separator The value is rounded depending \non the specified value of the precision\na A It formats the argument in hexadecimal exponential form It is not applicable \nto the argument of a BigDecimal  typeChapter 17  Formatting Data\n6441020000e01\n10200000\n102000\n2079000e06\n0000002\n207900e06\n197e03\n0x11709e564a6d14p19\nThe following snippet of code shows the effects of using width  and precision  in floatingpoint number \nformatting\nSystemoutprintf2e n 196927\nSystemoutprintf2f n 196927\nSystemoutprintf2g n 196927\nSystemoutprintf82e n 196927\nSystemoutprintf82f n 196927\nSystemoutprintf82g n 196927\nSystemoutprintf102e n 196927\nSystemoutprintf102f n 196927\nSystemoutprintf102g n 196927\nSystemoutprintf102e n 196927\nSystemoutprintf102f n 196927\nSystemoutprintf102g n 196927\nSystemoutprintf0102e n 196927\nSystemoutprintf0102f n 196927\nSystemoutprintf0102g n 196927\n197e03\n196927\n20e03\n197e03\n 196927\n 20e03\n  197e03\n   196927\n   20e03\n197e03   \n196927    \n20e03    \n00197e03\n000196927\n00020e03\nIf the argument value for a floatingpoint conversion is NaN or Infinity  the output contains the string \nNaN  or Infinity  respectively The following snippet of code shows the formatting of floatingpoint \nnumbers when their values are NaN or infinitiesChapter 17  Formatting Data\n645Systemoutprintf2e n DoubleNaN\nSystemoutprintf2f n DoublePOSITIVEINFINITY\nSystemoutprintf2g n DoubleNEGATIVEINFINITY\nSystemoutprintff n DoublePOSITIVEINFINITY\nSystemoutprintff n DoubleNEGATIVEINFINITY\nNaN\nInfinity\nInfinity\nInfinity\nInfinity\n Formatting Dates and\u00a0Times\nDatetime formatting deals with formatting date time and datetime It can be applied to format values of \nthe long  Long  javautilCalendar  javautilDate  and javatimetemporalTemporalAccessor  types \nThe value in a long Long type argument is interpreted as the milliseconds passed since January 1 1970 \nmidnight UTC\n Note  TemporalAccessor  is an interface added in Ja va 8 it is part of the new Da tetime api\u00a0all classes \nin the api that specify some kind of date time or both are TemporalAccessor LocalDate  LocalTime  \nLocalDateTime  and ZonedDateTime  are some examples of TemporalAccessor  refer to Cha pter 16 for \nmore information on using the new Date time api\nThe t conversion character is used to format datetime values It has an uppercase variant T The \ngeneral syntax for a format specifier for datetime formatting is as follows\nargumentindexflagswidthconversion\nNote that the precision part in a format specifier is not applicable to datetime formatting For date\ntime formatting the conversion is a twocharacter sequence The first character in the conversion is always \nt or T The second character is called the conversion suffix which determines the format of the datetime \nargument Tables 177  through 179  list all the conversion suffixes that can be used with tT datatime \nconversion character\nTable 177  List of Suffix Characters for Time Formatting\nConversion Suffix Description\nH A twodigit hour of the day for the 24hour clock The valid values are 0023 00 is used \nfor midnight\nI A twodigit hour of the day for the 12hour clock The valid values are 0112 The 01 \nvalue corresponds to one oclock in the morning or afternoon\nk It behaves the same as the H suffix except that it does not add a leading zero to the \noutput Valid values are 023\ncontinued Chapter 17  Formatting Data\n646Conversion Suffix Description\nl It behaves the same as I suffix except that it does not add a leading zero Valid values \nare 112\nM A twodigit minute within an hour Valid values are 0059\nS A twodigit second within a minute Valid values are 0060 The value 60 is a special \nvalue that is required to support leap seconds\nL A threedigit millisecond within a second Valid values are 000999\nN A ninedigit nanosecond within a second The valid values are 000000000\n999999999 The precision of the nanosecond value is dependent on the precision that \nis supported by the operating system\np It outputs a localespecific morning or afternoon marker in lowercase For example \nfor US locale it will output am  or pm  If you want the output in uppercase \neg AM  and PM  for US locale you need to use the uppercase variant T as the \nconversion character\nz It outputs the numeric time zone offset from GMT eg 0530\nZ It is a string abbreviation of the time zone eg CST EST IST etc\ns It outputs seconds since the beginning of the epoch starting at January 1 1970 \nmidnight UTC\nQ It outputs milliseconds since the beginning of the epoch starting at January 1 1970 \nmidnight UTCTable 177  continued \nTable 178  List of Suffix Characters for Date Formatting\nConversion Suffix Description\nB Localespecific full name of the month such as  January   February   etc for US locale\nb Localespecific abbreviated month name such as  Jan  Feb  etc for US locale\nh Same as b\nA Localespecific full name of the day of the week such as  Sunday  Monday  etc for \nUS locale\na Localespecific short name of the day of the week such as Sun  Mon  etc for US locale\nC It divides the fourdigit year by 100 and formats the result as two digits It adds a \nleading zero if the resulting number is one digit It ignores the fraction part from the \nresult of the division by 100 Valid values are 0099 For example if the fourdigit year \nis 2011 it will output 20 if the fourdigit year is 12 it will output 00\nY At least a fourdigit year It adds leading zeros if the year contains less than four digits \nFor example if the year is 789 it will output 0789 if the year is 2021 it will output 2021 \nif the year is 20189 it will output 20189\ny The last two digits of the year It adds a leading zero if necessary For example if the year \nis 9 it will output 09 if the year is 123 it will output 23 if the year is 2011 it will output 11\ncontinued Chapter 17  Formatting Data\n647The datatime formatting applies localization wherever it is applicable The following snippet of code \nformats the same date and time January 25 2014 114816 AM in US Indian and Thai locales Note the \nuse of the  flag in the format specifier It lets you use the argument that holds the date and time value in \nmultiple format specifiers\nLocale englishUS  LocaleUS\nLocale hindiIndia  new Locale hi IN\nLocale thaiThailand  new Locale th TH TH\n Construct a LocalDateTime\nLocalDateTime ldt  LocalDateTimeof2014 MonthJANUARY 25 11 48 16\nSystemoutprintfenglishUS In US tB te tY tT Tpn ldt\nSystemoutprintfhindiIndia In India tB te tY tT Tpn ldt\nSystemoutprintfthaiThailand In Thailand tB te tY tT Tpn ldtTable 179  List of Suffix Characters for DateTime Formatting\nConversion Suffix Description\nR It formats time in 24hour clock format as hour minute  Its effects are the same as \nusing tHtM  as a format specifier Examples are 1 123  0135  2130  etc\nT It formats time in 24hour clock format as hourminutesecond  Its effect is the \nsame as using tHtMtS  as a format specifier Examples are 112310  013501 \n213034  etc\nr It formats time in 12hour clock format as hourminutesecond morningafternoon \nmarker  Its effect is the same as using tItMtS T p as a format specifier The \nmorningafternoon marker may be localespecific 092345 AM  093000 PM  etc \nare examples of the US locale\nD It formats the date as tmtdty  such as 011911 \nF It formats the date as tYtmtd  such as 20110119 \nc It formats the date and time as ta tb td tT tZ tY  such as Wed Jan 19 \n115206 CST 201 1Conversion Suffix Description\nj A threedigit day of the year Valid values are 000366\nm A twodigit month Valid values are 0113 The special value of 13 is required to \nsupport the lunar calendar\nd A twodigit day of the month Valid values are 0131\ne Day of the month Valid values are 131 It behaves the same as d except that it does \nnot add a leading zero to the outputTable 177  continued Chapter 17  Formatting Data\n648\nThe following snippet of code formats the current date and time in the default locale US in this case \nYou will get different output when you run the code It uses a ZonedDateTime  argument that holds the \ncurrent datetime with time zone\nZonedDateTime currentTime  ZonedDateTimenow\nSystemoutprintftA tB te tY n currentTime\nSystemoutprintfTA TB te tY n currentTime\nSystemoutprintftD n currentTime\nSystemoutprintftF n currentTime\nSystemoutprintftc n currentTime\nSystemoutprintfTc n currentTime\nSaturday August 21 2021\nSATURDAY AUGUST 21 2021\n082121\n20210821\nSat Aug 21 205219 EDT 2021\nSAT AUG 21 205219 EDT 2021\nNote the effect of using the uppercase variant T as the conversion character It formats the argument in \nuppercase letters The definition of uppercase depends on the locale that is used If the locale does not have \ndifferent uppercase and lowercase letters the output will be the same when you use T or t as the conversion \ncharacter\n Summary\nThe DateFormat  class is used to format legacy dates and times using predefined formats whereas the \nSimpleDateFormat  class is used to format legacy dates and times in custom formats\nThe NumberFormat  class is used to format numbers in a particular locales predefined format The \nDecimalFormat  class is used to format a number in a format of your choice in a particular locale\nYou can use printf style formatting using the javautilFormatter  class to format strings numbers \nand datetime It lets you send the formatted output to a StringBuilder  a StringBuffer  a File  an \nOutputStream  a PrintStream  etc You have been using the Systemoutformat  and Systemout\nprintf  methods to send the formatted output to the standard output Use the static Stringformat  \nmethod to get a formatted string Use a Formatter  to send the formatted output to the destination of your \nchoice You can implement the Formattable  interface to apply a custom formatting to the objects of the \nclassChapter 17  Formatting Data\n649QUESTIONS AND EXERCISES\n 1 What class would you use to format a date in a javautilDate  object using a \npredefined localespecific format\n 2 What class would you use to format a date in a javautilDate  object using a \ncustom format\n 3 What class would you use to parse a date in a String  object to get a javautil\nDate  object\n 4 What class would you use to format a number in a predefined localespecific \nformat\n 5 What class would you use to format a number in a custom format\n 6 What class would you use to parse a double  in a string to get a number\n 7 assuming the current date returned by the new Date  expression in the \nfollowing snippet of code is January 12 1968 what will be the output of the \nfollowing snippet of code\nimport javatextSimpleDateFormat\nimport javautilDate\n\nSimpleDateFormat sdf  new SimpleDateFormatddMMyyyy\nString currDate  sdfformatnew Date\nSystemoutprintlncurrDate\n 8 What method would you use to print a formatted output to the standard output\nSystemoutprintln  or Systemoutprintf \n 9 What are the format specifiers for outputting a Boolean value a character an \ninteger a floatingpoint number and a string\n 10 the following statement throws a MissingFormatArgumentException  \nDescribe the reasons behind the exception and how you will fix it\nSystemoutprintfd f 1969\nSystemoutprintfd f 1969 2017\n 11 Write the output of the follo wing statement\nSystemoutprintfs sn Ken Lu\nSystemoutprintfs sn Ken Lu\nSystemoutprintfs s 2sn Ken LuChapter 17  Formatting Data\n650 12 Write the output for the follo wing snippet of code\nSystemoutprintlnnew DecimalFormatformat12675\nSystemoutprintf2fn 12675\nSystemoutprintf12fn 12675\nSystemoutprintf22fn 12675\nSystemoutprintf21fn 12675\n 13 Complete the follo wing snippet of code that will output  my birthday is on F riDaY \nSeptem Ber 19 1969 note that you have to output the names of the weekday \nand month in uppercase\nLocalDate bDay  LocalDateof1969 9 19\nString format   Your code goes here\nSystemoutprintfformat bDay\n 14 Write the output of the follo wing snippet of code\nSystemoutprintfdn 16\nSystemoutprintfxn 10\nSystemoutprintfcn a\nSystemoutprintf5C n a\nSystemoutprintf5C n a\n 15 Write the output of the follo wing snippet of code\nSystemoutprintfs s s 1s sn Li Hu Xi651\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307418CHAPTER 18\nRegular Expressions\nIn this chapter you will learn\n\t How to create regular expressions\n\t How to use convenience methods in the String  class to perform regular expression\nbased findandreplace\n\t How to use the Pattern  class to compile regular expressions\n\t How to use the Matcher  class to match a regular expression against an input string\n\t How to use groups in regular expressions\n\t How to perform advanced findandreplace using the Matcher  class\nAll example programs in this chapter are a member of a jdojoregex  module as declared in Listing 181 \nListing 181  The D eclaration of a jdojoregex Module\n moduleinfojava\nmodule jdojoregex \n    exports comjdojoregex\n\n What Is a\u00a0Regular Expression\nA regular expression  is a way to describe a pattern in a sequence of characters The pattern may be used to \nvalidate the sequence of characters to search through the sequence of characters to replace the sequence of \ncharacters matching the pattern with another sequence of characters etc\nLets start with an example Suppose you have a string which may be an email address How would \nyou make sure that the string is in a valid email address format At this point you are not interested in the \nexistence of the email address You just want to validate its format\nYou would like to validate the string against some rules For example it must contain an  sign which is \npreceded by at least one character and followed by a domain name Optionally you may specify that the text \npreceding the  sign must contain only letters digits underscores and hyphens The domain name must \ncontain a dot You may want to add some more validations If you just want to check for an  character in a \nstring you can do it by calling emailindexOf  where email  is the reference of the string holding the \nemail address If you want to make sure that there is only one  character in the email string you need to add \nmore logic In such cases you may end up with 2050 or even more lines of code depending on the number \nof validations you want to performChapter 18  regular expressions\n652This is where regular expressions come in handy It will make your email address validation easy You \ncan accomplish it in just one line of code Doesnt that sound too good to be true Just a little while ago you \nwere told that you might end up with 50 lines of code Now you are told that you could accomplish the same \nin just one line of code This is true It can be done in one line of code Before we go into the details of how to \ndo this lets list the steps needed to accomplish this task\n\t To validate these kinds of strings you need to recognize the pattern you are looking \nfor For example in the simplest form of email address validation the string should \nconsist of some text at least one character plus an  sign followed by some text for \ndomain name Lets ignore any other details for now\n\t You need a way to express the recognized pattern A regular expression is used to \ndescribe such a pattern\n\t You need a program that can match the pattern against the input string Such a \nprogram is also known as a regular expression engine\nSuppose you want to test whether a string is of the form XX where X is any character Strings aa  \nbf  and 3h  are in this form You can observe a pattern here The pattern is  A character followed by  \nwhich is followed by another character  How do you express this pattern in Java\nThe string   will represent your regular expression in this case In   the dots have a special \nmeaning They represent any character All characters that have special meanings inside a regular expression \nare called metacharacters We discuss metacharacters in the next section The String  class contains a \nmatches  method It takes a regular expression as an argument and returns true  if the whole string matches \nthe regular expression Otherwise it returns false  The signature of this method is\nboolean matchesString regex\nListing 182  contains the complete code to illustrate the use of the matches  method of the String  \nclass\nListing 182  Matching a String Against a Pattern\n RegexMatchjava\npackage comjdojoregex\npublic class RegexMatch \n    public static void mainString args \n         Prepare a regular expression to represent a pattern\n        String regex  \n         Try matching many strings against the regular expression\n        matchItak regex\n        matchItwebmasterjdojocom regex\n        matchItrj regex\n        matchItaN regex\n        matchIt regex\n    \n    public static void matchItString str String regex \n         Test for pattern match\n        boolean matched  strmatchesregex\n        Systemoutprintfs matched s  bn str regex matched\n    \nChapter 18  regular expressions\n653ak matched   true\nwebmasterjdojocom matched   false\nrj matched   true\naN matched   false\n matched   true\nSome important points to note are the following\n\t The regular expression   did not match webmasterjdojocom  because a dot \nmeans only one character and the Stringmatches  method matches the pattern \nin the regular expression against the entire string Note that the string webmaster\njdojocom  has the pattern represented by  that is a character followed by  and \nanother character However the pattern matches part of the string not the entire \nstring The rj  part of webmasterjdojocom  matches that pattern We present \nsome examples where you will match the pattern anywhere in the string rather than \nmatch the entire string\n\t If you want to match a dot character in a string you need to escape the dot \nin the regular expression The regular expression   will match any \nstring of three characters in which the middle character is a dot character \nFor example the method call abmatches  will return true  the \nmethod call matches  will return true  the method calls abc\nmatches  and aacamatches  will return false \nYou can also replace the matching string with another string The String  class has two methods to do \nthe match replacement\n\tString replaceAllString regex String replacementString\n\tString replaceFirstString regex String replacementString\nThe replaceAll  method replaces strings which match the pattern represented by the specified \nregex  with the specified replacementString  It returns the new string after replacement Some examples of \nusing the replaceAll  method are as follows\nString regex  \n newStr will contain webmastedojocom String newStr  webmasterjdojocom\nreplaceAllregex\n newStr will contain \nnewStr  ABreplaceAllregex\n newStr will contain and\nnewStr  ABandHGreplaceAllregex\n newStr will contain BT same as the original string\nnewStr  BTreplaceAllregex\nThe replaceFirst  method replaces the first occurrence of the match with the replacementString  \nIt returns the new string after replacement Some examples of using the replaceFirst  method are as \nfollows\nString regex  \n newStr will contain webmastedojocom\nString newStr  webmasterjdojocomreplaceFirstregex Chapter 18  regular expressions\n654 newStr will contain \nnewStr  ABreplaceFirstregex \n newStr will contain andHG\nnewStr  ABandHGreplaceFirstregex \n newStr will contain BT same as the original string\nnewStr  BTreplaceFirstregex \n Metacharacters\nMetacharacters are characters with special meanings They are used in regular expressions Sometimes \nmetacharacters do not have any special meanings and they are treated as ordinary characters They are \ntreated as ordinary characters or metacharacters depending on the context in which they are used The \nmetacharacters supported by the regular expressions in Java are as follows\n\t a left parenthesis\n\t a right parenthesis\n\t a left bracket\n\t a right bracket\n\t a left brace\n\t a right brace\n\t a backslash\n\t a caret\n\t a dollar sign\n\t a vertical bar\n\t a question mark\n\t an asterisk\n\t an addition sign\n\t a dot or period\n\t a lessthan sign\n\t a greaterthan sign\n\t a hyphen\n\t an equal to sign\n\t an exclamation mark\n Character Classes\nThe metacharacters  and  left and right brackets are used to specify a character class inside a regular \nexpression A character class is a set of characters The regular expression engine will attempt to match \none character from the set Note that a character class has no relation with a class construct or class files in \nJava The character class ABC  will match character A B or C For example the strings AV  BV  and Chapter 18  regular expressions\n655CV  will match the regular expression ABC  However the string HV  will not match the regular \nexpression ABC  because  is not preceded by A B or C As another example the string man  or men  \nwill match the regular expression maen \nWhen we use the word match  we mean that the pattern exists in a string We do not mean that the \nwhole string matches the pattern For example WEBJDOJOCOM  matches the pattern ABC  because \n is preceded by B The string ABANDYEAU  matches the pattern ABC  twice even though the string \ncontains three  signs The second  is not part of a match because it is preceded by D and not A B or C\nYou can also specify a range of characters using a character class The range is expressed using a \nhyphen   character For example AZ  in a regular expression represents any uppercase English \nletters 09  represents any digit between 0 and 9 If you use  in the beginning of a character class it \nmeans complement meaning not For example ABC  means any character except A B and C The \ncharacter class AZ  represents any character except uppercase English letters If you use  anywhere \nin a character class except in the beginning it loses its special meaning ie the special meaning of \ncomplement and it matches just a  character For example ABC  will match A B C or \nYou can also include two or more ranges in one character class For example azAZ  matches any \ncharacter a through z and A through Z azAZ09  matches any character a through z uppercase and \nlowercase and any digit 0 through 9 Some examples of character classes are listed in Table\u00a0 181 \n Predefined Character Classes\nSome frequently used predefined character classes are listed in Table\u00a0 182 Table 181  Examples of Character Classes\nCharacter Classes Meaning Category\nabc Character a b or c Simple character class\nxyz A character except x y and z Complement or negation\nap Characters a through p Range\nacxz Characters a through c or x through z which would \ninclude a b c x y or zUnion\n0948 Intersection of two ranges  4 5 6 7 or 8 Intersection\nazaeiou All lowercase letters minus vowels In other words \na lowercase letter which is not a vowel That is all \nlowercase consonantsSubtraction\nTable 182  List of the Predefined Regular Expression Character Classes\nPredefined Character Classes Meaning\n a dot Any character may or may not match line terminators Refer to the \nsection Line terminators in the API documentation of the javautil\nregexPattern  class for more details\nd A digit Same as 09 \nD A nondigit Same as 09 \ncontinued Chapter 18  regular expressions\n656If you allow all uppercase and lowercase letters underscore and digits in your email address \nvalidations the regular expression to validate email addresses of only three characters would be ww  \nNow you are one step ahead in your email address validation process Instead of allowing only A B or C \nin the first part of the email as expressed by regular expression ABC  now you are allowing any word \ncharacter as the first part as well as second part\n More Powers to\u00a0Regular Expressions\nUntil now you have seen only three methods of the String  class using the regular expressions The package \njavautilregex  contains three classes to support the full version of regular expressions Those classes are \nas follows\n\t Pattern\n\t Matcher\n\t PatternSyntaxException\nA Pattern  holds the compiled form of a regular expression The compiled form of a regular expression \nis its specialized inmemory representation to facilitate faster string matching\nA Matcher  associates the string to be matched with a Pattern  and it performs the actual match\nA PatternSyntaxException  represents an error in a malformed regular expression\n Compiling Regular Expressions\nA Pattern  holds the compiled form of a regular expression It is immutable It can be shared It has no \npublic  constructor The class contains a static compile  method which returns a Pattern  object The \ncompile  method is overloaded\n\tstatic Pattern compileString regex\n\tstatic Pattern compileString regex int flags\nThe following snippet of code compiles a regular expression into a Pattern  object\n Prepare a regular expression\nString regex  az\n Compile the regular expression into a Pattern object\nPattern p  PatterncompileregexPredefined Character Classes Meaning\ns A whitespace character Same as  tnx0Bfr  The list includes a \nspace a tab a new line a vertical tab a form feed and a carriage return \ncharacter\nS A nonwhitespace character Same as s \nw A word character Same as azAZ09  The list includes lowercase \nletters uppercase letters underscore and decimal digits\nW A nonword character Same as w Table 182  continued Chapter 18  regular expressions\n657The second version of the compile  method lets you specify flags that modify the way the pattern is \nmatched The flags  parameter is a bitmask The flags are defined as int constants in the Pattern  class as \nlisted in Table\u00a0 183 \nThe following snippet of code compiles a regular expression setting the CASEINSENSTIVE  and DOTALL  \nflags so the matching will be caseinsensitive for USASCII charset and the expression  a dot will match a \nline terminator For example An  will be matched by the following pattern\n Prepare a regular expression\nString regex  az\n Compile the regular expression into a Pattern object with\n the CASEINSENSITIVE and DOTALL flags\nPattern p  Patterncompileregex PatternCASEINSENSITIVE  PatternDOTALLTable 183  List of Flags Defined in the Pattern Class\nFlag Description\nPatternCANONEQ Enables canonical equivalence If this flag is set two characters match only if \ntheir full canonical decompositions match\nPattern \nCASEINSENSITIVEEnables caseinsensitive matching This flag sets the caseinsensitive matching \nonly for USASCII charset For caseinsensitive matching of Unicode charset \nthe UNICODECASE  flag should also be set in conjunction with this flag\nPatternCOMMENTS Permits whitespace and comments in pattern When this flag is set whitespace \nis ignored and embedded comments starting with  are ignored until the end of \na line\nPatternDOTALL Enables dotall  mode By default the expression  a dot does not match \nline terminators When this flag is set the expression matches any character \nincluding a line terminator\nPatternLITERAL Enables literal parsing of the pattern When this flag is set the characters in \nthe regular expression are treated literally That is metacharacters and escape \nsequences have no special meanings CASEINSENSTIVE  and UNICODECASE  flags \nretain their effects when used with this flag\nPatternMULTILINE Enables multiline mode By default the expressions  and  match the \nbeginning and the end of the entire input sequence When this flag is set \nthey match just after and just before a line terminator or the end of the input \nsequence respectively\nPatternUNICODECASE Enables Unicodeaware case folding When this flag is set in conjunction \nwith the CASEINSENSITIVE  flag the caseinsensitive matching is performed \naccording to the Unicode standard\nPatternUNICODE\nCHARACTERCLASSEnables the Unicode version of predefined character classes and POSIX  \ncharacter classes Setting this flag also has the effect of setting the UNICODECASE  \nflag When this flag is set the USASCII only predefined character classes and \nPOSIX  character classes are in conformance with Unicode Technical Standard \n18 Unicode Regular Expression Annex CCompatibility Properties\nPatternUNIXLINES Enables UNIX  lines mode When this flag is set only the n character is \nrecognized as a line terminatorChapter 18  regular expressions\n658 Creating a\u00a0Matcher\nAn instance of the Matcher  class is used to perform a match on a sequence of characters by interpreting \nthe compiled pattern held in a Pattern  object It has no public  constructor The matcher  method of the \nPattern  class is used to get an instance of the Matcher  class The method takes the string to be matched by \nthe pattern as an argument The following snippet of code shows how to get a Matcher \n Create a Pattern object and compile it into a Pattern\nString regex  az\nPattern p  Patterncompileregex\n String to perform the match\nString str  abcyahoocom123cnncomksharanjdojocom\n Get a matcher object using Pattern object p for str\nMatcher m  pmatcherstr\nAt this point the Matcher  object m has associated the pattern represented in the Pattern  object p with \nthe sequence of characters in str It is ready to start the match operation Typically a Matcher  object is used \nto find a match in the sequence of characters The match may succeed or fail If the match succeeds you \nmay be interested in knowing the start and end positions of the match and the matched text You can query a \nMatcher  object to get\u00a0all these pieces of information\n Matching the\u00a0Pattern\nYou need to use the following methods of the Matcher  to perform the match on the input\n\t The find  method\n\t The start  method\n\t The end  method\n\t The group  method\nThe find  method is used to find a match for the pattern in the input If the find succeeds it returns \ntrue  Otherwise it returns false  The first call to this method starts the search for the pattern at the \nbeginning of the input If the previous call to this method was successful the next call to this method starts \nthe search after the previous match Typically a call to the find  method is used in a while  loop to find all \nthe matches It is an overloaded method Another version of the find  method takes an integer argument \nwhich is the offset to start the find for a match\nThe start  method returns the start index of the previous match Typically it is used after a successful \nfind  method call\nThe end  method returns the index of the last character in the matched string plus one Therefore \nafter a successful invocation of the find  method the difference between the values returned by the end  \nand start  methods will give you the length of the matched string Using the substring  method of the \nString  class you can get the matched string as follows\n Continued from previous fragment of code\nif mfind \n     str is the string we are looking into\n    String foundStr  strsubstringmstart mend\n    SystemoutprintlnFound string is  foundStr\nChapter 18  regular expressions\n659The group  method returns the found string by the previous successful find  method call Recall that \nyou can also get the previous matched string using the substring  method of the String  class by using the \nstart and end of the match Therefore the previous snippet of code can be replaced with the following code\nif mfind \n    String foundStr  mgroup\n    SystemoutprintlnFound text is  foundStr\n\nListing 183  illustrates the use of these methods The validations for the methods arguments have been \nomitted for clarity The program attempts to find the abc  pattern in different strings\nListing 183  Using Pattern and Matcher Classes\n PatternMatcherjava\npackage comjdojoregex\nimport javautilregexPattern\nimport javautilregexMatcher\npublic class PatternMatcher \n    public static void mainString args \n        String regex  abc\n        String source  cricjdojocom is a valid email address\n        PatternMatcherfindPatternregex source\n        source  kellyjdojocom is invalid\n        PatternMatcherfindPatternregex source\n        source  abandyeau\n        PatternMatcherfindPatternregex source\n        source  There is an  sign here\n        PatternMatcherfindPatternregex source\n    \n    public static void findPatternString regex String source \n         Compile regex into a Pattern object\n        Pattern p  Patterncompileregex\n         Get a Matcher object\n        Matcher m  pmatchersource\n         Print regex and source text\n        SystemoutprintlnnRegex   regex\n        SystemoutprintlnText   source\n         Perform find\n        boolean found  false\n        while mfind \n            SystemoutprintfMatched Text s Start s End sn\n                    mgroup mstart mend\n             We found at least one match Set the found flag to true\n            found  true\n        \n        if found \n             We did not find any match\n            SystemoutprintlnNo match found\n        \n    \nChapter 18  regular expressions\n660Regex abc\nText cricjdojocom is a valid email address\nMatched Text cj Start 3 End 6\nRegex abc\nText kellyjdojocom is invalid\nNo match found\nRegex abc\nText abandyeau\nMatched Text ab Start 0 End 3\nMatched Text au Start 9 End 12\nRegex abc\nText There is an  sign here\nNo match found\n Querying a\u00a0Match\nIn the previous section we showed you how to query a Matcher  for the state or details of a match The \nmethods to get such states were start  end  group  and groupCount  The match state can also be \nrepresented as an instance of MatchResult  which is an interface You can use the following methods of \nMatchResult  to get the match state\n\tint end\n\tint endint group\n\tString group\n\tString groupint group\n\tint groupCount\n\tint start\n\tint startint group\nHow do you get an instance of MatchResult  Call the toMatchResult  method of a Matcher  get to a \ncopy of the match state\nMatcher m   get a matcher here \nwhile mfind \n    MatchResult result  mtoMatchResult\n     Use result here\n\nWhy would you use a MatchResult  to get the match state instead of methods in the Matcher  There are \ntwo reasons\n\t The toMatchResult  of the Matcher  returns a copy of the match state which \nmeans any subsequent change in the match state of the Matcher  will not affect the \nMatchResult  During matching you can collect all match states into instances of \nMatchResult  and analyze them later in your programChapter 18  regular expressions\n661\t A MatchResult  is immutable If you have processors to process matches you can \nsafely pass MatchResult  instances to those processors Passing the Matcher  is not \nsafe because the processor may accidently modify the Matcher  which will affect your \nprogram in an unintentional way\nThere are a few methods in the Matcher  class that work with MatchResult  We cover them later in this \nchapter For now just remember that a MatchResult  contains a copy of the details of a match\n Beware of\u00a0Backslashes\nBeware of using backslashes in regular expressions The character class w ie a backslash followed by a w \nrepresents a word character Recall that a backslash character is also used as a part of an escape character \nTherefore w must be written as w as a string literal You can also use a backslash to nullify the special \nmeaning of metacharacters For example a  marks the beginning of a character class What would be the \nregular expression that will match a digit enclosed in brackets for example 1 5 etc Note that the \nregular expression 09  will match any digit The digit may or may not be enclosed in a bracket You may \nthink about using 09  It will not give you any error however it will not do the job either You can also \nembed a character class within another For example you can write az09  which is the same as a\nz09  In this case the first  in 09  should be treated as an ordinary character not as a metacharacter \nYou must use a backslash as 09  To write this regular expression as a string literal you need to use \ntwo backslashes as 09  when you enclose it in double quotes\n Quantifiers in\u00a0Regular Expressions\nYou can also specify the number of times a character in a regular expression may match the sequence of \ncharacters If you want to match all twodigit integers your regular expression would be dd  which is the \nsame as 0909  What would be the regular expression to match any integer You cannot write the \nregular expression to match any integer with the knowledge you have gained so far You need to be able to \nexpress a pattern one digit or more using a regular expression Here comes the concept of quantifiers \nQuantifiers and their meanings are listed in Table\u00a0 184 \nIt is important to note that a quantifier must follow a character or character class for which it specifies \nthe quantity The regular expression to match any integer would be d which will match one or more \nnumbers of digits Is this solution for matching integers correct No it is not Suppose your text is This is \ntext123 which contains 10 and 120  If you run your pattern d against this string it will match against 123 Table 184  Quantifiers and Their Meanings\nQuantifier Meaning\n Zero or more times\n One or more times\n Once or not at all\nm Exactly m times\nm  At least m times\nm n At least m times but not more than n timesChapter 18  regular expressions\n66210 and 120 Note that 123 is not used as an integer rather it is a part of word text123  If you are looking for \nintegers inside text certainly 123\u00a0in text123  does not qualify as an integer You want to match all integers \nthat form a word in the text\nNecessity is the mother of invention Now you need to specify that the match should be performed only \non word boundaries not inside text having embedded integers This is necessary to exclude integer 123 from \nyour previous result The next section discusses the use of metacharacters to match boundaries\nWith the knowledge you have gained in this section lets improve your email address validation Inside \nan email address there must be one and only one  sign To specify one and only one character you use that \ncharacter one time in the regular expression although you can use 1 as the quantifier For example X1  \nand X means the same inside a regular expression You are fine on this account However your solution until \nnow supports only one character before and after the  sign In reality there can be more than one character \nbefore and after the  sign in an email address You can specify the pattern to validate an email address as  \nww  which means one or more word characters an  sign and one or more word characters\n Matching Boundaries\nUntil now you did not care about the location of the pattern match in the text Sometimes you may be \ninterested in knowing if the match occurred at the beginning of a line You may be interested in finding and \nreplacing a particular match only if the match was found in a word not as part of any word For example you \nmay want to replace the word apple  inside a string with the word orange  Suppose your string is I have an \napple and five pineapples  Certainly you do not want to replace all occurrences of apple  with orange  in this \nstring If you do your new string would be I have an orange and five pineoranges  In fact you want the new \nstring to be I have an orange and five pineapples  You want to match the word apple  as a standalone word \nnot the part of any other word\nTable 185  lists all boundary matchers that can be used in a regular expression\nIn Java a word character is defined by azAZ09  A word boundary is a zerowidth match that can \nmatch the following\n\t Between a word character and a nonword character\n\t Start of the string and a word character\n\t A word character and the end of the stringTable 185  List of Boundary Matchers Inside Regular Expressions\nBoundary Matcher Meaning\n The beginning of a line\n The end of a line\nb A word boundary\nB A nonword boundary\nA The beginning of the input\nG The end of previous match\nZ The end of the input but for the final terminator if any\nz The end of the inputChapter 18  regular expressions\n663A nonword boundary is also a zerowidth match and it is the opposite of the word boundary It \nmatches the following\n\t The empty string\n\t Between two word characters\n\t Between two nonword characters\n\t Between a nonword character and the start or end of the string\nThe regular expression to match the word apple  would be bappleb  which means the following a \nword boundary the word apple  and a word boundary Listing 184  demonstrates how to match a word \nboundary using a regular expression\nListing 184  Matching a Word Boundary\n MatchBoundaryjava\npackage comjdojoregex\npublic class MatchBoundary \n    public static void mainString args \n         Prepare regular expression Use b to get b inside the string literal\n        String regex  bappleb\n        String replacementStr  orange\n        String inputStr  I have an apple and five pineapples\n        String newStr  inputStrreplaceAllregex replacementStr\n        SystemoutprintfRegular Expression sn regex\n        SystemoutprintfInput String sn inputStr\n        SystemoutprintfReplacement String sn replacementStr\n        SystemoutprintfNew String sn newStr\n    \n\nRegular Expression bappleb\nInput String I have an apple and five pineapples\nReplacement String orange\nNew String I have an orange and five pineapples\nThere are two boundary matchers  beginning of a line and A beginning of the input An input \nstring may consist of multiple lines In that case A will match the beginning of the entire input string \nwhereas  will match the beginning of each line in the input For example the regular expression The  will \nmatch a the input string which is in the beginning of any line\n Groups and\u00a0Back Referencing\nYou can treat multiple characters as a unit by using them as a group A group is created inside a regular \nexpression by enclosing one or more characters inside parentheses ab  abz  ababxyz  and \ntheisis  are examples of groups Each group in a regular expression has a group number The \ngroup number starts at 1 The Matcher  class has a method groupCount  that returns the number of groups \nin the pattern associated with the Matcher  instance There is a special group called group 0 zero It refers to \nthe entire regular expression The group 0 is not reported by the groupCount  methodChapter 18  regular expressions\n664How is each group numbered Each left parenthesis inside a regular expression marks the start of a \nnew group Table\u00a0 186  lists some examples of group numbering in a regular expression Note that we have \nalso listed group 0 for all regular expressions although it is not reported by the groupCount  method of \nthe Matcher  class The last example in the list shows that the group 0 is present even if there are no explicit \ngroups present in the regular expression\nYou can also back reference group numbers in a regular expression Suppose you want to match text \nthat starts with ab  followed by xy  which is followed by ab  You can write a regular expression as \nabxyab  You can also achieve the same result by forming a group that contains ab  and back referencing \nit as abxy1  Here 1  refers to group 1 which is ab  in this case You can use 2  to refer to group \n2 3  to refer to group 3 and so on How will regular expression abxy12  be interpreted You have Table 186  Examples of Groups in Regular Expressions\nRegular Expression ABXY\nNumber of groups reported by the Matcher  classs groupCount  method 1\nGroup Number Group Text\n0 ABXY\n1 XY\nRegular Expression ABXY\nNumber of groups reported by the Matcher  classs groupCount  method 2\nGroup Number Group Text\n0 ABXY\n1 AB\n2 XY\nRegular Expression AXY\nNumber of groups reported by the Matcher  classs groupCount  method 5\nGroup Number Group Text\n0 AXY\n1 AXY\n2 A\n3 XY\n4 X\n5 Y\nRegular Expression ABXY\nNumber of groups reported by the Matcher  classs groupCount  method 0\nGroup Number Group Text\n0 ABXYChapter 18  regular expressions\n665used 12  as the group back reference The regular expression engine is smart enough to detect that it \ncontains only one group in abxy12  It uses 1  as back reference to group 1 which is ab  and 2 as \nan ordinary character Therefore the regular expression abxy12  is the same as abxyab2  If a regular \nexpression has 12 or more groups 12\u00a0in the regular expression will refer to the 12th group\nYou can also fetch part of a matched text by using a group number in the regular expression The \ngroup  method in the Matcher  class is overloaded You have already seen the group  method which \ntakes no arguments Another version of the method takes a group number as an argument and returns \nthe matched text by that group Suppose you have phone numbers embedded in the input text All phone \nnumbers occur as a word and are ten digits long The first three digits are the area code The regular \nexpression bd10b  will match all phone numbers in the input text However to get the first three digits \nthe area code you will have to write extra code If you form a regular expression using groups you can \nget the area code using the group number The regular expression placing the first three digits of a phone \nnumber in a group would be bd3d7b  If m is the reference to a Matcher  object associated with \nthis pattern mgroup1  will return the first three digits of the phone number after a successful match You \ncan also use mgroup0  to get the entire matched text Listing 185  illustrates the use of groups in regular \nexpressions to get the area code part of phone numbers Note that 2339829  does not match the pattern \nbecause it has only seven digits whereas the pattern used looks for only tendigit phone numbers\nListing 185  Using Groups in Regular Expressions\n PhoneMatcherjava\npackage comjdojoregex\nimport javautilregexPattern\nimport javautilregexMatcher\npublic class PhoneMatcher \n    public static void mainString args \n         Prepare a regular expression A group of 3 digits followed by 7 digits\n        String regex  bd3d7b\n         Compile the regular expression\n        Pattern p  Patterncompileregex\n        String source  3342449027 2339829 and 6152534734\n         Get the Matcher object\n        Matcher m  pmatchersource\n         Start matching and display the found area codes\n        while mfind \n            String phone  mgroup\n            String areaCode  mgroup1\n            SystemoutprintfPhone s Area Code sn phone areaCode\n        \n    \n\nPhone 3342449027 Area Code 334\nPhone 6152534734 Area Code 615\nGroups are also used to format or replace the matched string with another string Suppose you want \nto format all tendigit phone numbers as xxx  xxxxxxx  where an x denotes a digit As you can see \nthe phone number is in three groups the first three digits the next three digits and the last four digits \nYou need to form a regular expression using three groups so you can refer to the three matched groups \nby their group numbers The regular expression would be bd3d3d4b  The b in the Chapter 18  regular expressions\n666beginning and in the end denotes that you are interested in matching ten digits only at word boundaries \nThe following snippet of code illustrates how you can display formatted phone numbers\n Prepare the regular expression\nString regex  bd3d3d4b\n Compile the regular expression\nPattern p  Patterncompileregex\nString source  3342449027 2339829 and 6152534734\n Get Matcher object\nMatcher m  pmatchersource\n Start match and display formatted phone numbers\nwhile mfind \n    SystemoutprintfPhone s Formatted Phone s ssn\n            mgroup mgroup1 mgroup2 mgroup3\n\nPhone 3342449027 Formatted Phone 334 2449027\nPhone 6152534734 Formatted Phone 615 2534734\nYou can also replace all tendigit phone numbers in the input text by formatted phone numbers You \nhave already learned how to replace the matched text with another text using the replaceAll  method of \nthe String  class The Matcher  class also has a replaceAll  method which accomplishes the same thing \nThe problem you are facing in replacing the phone numbers by the formatted phone numbers is getting the \nmatched parts of the matched phone numbers In this case the replacement text also contains the matched \ntext You do not know what text matches the pattern in advance Groups come to your rescue n where n is \na group number inside replacement text refers to the matched text for group n For example 1 refers to the \nfirst matched group The replacement text to replace the phone numbers with the formatted phone numbers \nwill be 1 23  Listing 186  illustrates the technique of referencing groups in replacement text\nListing 186  Bac k Referencing a Group in Replacement Text\n MatchAndReplacejava\npackage comjdojoregex\nimport javautilregexMatcher\nimport javautilregexPattern\npublic class MatchAndReplace \n    public static void mainString args \n         Prepare the regular expression\n        String regex  bd3d3d4b\n        String replacementText  1 23\n        String source  3342449027 2339829 and 6152534734\n         Compile the regular expression\n        Pattern p  Patterncompileregex\n         Get Matcher object\n        Matcher m  pmatchersource\n         Replace the phone numbers by formatted phone numbers\n        String formattedSource  mreplaceAllreplacementText\n        SystemoutprintfText sn source \n        SystemoutprintfFormatted Text sn formattedSource \n    \nChapter 18  regular expressions\n667Text 3342449027 2339829 and 6152534734\nFormatted Text 334 2449027 2339829 and 615 2534734\nYou can also achieve the same result by using the String  class You do not need to use the Pattern  and \nMatcher  classes at all The following snippet of code illustrates the same concept using the String  class \ninstead The String  class uses Pattern  and Matcher  classes internally to get the result\n Prepare the regular expression\nString regex  bd3d3d4b\nString replacementText  1 23\nString source  3342449027 2339829 and 6152534734\n Use replaceAll method of the String class\nString formattedSource  sourcereplaceAllregex replacementText\nThe Matcher  class contains the following replaceAll  and replaceFirst  methods\n\t String replaceAllString replacement\n\t String replaceAllFunctionMatchResultString replacer\n\t String replaceFirstString replacement\n\t String replaceFirstFunctionMatchResultString replacer\n Tip the replaceAllFunctionMatchResultString replacer  and replaceFirstFunction  \nMatchResultString replacer  methods were added to the Matcher  class in Java 9\nThe replaceAllString  and replaceFirstString  methods work the same as the methods with \nthe same name in the String  class as we have explained them in this section The other versions take \na FunctionMatchResultString  as an argument The Function  takes a MatchResult  and returns a \nreplacement string These methods give you a chance to use your logic inside the Function  to get the \nreplacement string All the four methods first reset the matcher before performing the findandreplace \nFunctionTR  is an interface in the javautilfunction  package We will discuss the Function  interface \nmore in Chapter 20\nSuppose you want to find tendigit phone numbers in an input string and you want to mask all phone \nnumbers with the area code 334 For example if a phone number is 3342449027 you want to replace it \nwith    You can do so using the new replaceAll  method in the Matcher  class Listing 187  \ncontains the complete program\nListing 187  Using Logic to Mask or Format Phone Number Depending on the Area Code\n MaskAndFormatjava\npackage comjdojoregex\nimport javautilregexMatchResult\nimport javautilregexMatcher\nimport javautilregexPattern\npublic class MaskAndFormat \n    public static void mainString args \n         Prepare the regular expression\n        String regex  bd3d3d4bChapter 18  regular expressions\n668        String source  3342449027 2339829 and 6152534734\n         Compile the regular expression\n        Pattern p  Patterncompileregex\n         Get Matcher object\n        Matcher m  pmatchersource\n         Replace the phone numbers by formatted phone numbers\n        String formattedSource  mreplaceAllMaskAndFormatmask\n        SystemoutprintfText sn source \n        SystemoutprintfFormatted Text sn formattedSource \n    \n    private static String maskMatchResult result \n        String replacementText  1 23\n        String areaCode  resultgroup1\n        if334equalsareaCode \n            replacementText   \n        \n        return replacementText\n    \n\nText 3342449027 2339829 and 6152534734\nFormatted Text   2339829 and 615 2534734\nNote the use of the following statement in the main  method\nString formattedSource  mreplaceAllMaskAndFormatmask\nThe argument to the replaceAll  method is MaskAndFormatmask  which is a method reference to \nthe mask  static method of the MaskAndFormat  class When a match is found the MatchResult  is passed to \nthe mask  method and the returned string from the method is used as replacement text Notice how you \nhave masked the phone number with the area code 334 inside the mask  method All other area codes use \nthe same replacement text as was used in the previous example\n Using Named Groups\nUsing group numbers in a big regular expression is cumbersome Java also supports named groups You can \ndo everything with the group name as you were able to do using the group numbers in the previous section\n\t You can name a group\n\t You can back reference groups using their names\n\t You can reference group names in replacement text\n\t You can get the matched text using the group names\nAs before you need to use a pair of parentheses to create a group The start parenthesis is followed by a \n and a group name placed in angle brackets The format to define a named group is as follows\ngroupNamepatternChapter 18  regular expressions\n669The group name must consist of only letters and digits a through z A through Z and 0 through 9 The \ngroup name must start with a letter The following is an example of a regular expression that uses three \nnamed groups The group names are areaCode  prefix  and lineNumber  The regular expression is to match \na tendigit phone number\nbareaCoded3prefixd3lineNumberd4b\nYou can use kgroupName  to back reference the group named groupName  The area code and prefix \nparts in a phone number use the same pattern You can rewrite the previous regular expression that back \nreferences the areaCode  group as the following\nbareaCoded3 kareaCode lineNumberd4b\nYou can reference a named group in replacement text as groupName  The following snippet of code \nshows a regular expression with three named groups and replacement text referencing those three groups \nusing their names\nString regex  bareaCoded3prefixd3lineNumberd4b\nString replacementText  areaCode prefixlineNumber\nWhen you name a group the group still gets a group number as discussed in the previous section \nYou can still refer to a group by its group number even though it has a name The previous snippet code is \nrewritten as follows in which the third group which has been named lineNumber  is referenced using its \ngroup number as 3 in the replacement text\nString regex  bareaCoded3prefixd3lineNumberd4b\nString replacementText  areaCode prefix3\nAfter a successful match you can use the groupString groupName  method of the Matcher  class to get \nthe matched text for the group\nListing 188  shows how to use group names in a regular expression and how to use the names in \nreplacement text\nListing 188  Using Named Groups in Regular Expressions\n NamedGroupsjava\npackage comjdojoregex\nimport javautilregexMatcher\nimport javautilregexPattern\npublic class NamedGroups \n    public static void mainString args \n         Prepare the regular expression\n        String regex \n            bareaCoded3prefixd3lineNumberd4b\n         Reference first two groups by names and the third one as its number\n        String replacementText  areaCode prefix3\n        String source  3342449027 2339829 and 6152534734\n         Compile the regular expression\n        Pattern p  Patterncompileregex\n         Get Matcher object\n        Matcher m  pmatchersourceChapter 18  regular expressions\n670         Replace the phone numbers by formatted phone numbers\n        String formattedSource  mreplaceAllreplacementText\n        SystemoutprintfText sn source\n        SystemoutprintfFormatted Text sn formattedSource\n    \n\nText 3342449027 2339829 and 6152534734\nFormatted Text 334 2449027 2339829 and 615 2534734\nAfter a successful match using the find  method of the Matcher  class you can use its start  and \nend  methods to know the match boundary for groups These methods are overloaded\n\tint start\n\tint startint groupNumber\n\tint startString groupName\n\tint end\n\tint endint groupNumber\n\tint endString groupName\nThe methods that take no arguments return the start and end of the previous match Other two sets of \nmethods return the start and end of a group in the previous match The following snippet of code uses the \nprevious example of matching a tendigit phone number in a string It prints the start of each group for each \nsuccessful match\n Prepare the regular expression\nString regex  bareaCoded3prefixd3lineNumberd4b\nString source  3342449027 2339829 and 6152534734\nSystemoutprintlnSource Text   source\n Compile the regular expression\nPattern p  Patterncompileregex\n Get Matcher object\nMatcher m  pmatchersource\nwhilemfind \n    String matchedText  mgroup\n    int start1  mstartareaCode\n    int start2  mstartprefix\n    int start3  mstartlineNumber\n    SystemoutprintfMatched Text s matchedText\n    Systemoutprintf Area code start d start1\n    Systemoutprintf Prefix start d start2\n    Systemoutprintf Line Number start dn start3\n\nSource Text 3342449027 2339829 and 6152534734\nMatched Text 3342449027 Area code start 0 Prefix start 3 Line Number start 6\nMatched Text 6152534734 Area code start 25 Prefix start 28 Line Number start 31Chapter 18  regular expressions\n671 Resetting the\u00a0Matcher\nIf you have finished matching a pattern against input text and you want to restart matching from the \nbeginning of the input text again you need to use the reset  method of the Matcher  class After a call to the \nreset  method the next call to match a pattern will start from the beginning of the input text The reset  \nmethod is overloaded Another version allows you to associate a different input text with the pattern These \ntwo versions of the reset  method allow you to reuse any existing instance of the Matcher  class if your \npattern remains the same This enhances the performance of your program by avoiding the need to recreate \na new Matcher  object to perform matches against the same pattern\n Final Words on\u00a0Email Validations\nYou now have learned the major parts of regular expressions You are ready to complete your email address \nvalidation example Note that we are only validating the format of the email address not whether it points to \na valid email inbox Your email addresses will be validated against the following rules\n\t All email addresses will be of the form namedomain \n\t The name part must start with an alphanumeric character  az AZ 09 \n\t The name part must have at least one character\n\t The name part may have any alphanumeric character  az AZ 09  underscore \nhyphen or dot\n\t The domain part must contain at least one dot\n\t The dot in the domain part must be preceded and followed by at least one \nalphanumeric character\n\t You should also be able to refer to the name and domain parts using group numbers \nThis validation states that you place name and domain parts as groups inside the \nregular expression\nThe following regular expression will match an email address according to these rules Group 1 is the \nname part whereas group 2 is the domain part\nazAZ09wazAZ09azAZ09\nThe more validations you add the more complex the regular expression Readers are encouraged to \nadd some more validations for email addresses and modify the previous regular expression accordingly This \nregular expression allows two consecutive dots in the domain part How would you prevent that\n FindandReplace Using Regular Expressions\nFindandreplace is a very powerful technique supported by regular expressions Sometimes you may be \nrequired to find a pattern and replace it depending upon the text it matches that is the replacement text \nis decided based on some conditions The Java regular expression designers visualized this need and they \nhave included two methods in the Matcher  class that let you accomplish this task\n\tMatcher appendReplacementStringBuffer sb String replacement\n\tMatcher appendReplacementStringBuilder sb String replacementChapter 18  regular expressions\n672\tStringBuffer appendTailStringBuffer sb\n\tStringBuffer appendTailStringBuilder sb\n Ti p t he versions of the appendReplacement  and appendTail  methods that work with a \nStringBuilder  were added in Java 9\nConsider the following text\nA train carrying 125 men and women was traveling at the speed of 100 miles per hour The train fare \nwas 75 dollars per person\nYou want to find all numbers in the text eg 125 100 and 75 and replace them as follows\n\t 100 by a hundred\n\t  100 by more than a hundred\n\t  100 by less than a hundred\nAfter replacement this text should read as follows\nA train carrying more than a hundred men and women was traveling at the speed of a hundred miles \nper hour The train fare was less than a hundred dollars per person\nTo accomplish this task you need to find all numbers embedded in the text compare the found number \nwith 100 and decide on the replacement text Such a situation also arises when you find and replace text \nusing a text editor The text editor highlights the word you were searching for you enter a new word and \nthe text editor does the replacement for you You can also create a findreplace program as found in text \neditors using these two methods Typically these methods are used in conjunction with the find  method \nof the Matcher  class The steps that are performed to accomplish findandreplace of texts using these two \nmethods are outlined here\n 1 Create a Pattern  object\n 2 Create a Matcher  object\n 3 Create a StringBufferStringBuilder  object to hold the result\n 4 Use the find  method in a loop to match the pattern\n 5 Call the appendReplacement  and appendTail  methods depending on the \nposition of the found match\nLets create a Pattern  by compiling the regular expression Since you want to find all numbers your \nregular expression would be bdb  Note the first and last b They specify that you are interested in \nnumbers only on word boundaries\nString regex  bdb Pattern p  Patterncompileregex\nCreate a Matcher  by associating the pattern with the text\nString text  A train carrying 125 men and women was traveling \n               at the speed of 100 miles per hour The train \n               fare was 75 dollars per person\nMatcher m  pmatchertextChapter 18  regular expressions\n673Create a StringBuilder  to hold the new text\nStringBuilder sb  new StringBuilder\nStart using the find  method on the Matcher  object to find a match When you invoke the find  \nmethod for the first time the number 125 will match the pattern At this point you would like to prepare the \nreplacement text depending on the matched text as\nString replacementText  \n Get the matched text Recall that group method returns the whole matched text\nString matchedText  mgroup\n Convert the text into integer for comparison\nint num  IntegerparseIntmatchedText\n Prepare the replacement text\nif num  100 \n    replacementText  a hundred\n else if num  100 \n    replacementText  less than a hundred\n else \n    replacementText  more than a hundred\n\nNow you will call the appendReplacement  method on the Matcher  object passing an empty \nStringBuilder  and replacementText  as arguments In this case replacementText  has a string more than \nhundred  because the find  method call matched the number 125\nmappendReplacementsb replacementText\nIt is interesting to know what the appendReplacement  method call does It checks if there was a \nprevious match Because this is the first call to the find  method there is no previous match For the \nfirst match it appends the text starting from the beginning of the input text until the character before the \nmatching text In your case the following text is appended to the StringBuilder  At this point the text in the \nStringBuilder  is\nA train carrying \nNow the appendReplacement  method appends the text in the replacementText  argument to the \nStringBuilder  This will change the StringBuilder  contents to\nA train carrying more than a hundred\nThe appendReplacement  method does one more thing It sets the append position which is an \ninternal state of the Matcher  object to the character position just after the first matching text In your case \nthe append position will be set to the character following 125 which is the position of the space character \nthat follows 125 This finishes the first findandreplace step\nYou will call the find  method of the Matcher  object again It will find the pattern that is another \nnumber which is 100 You will compute the value of the replacement text using the same procedure as you \ndid after the first match This time the replacementText  will contain the string a hundred  You call the \nappendReplacement  method as follows\nmappendReplacementsb replacementTextChapter 18  regular expressions\n674Again it checks if there was a previous match Since this is the second call to the find  method it will \nfind a previous match and it will use the append position saved by the last appendReplacement  call as \nthe starting position The last character to be appended will be the character just before the second match \nIt will also set the append position to the character position following the number 100 At this point the \nStringBuilder  contains the following text\nA train carrying more than a hundred men and women was traveling at the speed of a hundred\nWhen you call the find  method for the third time it will find the number 75 and the StringBuilder  \ncontent will be as follows after the replacement The append position will be set to the character position \nfollowing the number 75\nA train carrying more than a hundred men and women was traveling at the speed of a hundred \nmiles per hour The train fare was less than a hundred\nIf you call the find  method again it will not find any match However the StringBuilder  does not \ncontain the text following the last match which is  dollars per person  To append the text following the \nlast match you need to call the appendTail  method It appends the text to the StringBuilder  starting at \nthe append position until the end of the input string The call to this method\nmappendTailsb\nwill modify the StringBuilder  to this\nA train carrying more than a hundred men and women was traveling at the speed of a hundred \nmiles per hour The train fare was less than a hundred dollars per person\nWhat will the content of the StringBuilder  be if you would have called the appendTail  method just \nafter the second call to the appendReplacement  method The complete program is shown in Listing 189 \nListing 189  FindandR eplace Using Regular Expressions and appendReplacement and appendTail \nMethods\n AdvancedFindReplacejava\npackage comjdojoregex\nimport javautilregexPattern\nimport javautilregexMatcher\npublic class AdvancedFindReplace \n    public static void mainString args \n        String regex  bdb\n        StringBuilder sb  new StringBuilder\n        String text  A train carrying 125 men and women was traveling at\n                  the speed of 100 miles per hour \n                 The train fare was 75 dollars per person\n        Pattern p  Patterncompileregex\n        Matcher m  pmatchertext\n        while mfind \n            String matchedText  mgroup\n             Convert the text into an integer for comparing\n            int num  IntegerparseIntmatchedText\n             Prepare the replacement textChapter 18  regular expressions\n675            String replacementText\n            if num  100 \n                replacementText  a hundred\n             else if num  100 \n                replacementText  less than a hundred\n             else \n                replacementText  more than a hundred\n            \n            mappendReplacementsb replacementText\n        \n         Append the tail\n        mappendTailsb\n         Display the old and new text\n        SystemoutprintfOld Text sn text\n        SystemoutprintfNew Text sn sbtoString\n    \n\nOld Text A train carrying 125 men and women was traveling at the speed of 100 miles per \nhour The train fare was 75 dollars per person\nNew Text A train carrying more than a hundred men and women was traveling at the speed of \na hundred miles per hour The train fare was less than a hundred dollars per person\n Streams of\u00a0Matched Results\nThere is a method on the Matcher  class that returns a Stream of MatchResult \nStreamMatchResult results\nThe Streams API is a vast topic which we touched on briefly in Chapter 16 It lets you apply filtermap\nreduce operations to a stream of data We present an example of using the results  method to complete \nthe discussion of the Matcher  class If you have difficulty understanding the examples in this section revisit \nthis section after you read about the Streams API\nThe results  method returns match results in a stream whose elements are of the MatchResult  type \nYou can query the MatchResult  to get the match details The results  method does not reset the matcher \nIf you want to reuse the matcher dont forget to call its reset  method to reset it to a desired position \nOperations such as counting the number of matches getting a list of matches and finding distinct area codes \nbecome easy when you use the results  method Listing 1810  shows a few interesting uses of this method \nIt searches for tendigit or sevendigit phone numbers in an input string It gets the list of all formatted \nmatched phone numbers In the second example it prints a set of distinct area codes in matched results\nListing 1810  Using the results Method of the Matcher Class\n DistinctAreaCodejava\npackage comjdojoregex\nimport javautilList\nimport javautilSet\nimport javautilregexMatcher\nimport javautilregexPattern\nimport static javautilstreamCollectorstoListChapter 18  regular expressions\n676import static javautilstreamCollectorstoSet\npublic class DistinctAreaCode \n    public static void mainString args \n         A regex to match 7digit or 10digit phone numbers\n        String regex  bd3d3d4b\n         An input string\n        String source  1 3342229999 2330001 6159996666 123 3340909090\n        SystemoutprintlnInput   source\n         Create a matcher\n        Matcher matcher  Patterncompileregex\n                matchersource\n         Collect formatted phone numbers into a list\n        ListString phones  matcherresults\n                mapmr  mrgroup1  null      mrgroup1   \n                       mrgroup2    mrgroup3\n                collecttoList\n        SystemoutprintlnPhones   phones\n         Reset the matcher so we can reuse it from start\n        matcherreset\n         Get distinct area codes\n        SetString areaCodes  matcherresults\n                filtermr  mrgroup1  null\n                mapmr  mrgroup1\n                collecttoSet\n        SystemoutprintlnDistinct Area Codes   areaCodes\n    \n\nInput 1 3342229999 2330001 6159996666 123 3340909090\nPhones 334 2229999 2330001 615 9996666 334 0909090\nDistinct Area Codes 334 615\nIn the main  method the following regular expression will match seven or tendigit phone numbers\n A regex to match 7digit or 10digit phone numbers\nString regex  bd3d3d4b\nYou want to format a tendigit phone number as xxx xxxxxxx  and a sevendigit phone number \nas xxxxxxx  Finally you want to collect all formatted phone numbers into a ListString  Collect is a \nterminal operation that takes in a Collector as an argument as seen in the example we import two methods \nthat provide Collectors toList and toSet The following statement performs this\n  Collect formatted phone numbers into a list\n ListString phones  matcherresults\n                        mapmr  mrgroup1  null      mrgroup1   \n                                     mrgroup2    mrgroup3\n                        collecttoListChapter 18  regular expressions\n677Note the use of the map  method that takes a MatchResult  and returns a formatted phone number as \na String  When a match is a sevendigit phone number group 1 will be null  Now you want to reuse the \nmatcher to find distinct area codes in tendigit phone numbers You must reset the matcher so the next \nmatch starts at the beginning of the input string\n Reset the matcher so we can reuse it from start\nmatcherreset\nThe first group in the MatchResult  contains the area code You need to filter out sevendigit phone \nnumbers and collect the value of group 1 into a SetString  to get a distinct set of area codes The following \nstatement does this\n Get distinct area codes\nSetString areaCodes  matcherresults\n                               filtermr  mrgroup1  null\n                               mapmr  mrgroup1\n                               collecttoSet\n Summary\nA regular expression is a sequence of characters used as a pattern to match some text Java provides \ncomprehensive support for using regular expressions through the Pattern  and Matcher  classes in the java\nutilregex  package Several convenience methods for using regular expressions exist in the String  class\nA Pattern  object represents a compiled regular expression A Matcher  object is used to associate a \nPattern  with an input text to be searched for the pattern The find  method of the Matcher  class is used \nto find a match for the pattern in the input text Regular expressions allow you to use groups Groups are \nautomatically numbered from 1 to N\u00a0The first group from the left is numbered 1 A special group 0 exists that \ncontains the entire regular expression You can also name groups You can refer to the groups by numbers or \ntheir names\nJava 9 added a few useful methods to the Matcher  class The replaceAll  and replaceFirst  \nmethods were overloaded now they take a FunctionMatchResultString  as a replacer for the matched \nresults allowing you to use any logic to generate the replacement text for a match The results  method \nreturns a StreamMatchResult  allowing you to stream operations to the matched results\nQUESTIONS AND EXERCISES\n 1 What is a regular expression\n 2 What is a metacharacter how do you use a metacharacter as an ordinary \ncharacter in a regular expression\n 3 What class do you use to compile a pattern\n 4 What class do you use to match a compiled pattern\n 5 What does the regular expression aieou  mean Will it match the string \nHello Chapter 18  regular expressions\n678 6 Write a regular expression tha t will match any word that starts with a consonant \nin lowercase followed by one or more vowels in lowercase and then followed by \na consonant in lowercase For example it should match cat dog cool cot doom \ndeem etc but not cola Cat fish Cold etc\n 7 What will be the output of the following snippet of code\nString source  I saw the rat running\nString regex  r\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nwhilemfind \n    Systemoutprintlnmgroup\n\n 8 Complete the follo wing snippet of code that will match two words cat and cot in \nthe input When the code is run it should print cat and cot on two separate lines\nString source  cat camera can pen cow cab cot\nString regex   Your code goes here \nPattern p  Patterncompileregex\nMatcher m   Your code goes here \nwhilemfind \n    Systemoutprintlnmgroup\n\n 9 Complete the follo wing snippet of code that will replace all threeletter words that \nstart with c with their uppercase equivalents the code should print CAT camera \nCAN pen COW CAB COT \nString source  cat camera can pen cow cab cot\nString regex   You code goes here\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nString str  mreplaceAllmr  mrgrouptoUpperCase\nSystemoutprintlnstr\n 10 Write the output of the follo wing snippet of code\nString source  ABXXXABB\nString regex  AB\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nString str  mreplaceAllHello\nSystemoutprintlnstrChapter 18  regular expressions\n679 11 Write the output of the follo wing snippet of code\nString source  ABXXXABB\nString regex  AB\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nString str  mreplaceAllHello\nSystemoutprintlnstr\n 12 Write the output of the follo wing snippet of code\nString source  ABXXXABB\nString regex  AB\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nString str  mreplaceAllHello\nSystemoutprintlnstr\n 13 Describe the intent of the follo wing snippet of code and write the output\nString source  I have 25 cents and 400 books\nString regex  bdb\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nint sum  mresults\n           mapToIntmr  IntegerparseIntmrgroup\n           sum\nSystemoutprintlnsum\n 14 how many groups are present in the following regular expression\nString regex  bd3d3d4d3d4b\n 15 Complete the follo wing snippet of code that prints sevendigit and tendigit phone \nnumbers in xxxxxxx and xxx xxxxxxx formats the output should be 334 \n2330908 2337656 234 617 9086547 unknown \nString source  3342330908 2337656 234 6179086547 unknown\nString regex   Your code goes here\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nStringBuilder sb  new StringBuilder\nwhilemfind \n    String replacement \n        mgroup1  null   Your code goes here\n    mappendReplacementsb replacement\n\nmappendTailsb\nSystemoutprintlnsbtoStringChapter 18  regular expressions\n680 16 Complete the follo wing snippet of code that will print each word in the source string \non a separate line\nString source  bug dug jug mug tug\nString regex  your code goes here\nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nwhilemfind \n   Systemoutprintlnmgroup\n\n 17 the following snippet of code attempts to count and print the number of question \nmarks  in the input string Complete the following snippet of code so the  \noutput is 3\nString source  What How I do not know Why\nString regex   Your code goes here \nPattern p  Patterncompileregex\nMatcher m  pmatchersource\nlong questionMarkCount  mresultscount\nSystemoutprintlnquestionMarkCount681\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307419CHAPTER 19\nArrays\nIn this chapter you will learn\n\t How to declare variables of array type\n\t How to create arrays\n\t How to access elements of an array\n\t How to use a for loop and a foreach  loop to iterate through elements of an array\n\t How to copy elements of one array to another array\n\t How to copy primitive and referencetype arrays\n\t How to use multidimensional arrays\n\t How to use an ArrayList  when a variablelength array is needed\n\t How to convert elements of an ArrayList  to an array and vice versa\n\t How to perform arrayrelated operations such as sorting elements of an array \ncomparing two arrays performing binary search in an array filling an array with a \nvalue getting a string representation of an array etc\nAll example programs in this chapter are a member of a jdojoarray  module as declared in Listing 191 \nListing 191  The D eclaration of a jdojoarray Module\n moduleinfojava\nmodule jdojoarray \n    exports comjdojoarray\n\n What Is an\u00a0Array\nAn array is a fixedlength data structure that is used to hold more than one value of the same data type \nLets consider an example which will explain why we need arrays Suppose you have been asked to declare \nvariables to hold employee IDs of three employees The employee IDs will be integers The variable \ndeclarations to hold three integer values will look like this\nint empId1 empId2 empId3Chapter 19  arrays\n682What do you do if the number of employees increases to five You may modify your variable \ndeclarations to look like this\nint empId1 empId2 empId3 empId4 empId5\nWhat do you do if the number of employees increases to 1000 You definitely would not want to declare \n1000 int variables like empId1  empId2empId1000  Even if you do that the resulting code would be \nunmanageable and clumsy Arrays come to your rescue in such situations Using an array you can declare \na variable of a type which can hold as many values of that type as you want In fact Java has a restriction on \nthe number of values an array can hold An array can hold a maximum of 2147483647 values which is the \nmaximum value of the int data type\nWhat makes a variable an array Placing  empty brackets after the data type or after the variable \nname in a variable declaration makes the variable an array For example\nint empId\nis a simple variable declaration Here int is the data type and empId  is the variable name This declaration \nmeans that the empId  variable can hold one integer value Placing  after the data type in the previous \ndeclaration as in\nint empId\nmakes empId  an array variable The previous declaration is read as  empId  is an array of int  You can also \nmake the empId  variable an array by placing the  after the variable name like so\nint empId\nBoth of these declarations are valid This book uses the first convention to declare an array We started \nour discussion with an example of variable declarations to hold three employee IDs Until now you have \nprepared the ground to hold more than one value in one variable That is your empId  variable declared as an \narray of int is capable of holding more than one int value How many values can your empId  array variable \nhold The answer is you do not know yet You cannot specify the number of values an array can hold at \nthe time you declare the array The subsequent sections explain how to specify the number of values an \narray can hold You can declare an array of primitive type as well as reference type The following are more \nexamples of array declarations\n salary can hold multiple float values\nfloat salary\n name can hold multiple references to String objects\nString name\n emp can hold multiple references to Employee objects\nEmployee emp\n Ti p a n array is a fixedlength data structure to store data items of the same type all elements of an array \nare stored contiguously in memoryChapter 19  arrays\n683 Arrays Are Objects\nAn array in Java is an object Every object in Java belongs to a class so does every array object You can create \nan array object using the new operator You have used the new operator with a constructor to create an object \nof a class The name of a constructor is the same as the name of the class What is the name of the class of an \narray object The answer to this question is not so obvious We will answer this question later in this chapter\nFor now lets concentrate on how to create an array object of a particular type The general syntax for \narray creation expression is as follows\nnew arraydatatypearraylength\nThe array object creation expression starts with the new operator followed by the data type of the values \nyou want to store in the array followed by an integer enclosed in  brackets which is the number of \nelements in the array For example you can now create an array to store five int values as follows\nnew int5\nIn this expression 5 is the length of the array  also called the dimension of the array The word \ndimension is also used in another context You can have an array of dimension one two three or more \nAn array with more than one dimension is called a multidimensional array We cover the multidimensional \narray later in this chapter In this book I refer to 5 in the previous expression as the length of the array not as \nthe dimension of the array\nNote that the previous expression creates an array object in memory which allocates memory to \nstore five integers The new operator returns the reference of the new object in memory If you want to use \nthis object later in your code you must store that reference in an object reference variable The reference \nvariable type must match the type of the object reference returned by the new operator In the previous case \nthe new operator will return an object reference of int array type You have already seen how to declare a \nreference variable of int array type It is declared as follows\nint empIds\nTo store the array object reference in empId  you can write this\nempIds  new int5\nYou can also combine the declaration of an array and its creation in one statement as follows\nint empIds  new int5\nSince the type of the array can be interpreted from the initialization you can use local type inference if \nthis is a local variable to avoid repetition like so\nvar empIds  new int5\nHow would you create an array to store 252 employee IDs You can do this as follows\nvar empIds  new int252Chapter 19  arrays\n684You can also use an expression to specify the length of an array while creating the array\nint total  23\nint array1  new inttotal       array1 has 23 elements\nint array2  new inttotal  3  array2 has 69 elements\nBecause all arrays are objects their references can be assigned to a reference variable of the Object  \ntype for example\nint empId  new int5  Create an array object\nObject obj  empId         A valid assignment\nHowever if you have the reference of an array in a reference variable of the Object  type you need to \ncast it to the appropriate array type before you can assign it to an array reference variable or access elements \nby index Remember that every array is an object However not every object is necessarily an array\n Assume that obj is a reference of the Object type that holds a reference of int\nint tempIds  int obj\n Accessing Array Elements\nOnce you create an array object using the new operator you can refer to each individual element of the array \nusing an elements index enclosed in brackets The index for the first element is 0 the second element 1 the \nthird element 2 and so on This is called zerobased indexing The index for the last element of an array is \nthe length of the array minus 1 If you have an array of length 5 the indexes of the array elements would be 0 \n1 2 3 and 4 Consider the following statement\nint empId  new int5\nThe length of the empId  array is 5 its elements can be referred to as empId0  empId1  empId2  \nempId3  and empId4 \nIt will cause a runtime error if you refer to a nonexisting element of an array For example using \nempId5  in your code will throw an exception because empId  has a length of 5 and empId5  refers to the \nsixth element which is nonexistent You can assign values to elements of an array as follows\nempId0  10    Assign 10 to the first element of empId\nempId1  20    Assign 20 to the second element of empId\nempId2  30    Assign 30 to the third element of empId\nempId3  40    Assign 40 to the fourth element of empId\nempId4  50    Assign 50 to the fifth element of empId\nTable 191  shows the details of an array It shows the indexes values and references of the elements of \nthe array after the statements are executed\nTable 191  Array Elements in Memory for the empId Array\nElements Index 0 1 2 3 4\nElements Value 10 20 30 40 50\nElements Reference empId0 empId1 empId2 empId3 empId4Chapter 19  arrays\n685The following statement assigns the value of the third element of the empId  array to an int variable \ntemp \nint temp  empId2  Assigns 30 to temp\n Length of\u00a0an\u00a0Array\nAn array object has a public final  instance variable named length  which contains the number of \nelements in the array\nint empId  new int5    Create an array of length 5\nint len  empIdlength      5 will be assigned to len\nNote that length  is the property of the array object you create Until you create the array object you \ncannot use its length  property The following code fragment illustrates this\n salary is a reference variable which can refer to an array of int\n At this point it contains null That is it is not referencing a valid object\nint salary  null\n A runtime error salary is not referring to any array object yet\nint len  salarylength\n Create an int array of length 1000 and assign its reference to salary\nsalary  new int1000\n Correct len2 has a value 1000\nint len2  salarylength\nTypically elements of arrays are accessed using loops If you want to do any processing with all of the \nelements of an array you execute a loop starting from index 0 zero to length minus 1 For example to \nassign the values 10 20 30 40 and 50 to the elements of the empId  array of length 5 you would execute a for \nloop as shown\nfor int i  0  i  empIdlength i \n    empIdi  i  1  10\n\nIt is important to note that while executing the loop the loop condition must check for the array index\nsubscript being less than the length of the array as in i  empIdlength  because the array index starts \nwith 0 not 1 Another common mistake made by programmers while processing an array using a for loop is \nto start the loop counter at 1 as opposed to 0 What will happen if you change the initialization part of the for \nloop in the previous code from int i  0  to int i  1  It would not give you any errors However the first \nelement empId0  would not be processed and would not be assigned the value of 10\nYou cannot change the length of an array after it is created You may be tempted to modify the length  \nproperty\nint roll  new int5  Create an array of 5 elements\n A compiletime error The length property of an array is final You cannot modify it\nrolllength  10Chapter 19  arrays\n686You can have a zerolength array Such an array is called an empty array\n Create an array of length zero\nint emptyArray  new int0\n Will assign zero to len\nint len  emptyArraylength\n Tip arrays use zerobased indexing  that is the first element of an array has an index of zero arrays are \ncreated dynamically at runtime the length of an array cannot be modified after the array has been crea ted \nIf you need to modify the length of an array you must create a new array and copy the elements from the old \narray to the new array an array can ha ve its length as zero\n Initializing Array Elements\nRecall from Chapter 7 that unlike class member variables instance and static variables local variables are \nnot initialized by default You cannot access a local variable unless it has been assigned a value The same \nrule applies to the blank final variables The compiler uses Rules of Definite Assignment  to make sure that all \nvariables have been initialized before their values are used in a program\nArray elements are always initialized irrespective of the scope in which the array is created Array elements \nof primitive data type are initialized to the default value for their data types For example the numeric array \nelements are initialized to zero boolean  elements to false  and char elements to u0000  Array elements of \nreference type are initialized to null  The following snippet of code illustrates the array initialization\n intArray0 intArray1 and intArray2 are initialized to zero by default\nint intArray  new int3\n bArray0 and bArray1 are initialized to false\nboolean bArray  new boolean2\n An example of a reference type array strArray0 and strArray1 are\n initialized to null\nString strArray  new String2\n Another example of a reference type array\n All 100 elements of the person array are initialized to null\nPerson person  new Person100\nListing 192  illustrates the array initialization for an instance variable and some local variables\nListing 192  Defa ult Initialization of Array Elements\n ArrayInitjava\npackage comjdojoarray\npublic class ArrayInit \n    private final boolean bArray  new boolean3    An instance variable\n    public ArrayInit \n         Display the initial value for elements of the instance variable bArray\n        for int i  0 i  bArraylength i \n            SystemoutprintlnbArray  i    bArrayi\n        \n    Chapter 19  arrays\n687    public static void mainString args \n        Systemoutprintlnint array initialization\n        int empId  new int3    A local array variable\n        for int i  0 i  empIdlength i \n            SystemoutprintlnempId  i    empIdi\n        \n        Systemoutprintlnnboolean array initialization\n         Initial value for bArray elements are displayed inside the constructor\n        new ArrayInit\n        SystemoutprintlnnReference type array initialization\n        String name  new String3    A local array variable\n        for int i  0 i  namelength i \n            Systemoutprintlnname  i    namei\n        \n    \n\nint array initialization\nempId00\nempId10\nempId20\nboolean array initialization\nbArray0false\nbArray1false\nbArray2false\nReference type array initialization\nname0null\nname1null\nname2null\n Beware of\u00a0ReferenceType Arrays\nArray elements of a primitive type contain values of that primitive type whereas array elements of a \nreference type contain the references to objects Suppose you have an int array\nint empId  new int5\nHere empId0  empId1empId4  contain an int value Suppose you have an array of String  like so\nString name  new String5\nHere name0 name1name4  may contain a reference to a String  object Note that the String  \nobjects the elements of the name  array have not been created yet As discussed in the previous section all \nelements of the name  array contain null  at this point You need to create the String  objects and assign their \nreferences to the elements of the array one by one as shown\nname0  John\nname1  Donna\nname2  Wally\nname3  Reddy\nname4  BuddyChapter 19  arrays\n688It is a common mistake to refer to the elements of an array of reference type just after creating the array \nand before assigning a valid object reference to each element The following code illustrates this common \nmistake\n Create an array of String\nString name  new String5\n A runtime error as name0 is null\nint len  name0length\n Assign a valid string object to all elements of the array\nname0  John\nname1  Donna\nname2  Wally\nname3  Reddy\nname4  Buddy\n Now you can get the length of the first element\nint len2  name0length  Correct len2 has value 4\nThe concept of initialization of the String  referencetype array is depicted in Figure\u00a0 191  This concept \napplies to all reference types\nFigure 191  Referencetype array initializationChapter 19  arrays\n689All elements of an array are stored contiguously in memory In the case of a referencetype array the \narray elements store the references of the objects Those references in the elements are stored contiguously \nnot the objects they are referring to The objects are stored on the heap and their locations are typically not \ncontiguous\n Explicit Array Initialization\nYou can initialize elements of an array explicitly when you declare the array or when you create the array \nobject using the new operator The initial values for elements are separated by a comma and enclosed in \nbraces \n Initialize the array at the time of declaration\nint empIds  1 2 3 4 5\nThis code creates an array of int of length 5 and initializes its elements to 1 2 3 4 and 5 Note that \nyou do not specify the length of an array when you specify the array initialization list at the time of the array \ndeclaration The length of the array is the same as the number of values specified in the array initialization \nlist Here the length of the empId  array will be 5 because you passed five values in the initialization list  1 2 \n3 4 5 A comma may follow the last value in an initialization list\nint empIds  1 2 3 4 5   A comma after the last value 5 is valid\nAlternatively you can initialize the elements of an array as shown\nint empIds  new int1 2 3 4 5\nIf you are defining a local variable you can also use var if the type is included in the initialization as \nfollows\nvar empIds  new int1 2 3 4 5\nNote that you cannot specify the length of an array if you specify the array initialization list The length \nof the array is the same as the number of values specified in the initialization list It is valid to create an \nempty array by using an empty initialization list\nint emptyNumList   \nFor a referencetype array you can specify the list of objects in the initialization list The following \nsnippet of code illustrates array initialization for String  and Account  types Assume that the Account  class \nexists and it has a constructor which takes an account number as an argument\n Create a String array with two Strings Sara and Truman\nString names  new StringSara new StringTruman\n You can also use String literals\nString names  Sara Truman\n Create an Account array with two Account objects\nAccount ac  new Accountnew Account1 new Account2Chapter 19  arrays\n690 Ti p When you use an initializa tion list to initialize the elements of an array you cannot specify the length of \nthe array the length of the array is set to the number of values in the initialization list\n Limitations of\u00a0Using Arrays\nAn array in Java cannot be expanded or shrunk after it is created Suppose you have an array of 100 elements \nand later you need to keep only 15 elements You cannot get rid of the remaining 85 elements If you need \n135 elements you cannot append 35 more elements to it You can deal with the first limitation memory \ncannot be freed for unused array elements if you have enough memory available to your application \nHowever there is no way out if you need to add more elements to an existing array The only solution is to \ncreate another array of the desired length and copy the array elements from the original array to the new \narray You can copy array elements from one array to another in two ways\n\t Using a loop\n\t Using the static arraycopy  method of the javalangSystem  class\n\t Using the copyOf  method of the javautilArrays  class\nSuppose you have an int array of the length originalLength  and you want to modify its length to \nnewLength  You can apply the first method of copying arrays as shown in the following snippet of code\nint originalLength  100\nint newLength  15\nint ids  new intoriginalLength\n Do some processing here\n Create a temporary array of new length\nint tempIds  new intnewLength\n While copying array elements we have to check if the new length\n is less than or greater than original length\nint elementsToCopy  originalLength  newLength  newLength  originalLength\n Copy the elements from the original array to the new array\nfor int i  0 i  elementsToCopy i\n    tempIdsi  idsi\n\n Finally assign the reference of new array to ids\nids  tempIds\nAnother way to copy elements of an array to another array is by using the arraycopy  method of the \nSystem  class The signature of the arraycopy  method is as follows\npublic static void arraycopyObject sourceArray int sourceStartPosition\n                             Object destinationArray\n                             int destinationStartPosition\n                             int lengthToBeCopied\nHere\n\tsourceArray  is the reference to the source array\n\tsourceStartPosition  is the starting index in the source array from where the \ncopying of elements will startChapter 19  arrays\n691\tdestinationArray  is the reference to the destination array\n\tdestinationStartPosition  is the start index in the destination array from where \nnew elements from the source array will be copied\n\tlengthToBeCopied  is the number of elements to be copied from the source array to \nthe destination array\nYou can replace the previous for loop with the following code\n Now copy array elements using the arraycopy method\nSystemarraycopy ids 0 tempIds 0 elementsToCopy\nYou can also use the copyOf  static method of the Arrays  class The following shows some of copyOf  \nmethods declarations\n\tboolean copyOfboolean original int newLength\n\tbyte copyOfbyte original int newLength\n\tchar copyOfchar original int newLength\n\tdouble copyOfdouble original int newLength\n\tfloat copyOffloat original int newLength\n\tint copyOfint original int newLength\n\tshort copyOflong original int newLength\n\tT T copyOfT original int newLength\nThe first argument to the copyOf  method is the source array The second argument newLength  is the \nnumber of elements in the new array If newLength  is less than the length of the source array the returned \narray will be a truncated copy of the source array If newLength  is greater than the length of the source array \nthe returned array will contain all elements from the original array and the extra elements will be having \ndefault values set based on the data type of the array If newLength  is equal to the length of the source array \nthe returned array contains the same number of elements as the source array\n Tip the Arrays  class contains a copyOfRange  method that lets you copy a range of elements from \nan array to another array Its declaration for the int array is int copyOfRangeint original \nint from int to  the method is overloaded for all da ta types here from  and to are the initial index \ninclusive and final index exclusive of the elements in the source array to be copied these indexes must be \nwithin the range of the source array  which means the length of the destination array can be at maximum \nequal to the source array\nThe objects of the two classes javautilArrayList  and javautilVector  can be used in place of an \narray where the length of the array needs to be modified You can think of the objects of these two classes as \nvariablelength arrays The next section discusses these two classes in detail\nListing 193  demonstrates how to copy an array using a for loop the Systemarraycopy  method the \nArrayscopyOf  method and the ArrayscopyOfRange  methodChapter 19  arrays\n692Listing 193  Copying an Array Using a for Loop and the Systemarraycopy Method\n ArrayCopyTestjava\npackage comjdojoarray\nimport javautilArrays\npublic class ArrayCopyTest \n    public static void mainString args \n         Have an array with 5 elements\n        int data  1 2 3 4 5\n         Expand the data array to 7 elements\n        int eData  expandArraydata 7\n         Truncate the data array to 3 elements\n        int tData  expandArraydata 3\n        SystemoutprintlnUsing forloop\n        printArraysdata eData tData\n         Using Systemarraycopy method \n         Copy data array to new arrays\n        eData  new int7\n        tData  new int3\n        Systemarraycopydata 0 eData 0 5\n        Systemarraycopydata 0 tData 0 3\n        SystemoutprintlnnUsing Systemarraycopy method\n        printArraysdata eData tData\n         Using ArrayscopyOf method   \n         Copy data array to new arrays\n        eData  ArrayscopyOfdata 7\n        tData  ArrayscopyOfdata 3\n        SystemoutprintlnnUsing ArrayscopyOf method\n        printArraysdata eData tData\n         Using ArrayscopyOfRange method \n         Copy data array to new arrays\n        int copy1  ArrayscopyOfRangedata 0 3\n        int copy2  ArrayscopyOfRangedata 2 4\n        SystemoutprintlnnUsing ArrayscopyOfRange method\n        SystemoutprintlnOriginal Array   ArraystoStringdata\n        SystemoutprintlnCopy1 0 3   ArraystoStringcopy1\n        SystemoutprintlnCopy2 2 4   ArraystoStringcopy2\n    \n     Uses a forloop to copy an array\n    public static int expandArrayint oldArray int newLength \n        int originalLength  oldArraylength\n        int newArray  new intnewLength\n        int elementsToCopy  originalLength  newLength  newLength  originalLength\n        for int i  0 i  elementsToCopy i \n            newArrayi  oldArrayi\n        \n        return newArray\n    \n    private static void printArraysint original int expanded int truncated \n        SystemoutprintlnOriginal Array   ArraystoStringoriginal\n        SystemoutprintlnExpanded Array   ArraystoStringexpandedChapter 19  arrays\n693        SystemoutprintlnTruncated Array   ArraystoStringtruncated\n    \n\nUsing forloop\nOriginal Array 1 2 3 4 5\nExpanded Array 1 2 3 4 5 0 0\nTruncated Array 1 2 3\nUsing Systemarraycopy method\nOriginal Array 1 2 3 4 5\nExpanded Array 1 2 3 4 5 0 0\nTruncated Array 1 2 3\nUsing ArrayscopyOf method\nOriginal Array 1 2 3 4 5\nExpanded Array 1 2 3 4 5 0 0\nTruncated Array 1 2 3\nUsing ArrayscopyOfRange method\nOriginal Array 1 2 3 4 5\nCopy1 0 3 1 2 3\nCopy2 2 4 3 4\nThe Arrays  class is in the javautil  package It contains many convenience methods to deal with \narrays For example it contains methods for converting an array to a string format sorting an array etc You \nused the ArraystoString  static method to get the contents of an array in the string format The method \nis overloaded you can use it to get the content of any type of array in string format In this example you used \na for loop and the S ystemarraycopy  method to copy arrays Notice that using the arraycopy  method \nis much more powerful than that of a for loop For example the arraycopy  method is designed to handle \ncopying of the elements of an array from one region to another region in the same array It takes care of \nany overlap in the source and the destination regions within the array For a referencetype array you can \nchange the type of the returned array using the following version of the copyOfRange  method\nTU T copyOfRangeU original int from int to Class extends T newType\nThe method takes a Utype array and returns an array of the T type\n Simulating VariableLength Arrays\nYou know that Java does not provide variablelength arrays However Java libraries provide some classes \nwhose objects can be used as variablelength arrays These classes provide methods to obtain an array \nrepresentation of their elements ArrayList  and Vector  are two classes in the javautil  package that can \nbe used whenever variablelength arrays are needed LinkedList is another type of list that can store any \nnumber of elements but does not utilize an array so has different performance characteristics\nArrayList  and Vector  classes work the same way except that the methods in the Vector  class are \nsynchronized whereas methods in ArrayList  are not Vector is a legacy class and should be avoided \nIf your object list is accessed and modified by multiple threads simultaneously you should use the \nCopyOnWriteArrayList  class which will be slower but threadsafe Otherwise you should use the ArrayList  \nclass For the rest of the discussion we will refer to ArrayList  only However the discussion applies to other \nList implementations  as wellChapter 19  arrays\n694One big difference between arrays and the ArrayList  class is that the latter works with only objects not \nwith primitive data types The ArrayList  class is a generic class and it takes the type of its elements as the \ntype parameter If you want to work with primitive values you need to declare an ArrayList  of one of the \nwrapper classes For example use ArrayListInteger  to work with int elements and all your int values \nwill be boxed into Integer  objects automatically for you The following code fragment illustrates the use of \nthe ArrayList  class\nimport javautilArrayList\n\n Create an ArrayList of Integer\nArrayListInteger ids  new ArrayList\n Get the size of array list\nint total  idssize      total will be zero at this point\n Print the details of array list\nSystemoutprintlnArrayList size is   total\nSystemoutprintlnArrayList elements are   ids\n Add three ids 10 20 30 to the   array list\nidsaddnew Integer10  Adding an Integer object\nidsadd20                Adding an int Autoboxing is at play\nidsadd30                Adding an int Autoboxing is at play\n Get the size of the array list\ntotal  idssize  total will be 3\n Print the details of array list\nSystemoutprintlnArrayList size is   total\nSystemoutprintlnArrayList elements are   ids\n Clear all elements from array list\nidsclear\n Get the size of the array list\ntotal  idssize  total will be 0\n Print the details of array list\nSystemoutprintlnArrayList size is   total\nSystemoutprintlnArrayList elements are   ids\nArrayList size is 0\nArrayList elements are \nArrayList size is 3\nArrayList elements are 10 20 30\nArrayList size is 0\nArrayList elements are \nNote one important observation from this output You can print the list of all elements in an ArrayList  \njust by passing its reference to the Systemoutprintln  method The toString  method of the \nArrayList  class returns a string that is a commaseparated string representation of its elements enclosed in \nbrackets   \nLike arrays ArrayList  uses zerobased indexing That is the first element of ArrayList  has an index of \nzero You can get the element stored at any index by using the getint index  method\n Get the element at the index 0 the first element\nInteger firstId  idsget0\n Get the element at the index 1 the second element\nint secondId  idsget1  Autounboxing is at playChapter 19  arrays\n695You can check if the ArrayList  contains an object using its contains  method\nInteger id20  20\nInteger id50  50\n Add three objects to the arraylist\nidsadd10\nidsadd20\nidsadd30\n Check if the array list contains id20 and id50\nboolean found20  idscontainsid20  found20 will be true\nboolean found50  idscontainsid50  found50 will be false\nYou can iterate through the elements of an ArrayList  in one of the three ways using a loop using \nan iterator or using the forEach method In this chapter we discuss how to iterate through elements of \nan ArrayList  using a for loop and forEach The following snippet of code shows how to use a for loop to \niterate through the elements of an ArrayList \n Get the size of the ArrayList\nint total  idssize\n Iterate through all elements\nfor int i  0 i  total i \n    int temp  idsgeti\n     Do some processing\n\nIf you want to iterate through all elements of the ArrayList  without caring for their indexes you can use \nthe foreach  loop as shown\n Iterate through all elements\nfor int temp  ids \n     Do some processing with temp\n\nTo loop through all elements using forEach you supply as an argument a method reference or lambda \nexpression such as\nidsforEachid \n      Do some processing with id\n\nListing 194  illustrates the use of a for loop and a foreach  loop to iterate through elements of an \nArrayList  It also shows you how to remove an element from an ArrayList  using the remove  method\nListing 194  Iterating Through Elements of an ArrayList\n NameIteratorjava\npackage comjdojoarray\nimport javautilArrayList\npublic class NameIterator \n    public static void mainString args \n         Create an ArrayList of String\n        ArrayListString nameList  new ArrayListChapter 19  arrays\n696         Add some names\n        nameListaddChris\n        nameListaddLaynie\n        nameListaddJessica\n         Get the count of names in the list\n        int count  nameListsize\n         Let us print the name list using a for loop\n        SystemoutprintlnList of names\n        forint i  0 i  count i \n            String name  nameListgeti\n            Systemoutprintlnname\n        \n         Let us remove Jessica from the list\n        nameListremoveJessica\n         Get the count of names in the list again\n        count  nameListsize\n         Let us print the name list again using a foreach loop\n        SystemoutprintlnnAfter removing Jessica\n        forString name  nameList \n            Systemoutprintlnname\n        \n    \n\nList of names\nChris\nLaynie\nJessica\nAfter removing Jessica\nChris\nLaynie\n Passing an\u00a0Array as\u00a0a\u00a0Parameter\nYou can pass an array as a parameter to a method or a constructor The type of array you pass to the method \nmust be assignmentcompatible to the formal parameter type The syntax for an arraytype parameter \ndeclaration for a method is the same as for the other data types That is the parameter declaration should \nstart with the array type followed by whitespace and the argument name as shown\nmodifiers returntype methodNamearraytype argumentName \nThe following are some examples of method declarations with array arguments\n The processSalary method has two parameters\n 1 id is an array of int\n 2 salary is an array of double\npublic static void processSalaryint id double salary \n     Code goes here\nChapter 19  arrays\n697 The setAka method has two parameters\n 1 id is int It is simply int type not array of int\n 2 aka is an array of String\npublic static void setAkaint id String aka \n     Code goes here\n\n The printStates method has one parameter\n 1 stateNames is an array of String\npublic static void printStatesString stateNames \n     Code goes here\n\nThe following snippet of code for a method mimics the toString  method of ArrayList  It accepts an \nint array and returns the commaseparated values enclosed in brackets  \npublic static String arrayToStringint source \n    if source  null \n        return null\n    \n     Use StringBuilder to improve performance\n    StringBuilder result  new StringBuilder\n    for int i  0 i  sourcelength i \n        if i  sourcelength   1 \n            resultappendsourcei\n         else \n            resultappendsourcei  \n        \n    \n    resultappend\n    return resulttoString\n\nThis method may be called as follows\nint ids  10 15 19\nString str  arrayToStringids    Pass ids int array to arrayToString method\nBecause an array is an object the array reference is passed to the method The method which receives \nan array parameter can modify the elements of the array Listing 195  illustrates how a method can change \nthe elements of its array parameter this example also shows how to implement the swap  method to swap \ntwo integers using an array\nListing 195  Passing an Array as a Method Parameter\n Swapjava\npackage comjdojoarray\npublic class Swap \n    public static void mainString args \n        int num  17 80\n        SystemoutprintlnBefore swap\n        Systemoutprintln1   num0\n        Systemoutprintln2   num1Chapter 19  arrays\n698         Call the swap method passing the num array\n        swapnum\n        SystemoutprintlnAfter swap\n        Systemoutprintln1   num0\n        Systemoutprintln2   num1\n    \n     The swap method accepts an int array as an argument and swaps the values\n     if array contains two values\n    public static void swap int source \n        if source  null  sourcelength  2 \n             Swap the first and the second elements\n            int temp  source0\n            source0  source1\n            source1  temp\n        \n    \n\nBefore swap\n1 17\n2 80\nAfter swap\n1 80\n2 17\nRecall in Chapter 8 that we were not able to implement a method for swapping two integers using \nthe methods parameters of primitive types It was so because for primitive types the actual parameters \nare copied to the formal parameter Here you were able to swap two integers inside the swap  method \nbecause you used an array as the parameter The arrays reference is passed to the method not the copy of \nthe elements of the array\n Tip there is a risk when an array is passed to a method  the method may modify the array elements  \nwhich sometimes may not be desired or intended In such a case you should pass a copy of the array to the \nmethod not the original array so if the method modifies the array your original array is not affected\nYou can make a quick copy of your array using the arrays clone  method The phrase quick copy \nwarrants special attention For primitive types the cloned array will have a true copy of the original array \nA new array of the same length is created and the value of each element in the original array is copied to \nthe corresponding element of the cloned array However for reference types the reference of the object \nstored in each element of the original array is copied to the corresponding element of the cloned array This \nis known as a shallow copy whereas the former type where the object or the value is copied is known as \na deep copy In the case of a shallow copy elements of both arrays the original and the cloned refer to the \nsame object in memory You can modify the objects using their references stored in the original array as well \nas the cloned array In this case even if you pass a copy of the original array to a method the state of objects \nreferenced in your original array can be modified inside the method The solution to this problem is to make \na deep copy of your original array to pass it to the method The following snippet of code illustrates the \ncloning of an int array and a String  array Note that the return type of the clone  method is Object  and \nyou need to cast the returned value to an appropriate array typeChapter 19  arrays\n699 Create an array of 3 integers 1 2 and 3\nint ids  1 2 3\n Declare an array of int named clonedIds\nint clonedIds\n The clonedIds array has the same values as the ids array\nclonedIds  int idsclone\n Create an array of 3 strings\nString names    Lisa Pat Kathy\n Declare an array of String named clonedNames\nString clonedNames\n The clonedNames array has the reference of the same three strings as the names array\nString clonedNames  String namesclone\nThe cloning process for primitive array ids and reference array names  in the previous snippet of code is \ndepicted in Figures\u00a0 192  through 195 \nFigure 192  The i ds array is populated and the clonedIds array is declared\nFigure 193  The i ds array is cloned in the clonedIds arrayChapter 19  arrays\n700Notice that when the names  array is cloned the clonedNames  array elements refer to the same String  \nobjects in memory When you mention a method of modifying an array parameter passed to it you may \nmean one or all of the following three things\n\t Array parameter reference\n\t Elements of the array parameter\n\t The objects referred to by the array parameter elementsFigure 195  The names array is cloned in the clonedNames arrayFigure 194  The names array is populated and the clonedNames array is declaredChapter 19  arrays\n701 Array Parameter Reference\nBecause an array is an object a copy of its reference is passed to a method If the method changes the array \nparameter the actual parameter is not affected Listing 196  illustrates this The main  method passes an \narray to the tryArrayChange  method which in turn assigns a different array reference to the parameter \nThe output shows that the array in the main  method remains unaffected\nListing 196  Modifying an Array Parameter Inside a Method\n ModifyArrayParamjava\npackage comjdojoarray\nimport javautilArrays\npublic class ModifyArrayParam \n    public static void mainString args \n        int origNum  101 307 78\n        SystemoutprintlnBefore method call   ArraystoStringorigNum\n         Pass the array to the method\n        tryArrayChangeorigNum\n        SystemoutprintlnAfter method call   ArraystoStringorigNum\n    \n    public static void tryArrayChangeint num \n        SystemoutprintlnInside method1   ArraystoStringnum\n         Create and store a new int array in num\n        num  new int10 20\n        SystemoutprintlnInside method2   ArraystoStringnum\n    \n\nBefore method call 101 307 78\nInside method1 101 307 78\nInside method2 10 20\nAfter method call 101 307 78\nIf you do not want your method to change the array reference inside the method body you must declare \nthe method parameter as final  like so\npublic static void tryArrayChange final int num \n     An error num is final and cannot be changed\n    num  new int10 20\n\n Elements of\u00a0the\u00a0Array Parameter\nThe values stored in the elements of an array parameter can always be changed inside a method Listing 197  \nillustrates thisChapter 19  arrays\n702Listing 197  Modifying Elements of an Array Parameter Inside a Method\n ModifyArrayElementsjava\npackage comjdojoarray\nimport javautilArrays\npublic class ModifyArrayElements \n    public static void mainString args \n        int origNum  10 89 7\n        String origNames  Mike John\n        SystemoutprintlnBefore method call origNum   ArraystoStringorigNum\n        SystemoutprintlnBefore method call origNames   ArraystoStringorigNames\n         Call methods passing the arrays\n        tryElementChangeorigNum\n        tryElementChangeorigNames\n        SystemoutprintlnAfter method call origNum   ArraystoStringorigNum\n        SystemoutprintlnAfter method call origNames   ArraystoStringorigNames\n    \n    public static void tryElementChangeint num \n         If the array has at least one element store 1116  in its first element\n        if num  null  numlength  0 \n            num0  1116\n        \n    \n    public static void tryElementChangeString names \n         If the array has at least one element store Twinkle in its first element\n        if names  null  nameslength  0 \n            names0  Twinkle\n        \n    \n\nBefore method call origNum 10 89 7\nBefore method call origNames Mike John\nAfter method call origNum 1116 89 7\nAfter method call origNames Twinkle John\nNotice that the first element of the arrays changed after the method calls You can change the elements \nof an array parameter inside a method even if the array parameter is declared final \n The Objects Referred To\u00a0by the\u00a0Array Parameter Elements\nThis section applies to array parameters of only the reference type If the arrays reference type is mutable \nyou can change the state of the objects stored in the array elements In the previous section I discussed \nreplacing the reference stored in an array element by a new object reference This section discusses \nchanging the state of the objects referred to by the elements of the array Consider an Item  class as shown in \nListing 198 Chapter 19  arrays\n703Listing 198  An It em Class\n Itemjava\npackage comjdojoarray\npublic class Item \n    private double price\n    private final String name\n    public Item String name double price \n        thisname  name\n        thisprice  price\n    \n    public double getPrice \n        return thisprice\n    \n    public void setPricedouble price  \n        thisprice  price\n    \n    Override\n    public String toString \n        return   thisname     thisprice  \n    \n\nListing 199  illustrates this The main  method creates an array of Item  The array is passed to the \ntryStateChange  method which changes the price of the first element in the array to 1038 The output \nshows that the price is changed for the original element in the array created in the main  method\nListing 199  Modifying the States of Array Elements of an Array Parameter Inside a Method\n ModifyArrayElementStatejava\npackage comjdojoarray\npublic class ModifyArrayElementState \n    public static void mainString args \n        Item myItems  new ItemPen 2511 new ItemPencil 010\n        SystemoutprintlnBefore method call 1  myItems0\n        SystemoutprintlnBefore method call 2  myItems1\n         Call the method passing the array of Item\n        tryStateChangemyItems\n        SystemoutprintlnAfter method call 1  myItems0\n        SystemoutprintlnAfter method call 2  myItems1\n    \n    public static void tryStateChangeItem allItems \n        if allItems  null  allItemslength  0 \n             Change the price of the first item to 1038\n            allItems0setPrice1038\n        \n    \nChapter 19  arrays\n704Before method call 1Pen 2511\nBefore method call 2Pencil 01\nAfter method call 1Pen 1038\nAfter method call 2Pencil 01\n Ti p the clone  method can be used to make a clone of an array For a reference array the clone  \nmethod performs a shallow copy an array should be passed to a method and returned from a method with \ncaution If a method may modify its array parameter and you do not want your actual array parameter to get \naffected by that method call you must pass a deep copy of your array to that method\nIf you store the state of an object in an array instance variable you should think carefully before \nreturning the reference of that array from any methods of your class The caller of that method will get the \nhandle of the array instance variable and will be able to change the state of the objects of that class outside \nthe class This situation is illustrated in the following example\npublic class MagicNumber \n     Magic numbers are not supposed to be changed They can be looked up though\n    private int magicNumbers  5 11 21 51 101\n     Other code goes here\n    public int getMagicNumbers  \n         Never do the following If you do this callers of this\n           method will be able to change the magic numbers\n        \n         return thismagicNumbers\n         Do the following instead In case of reference arrays make a deep copy and\n          return that copy For primitive arrays you can use the clone method\n        \n        return int magicNumbersclone\n    \n\nYou can also create an array and pass it to a method without storing the array reference in a variable \nSuppose there is a method named setNumbersint nums  which takes an int array as a parameter You \ncan call this method as shown\nsetNumbersnew int10 20 30\nNote that you must use the new operator in this case The following method call will not work\n A compiletime error The array initialization list is supported only\n in an array declaration statement\nsetNumbers10 20 30Chapter 19  arrays\n705 CommandLine Arguments\nA Java application can be launched from a command prompt a command prompt in Windows and a \nshell prompt in UNIX It can also be launched from within a Java development environment tool such as \nNetBeans Eclipse JDeveloper etc A Java application is run at the command line like so\njava modulepath modulepath module modulenameclassname\njava modulepath modulepath module modulenameclassname  \nlistofcommandline arguments\nEach argument in the argument list is separated by a space For example the following command runs \nthe comjdojoarrayTest  class and passes three names as the commandline arguments\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayTest Cat Dog Rat\nWhat happens to these three commandline arguments when the Test  class is run The operating \nsystem passes the list of the arguments to the JVM\u00a0Sometimes the operating system may expand the list \nof arguments by interpreting their meanings and may pass a modified argument list to the JVM\u00a0The JVM \nparses the argument list using a space as a separator It creates an array of String  whose length is the same \nas the number of arguments in the list It populates the String  array with the items in the argument list \nsequentially Finally the JVM passes this String  array to the main  method of the Test  class that you are \nrunning This is the time when you use the String  array argument passed to the main  method If there \nis no commandline argument the JVM creates a String  array of zero length and passes it to the main  \nmethod If you want to pass spaceseparated words as one argument you can enclose them in double \nquotes You can also avoid the operating system interpretation of special characters by enclosing them in \ndouble quotes Lets create a class called CommandLine  as shown in Listing 1910 \nListing 1910  Processing Commandline Arguments Inside the main Method\n CommandLinejava\npackage comjdojoarray\npublic class CommandLine \n    public static void mainString args \n         args contains all commandline arguments\n        SystemoutprintlnTotal Arguments   argslength\n         Display all arguments\n        for int i  0 i  argslength i \n            SystemoutprintlnArgument   i  1     argsi\n        \n    \n\nThe following are a few examples of passing commandline arguments to the CommandLine  class\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCommandLine\nTotal Arguments 0Chapter 19  arrays\n706CJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCommandLine Cat Dog Rat\nTotal Arguments 3\nArgument 1 Cat\nArgument 2 Dog\nArgument 3 Rat\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCommandLine Cat Dog Rat\nTotal Arguments 1\nArgument 1 Cat Dog Rat\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCommandLine 29 Dogs\nTotal Arguments 2\nArgument 1 29\nArgument 2 Dogs\nWhat is the use of commandline arguments They let you change the behavior of your program \nwithout recompiling it For example you may want to sort the contents of a file in ascending or descending \norder You may pass commandline arguments which will specify the sorting order If there is no sorting \norder specified on the command line you may assume ascending order by default If you call the sorting \nclass comjdojoarraySortFile  you may run it in the following ways\n To sort employeetxt file in ascending order\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarraySortFile namestxt asc\n To sort departmenttxt file in descending order\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarraySortFile namestxt desc\n To sort salarytxt in ascending order\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarraySortFile namestxt\nDepending on the second element if any of the String  array passed to the main  method of the \nSortFile  class you may sort the file differently\nNote that all commandline arguments are passed to the main  method as a String  If you want to pass \na numeric argument you need to convert the argument to a number To illustrate this numeric argument \nconversion lets develop a mini calculator class which takes an expression as a commandline argument \nand prints the result The mini calculator supports only four basic operations add subtract multiply and \ndivide See Listing 1911 Chapter 19  arrays\n707Listing 1911  A M ini CommandLine Calculator\n Calcjava\npackage comjdojoarray\nimport javautilArrays\npublic class Calc \n    public static void mainString args \n         Print the list of commandline argument\n        SystemoutprintlnArraystoStringargs\n         Make sure we received three arguments and the\n         the second argument has only one character to indicate operation\n        if argslength  3  args1length  1 \n            printUsage\n            return     Stop the program here\n        \n         Parse the two number operands Place the parsing code inside a trycatch\n         so we will handle the error in case both operands are not numbers\n        double n1\n        double n2\n        try \n            n1  DoubleparseDoubleargs0\n            n2  DoubleparseDoubleargs2\n         catch NumberFormatException e \n            SystemoutprintlnBoth operands must be a number\n            printUsage\n            return     Stop the program here\n        \n        String operation  args1\n        double result  computen1 n2 operation\n         Print the result\n        Systemoutprintlnargs0  args1  args2      result\n    \n    public static double computedouble n1 double n2 String operation \n         Initialize the result with notanumber\n        double result  DoubleNaN\n        switch operation \n            case \n                result  n1  n2\n                break\n            case \n                result  n1   n2\n                break\n            case \n                result  n1  n2\n                break\n            case \n                result  n1  n2\n                breakChapter 19  arrays\n708            default\n                SystemoutprintlnInvalid operation  operation\n        \n        return result\n    \n    public static void printUsage \n        SystemoutprintlnUsage java comjdojoarrayCalc expr\n        SystemoutprintlnWhere expr could be\n        Systemoutprintlnn1  n1\n        Systemoutprintlnn1   n2\n        Systemoutprintlnn1  n2\n        Systemoutprintlnn1  n2\n        Systemoutprintlnn1 and n2 are two numbers\n    \n\nThe following are a few ways to use the Calc  class to perform basic arithmetic operations\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCalc 3  7\n3  7\n37  100\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCalc 789  985\n789  985\n789985  7771650000000001\nYou may get an error when you try to use  asterisk as an operation to multiply two numbers The \noperating system may interpret it as all file names in the current directory To avoid such errors you can \nenclose the operator in double quotes or the escape character provided by the operating system as follows\nCJavaFunjava modulepath buildmodulesjdojoarray module  \njdojoarraycomjdojoarrayCalc 789  985\n Ti p If your program uses commandline arguments  it is not a 100 Java program this is because the \nprogram does not fit in the category of write once run everywhere some operating systems do not have a \ncommand prompt and therefore you may not be able to use the commandline argument feature additionally \nan operating system may interpret the metacharacters in the commandline arguments differentlyChapter 19  arrays\n709 Multidimensional Arrays\nIf a data element in a list is identified using more than one dimension you can use a multidimensional array \nto represent the list For example a data element in a table is identified by two dimensions row and column \nYou can store tabular data in a twodimensional array You can declare a multidimensional array by using \na pair of brackets   for each dimension in the array declaration For example you can declare a two\ndimensional array of int as shown\nint table\nHere table  is a reference variable that can hold a reference to a twodimensional array of int At the \ntime of declaration memory is allocated only for the reference variable table  not for any array elements \nThe memory state after this code is executed is depicted in Figure\u00a0 196 \nA twodimensional array of int with three rows and two columns can be created as shown\ntable  new int32\nThe memory state after execution of this code is depicted in Figure\u00a0 197  All elements have been shown \nto have a value of zero because all elements of a numeric array are initialized to zero by default The rules \nfor default initialization of array elements of a multidimensional array are the same as that of a single\ndimensional array as discussed previously in this chapter\nThe indexes of each dimension in a multidimensional array are zerobased Each element of the table  \narray can be accessed as tablerowNumbercolumnNumber  The row number and the column number \nalways start at zero For example you can assign a value to the first row and the second column in the table  \narray as shown\ntable01  32\nYou can assign a value 71 to the third row and the first column like so\ntable20  71Figure 197  Memor y state after the creation of a twodimensional arrayFigure 196  Memor y state after the declaration of a twodimensional arrayChapter 19  arrays\n710The memory state after the two assignments is depicted in Figure\u00a0 198 \nJava does not support a multidimensional array in a true sense Rather it supports an array of arrays \nUsing an array of arrays you can implement the same functionality as provided by multidimensional arrays \nWhen you create a twodimensional array the elements of the first array are of an array type which can refer \nto a singledimensional array The size of each singledimensional array need not be the same Considering \nthe array of arrays concept for the table  twodimensional array you can depict the memory state after array \ncreation and assignments of two values as shown in Figure\u00a0 199 \nThe name of the twodimensional array table  refers to an array of three elements Each element of the \narray is a onedimensional array of int The data type of table0  table1  and table2  is an int array \nThe length of table0  table1  and table2  is each 2\nYou must specify the dimension of at least the firstlevel array at the time you create a multidimensional \narray For example when you create a twodimensional array you must specify at least the first dimension \nwhich is the number of rows You can achieve the same results as the previous code fragment as follows\ntable  new int3\nThis statement creates only the first level of the array Only table0  table1  and table2  exist at \nthis time They are referring to null  At this time tablelength  has a value of 3 Since table0  table1  \nand table2  are referring to null  you cannot access their length  attribute That is you have created three \nrows in a table but you do not know how many columns each row will contain Since table0  table1  \nand table2  are arrays of int you can assign them values as followsFigure 198  Memor y state after two assignments to the twodimensional array elements\nFigure 199  An a rray of arraysChapter 19  arrays\n711table0  new int2  Create 2 columns for row 1\ntable1  new int2  Create 2 columns for row 2\ntable2  new int2  Create 2 columns for row 3\nYou have completed the creation of the twodimensional array which has three rows and where each \nrow has two columns You can assign the values to some cells as follows\ntable01  32\ntable20  71\nIt is also possible to create a twodimensional array with a different number of columns for each row \nSuch an array is called a ragged  array Listing 1912  illustrates working with a ragged array\nListing 1912  An Exam ple of a Ragged Array\n RaggedArrayjava\npackage comjdojoarray\npublic class RaggedArray \n    public static void mainString args \n         Create a twodimensional array of 3 rows\n        int raggedArr  new int3\n         Add 2 columns to the first row\n        raggedArr0  new int2\n         Add 1 column to the second row\n        raggedArr1  new int1\n         Add 3 columns to the third row\n        raggedArr2  new int3\n         Assign values to all elements of raggedArr\n        raggedArr00  1\n        raggedArr01  2\n        raggedArr10  3\n        raggedArr20  4\n        raggedArr21  5\n        raggedArr22  6\n         Print all elements One row at one line\n        SystemoutprintlnraggedArr00  t  raggedArr01\n        SystemoutprintlnraggedArr10\n        SystemoutprintlnraggedArr20  t  raggedArr21  t  raggedArr22\n    \n\n1     2\n3\n4     5        6Chapter 19  arrays\n712 Tip Java supports an array of arrays which can be used to achieve functionalities provided by a \nmultidimensional array  Multidimensional arrays are widely used in scientific and engineering applications If \nyou are using arrays in your business application program that have more than two dimensions you may need \nto reconsider the choice of multidimensional arrays as the choice for your data structure\n Accessing Elements of\u00a0a\u00a0Multidimensional Array\nTypically a multidimensional array is populated using nested for loops The number of for loops used to \npopulate a multidimensional array equals the number of dimensions in the array For example two for \nloops are used to populate a twodimensional array Typically a loop is used to access the elements of a \nmultidimensional array Listing 1913  illustrates how to populate and access elements of a twodimensional \narray\nListing 1913  Acces sing Elements of a Multidimensional Array\n MDAccessjava\npackage comjdojoarray\npublic class MDAccess \n    public static void mainString args\n        int ra  new int3\n        ra0  new int2\n        ra1  new int1\n        ra2  new int3\n         Populate the ragged array using for loops\n        forint i  0 i  ralength i \n            forint j  0 j  railength j\n                raij  i  j\n            \n        \n         Print the array using for loops\n        forint i  0 i  ralength i \n            for int j  0 j  railength j\n                Systemoutprintraij  t\n            \n             Add a new line after each row is printed\n            Systemoutprintln\n        \n    \n\n0     1\n1\n2     3        4Chapter 19  arrays\n713 Initializing Multidimensional Arrays\nYou may initialize the elements of a multidimensional array by supplying the list of values at the time of its \ndeclaration or at the time of creation You cannot specify the length of any dimension if you initialize the \narray with a list of values The number of initial values for each dimension will determine the length of each \ndimension in the array Since many dimensions are involved in a multidimensional array the list of values \nfor a level is enclosed in braces For a twodimensional array the list of values for each row is enclosed in a \npair of braces like so\nint arr  10 20 30 11 22 222 333 444 555\nThis statement creates a twodimensional array with three rows The first row contains three columns \nwith values 10 20 and 30 The second row contains two columns with values 11 and 22 The third row \ncontains four columns with values 222 333 444 and 555 A zerorow and zerocolumn twodimensional \narray can be created as shown\nint empty2D   \nInitialization of a multidimensional array of reference type follows the same rule You can initialize a \ntwodimensional String  array like so\nString acronymList  JMF Java Media Framework\n                          JSP Java Server Pages\n                          JMS Java Message Service\nYou can initialize the elements of a multidimensional array at the time you create it like so\nint arr  new int1 2 345\n Enhanced for\u00a0Loop for\u00a0Arrays\nJava has an enhanced for loop that lets you loop through elements of an array in a cleaner way The \nenhanced for loop is also known as a foreach  loop The syntax is as follows\nforDataType e  array \n     Loop body goes here\n     e contains one element of the array at a time\n\nThe foreach  loop uses the same for keyword used by the basic for loop Its body is executed as many \ntimes as the number of elements in the array  DataType e  is a variable declaration where e is the variable \nname and DataType  is its data type The data type of the variable e should be assignmentcompatible with \nthe type of the array  The variable declaration is followed by a colon   which is followed by the reference \nof the array that you want to loop through The foreach  loop assigns the value of an element of the array to \nthe variable e which you can use inside the body of the loop The following snippet of code uses a foreach  \nloop to print all elements of an int array\nint numList  1 2 3\nforint num  numList \n    Systemoutprintlnnum\nChapter 19  arrays\n7141\n2\n3\nYou can accomplish the same feat using the basic for loop as follows\nint numList  1 2 3\nforint i  0 i  numListlength i \n    int num  numListi\n    Systemoutprintlnnum\n\n1\n2\n3\nNote that the foreach  loop provides a way to loop through elements of an array which is cleaner than \nthe basic for loop However it is not a replacement for the basic for loop because you cannot use it in all \ncircumstances For example you cannot access the index of the array element and you cannot modify the \nvalue of the element inside the loop as you do not have the index of the element\n Array Declaration Syntax\nYou can declare an array by placing a pair of brackets   after the data type of the array or after the name of \nthe array reference variable For example the following declaration\nint empIds\nint points2D\nint points3D\nPerson persons\nis equivalent to\nint empIds\nint points2D\nint points3D\nPerson persons\nJava also allows you to mix two syntaxes In the same array declaration you can place some brackets \nafter the data type and some after the variable name For example you can declare a twodimensional array \nof int as follows\nint points2DChapter 19  arrays\n715You can declare a twodimensional and a threedimensional array of int in one declaration statement \nas follows\nint points2D points3D\nor\nint points2D points3D\n Runtime Array Bounds Checks\nAt runtime Java checks array bounds for every access to an array element If the array bounds are exceeded \na javalangArrayIndexOutOfBoundsException  is thrown The only requirement for array index values at \ncompile time is that they must be integers The Java compiler does not check if the value of an array index is \nless than zero or beyond its length This check must be performed at runtime before every access to an array \nelement is allowed Runtime array bounds checks slow down the program execution for two reasons\n\t The first reason is the cost of bound checks itself To check the array bounds the \nlength of the array must be loaded in memory and two comparisons one for less \nthan zero and one for greater than or equal to its length must be performed\n\t The second reason is that an exception must be thrown when the array bounds are \nexceeded Java must do some housekeeping and get ready to throw an exception if \nthe array bounds are exceeded\nListing 1914  illustrates the exception thrown if the array bounds are exceeded The program creates an \narray of int named test  which has a length of 3 The program cannot access the fourth element  test3  \nas it does not exist An ArrayIndexOutOfBoundsException  is thrown when such an attempt is made\nListing 1914  Array Bounds Checks\n ArrayBoundsjava\npackage  comjdojoarray\npublic class ArrayBounds \n    public static void mainString args \n        int test  new int3\n        SystemoutprintlnAssigning 12 to the first element\n        test0  12    OK Index 0 is between 0 and 2\n        SystemoutprintlnAssigning 79 to the fourth element\n         Index 3 is not between 0 and 2 At runtime an exception is thrown\n        test3  79\n        SystemoutprintlnWe will not get here\n    \n\nAssigning 12 to the first element\nAssigning 79 to the fourth element\nException in thread main javalangArrayIndexOutOfBoundsException 3\n      at comjdojoarrayArrayBoundsmainArrayBoundsjava14Chapter 19  arrays\n716It is good practice to check for array length before accessing its elements The fact that array bounds \nviolation throws an exception may be misused as shown in the following snippet of code which prints \nvalues stored in an array\n Do not use this code even if it works\n Create an array\nint arr  new int10\n Populate the array here\n Print the array Wrong way\ntry \n     Start an infinite loop When we are done with all elements an exception is\n     thrown and we will be in catch block and hence out of the loop\n    int counter  0\n    while true \n        Systemoutprintlnarrcounter\n    \n catch ArrayIndexOutOfBoundsException e \n     We are done with printing array elements\n\n Do some processing here\nThe previous snippet of code uses an infinite while  loop to print values of the elements of an array and \nrelies on the exceptionthrowing mechanism to check for array bounds The right way is to use a for loop \nand check for the array index value using the length  property of the array\n What Is the\u00a0Class of\u00a0an\u00a0Array Object\nArrays are objects Because every object has a class you must have a class for every array All methods of the \nObject  class can be used on arrays Because the getClass  method of the Object  class gives the reference \nof the class for any object in Java you will use this method to get the class name for all arrays Listing 1915  \nillustrates how to get the class name of an array\nListing 1915  Kno wing the Class of an Array\n ArrayClassjava\npackage comjdojoarray\npublic class ArrayClass \n    public static void main String args\n        int iArr  new int2\n        int iiArr  new int22\n        int iiiArr  new int222\n        String sArr    A B \n        String ssArr  AA BB \n        String sssArr     A 3D empty array of string\n         Print the class name for all arrays\n        Systemoutprintlnint   getClassNameiArr\n        Systemoutprintlnint   getClassNameiiArr\n        Systemoutprintlnint   getClassNameiiiArr\n        SystemoutprintlnString   getClassNamesArrChapter 19  arrays\n717        SystemoutprintlnString   getClassNamessArr\n        SystemoutprintlnString   getClassNamesssArr\n    \n     Any Java object can be passed to getClassName method\n     Since every array is an object we can also pass an array to this method\n    public static String getClassNameObject obj \n         Get the reference of its class\n        Class c  objgetClass\n         Get the name of the class\n        String className  cgetName\n        return className\n    \n\nint I\nint I\nint I\nString LjavalangString\nString LjavalangString\nString LjavalangString\nThe class name of an array starts with left brackets  The number of left brackets is equal to the \ndimension of the array For an int array the left brackets is followed by a character I For a referencetype  \narray the left brackets is followed by a character L followed by the name of the class name which is \nfollowed by a semicolon The class names for onedimensional primitive arrays and a reference type are \nshown in Table\u00a0 192 \nTable 192  Class Name of Arrays\nArray Type Class Name\nbyte B\nshort S\nint I\nlong J\nchar C\nfloat F\ndouble D\nboolean Z\ncomjdojoarrayPerson LcomjdojoarrayPersonChapter 19  arrays\n718The class names of arrays are not available at compile time for declaring or creating them You must use \nthe syntax described in this chapter to create an array That is you cannot write the following to create an \nint array\nI myIntArray\nRather you must write the following to create an int array\nint myIntArray\n Array Assignment Compatibility\nThe data type of each element of an array is the same as the data type of the array For example each \nelement of an int  array is an int each element of a String  array is a String  The value assigned to an \nelement of an array must be assignmentcompatible to its data type For example it is allowed to assign a \nbyte  value to an element of an int array because byte  is assignmentcompatible to int However it is not \nallowed to assign a float  value to an element of an int array because float  is not assignmentcompatible \nto int\nint sequence  new int10\nsequence0  10      OK Assigning an int 10 to an int\nsequence1  194f  A compiletime error Assigning a float to an int\nThe same rule must be followed when dealing with a referencetype array If there is a referencetype \narray of type T its elements can be assigned an object reference of type S if and only if S is assignment\ncompatible to T The subclass object reference is always assignmentcompatible to the superclass of all \nclasses in Java You can use an array of Object  class to store objects of any class for example\nObject genericArray  new Object4\ngenericArray0  new StringHello    OK\ngenericArray1  new PersonDaniel  OK  Assuming Person class exists\ngenericArray2  new Account189       OK Assuming Account class exist\ngenericArray3  null                   Ok null can be assigned to any reference type\nYou need to perform a cast at the time you read back the object from the array as shown\n The compiler will flag an error for the following statement genericArray is of Object\n   type and an Object reference cannot be assigned to a String reference variable Even\n   though genericArray0 contains a String object reference we need to cast it to String\n   as we do in next statement\n\nString s  genericArray0  A compiletime error\nString str  String genericArray0  OK\nPerson p  Person genericArray1     OK\nAccount a  Account genericArray2  OK\nIf you try to cast the array element to a type whose actual type is not assignmentcompatible to the \nnew type a javalangClassCastException  is thrown For example the following statement will throw a \nClassCastException  at runtime\nString str  String genericArray1  Person cannot be cast to StringChapter 19  arrays\n719You cannot store an object reference of the superclass in an array of the subclass The following snippet \nof code illustrates this\nString names  new String3\nnames0  new Object  A compiletime error Object is superclass of String\nnames1  new Person  A compiletime error Person is not subclass of String\nnames2  null           OK\nFinally an array reference can be assigned to another array reference of another type if the former type \nis assignmentcompatible to the latter type\nObject obj  new Object3\nString str  new String2\nAccount a  new Account5\nobj  str              OK\nstr  String obj  OK because obj has String array reference\nobj  a\n A ClassCastException will be thrown obj has the reference of an Account array and\n an Account cannot be converted to a String\nstr  String obj\na  Account obj  OK\n Converting a\u00a0List to\u00a0an\u00a0Array\nAn ArrayList  can be used when the number of elements in the list is not precisely known Once the number \nof elements in the list is fixed you may want to convert an ArrayList  to an array You may do this for one of \nthe following reasons\n\t The program semantics may require you to use an array not an ArrayList  For example \nyou may need to pass an array to a method but you have data stored in an ArrayList \n\t You may want to store user inputs in an array However you do not know the number \nof values the user will input In such a case you can store values in an ArrayList  while \naccepting input from the user At the end you can convert the ArrayList  to an array\n\t Accessing array elements is faster than accessing ArrayList  elements If you have \nan ArrayList  and you want to access the elements multiple times you may want to \nconvert the ArrayList  to an array for better performance\nThe ArrayList  class has an overloaded method named toArray \n\tObject toArray\n\tT T toArrayT a\nThe first method returns the elements of ArrayList  as an array of Object  The second method takes an \narray of any type as an argument All ArrayList  elements are copied to the passed array if there is enough \nspace and the same array is returned If there is not enough space in the passed array a new array is created \nThe type of new array is the same as the passed array The length of the new array is equal to the size of \nArrayList  Listing 1916  shows how to convert an ArrayList  to an arrayChapter 19  arrays\n720Listing 1916  An Ar rayList to an Array Conversion\n ArrayListToArrayjava\npackage comjdojoarray\nimport javautilArrayList\nimport javautilArrays\npublic class ArrayListToArray \n    public static void mainString args \n        ArrayListString al  new ArrayList\n        aladdcat\n        aladddog\n        aladdrat\n         Print the content of the ArrayList\n        SystemoutprintlnArrayList   al\n         Create an array of the same length as the ArrayList\n        String s1  new Stringalsize\n         Copy the ArrayList elements to the array\n        String s2  altoArrays1\n         s1 has enough space to copy all ArrayList elements\n         altoArrays1 returns s1 itself\n        Systemoutprintlns1  s2   s1  s2\n        Systemoutprintlns1   ArraystoStrings1\n        Systemoutprintlns2   ArraystoStrings2\n         Create an array of string with 1 element\n        s1  new String1\n        s10  hello  Store hello in first element\n         Copy ArrayList to the array s1\n        s2  altoArrays1\n         Since s1 doesnt have sufficient space to copy all ArrayList elements\n           altoArrays1 creates a new String array with 3 elements in it All\n           elements of arraylist are copied to the new array Finally the new array is\n           returned Here s1  s2 is false s1 will be untouched by the method call\n         \n        Systemoutprintlns1  s2   s1  s2\n        Systemoutprintlns1   ArraystoStrings1\n        Systemoutprintlns2   ArraystoStrings2\n    \n\nArrayList cat dog rat\ns1  s2 true\ns1 cat dog rat\ns2 cat dog rat\ns1  s2 false\ns1 hello\ns2 cat dog ratChapter 19  arrays\n721 Performing Array Operations\nThere are several routine array operations such as sorting searching comparing and copying that you need to \nperform in everyday programming The javautilArrays  class is a utility class that contains over 150 static \nconvenience methods to perform such types of array operations Before you roll out your own code to perform \narray operations refer to the Arrays  class API documentation and you might find a method to achieve the same\nDo not get intimidated by the large number of methods in this class It does not support over 150 types \nof array operations The reason for the large number of methods in the Arrays  class is to support the same \noperations on arrays of all primitive types and reference types Most methods have at least nine overloaded \nversionsone for each of the eight primitivetype arrays and one for the referencetype array Sometimes \noperations can be performed on the entire array or on a range of elements that doubles the number of \nminimum methods for one array operation to at least 18 It is not possible to go through each and every \nmethod and provide examples That will take over 100 pages of this book We put all methods into different \ncategories based on the type of operations they perform and provide a few examples Table\u00a0 193  lists such \ncategories and the names of the methods that perform array operations in those categories\nTable 193  Metho ds in the Arrays Class and Their Categories with Description\nCategory Method Name Description\nConversion asList Returns a fixedsize  list backed by the specified array There is only one \nversion of this method\nstream Returns a sequential stream of an array for all elements or a range of \nelements\ntoString Returns a string representation of the contents of the specified array\ndeepToString Returns a string representation of the deep contents of an array \nSuitable for using for a multidimensional array\nSearching binarySearch Allows you to search a sorted array using the binary search algorithm \nThe array must be sorted before being passed to this method \notherwise the result is undefined Search is allowed in the entire \narray or in a range of elements within the array\nComparing compare Compares two arrays lexicographically It returns 0 if the first and second \narrays are equal and contain the same elements in the same order a \nvalue less than 0 if the first array is lexicographically less than the second \narray and a value greater than 0 if the first array is lexicographically \ngreater than the second array The method was added in Java 9\ncompareUnsigned Works the same as the compare  method numerically treating \nelements as unsigned The method was added in Java 9\ndeepEquals Returns true  if the two specified arrays are deeply equal to one another\nequals Returns true  if the two specified arrays of ints are equal to one \nanother You can compare entire arrays or a range of elements in \nthem for equality The method was added in Java 9\nmismatch Finds and returns the index of the first mismatch between two arrays \notherwise returns 1 if no mismatch is found The entire contents \nof two arrays or their range of elements can be compared for a \nmismatch The method was added in Java 9\ncontinued Chapter 19  arrays\n722The following sections show you how to use some of these methods You will need to import several \nclasses and interfaces from the javautil  package to run the example snippets of code The following \nimport will do the job\nimport javautil\n Converting Arrays to\u00a0Another Type\nIn this category methods in the Arrays  class let you obtain a List  a Stream  and a String  from an array \nThe asListT a  method takes a varargs argument of type T and returns a ListT  The following are a \nfew examples\n Create a String array\nString animals  rat dog cat\n Convert the array to a List\nListString animalList  ArraysasListanimals\nSystemoutprintlnAs a List   animalList\n Convert the array to a String\nString str  ArraystoStringanimalsTable 193  continued \nCategory Method Name Description\nCopying copyOf Copies an array to another array The length of the new array is \nspecified The new array may be smaller or bigger than the source \narray If it is bigger additional elements are filled with the default \nvalue of the data type of the array\ncopyOfRange Copies a range of elements from one array to another\nFilling fill Allows you to assign the same value to all elements or to a range of \nelements in an array\nsetAll Allows you to assign a value to all elements or to a range of elements \nin an array The values are generated by a generator function\nComputing\nhash codedeepHashCode Returns a hash code based on the deep contents of an array For a \nmultidimensional array contents in all dimensions are included in \ncomputing the hash code\nhashCode Returns a hash code based on the contents of the specified array\nParallel \nupdateparallelPrefix Cumulates in parallel each element of an array in place using the \nsupplied function\nparallelSetAll Sets all elements of the specified array in parallel using a generator \nfunction to compute each element\nSorting parallelSort Sorts all elements or a range of elements in an array using parallel \nsort\nsort Sorts all elements or a range of elements in an array\nObtaining \nSpliteratorspliterator Returns a Spliterator  including all or a range of elements in an \narrayChapter 19  arrays\n723SystemoutprintlnAs a String   str\n Get a sorted Stream of the array and print its elements\nSystemoutprintlnSorted Stream of Animals \nArraysstreamanimals\n      sorted\n      forEachSystemoutprintln\nAs a List rat dog cat\nAs a String rat dog cat\nSorted Stream of Animals\ncat\ndog\nrat\n Searching an\u00a0Array\nUse the binarySearch  method to search for a key in an array The array must be sorted for this method to \nwork The method returns the index of the search key if it is contained in the array Otherwise it returns a \nnegative number which is equal to\ninsertion point   1\nHere insertion point is defined as the index at which the key would be inserted into the array This \nguarantees that the returned value is a negative integer if the key is not present in the array The following is \nan example\n Create an array to work with\nint num  2 4 3 1\nSystemoutprintlnOriginal Array   ArraystoStringnum\n Sort the array before using the binary search\nArrayssortnum\nSystemoutprintlnArray After Sorting   ArraystoStringnum  Array After Sorting \n1 2 3 4\nint index  ArraysbinarySearchnum 3\nSystemoutprintlnFound index of 3   index     Found index of 3 2\nindex  ArraysbinarySearchnum 200\nSystemoutprintlnFound index of 200   index    Found index of 200 5\nSince 200 should go last at index 4 the binarySearch method returns 4\u00a0 1 which is 5\n Comparing Arrays\nThe equals  method lets you compare two arrays for equality Two arrays are considered equal if the \nnumber of elements in the arrays or slices is the same and all corresponding pairs of elements in the arrays \nor slices are equal\nThe compare  and compareUnsigned  methods compare elements in arrays or array slices \nlexicographically The compareUnsigned  method treats the integer values as unsigned A null  array is \nlexicographically less than a non null  array Two null  arrays are equalChapter 19  arrays\n724The mismatch  method compares two arrays or array slices The method returns the index of the first \nmismatch If there is no mismatch it returns 1 If either array is null  it throws a NullPointerException  \nListing 1917  contains a complete program that compares two arrays and their slices The program uses int \narrays for comparisons\nListing 1917  Com paring Arrays and Array Slices Using the Arrays Class Methods\n ArrayComparisonjava\npackage comjdojoarray\nimport javautilArrays\npublic class ArrayComparison \n    public static void mainString args \n        int a1  1 2 3 4 5\n        int a2  1 2 7 4 5\n        int a3  1 2 3 4 5\n         Print original arrays\n        SystemoutprintlnThree arrays\n        Systemoutprintlna1   ArraystoStringa1\n        Systemoutprintlna2   ArraystoStringa2\n        Systemoutprintlna3   ArraystoStringa3\n         Compare arrays for equality\n        SystemoutprintlnnComparing arrays using equals method\n        SystemoutprintlnArraysequalsa1 a2   Arraysequalsa1 a2\n        SystemoutprintlnArraysequalsa1 a3   Arraysequalsa1 a3\n        SystemoutprintlnArraysequalsa1 0 2 a2 0 2 \n                 Arraysequalsa1 0 2 a2 0 2\n         Compare arrays lexicographically\n        SystemoutprintlnnComparing arrays using compare method\n        SystemoutprintlnArrayscomparea1 a2   Arrayscomparea1 a2\n        SystemoutprintlnArrayscomparea2 a1   Arrayscomparea2 a1\n        SystemoutprintlnArrayscomparea1 a3   Arrayscomparea1 a3\n        SystemoutprintlnArrayscomparea1 0 2 a2 0 2 \n                 Arrayscomparea1 0 2 a2 0 2\n         Find the mismatched index in arrays\n        SystemoutprintlnnFinding mismatch using the mismatch method\n        SystemoutprintlnArraysmismatcha1 a2   Arraysmismatcha1 a2\n        SystemoutprintlnArraysmismatcha1 a3   Arraysmismatcha1 a3\n        SystemoutprintlnArraysmismatcha1 0 5 a2 0 1 \n                 Arraysmismatcha1 0 5 a2 0 1\n    \n\nThree arrays\na1 1 2 3 4 5\na2 1 2 7 4 5\na3 1 2 3 4 5\nComparing arrays using equals method\nArraysequalsa1 a2 false\nArraysequalsa1 a3 true\nArraysequalsa1 0 2 a2 0 2 true\nComparing arrays using compare methodChapter 19  arrays\n725Arrayscomparea1 a2 1\nArrayscomparea2 a1 1\nArrayscomparea1 a3 0\nArrayscomparea1 0 2 a2 0 2 0\nFinding mismatch using the mismatch method\nArraysmismatcha1 a2 2\nArraysmismatcha1 a3 1\nArraysmismatcha1 0 5 a2 0 1 1\n Copying Arrays\nThe copyOf  method lets you copy elements of the original array by specifying a new length for the new \narray If the length of the new array is greater than the length of the original array the additional elements \nare assigned a default value according to the type of the array The copyOfRange  method lets you copy a \nslice of an array to another array Here is an example\n Create an array to work with\nint nums  2 4 3 1\nSystemoutprintlnOriginal Array   ArraystoStringnums\n Copy of the truncated num to 2 elements\nint numCopy1  ArrayscopyOfnums 2\nSystemoutprintlnTruncated Copy   ArraystoStringnumCopy1\n Copy of the extended num to 6 elements\nint numCopy2  ArrayscopyOfnums 6\nSystemoutprintlnExtended Copy     ArraystoStringnumCopy2\n Copy of the range index 2 inclusive to 4 exclusive\nint numCopy3  ArrayscopyOfRangenums 2 4\nSystemoutprintlnRange Copy     ArraystoStringnumCopy3\nOriginal Array 2 4 3 1\nTruncated Copy 2 4\nExtended Copy 2 4 3 1 0 0\nRange Copy 3 1\n Filling Arrays\nYou can use the fill  method to fill all elements or a range of elements of an array with the same value \nThe setAll  method lets you set values for all elements in an array using a function The function is passed \nthe index of the array and it returns the value for the element at that index Here are examples of using both \nmethods\n Create an array to work with\nint num  2 4 3 1\nSystemoutprintlnOriginal Array   ArraystoStringnum\n Fill elements of the array with 10\nArraysfillnum 10\nSystemoutprintlnArray filled with 10   ArraystoStringnumChapter 19  arrays\n726 Fill elements of the array with a value index  1  10\nArrayssetAllnum index  index  1  10\nSystemoutprintlnArray filled with a function   ArraystoStringnum\nOriginal Array 2 4 3 1\nArray filled with 10 10 10 10 10\nArray filled with a function 10 20 30 40\n Computing Hash Code\nUse the hashCode  method to compute the hash code for an array based on its elements values If the \npassedin array is null  the method returns 0 For any two arrays a1 and a2 such that Arraysequals  \na1 a2  it is also the case that ArrayshashCodea1  ArrayshashCodea2  Here is an example\n Create an array to work with\nint num  2 4 3 1\nSystemoutprintlnArray   ArraystoStringnum\n Compute the hash code of the array\nint hashCode  ArrayshashCodenum\nSystemoutprintlnHash Code   hashCode\nArray 2 4 3 1\nHash Code 987041\n Performing Parallel Accumulation\nint num  2 4 3 1\nSystemoutprintlnBefore   ArraystoStringnum\nArraysparallelPrefixnum n1 n2  n1  n2\nSystemoutprintlnAfter   ArraystoStringnum\nBefore 2 4 3 1\nAfter 2 8 24 24\n Sorting Arrays\nUse the sort  and parallelSort  methods to sort elements of an array The former is suitable for smaller \narrays and the latter for bigger arrays Here are a few examples\n Create an array to work with\nint num1  2 4 3 1\nSystemoutprintlnOriginal Array   ArraystoStringnum1\n Sort the array\nArrayssortnum1\nSystemoutprintlnUsing sort   ArraystoStringnum1Chapter 19  arrays\n727 Create an array to work with\nint num2  2 4 3 1\nSystemoutprintlnOriginal Array   ArraystoStringnum2\n Sort the array\nArraysparallelSortnum2\nSystemoutprintlnUsing parallelSort   ArraystoStringnum2\nOriginal Array 2 4 3 1\nUsing sort 1 2 3 4\nOriginal Array 2 4 3 1\nUsing parallelSort 1 2 3 4\n Summary\nAn array is a data structure to store multiple data values of the same type All array elements are allocated \ncontiguous space in memory Array elements are accessed using their indexes Arrays use zerobased \nindexing The first element has an index of zero Every array has a property named length  which contains \nthe number of elements in the array An array can have a length of zero\nArrays in Java are objects Java supports fixedlength arrays That is once an array is created its length \ncannot be changed Use an ArrayList  if you need a variablelength array The ArrayList  class provides a \ntoArray  method to convert its elements to an array Java supports multidimensional arrays in the form \nof ragged arrays that are arrays of arrays You can clone an array using the clone  method The method \nperforms a shallow cloning for reference arrays\nThe Arrays  class in the javautil  package contains several static convenience methods that let you \nperform many different types of operations on an array like searching sorting comparing filling etc\nEXERCISES\n 1 What is an array Name the property of an array that gives you the number of \nelements in the array\n 2 What is the index of the first element of an array\n 3 Write the code to initialize an int array in two ways the array contains elements \n10 20 and 30\n 4 you ha ve to store values in an array but you do not know the number of elements \nin advance how will you code this situation so you get\u00a0all elements in an array in \nthe end\n 5 Complete the follo wing snippet of code that prints the class name of an array \nobject\nString names  Corky Bryce Paul Tony\nString className  names Your code goes here \nSystemoutprintlnClass Name   classNameChapter 19  arrays\n728 6 Consider the follo wing declaration of a method named test  that takes an \nint  array as an argument\npublic static void testint num \n    ifnumlength  0 \n        num0  100\n    \n    num  new int1000 2000\n \nWrite the output when the following code is executed\nint num  2 4 3 1\nSystemoutprintlnnum0    num0\ntestnum\nSystemoutprintlnnum0    num0\n 7 Which of the follo wing statements declares a twodimensional int array\nint y\nint z\nint x\nint x  2 2\n 8 Declare a twodimensional array of three rows and three columns named table  \nDemonstrate how you will initialize all elements of the array with a value 10 during \ndeclaration and using a for loop\n 9 Consider the follo wing declaration for an array\nint x  10 20 30 40\nWrite a for loop and a foreach  loop to print each elements value in the array on \na single line on the standard output\n 10 Consider the follo wing declaration for an array\nint x  10 20 30 40\nSystemoutprintlnx5\nWhat will happen when this snippet of code is executed\n 11 What method of the Arrays  class will you use to sort a large array sort  or \nparallelSort \n 12 Name the method in the Arrays  class that converts an array to its string \nrepresentation\n 13 the Arrays  class contains a binarySearch  method that lets you search a \nvalue in the array What condition must the array meet before you should use the \nbinarySearch  methodChapter 19  arrays\n729 14 Write and explain the output of the follo wing snippet of code\nint table1  1 2 3 10 20 30\nint table2  1 2 3 10 20 30\nboolean equal1  Arraysequalstable1 table2\nboolean equal2  ArraysdeepEqualstable1 table2\nSystemoutprintlnequal1\nSystemoutprintlnequal2\n 15 Consider the follo wing snippet of code that is meant to copy the contents of a \ntwodimensional array named table1  to another twodimensional array named \ntable2  help the author of this code to complete the missing logic you need to \nwrite two lines of code\nint table1  1 2 3 10 20 30\nint table2  new inttable1length\n Complete missing logic\nforint i  0 i  table1length i \n     Your one line code goes here \n    forint j  0 j  table1ilength j \n         Your one line code goes here \n    \n\nboolean equal  ArraysdeepEqualstable1 table2\nSystemoutprintlnequal\nSystemoutprintlnArraysdeepToStringtable1\nSystemoutprintlnArraysdeepToStringtable2\nthis snippet of code is supposed to have the following output\ntrue\n1 2 3 10 20 30\n1 2 3 10 20 30731\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307420CHAPTER 20\nInheritance\nIn this chapter you will learn\n\t What inheritance is\n\t How to inherit a class from another class\n\t The difference between early binding and late binding\n\t What method overriding is and how to override methods\n\t What field hiding and method hiding are and how to use them\n\t What abstract classes are and where to use them\n\t How to declare final  classes and methods\n\t The difference between isa  hasa  and partof relationships\n\t How to use pattern matching for classes\n\t How to use sealed classes\nAll example programs in this chapter are a member of a jdojoinheritance  module as declared in \nListing 201 \nListing 201  The D eclaration of a jdojoinheritance Module\n moduleinfojava\nmodule jdojoinheritance \n    exports comjdojoinheritance\n\n What Is Inheritance\nSometimes you may need the same functionality at multiple places in your application There are different \nways to write code to achieve this One way is to copy the same code in all places where you need the same \nfunctionality If you follow this logic you need to make changes at all places when the functionality changes \nConsider an example where you need the same functionality at three different places Suppose you have an \napplication that deals with three kinds of objects planets employees and managers Further suppose that \nall three kinds of objects have a name You create three classes Planet  Employee  and Manager  to represent \nthe three kinds of objects Each class has an instance variable called name  and two methods called getName  \nand setName  If you think about the code in three classes to maintain the name of their objects you would Chapter 20  Inher ItanCe\n732find that they are the same You might have written code for one class and copied it to another two classes \nYou may realize the problem in maintaining this kind of code when the same code is copied in multiple \nplaces If you need to handle the name differently later you will need to make changes in three places \nInheritance is the feature of objectoriented programming that helps in such circumstances to avoid copying \nthe same code at multiple places thus facilitating code reuse Inheritance also lets you customize the code \nwithout changing the existing code Inheritance offers much more than just code reuse and customization\nInheritance is one of the cornerstones of objectoriented programming languages It lets you create a \nnew class by reusing code from an existing class The new class is called a subclass and the existing class is \ncalled the superclass A superclass contains the code that is reused and customized by the subclass It is said \nthat the subclass inherits from the superclass A superclass is also known as a base class or a parent class \nA subclass is also known as a derived class or a child class Technically it may be possible to inherit a class \nfrom any existing class However practically it is not always a good idea to do so Inheritance in software \ndevelopment works much the same way as inheritance in normal human life You inherit something from \nyour parents your parents inherit something from their parents and so on If you look at inheritance in \nhuman lives there exists a relationship between humans for inheritance to occur Similarly there exists a \nrelationship between objects of the superclass and the subclass The relationship that must exist between \nthe superclass and the subclass in order for inheritance to be effective is called an isa relationship You \nneed to ask yourself a simple question before you should inherit class Q from class P Is an object of class Q \nalso an object of class P In other words Does an object of class Q behave like an object of class P If the \nanswer is yes class Q may inherit from class P Consider three classes Planet  Employee  and Manager  Lets \nask the same question using these three classes one by one\n\t Is a planet an employee That is does an isa relationship exist between a planet \nand an employee The answer is no Is an employee a planet The answer is no\n\t Is a planet a manager The answer is no Is a manager a planet The answer is no\n\t Is an employee a manager The answer is maybe An employee may be a manager \na clerk a programmer or any other type of employee However an employee is not \nnecessarily always a manager Is a manager an employee The answer is yes\nYou asked six questions using the three classes You got yes as the answer in only one case This is the \nonly case that is fit for using inheritance The Manager  class should inherit from the Employee  class\n Inheriting Classes\nHow does a class inherit from another class It is very simple to inherit a class from another class You need \nto use the keyword extends  followed by the superclass name in the class declaration of your subclass The \ngeneral syntax is as follows\nmodifiers class subclassname extends superclassname  \n     Code for the subclass goes here\n\nFor example the following code declares a class Q which inherits from class P assuming that class P \nalready exists\npublic class Q extends P \n     Code for class Q goes here\nChapter 20  Inher ItanCe\n733You can use either the simple name or the fully qualified name of the superclass in a class declaration \nIf the subclass and the superclass do not reside in the same package you may need to import the superclass \nname to use its simple name in the extends  clause Suppose the fully qualified names of classes P and Q \nare pkg1P  and pkg2Q  respectively The previous declaration may be rewritten in one of the following two \nwaysusing the simple name of the superclass or using the fully qualified name of the superclass\n 1  Use the simple name of P in the extends clause and use an import statement\npackage pkg2\nimport pkg1P\npublic class Q extends P \n     Code for class Q goes here\n\n 2  Use the fully qualified name of P  No need to use an import statement\npackage pkg2\npublic class Q extends pkg1P \n     Code for class Q goes here\n\nLets look at the simplest example of inheritance in Java Lets start with an Employee  class as shown in \nListing 202 \nListing 202  An Em ployee Class\n Employeejava\npackage comjdojoinheritance\npublic class Employee \n    private String name  Unknown\n    public void setNameString name \n        thisname  name\n    \n    public String getName \n        return name\n    \n\nEmployee  is a simple class with a private instance variable name  and two public methods setName  \nand getName  The instance variable is used to store the name for an employee and the two methods are \nused to get and set the name instance variable Note that there is no special code in the Employee  class It is \none of the simplest classes you can write in Java It is easy to write and understand the following snippet of \ncode that uses the Employee  class\nEmployee emp  new Employee\nempsetNameJohn Jacobs\nString empName  empgetName\nSystemoutprintlnEmployee Name   empName\nEmployee Name John JacobsChapter 20  Inher ItanCe\n734Listing 203  contains the code for a Manager  class which inherits from the Employee  class Note the \nuse of the keyword extends  to indicate that the Employee  class is the superclass and the Manager  class is the \nsubclass The Manager  class does not contain any code except its declaration That is all you need in the \nManager  class for now\nListing 203  A Man ager Class\n Managerjava\npackage comjdojoinheritance\npublic class Manager extends Employee \n     No code is needed for now\n\nLets test the Manager  class Listing 204  contains the test program\nListing 204  Testing the Manager Class\n SimplestInheritanceTestjava\npackage comjdojoinheritance\npublic class SimplestInheritanceTest \n    public static void mainString args \n         Create an object of the Manager class\n        Manager mgr  new Manager\n         Set the manager name\n        mgrsetNameLeslie Zanders\n         Get the manager name\n        String mgrName  mgrgetName\n         Print the manager name\n        SystemoutprintlnManager Name   mgrName\n    \n\nManager Name Leslie Zanders\nEven if you did not write any code for the Manager  class it works the same as the Employee  class \nbecause it inherits from the Employee  class You create a manager object by using the Manager  classs \nconstructor\nManager mgr  new Manager\nAfter the Manager  object is created the code looks similar to the one you used for dealing with an \nEmployee  object You used the setName  and getName  methods with the Manager  object\nmgrsetNameLeslie Zanders\nString mgrName  mgrgetName\nNote that the Manager  class does not declare the setName  and getName  methods Neither does \nit declare the name  instance variable However it appears that all of them have been declared inside the \nManager  class because it uses the extends Employee  clause in its declaration When a class inherits from \nanother class it inherits its superclass members instance variables methods etc There are many rules \nthat govern inheritance We discuss those rules in detail one by one later in this chapterChapter 20  Inher ItanCe\n735 The Object Class Is the\u00a0Default Superclass\nIf a class does not specify a superclass using the keyword extends  in its class declaration it inherits from the \njavalangObject  class For example the following two class declarations for class P are the same\n 1  extends Object is implicitly added for class P\npublic class P \n     Code for class P goes here\n\n 2  extends Object is explicitly added for class P\npublic class P extends Object  \n     Code for class P goes here\n\nIn the previous chapters you did not use the extends  clause to declare your classes They were \nimplicitly inherited from the Object  class This is the reason that objects of those classes were able to use the \nmethods of the Object  class Consider the following snippet of code\nEmployee emp  new Employee\nint hc  emphashCode\nString str  emptoString\nThe Employee  class does not specify its superclass using an extends clause This means that it inherits \nfrom the Object  class The Object  class declares the hashCode  and toString  methods Because the \nEmployee  class is implicitly a subclass of the Object  class it can use these methods as if they have been \nincluded in its own declaration You have been using inheritance from the very first Java program you wrote \nalthough you were not aware of it This section has demonstrated the power of inheritance that comes as \ncode reuse You will see other benefits of inheritance later in this chapter\n Inheritance and\u00a0Hierarchical Relationship\nWe touched upon this point in the previous section that inheritance should be used only if an isa \nrelationship exists between the subclass and the superclass A subclass can have its own subclasses which in \nturn can have their own subclasses and so on All classes in an inheritance chain form a treelike structure \nwhich is known as an inheritance hierarchy or a class hierarchy All classes above a class in the inheritance \nhierarchy are called ancestors for that class All classes below a class in the inheritance hierarchy are called \ndescendants of that class\nJava allows single inheritance for a class That is a class can have only one superclass or parent \nHowever a class can be the superclass for multiple classes All classes in Java have a superclass except the \nObject  class The Object  class sits at the top of the inheritance hierarchies Figure\u00a0 201  shows a sample \ninheritance hierarchy for the Employee  class and its descendants using a UML Unified Modeling Language \ndiagram In a UML diagram a superclass and a subclass are connected using an arrow pointing from the \nsubclass to the superclassChapter 20  Inher ItanCe\n736Sometimes the term immediate superclass is used to mean the ancestor class which is one level up \nin the inheritance hierarchy whereas the term superclass is used to mean an ancestor class at any level \nThis book uses the term superclass to mean ancestor of a class which is one level up in the inheritance \nhierarchy For example Programmer  is the superclass of SystemProgrammer  whereas Employee  and \nObject  are ancestors of SystemProgrammer  Sometimes the term immediate subclass is used to mean a \ndescendant class which is one level down in the inheritance hierarchy whereas the term subclass is used \nto mean a descendant class at any level This book uses the term subclass to mean a descendant of a class \nwhich is one level down in the inheritance hierarchy For example Employee  is a subclass of Object whereas \nClerk  Programmer  and Manager  are subclasses of Employee  Clerk  Programmer  ApplicationProgrammer  \nSystemProgrammer  DatabaseProgrammer  Manager  FullTimeManager  and PartTimeManager  are all \ndescendants of Employee  If a class is a descendant of another class it is also a descendant of the ancestor of \nthat class For example all descendants of the Employee  class are also descendants of the Object  class All \ndescendants of the Manager  class are also descendants of the Employee  class and the Object  class\n What Is Inherited by a\u00a0Subclass\nA subclass does not inherit everything from its superclass However a subclass may use directly or \nindirectly everything from its superclass Lets discuss the distinction between a subclass inheriting  \nsomething from its superclass and a subclass using  something from its superclass \nLets take a realworld example Suppose your parent a superclass has money in a bank account The \nmoney belongs to your parent You a subclass need some money If you inherit the money you would just \nuse the money at will as if the money is yours If you can just use the money you cannot get to the parents \nmoney directly Rather you need to ask your parent for money and they will give it to you In both cases \nyou used your parents money In the case of inheritance the money appears to be owned by you That is \nyou have direct access to it In the second case your parents money was available to you for use without you \nhaving direct access to it In the latter case you had to go through your parent to use their money\nA subclass inherits nonprivate members  of its superclass We will discuss this rule in detail shortly Note \nthat constructors and initializers static and instance are not members of a class and therefore they are not \ninherited Members of a class are all members that are declared inside the body of the class and members \nthat it inherits from the superclass This definition of members of a class has a trickledown effect\nSuppose there are three classes A B and C The class A inherits from the Object  class The class B \ninherits from the class A and the class C inherits from the class B Suppose that class A declares a private \nmember m1 and a nonprivate member m2 The members of class A are m1 m2 and all inherited members \nfrom the Object  class Note that m1 and m2 members of class A are declared members whereas others are \nFigure 201  A sample inheritance class hierarchyChapter 20  Inher ItanCe\n737inherited members Members of class B will be any members that are declared in class B and all nonprivate \nmembers of class A The member m1 is declared private in class A so it is not inherited by class B The same \nlogic applies to the members of class C Nonprivate members of the Object  class trickle down to classes A B \nand C through the inheritance hierarchy The nonprivate members of class A trickle down to class B which \nin turn trickle down to class C through the inheritance hierarchy\n Tip a superc lass and its subclasses may be in different modules a subc lass in module P can inherit from \na superclass in module Q only if the subclass has been declared public and module Q exports the package \ncontaining the superclass to at least module P refer to Cha pter 10 for more on accessing classes across \nmodule boundaries\nThere are four access modifiers private  public  protected  and package level The absence of the \nprivate  public  or protected  access modifier is considered as the default or packagelevel access The \naccess level modifier of a class member determines two things\n\t Who can access or use that class member directly\n\t Whether a subclass inherits that class member or not\nAccess modifiers are also used with nonmembers eg constructors of a class In such cases an access \nmodifiers role is only one Who can access that nonmember\nIf a class member is declared private  it is accessible only inside the class that declares it A private  \nclass member is not inherited by subclasses of that class\nA public  class member is accessible from everywhere provided the class itself is accessible A subclass \ninherits all public  members of its superclass\nIf a class member is declared protected  it is accessible in the package in which it is declared A \nprotected class member is always accessible inside the body of a subclass whether the subclass is in the \nsame package as the class or in a different package A protected class member is inherited by a subclass The \nprotected  access modifier is used with a class member when you want subclasses to access and inherit the \nclass member Note that a protected class member can be accessed both through the package in which it is \ndeclared and subclasses If you want to provide access to a class member only from inside its package you \nshould use a packagelevel access modifier not a protected  access modifier\nIf a class member is declared package level it is accessible only inside the package in which the class \nis declared A packagelevel class member is inherited only if the superclass and subclass are in the same \npackage If the superclass and the subclass are in different packages the subclass does not inherit package\nlevel members from its superclass\n Tip the access modifiers build on each other where you start with no access to the outside world \nprivate  and add to it first package default then subclasses  protected  and then the world  public \nLets look at your example of inheritance in Listings 202  and 203  The Employee  class has three \nmembers a name  field a getName  method and a setName  method The name  field has been declared \nprivate  and hence it is not accessible inside the Manager  class because it is not inherited The getName  \nand setName  methods have been declared public  and they are accessible from anywhere including \nthe Manager  class They are inherited from the Employee  class by the Manager  class though since they are \npublic  the fact they are inherited doesnt matterChapter 20  Inher ItanCe\n738 Upcasting and\u00a0Downcasting\nAn isa relationship in the real world translates into inheritance class hierarchy in software A class is a \ntype in Java When you express the isa relationship using inheritance you create a subclass which is a \nmore specific type of the superclass For example a Manager  is a specific type of Employee  An Employee  is \na specific type of Object  As you move up in the inheritance hierarchy you move from a specific type to a \nmore general type How does inheritance affect the client code In this context the client code is any code \nthat uses the classes in a class hierarchy Inheritance guarantees that whatever behavior is present in a class \nwill also be present in its subclass A method in a class represents a behavior of the objects of that class \nThis means that whatever behavior a client code expects to be present in a class will also be present in the \nclasss subclass This leads to the conclusion that if client code works with a class it will also work with the \nclasss subclass because a subclass guarantees at least the same behaviors as its superclass For example \nthe Manager  class provides at least the same behaviors as provided by its superclass Employee  Consider the \nfollowing snippet of code\nEmployee emp\nemp  new Employee\nempsetNameRichard Castillo\nString name  empgetName\nThis snippet of code compiles without any errors When the compiler comes across emp\nsetNameRichard Castillo  and empgetName  calls it checks the declared type of the emp variable \nIt finds that the declared type of the emp variable is Employee  It makes sure that the Employee  class has \nsetName  and getName  methods that conform to the call being made It finds that the Employee  class \ndoes have a setName  method that takes a String  as a parameter It finds that the Employee  class does \nhave a getName  method that takes no parameters and returns a String  After verifying these two facts the \ncompiler is fine with the empsetName  and empgetName  method calls\nWith the point in mind that a subclass guarantees at least the same behavior methods as its \nsuperclass consider the following snippet of code\nEmployee emp\nemp  new Manager  A Manager object assigned to an Employee variable\nempsetNameRichard Castillo\nString name  empgetName\nThe compiler will compile this snippet of code too even though you have changed the code this time \nto assign the emp variable an object of the Manager  class It will pass the setName  and getName  method \ncalls on the same basis as described in the previous case It also passes the assignment statement\nemp  new Manager\nThe compiletime type of the new Manager  expression is the Manager  type The compiletime type or \ndeclared type of the emp variable is Employee  type Since the Manager  class inherits from the Employee  class \nan object of the Manager  class isa object of the Employee  class Simply you say that a manager is always \nan employee Such an assignment from subclass to superclass is called upcasting  and it is always allowed \nin Java It is also called a widening conversion because an object of the Manager  class more specific type is \nassigned to a reference variable of the Employee  type a more generic type All of the following assignments \nare allowed and they are all examples of upcastingChapter 20  Inher ItanCe\n739Object obj\nEmployee emp\nManager mgr\nPartTimeManager ptm\n An employee is always an object\nobj  emp\n A manager is always an employee\nemp  mgr\n A parttime manager is always a manager\nmgr  ptm\n A parttime manager is always an employee\nemp  ptm\n A parttime manager is always an object\nobj  ptm\nUse a simple rule to check if an assignment is a case of upcasting Look at the compiletime type \ndeclared type of the expression on the right side of the assignment operator eg b in a  b  If the \ncompiletime type of the righthand operand is a subclass of the compiletime type of the lefthand operand \nit is a case of upcasting and the assignment is safe and allowed Upcasting is a direct technical translation of \nthe fact that an object of a subclass isa object of the superclass too\n Tip Inheritance armed with upcasting and late binding is the basis for inc lusion polymorphism in Java \nrefer to Cha pter 1 for more on inclusion polymorphism\nUpcasting is a very powerful feature of inheritance It lets you write polymorphic code that works with \nclasses that exist and classes that will be added in the future It lets you code your application logic in terms \nof a superclass that will always work with all subclasses existing subclasses or subclasses to be added in \nthe future It lets you write generic code without worrying about a specific type class with which the code \nwill be used at runtime Listing 205  is a simple utility class to test your upcasting rule It has a printName  \nstatic method that accepts an argument of the Employee  type The method uses the getName  method of the \nEmployee  class to get the name of the employee object and print the name on the standard output\nListing 205  A Utilit y Class That Uses an EmployeeType Parameter in Its printName Method\n EmpUtiljava\npackage comjdojoinheritance\npublic class EmpUtil \n    public static void printNameEmployee emp\n         Get the name of employee\n        String name  empgetName\n         Print employee name\n        Systemoutprintlnname\n    \nChapter 20  Inher ItanCe\n740Listing 206  contains a program to test the upcasting rule using the EmpUtil  class\nListing 206  A Tes t Class to Test the Upcasting Rule\n UpcastTestjava\npackage comjdojoinheritance\npublic class UpcastTest \n    public static void mainString args \n        Employee emp  new Employee\n        empsetNameKen Wood\n        Manager mgr  new Manager\n        mgrsetNameKen Furr  Inheritance of setName at work\n         Print names\n        EmpUtilprintNameemp\n        EmpUtilprintNamemgr   Upcasting at work\n    \n\nKen Wood\nKen Furr\nThe main  method creates two objects  emp and mgr one of the Employee  class and one of the Manager  \nclass It sets names for both objects Finally it calls the printName  method of the EmpUtil  class to print the \nnames of both objects The first call to EmpUtilprintNameemp  is fine because the printName  method \naccepts an Employee  object and you have passed an Employee  object emp The second call EmpUtil\nprintNamemgr  is fine because of the upcasting rule The printNameEmployee emp  accepts an Employee  \nobject and you were able to pass a Manager  object mgr instead because a manager is always an employee \nand upcasting rules allow the assignment of a subclass object to a variable of superclass type\nAssigning a superclass reference to a subclass variable is called downcasting  or narrowing conversion \nDowncasting is the opposite of upcasting In upcasting the assignment moves up the class hierarchy \nwhereas in downcasting the assignment moves down the class hierarchy The Java compiler cannot make \nsure at compile time that downcasting is legal Consider the following snippet of code\nEmployee emp\nManager mgr  new Manager\nemp  mgr  OK  Upcasting\nmgr  emp  A compiletime error Downcasting\nThe assignment emp  mgr  is allowed because of upcasting However the assignment mgr  emp  is \nnot allowed because it is a case of downcasting where a variable of superclass  Employee  is being assigned \nto a variable of subclass  Manager  The compiler is right in assuming that every manager is an employee \nupcasting However not every employee is a manager downcasting In the previous snippet of code you \nwould like the downcasting to work because you know for sure that the emp variable holds a reference to a \nManager  Java imposes an additional rule in order for your downcast to succeed at compile time You need to \ngive additional assurance to the compiler that you have considered the assignment of a superclass reference \nto a subclass reference variable and you would like the compiler to pass it You give this assurance by adding \na typecast or simply a cast to the assignment as shown\nmgr  Manager emp  OK using a typecast Downcast at workChapter 20  Inher ItanCe\n741This downcasting with a typecast succeeds at compile time However the Java runtime will perform an \nadditional verification The job of the compiler is just to make sure that the declared type of the mgr variable \nwhich is Manager  is assignmentcompatible with the typecast being used which is Manager  The compiler \ncannot check what type of object the emp variable will actually refer to at runtime The Java runtime verifies \nthe correctness of the typecast Manager emp  in the previous statement\nThe type of the object to which the emp variable refers at runtime is also called its runtime type The \nruntime compares the runtime type of the emp variable and the Manager  type the Manager  type is used in the \ntypecast If the runtime type of the emp variable is assignmentcompatible with the type used in typecast the \ntypecast succeeds at runtime Otherwise the runtime throws a javalangClassCastException \nConsider the following snippet of code assuming that you have a subclass of the Manager  class which is \ncalled PartTimeManager \nEmployee emp\nManager mgr  new Manager\nPartTimeManager ptm  new PartTimeManager\nemp  mgr                     Upcasting OK\nptm  PartTimeManager emp  Downcasting OK at compiletime A runtime error\nThe last assignment which uses downcasting succeeds at compile time because the declared type \nof the ptm variable and the typecast type are the same The runtime type of emp is Manager  because the \nemp  mgr  statement assigns a Manager  objects reference to it When the runtime attempts to execute the \nPartTimeManager emp  part of the downcasting it finds that the runtime type of emp which is Manager  \nis not assignmentcompatible with the typecast type which is PartTimeManager  This is the reason that the \nruntime will throw a ClassCastException \nYou can think of a statement that involves a downcasting as having two parts for the verification \npurpose Suppose the statement is a2  K b2  The compilers job is to verify that the declared type of a2 is \nassignmentcompatible with type K The runtimes job is to verify that the runtime type of b2 is assignment\ncompatible with type K If any of the two checks fails you get an error at compile time or runtime depending \nof which check fails Figure\u00a0 202  depicts this scenario\n Tip the Object  class is at the top of every class hierarchy in Java this allo ws you to assign a reference \nof any class type to a variable of the Object  type the follo wing type of assignment is always allowed\nObject obj  new AnyJavaClass  Upcasting\nWhether downcasting from an Object  type to another class type will succeed depends on the downcasting \nrule as discussed in this sectionFigure 202  Run time and compiletime checks made for downcastingChapter 20  Inher ItanCe\n742 The instanceof Operator\nHow can you be sure that a downcasting will always succeed at runtime Java has an instanceof  operator \nwhich helps you determine whether a reference variable has a reference to an object of a class or a subclass \nof the class at runtime It takes two operands and evaluates to a boolean  value true  or false  Its syntax is as \nfollows\nreferencevariable instanceof typename\nIf referencevariable  refers to an object of the type typename  or any of its descendants \ninstanceof  returns true  Otherwise it returns false  If referencevariable  is null  instanceof  always \nreturns false \nYou should use the instanceof  operator before downcasting to check if the reference variable you \nare trying to downcast is of the type you expected it to be For example if you want to check if a variable of \nEmployee  type refers to a Manager  object at runtime you would write the following\nManager mgr  new Manager\nEmployee emp  mgr\nif emp instanceof Manager \n     The following downcast will always succeed\n    mgr  Manager emp\n else \n     emp is not a Manager type\n\nYou can simplify this with the patternmatching feature added in Java 16 like the following\nManager mgr  new Manager\nEmployee emp  mgr\nif emp instanceof Manager mgr \n     mgr is a variable of type Manager you can reference here\n else \n     emp is not a Manager type\n\nThe syntax of the patternmatching instanceof operator is as follows\nreferencevariable instanceof typename newvariablename\nThe instanceof  operator goes through two types of checks compiletime check and runtime check \nThe compiler checks if it is ever possible for the lefthand operand to refer to an object of the righthand \noperand This check may not be obvious to you at this point The purpose of using the instanceof  operator \nis to compare the runtime type of a reference variable to a type In short it compares two types Does it ever \nmake sense to compare a mango with an employee You would say no The compiler adds checks for this \nkind of illogical comparison using the instanceof  operator It makes sure that it is possible for the lefthand \noperand of the instanceof  operator to hold a reference to an object of the righthand operand type If it is \nnot possible the compiler generates an error It is easy to find out whether the compiler will generate an \nerror for using the instanceof  operator or not Consider the following snippet of code\nManager mgr  null\nif mgr instanceof Clerk     A compiletime error\nChapter 20  Inher ItanCe\n743The variable mgr can hold a reference to Manager  type or its descendant type However it can never \nhold a reference to the Clerk  type The Clerk  type is not in the same inheritance chain as the Manager  class \nalthough it is in the same inheritance tree For the same reason the following use of the instanceof operator \nwill generate a compiletime error because the String  class is not in the inheritance chain of the Employee  \nclass\nString str  test\nif str instanceof Employee   A compiletime error\n\n Tip an object is considered an instance of a c lass if that object is of that class type or its direct or indirect \ndescendant type You can use the instanceof  operator to check if an object is an instance of a class or not\nSometimes you may end up writing code that uses the instanceof  operator to test for multiple \nconditions at one place as follows\nEmployee emp\n Some logic goes here\nif emp instanceof TempEmployee temp \n     Code to deal with a temp employee\n else if emp instanceof Manager mgr \n     Code to deal with a manager\n else if emp instanceof Clerk clerk \n     Code to deal with a clerk\n\nYou should avoid writing this kind of code If you add a new subclass of Employee  you will need to add \nthe logic for the new subclass to this code Usually this kind of code indicates a design flaw Always ask \nyourself the question Will this code keep working when I add a new class to the existing class hierarchy If \nthe answer is yes you are fine Otherwise reconsider the design\nThe equals  method is the one place in which you will often end up using the instanceof  operator It \nis defined in the Object  class and the method is inherited by all classes It takes an Object  as an argument It \nreturns true  if the argument and the object on which this method is called are considered equal Otherwise \nit returns false  Objects of each class may be compared for equality differently For example two employees \nmay be considered equal if they work for the same company and in the same department and have the same \nemployee ID\u00a0What happens if a Manager  object is passed to the equals  method of the Employee  class \nSince a manager is also an employee it should compare the two for equality Listing 207  contains a possible \nimplementation of the equals  method for the Employee  class\nListing 207  Implemen ting the equals Method for the Employee Class\n Employeejava\npackage comjdojoinheritance\npublic class Employee \n    private String name  Unknown\n    public void setNameString name \n        thisname  name\n    Chapter 20  Inher ItanCe\n744    public String getName \n        return name\n    \n    public boolean equalsObject obj \n        boolean isEqual  false\n         We compare objects of the Employee class with the objects of\n         Employee class or its descendants\n        if obj instanceof Employee e \n             If two have the same name consider them equal\n            String n  egetName\n            isEqual  nequalsthisname\n        \n        return isEqual\n    \n\nAfter you have added the equals  method to the Employee  class you can write code like the following \nwhich compares two objects of the Employee  type for equality based on their names\nEmployee emp  new Employee\nempsetNameJohn Jacobs\nManager mgr  new Manager\nmgrsetNameJohn Jacobs\nSystemoutprintlnmgrequalsemp             prints true\nSystemoutprintlnempequalsmgr             prints true\nSystemoutprintlnempequalsJohn Jacobs  prints false\nIn the third comparison you compare an Employee  object with a String  object which returns false  \nComparing an Employee  and a Manager  object returns true  because they are related by subclassing and have \nthe same name\nthe employee equals method can be reduced to one line since the e variable is defined by the  \npatternma tching instanceof operator as the following line\nreturn obj instanceof Employee e  egetNameequals thisname \n Binding\nClasses have methods and fields we write code to access them as follows Assume that myMethod  and xyz \nare members of the MyClass  class which is the declared type of the myObject  reference variable\nMyClass myobject  get an object reference\nmyObjectmyMethod     Which myMethod to call\nint a  myObjectxyz    Which xyz to accessChapter 20  Inher ItanCe\n745Binding is the process of identifying the accessed methods code  myMethod  in this case or the field \nxyz in this case which will be used when the code executes In other words binding is a process of making \na decision which methods code or field will be accessed when the code executes There are two stages \nwhere the binding can happen compile time and runtime When the binding occurs at compile time it is \nknown as early binding  Early binding is also known as static binding  or compiletime binding  When the \nbinding occurs at runtime it is known as late binding  Late binding is also known as dynamic binding  or \nruntime binding \n Early Binding\nEarly binding is simple to understand compared to late binding In early binding the decision about which \nmethod code or field will be accessed is made by the compiler at compile time For a method call the \ncompiler decides which method from which class will be executed when the code having the method call \nis executed For a field access the compiler decides which field from which class will be accessed when the \ncode having the field access is executed Early binding is used for the following types of methods and fields \nof a class\n\t All types of fields static and nonstatic\n\t Static methods\n\t Nonstatic final methods\nIn early binding a method or a field is accessed based on the declared type or compiletime type of \nthe variable or expression accessing the method or the field For example if early binding is used for an a2\nm1  method call if a2 has been declared of type A the m1  method in class A will be called when a2m1  is \nexecuted\nLets look at a detailed example that demonstrates the early binding rules Consider the two classes \nshown in Listings 208  and 209 \nListing 208  An Earl yBindingSuper Class That Has a Static Field an Instance Field and a Static Method\n EarlyBindingSuperjava\npackage comjdojoinheritance\npublic class EarlyBindingSuper \n     An instance variable\n    public String str  EarlyBindingSuper\n     A static variable\n    public static int count  100\n    public static void print \n        SystemoutprintlnInside EarlyBindingSuperprint\n    \n\nListing 209  An Earl yBindingSub Class Which Inherits from the EarlyBindingSuper Class and Has a Static \nField an Instance Field and a Static Method Which Are of the Same Type as in Its Superclass\n EarlyBindingSubjava\npackage comjdojoinheritance\npublic class EarlyBindingSub extends EarlyBindingSuper\n     An instance variable\n    public String str  EarlyBindingSubChapter 20  Inher ItanCe\n746     A static variable\n    public static int count  200\n    public static void print \n        SystemoutprintlnInside EarlyBindingSubprint\n    \n\nThe EarlyBindingSuper  class declares two fields str and count  The str field is declared nonstatic \nand count  is declared static  The print  method is declared static \nThe EarlyBindingSub  class inherits from the EarlyBindingSuper  class and it declares the same types \nof fields and methods which have the same names Fields are set to different values and the method prints \na different message in the EarlyBindingSub  class so you can know which one is accessed when you execute \nyour code The EarlyBindingTest  class in Listing 2010  demonstrates the result of the early binding\nListing 2010  A Tes t Class to Demonstrate Early Binding for Fields and Methods\n EarlyBindingTestjava\npackage comjdojoinheritance\npublic class EarlyBindingTest \n    public static void mainString args \n        var ebSuper  new EarlyBindingSuper\n        var ebSub  new EarlyBindingSub\n         Will access EarlyBindingSuperstr\n        SystemoutprintlnebSuperstr\n         Will access EarlyBindingSupercount\n        SystemoutprintlnebSupercount\n         Will access EarlyBindingSuperprint\n        ebSuperprint\n        Systemoutprintln\n         Will access EarlyBindingSubstr\n        SystemoutprintlnebSubstr\n         Will access EarlyBindingSubcount\n        SystemoutprintlnebSubcount\n         Will access EarlyBindingSubprint\n        ebSubprint\n        Systemoutprintln\n         Will access EarlyBindingSuperstr\n        SystemoutprintlnEarlyBindingSuper ebSubstr\n         Will access EarlyBindingSupercount\n        SystemoutprintlnEarlyBindingSuper ebSubcount\n         Will access EarlyBindingSuperprint\n        EarlyBindingSuper ebSubprint\n        Systemoutprintln\n         Assign the ebSub to ebSuper\n        ebSuper  ebSub  Upcasting\n         Now access methods and fields using ebSuper variable which is\n           referring to a EarlyBindingSub object\n         \n         Will access EarlyBindingSuperstr\n        SystemoutprintlnebSuperstr\n         Will access EarlyBindingSupercount\n        SystemoutprintlnebSupercountChapter 20  Inher ItanCe\n747         Will access EarlyBindingSuperprint\n        ebSuperprint\n        Systemoutprintln\n    \n\nEarlyBindingSuper\n100\nInside EarlyBindingSuperprint\n\nEarlyBindingSub\n200\nInside EarlyBindingSubprint\n\nEarlyBindingSuper\n100\nInside EarlyBindingSuperprint\n\nEarlyBindingSuper\n100\nInside EarlyBindingSuperprint\n\nThe main  method creates an object of each type EarlyBindingSuper  and EarlyBindingSub \nvar ebSuper  new EarlyBindingSuper\nvar ebSub  new EarlyBindingSub\nAccording to early binding rules the statements ebSuperstr  ebSupercount  and ebSuperprint  \nwill always access the str and count  fields and the print  method of the EarlyBindingSuper  class because \nyou have declared ebSuper  of the EarlyBindingSuper  type This decision is made by the compiler because \nstr and count  are fields and for fields Java always uses early binding The print  method is a static  \nmethod and Java always uses early binding for static  methods The same rule applies when you access \nthese members using the ebSub  variable\nThe output of the following statements may not be obvious\n Will access EarlyBindingSuperstr\nSystemoutprintlnEarlyBindingSuperebSubstr\n Will access EarlyBindingSupercount\nSystemoutprintlnEarlyBindingSuperebSubcount\n Will access EarlyBindingSuperprint\nEarlyBindingSuperebSubprint\nThese three statements use an expression to access fields and methods When you write ebSub\nstr you access the str field using the ebSub  variable directly It is clear that the ebSub  variable is of type \nEarlyBindingSub  and therefore ebSubstr  will access the str field of the EarlyBindingSub  class When \nyou use typecast the compiletime type of the expression changes For example the compiletime type \nof ebSub  is EarlyBindingSub  However the compiletime type of the expression EarlyBindingSuper \nebSub  is EarlyBindingSuper  This is the reason that all of the previous three statements will access fields \nand methods from the EarlyBindingSuper  class not from the EarlyBindingSub  class even though they \nall use the ebSub  variable which is of the EarlyBindingSub  type The output of Listing 2010  validates this \nexplanation discussion about the early binding rulesChapter 20  Inher ItanCe\n748 Tip You can also access static  fields and methods of a class using the name of the class for example \nEarlyBindingSubstr  the early binding rules still a pply and the compiler will bind the access to those \nfields and methods to the class whose name is used to access them Using the class name to access static \nmembers of the class should be preferred for readability\n Late Binding\nBinding for all nonstatic nonfinal methods follows the rules of late binding That is if your code accesses \na nonstatic method which is not declared final  the decision as to which version of the method is called is \nmade at runtime The version of the method that will be called depends on the runtime type of the object on \nwhich the method call is made not on its compiletime type Consider the following snippet of code which \ncreates an object of the Manager  class and assigns the reference to a variable emp of the Employee  class The \nemp variable accesses the setName  method\nEmployee emp  new Manager\nempsetNameJohn Jacobs\nThe compiler performs only one check for the empsetName  method call in this code It makes sure \nthat the declared type of the emp variable which is Employee  has a method called setNameString s  The \ncompiler detects that the setNameString s  method in the Employee  class is an instance method which \nis not final  For an instance method call the compiler does not perform binding It will leave this work for \nthe runtime The method call empsetNameJohn Jacobs  is an example of late binding At runtime \nthe JVM decides which setNameString s  method should be called The JVM gets the runtime type of \nthe emp variable The runtime type of the emp variable is Manager  when the empsetNameJohn Jacobs  \nstatement is looked at in this code The JVM traverses up the class hierarchy starting from the runtime type \nie Manager  of the emp variable looking for the definition of a setNameString s  method First it looks \nat the Manager  class and it finds that the Manager  class does not declare a setNameString s  method The \nJVM now moves one level up the class hierarchy which is the Employee  class It finds that the Employee  \nclass declares a setNameString s  method Once the JVM finds a match it binds the call to that method \nand stops the search Recall that the Object  class is always at the top of all class hierarchies in Java The JVM \ncontinues its search for a method definition up to the Object  class If it does not find a match in the Object  \nclass it throws a runtime exception\nLets look at an example that will demonstrate the late binding process Listings 2011  and 2012  have \ncode for LateBindingSuper  and LateBindingSub  classes respectively The LateBindingSub  class inherits \nfrom the LateBindingSuper  class It defines and overrides the same instance method print  as defined in \nthe LateBindingSuper  class The print  method in both classes prints different messages so that you can \nsee which method is being called\nListing 2011  A Lat eBindingSuper Class Which Has an Instance Method Named print\n LateBindingSuperjava\npackage comjdojoinheritance\npublic class LateBindingSuper \n    public void print \n        SystemoutprintlnInside LateBindingSuperprint\n    \nChapter 20  Inher ItanCe\n749Listing 2012  A Lat eBindingSub Class Which Has an Instance Method Named print\n LateBindingSubjava\npackage comjdojoinheritance\npublic class LateBindingSub extends LateBindingSuper \n    Override\n    public void print \n        SystemoutprintlnInside LateBindingSubprint\n    \n\nListing 2013  demonstrates the result of late binding\nListing 2013  A Tes t Class to Demonstrate Late Binding\n LateBindingTestjava\npackage comjdojoinheritance\npublic class LateBindingTest \n    public static void mainString args \n        LateBindingSuper lbSuper  new LateBindingSuper\n        LateBindingSub lbSub  new LateBindingSub\n         Will access LateBindingSuperprint\n        lbSuperprint  1\n         Will access LateBindingSubprint\n        lbSubprint     2\n         Will access LateBindingSubprint\n        LateBindingSuper lbSubprint  3\n         Assign the lbSub to lbSuper\n        lbSuper  lbSub  Upcasting\n         Will access LateBindingSubprint because lbSuper\n         is referring to a LateBindingSub object\n        lbSuperprint  4\n    \n\nInside LateBindingSuperprint\nInside LateBindingSubprint\nInside LateBindingSubprint\nInside LateBindingSubprint\nThe main method creates an object of each type LateBindingSuper  and LateBindingSub \nLateBindingSuper lbSuper  new LateBindingSuper\nLateBindingSub lbSub  new LateBindingSub\nThe calls to the print  method are labeled 1 2 3 and 4 so we may refer to them in our discussion\nBoth variables lbSuper  and lbSub  are used to access the print  instance method The runtime \ndecides which version of the print  method is called When you use lbSuperprint  which print  \nmethod is called depends on the object to which the lbSuper  variable is referring at that point in time Recall \nthat a reference variable of a class type may also refer to an object of any of its descendants The lbSuper  \nvariable may refer to an object of LateBindingSuper  or LateBindingSub Chapter 20  Inher ItanCe\n750When statement 1 lbSuperprint  is ready to execute the runtime will need to find the code for \nthe print  method The runtime looks for the runtime type of the lbSuper  variable and it finds that the \nlbSuper  variable is referring to an object of LateBindingSuper  type It looks for a print  method in the \nLateBindingSuper  class and finds it Therefore the runtime binds the print  method call in the statement \nlabeled 1 to the print  method of the LateBindingSuper  class This is confirmed by the first line in the \noutput\nThe logic for binding the print  method in statement 2 is the same as for the statement labeled 1 \nbut the class this time is LateBindingSub \nStatement 3 is tricky When you use a typecast such as LateBindingSuper lbSub  the object to \nwhich lbSub  refers to at runtime does not change Using a typecast all you say is that you want to use the \nobject to which the lbSub  variable refers as an object of the LateBindingSuper  type However the object \nitself never changes You can verify this by using the following code which gets the class name of an object\n Both s1 and s2 have comjdojoinheritanceLateBindingSub class name  \nLateBindingSub lbSub  new LateBindingSub\nString s1  lbSubgetClassgetName\nString s2  LateBindingSuperlbSubgetClassgetName\nWhen statement 3 is ready to execute at that time the expression with the typecast still refers to an \nobject of LateBindingSub  type and therefore the print  method of the LateBindingSub  class will be \ncalled This is confirmed by the third line in the output\nConsider two lines of code to discuss statement 4\nlbSuper  lbSub  Upcasting\nlbSuperprint  4\nThe first source line assigns lbSub  to lbSuper  The effect of this line is that the lbSuper  variable starts \nreferring to an object of LateBindingSub  type When statement 4 is ready to execute the runtime needs to \nfind the code for the print  method The runtime finds that the runtime type of the lbSuper  variable is the \nLateBindingSub  class It looks for the print  method in the LateBindingSub  class and finds it right there \nTherefore statement 4 executes the print  method in the LateBindingSub  class This is confirmed by the \nfourth line in the output\n Ti p La te binding incurs a small performance overhead compared to early binding because the method calls \nare resolved at runtime however many techniques eg virtual method table can be used by the programming \nlanguages to implement late binding so the performance hit is minimal or negligible the benefit of late binding \novershadows the little performance hit It lets you implement inclusion polymorphism When you write code like \na2print  the a2 variable exhibits polymorphic behavior with respect to the print  method the same \ncode a2print  may call the print  method of the class of the a2 variable or any of its descendant \nclasses depending on what type of object a2 is referring to at runtime Inheritance and late binding let you write \npolymorphic code which is written in terms of superclass type and works for all subclass types as wellChapter 20  Inher ItanCe\n751 Method Overriding\nRedefining an instance method in a class which is inherited from the superclass is called method \noverriding Consider the following declarations of class A and class B\npublic class A \n    public void print \n        SystemoutprintlnA\n    \n\npublic class B extends A \n    Override\n    public void print \n        SystemoutprintlnB\n    \n\nClass B is a subclass of class A Class B inherits the print  method from its superclass and redefines it \nIt is said that the print  method in class B overrides the print  method of class A\u00a0It is like class B telling \nclass A Thanks for being my superclass and letting me inherit your print  method However I need to \nwork differently I am going to redefine it my way without affecting your print  method in any way You \ncan keep using your print  method  If a class overrides a method it affects the overriding class and its \nsubclasses Consider the following declaration of class C\npublic class C extends B \n     C inherits Bprint\n\nClass C does not declare any methods What method does class C inherit Aprint  or Bprint  \nor both It inherits the print  method from class B A class always inherits what is available from its \nimmediate superclass declared in superclass or inherited by its supersuperclass If a class D inherits from \nclass C it will inherit the print  method of class B through class C\npublic class D extends C \n     D inherits Bprint through C\n\nConsider two more classes E and F which inherit from D and E respectively Class E overrides the \nprint  method of class B which it inherited from class D\npublic class E extends D \n    Override\n    public void print \n        SystemoutprintlnE\n    \n\npublic class F extends E \n     F inherits Eprint through E\nChapter 20  Inher ItanCe\n752What will be the output of the following snippet of code\nA a  new A\naprint       will print A\na  new B\naprint       will print B\na  new C\naprint       will print B\na  new D\naprint       will print B\na  new E\naprint       will print E\na  new F\naprint       will print E\nThe comments in the code tell you what will be printed Can you figure out why you get this output \nThere are three things at work First you can assign an object of a descendant of class A to a variable of class \nA type This is the reason that you have called aprint  in all statements Second the print  method has \nbeen overridden by some of the descendants of class A in the class hierarchy Third late binding performs \nthe magic of calling the appropriate print  method depending on the class of the object to which the \nvariable is referring at runtime Consider the following definitions of two classes S and T\npublic class S \n    public void print \n        SystemoutprintlnS\n    \n\npublic class T extends S \n    public void printString msg \n        Systemoutprintlnmsg\n    \n\nDoes the print  method in class T override the print  method in its superclass S The answer is \nno The print  method in class T does not override the print  method in class S This is called method \noverloading Class T will now have two print  methods one inherited from its superclass S which takes \nno arguments and one declared in it which takes a String  argument However both methods of class T \nhave the same name print  This is the reason that it is called method overloading because the same method \nname is used more than once in the same class\nHere are the rules when a class is said to override a method which it inherits from its superclass\n Method Overriding Rule 1\nThe method must be an instance method Overriding does not apply to static methods\n Method Overriding Rule 2\nThe overriding method must have the same name as the overridden methodChapter 20  Inher ItanCe\n753 Method Overriding Rule 3\nThe overriding method must have the same number of parameters of the same type in the same order as \nthe overridden method Generics as introduced in Java 5 changed this rule slightly when the methods use \ngeneric types as their parameters When the methods parameters use generic type you need to consider \nthe erasure of the generictype parameter not the generic type itself when comparing with other methods \nto check if one overrides another We revisit this rule later to discuss it in detail with examples For now \nconsider a method as overriding another method if they have the same number of parameters of the \nsame type in the same order Note that the name of the parameter does not matter For example void \nprintString str  and void printString msg  are considered the same method The different names of \nthe parameters str and msg do not make them different methods\n Method Overriding Rule 4\nBefore Java 5 the return type of the overriding and the overridden methods must be the same This rule \nremains the same for return types of primitive data types However the rule is different for return types of \nreference data types If the return type of the overridden method is a reference type the return type of the \noverriding method must be assignmentcompatible with the return type of the overridden method Suppose \na class has a method definition of R1 m1  which is overridden by a method definition R2 m1  This \nmethod overriding is allowed only if an instance of R2 can be assigned to a variable of R1 type without any \ntypecast Consider the following snippet of code that defines three classes P Q and R\npublic class P \n    public Employee getEmp \n         Code goes here\n    \n\npublic class Q extends P \n    public Employee getEmp \n         code goes here\n    \n\npublic class R extends P \n    public Manager getEmp \n         code goes here\n    \n\nClass P defines a getEmp  method that returns an object of Employee  type The getEmp  method \nof Class Q overrides the getEmp  method of its superclass P because it has the same name number of \nparameters zero in this case of the same type in the same order and the same return type Employee  \nThe getEmp  method of class R also overrides the getEmp  method of class P even though its return type \nManager  is different from the return type of the overridden method which is Employee  The getEmp  \nmethod of class R overrides its superclass getEmp  method because an instance of Manager  type can always \nbe assigned to a variable of Employee  type without any typecastChapter 20  Inher ItanCe\n754 Method Overriding Rule 5\nThe access level of the overriding method must be at least the same or more relaxed than that of the \noverridden method The three access levels are public  protected  and package level that allow for \ninheritance Recall that private  members are not inherited and hence cannot be overridden The order of \naccess level from the most relaxed to the strictest is public  protected  and package level If the overridden \nmethod has public  access level the overriding method must have the public  access level because public  \nis the most relaxed access level If the overridden method has protected  access level the overriding \nmethod may have public  or protected  access level If the overridden method has packagelevel access the \noverriding method may have public  protected  or packagelevel access Table\u00a0 201  summarizes this rule \nWe will discuss why this rule exists shortly\n Method Overriding Rule 6\nA method may include a list of checked exceptions in its throws  clause Although it is allowed to include \nan unchecked exception in the throws  clause of a method it is not required In this section we discuss \nonly checked exceptions The overriding method cannot add a new exception to the list of exceptions in \nthe overridden method It may remove one or all exceptions or it may replace an exception with another \nexception which is one of the descendants of the exception listed in the overridden method Consider the \nfollowing class definition\npublic class G \n    public void m1 throws CheckedException1 CheckedException2 \n         Code goes here\n    \n\nIf a c lass overrides the m1  method of class G it must not add any new checked exception to it The \nfollowing code will not compile because it has added a new checked exception CheckException3  in the \noverridden method m1 \npublic class H extends G \n    public void m1 throws CheckedException1 CheckedException2 CheckedException3 \n         Code goes here\n    \n\nThe following class declarations override the m1  method in class G and they are all valid In class I \nthe method m1  removes both exceptions In class J it removes one exception and keeps one In class K \nit keeps one and replaces the other one with a descendant type assuming that CheckedException22  is a \ndescendant class of CheckedException2 Table 201  Allow ed Access Levels for an Overriding Method\nOverridden Method Access Level Allowed Overriding Method Access Level\npublic Public\nprotected public protected\nPackage level public protected  package levelChapter 20  Inher ItanCe\n755public class I extends G \n     m1 removes all exceptions\n    public void m1 \n         Code goes here\n    \n\npublic class J extends G \n     m1 removes one exception and keeps another\n    public void m1 throws CheckedException1 \n         Code goes here\n    \n\npublic class J extends G \n     m1 removes one keep one and replaces one with a subclass\n    public void m1 throws CheckedException1 CheckedException22 \n         Code goes here\n    \n\nThe rules about the return type and the list of exceptions of an overriding method may not be obvious \nThere is a reason behind these rules which is  A variable of a class type can hold the reference to an object \nof any of its descendants  When you write code using the superclass type that code must also work without \nany modification with objects of subclass types Consider the following definition of class P assuming the \nEmpNotFoundException  is a checked exception class\npublic class P \n    public Employee getEmpint empId throws EmpNotFoundException \n         code goes here\n    \n\nYou can write the following snippet of code\nP p   get an object reference of P or its descendant\ntry \n    Employee emp  pgetEmp10\n catch EmpNotFoundException e \n     Handle the exception here\n\nThere are two points that need to be considered in this snippet of code First the variable p which \nis of type P can point to an object of type P or to an object of any descendant of class P Second when \nthe pgetEmp10  method is called the compiler verifies that the declared type of variable p P class \nhas a getEmp  method which accepts one parameter of type int returns an Employee type object and \nthrows EmpNotFoundException  These pieces of information are verified by the compiler with class P \nThe assumption made and verified too by the compiler about the getEmp  method should never be \ninvalidated at runtime Otherwise it will result in a chaoscode compiles but might not runChapter 20  Inher ItanCe\n756Consider one of the possible cases of overriding the getEmp  method as shown\npublic class Q extends P \n    public Manager getEmpint empId \n         code goes here\n    \n\nIf the variable p is assigned an object of class Q the code\nEmployee emp  pgetEmp10\ninside the trycatch  block is still valid In this case the variable p will refer to an object of class Q whose \ngetEmp  method returns a Manager  object and does not throw any exception Returning a Manager  object \nfrom the getEmp  method is fine because you can assign a Manager  object to the emp variable which is a \ncase of upcasting Not throwing an exception from the getEmp  method is also fine because the code was \nready to handle the exception by using a trycatch  block in case the exception was thrown\nWhat is the reason behind the access level rules for overriding methods Note that when a variable p \naccesses the getEmp  method the compiler verifies that the code where pgetEmp  is used has access to \nthe getEmp  method of class P If the subclasses of P reduce the access level the same code pgetEmp  \nmay not work at runtime because the code executing the statement may not have access to the getEmp  \nmethod in the descendant of class P\nConsider the following definition of class Q2 which inherits from class P It overrides the \ngetEmp  method and replaces the EmpNoFoundException  with another checked exception named \nBadEmpIdException \n Wont compile\npublic class Q2 extends P \n    public Manager getEmpint empId throws BadEmpIdException \n         code goes here\n    \n\nSuppose the code which was written in terms of P type gets a reference of a Q2 object as follows\nP p  new Q2\ntry \n    Employee emp  pgetEmp10\n catchEmpNotFoundException e \n     Handle exception here\n\nNote that the trycatch  block is not prepared to handle the BadEmpIdException  which the method \ngetEmp  of the Q2 class may throw This is why the declaration of class Q2 would not compile\nTo summarize the rules of overriding lets break down the parts of a method declaration as follows\n\t Name of the method\n\t Number of parameters\n\t Type of parameters\n\t Order of parametersChapter 20  Inher ItanCe\n757\t Return type of the method\n\t Access level\n\t List of checked exceptions in the throws  clause\nThe first four parts must always be the same in the overriding and the overridden methods Before \nJava 5 the return type had to be the same in the overriding and the overridden methods From Java 5 \nonward if the return type is a reference type overriding a methods return type could also be a subtype \nany descendant of the return type of the overridden method Access level and list of exceptions in the \noverridden method may be thought of as its constraints An overriding method may relax or even remove \nthe constraints of the overridden method However an overriding method can never have more restrictive \nconstraints than that of the overridden method\nThe rules of overriding a method are complex It may take you a long time to master them All rules are \ndirectly supported by the compiler If you make a mistake in the source code while overriding a method the \ncompiler will generate a nice not always error message that will give you a clue about your mistake There \nis a golden rule about method overriding that helps you avoid mistakes Whatever code is written using the \nsuperclass type must also work with the subclass type \n Tip If you want to override a method in your class  you should annotate the method with an Override  \nannotation For a method annotated with Override  the compiler verifies that the method really overrides a \nmethod in the superclass otherwise it generates a compiletime error\n Accessing an\u00a0Overridden Method\nSometimes you may need to access the overridden method from a subclass A subclass can use the keyword \nsuper  as a qualifier to call the overridden method of the superclass Note that the Object  class has no \nsuperclass It is illegal to use the keyword super  in the Object  class As a programmer you will never need \nto write code for the Object  class anyway as it is part of the Java class library Consider the code for the \nAOSuper  class in Listing 2014  It has a print  method which prints a message on the standard output\nListing 2014  An AO Super Class\n AOSuperjava\npackage comjdojoinheritance\npublic class AOSuper \n    public void print \n        SystemoutprintlnInside AOSuperprint\n    \n\nThe code in Listing 2015  contains the declaration for an AOSub  class which inherits from the AOSuper  \nclass\nListing 2015  An AO Sub Class Which Inherits from the AOSuper Class\n AOSubjava\npackage comjdojoinheritance\npublic class AOSub extends AOSuper \n    OverrideChapter 20  Inher ItanCe\n758    public void print \n         Call print method of AOSuper class\n        superprint\n         Print a message\n        SystemoutprintlnInside AOSubprint\n    \n    public void callOverriddenPrint \n         Call print method of AOSuper class\n        superprint\n    \n\nThe AOSub  class overrides the print  method of the AOSuper  class Note the superprint  method \ncall inside the print  method and the callOverriddenPrint  methods of the AOSub  class It will call the \nprint  method of the AOSuper  class The output of Listing 2016  shows that a method call with a super  \nqualifier calls the overridden method in the superclass\nListing 2016  A Tes t Class to Test a Method Call with the super Qualifier\n AOTestjava\npackage comjdojoinheritance\npublic class AOTest \n    public static void mainString args \n        AOSub aoSub  new AOSub\n        aoSubprint\n        aoSubcallOverriddenPrint\n    \n\nInside AOSuperprint\nInside AOSubprint\nInside AOSuperprint\nThere is no way to directly call an instance method of the superclass of the superclass You can call the \noverridden method of the superclass only the immediate ancestor using the keyword super  Suppose there \nare three classes A B and C where class B inherits from class A and class C inherits from class B There is \nno way to call methods of class A from inside class C If class C needs to call a method of class A you need to \nprovide a method in class B that will call a method of class A Class C will call the method of class B which in \nturn will call the method of class A\n Tip When a method call is made using the keyword super  Java uses early binding even though the \nmethod is an instance method another instance when Ja va uses early binding for an instance method call \nis a private  method call because a private  method cannot be invoked from outside its defining class a \nprivate  method cannot be overridden either the keyword super  refers to the instance fields methods or \nconstructors of the immediate ancestor of the class in which it appearsChapter 20  Inher ItanCe\n759 Method Overloading\nHaving more than one method with the same name in the same class is called method overloading \nMethods with the same name in a class could be declared methods inherited methods or a combination \nof both Overloaded methods must have a different number of parameters different types of parameters or \nboth The return type access level and throws  clause of a method play no role in making it an overloaded \nmethod The m1  method of the OME1  class is an example of an overloaded method\npublic class OME1 \n    public void m1int a \n         Code goes here\n    \n    public void m1int a int b \n         Code goes here\n    \n    public int m1String a \n         Code goes here\n    \n    public int m1String a int b throws CheckedException1 \n         Code goes here\n    \n\nThe following is an example of an incorrect attempt to overload the m2  method in class OME2 \n Wont compile\npublic class OME2 \n    public void m2int p1 \n         Code goes here\n    \n    public void m2int p2 \n         Code goes here\n    \n\nUsing different names for parameters  p1 and p2 does not make the m2  method overloaded The \ncode for the OME2  class would not compile because it has a duplicate declaration for the m2  method Both \nmethods have the same number and type of parameters which makes it not overloaded\nThe order of the parameters may play a role in making a method overloaded The m3  method of the \nOME3  class is overloaded because parameter types are different Both methods have one parameter of type \nint and another of type double  However they are in a different order\npublic class OME3 \n    public void m3int p1 double p2 \n         Code goes here\n    \n    public void m3double p1 int p2 \n         Code goes here\n    \nChapter 20  Inher ItanCe\n760Use a simple rule to check if two methods can be termed as an overloaded method List the name of the \nmethods and the type of their parameters from left to right separated by a comma You can use any other \nseparator If the two methods of a class having the same name give you different lists they are overloaded \nOtherwise they are not overloaded If you make such lists for m1  m2  and m3  methods in OME1  OME2  \nand OME3  classes you will come up with the following results\n Method list for m1  in class OME1   Overloaded\nm1int\nm1intint\nm1String\nm1Stringint\n Method list for m2  in class OME2   Not Overloaded\nm2int\nm2int\n Method list for m3  in class OME3   Overloaded\nm3intdouble\nm3doubleint\nYou should realize that the results for the m2  method in class OME2  are the same for both versions and \nhence OME2m2  is not overloaded Table\u00a0 202  lists some important differences between method overriding \nand method overloading\nMethod overloading is another kind of polymorphism where the same method name has different \nmeanings Method overloading is bound at compile time as opposed to method overriding that is bound at \nruntime The compiler resolves only the version of the overloaded methods that will be called It determines \nwhich version of the overloaded method will be called matching the actual parameters with the formal \nparameters of the overloaded methods If the overloaded method is an instance method which code will be \nexecuted is still determined at runtime using late bindingTable 202  Some I mportant Differences Between Method Overriding and Method Overloading\nMethod Overriding Method Overloading\nOverriding involves inheritance and at least two \nclassesOverloading has nothing to do with inheritance \nOverloading involves only one class\nIt occurs when a class defines a method with the \nsame name and the same number of parameters \nof the same type in the same order as defined by \nits superclassIt occurs when a class defines more than one method \nwith the same name All methods with the same name \nmust differ at least in one respect from othersthe \nnumber of parameters their types or orders etc\nThe return type of the overriding method must \nbe assignmentsubstitutable with the return type \nof the overridden methodReturn types of overloaded methods do not play a role \nin overloading\nThe overriding method cannot have an \nadditional throws clause than the overridden \nmethod It can have the same or a less restrictive \nlist of exceptions as the overridden methodThrows clauses of overloaded methods do not play a \nrole in overloading\nOverriding applies only to instance nonstatic \nmethodsAny method static or nonstatic can be overloadedChapter 20  Inher ItanCe\n761For an overloaded method call the compiler chooses the most specific method If it does not find an \nexact match it will try to look for a more generic version by converting the actual parameter type to a more \ngeneric type using the rules of automatic type widening Listing 2017  demonstrates how the compiler \nchooses an overloaded method\nListing 2017  A Tes t Program That Demonstrates How the Compiler Chooses the Most Specific Method \nfrom Several Versions of an Overloaded Method\n OverloadingTestjava\npackage comjdojoinheritance\npublic class OverloadingTest \n    public static void mainString args \n        var ot  new OverloadingTest\n        int i  10\n        int j  15\n        double d1  104\n        double d2  25\n        float f1  23F\n        float f2  45F\n        short s1  2\n        short s2  6\n        otaddi j\n        otaddd1 j\n        otaddi s1\n        otadds1 s2\n        otaddf1 f2\n        otaddf1 s2\n        Employee emp  new Employee\n        Manager mgr  new Manager\n        ottestemp\n        ottestmgr\n        emp  mgr\n        ottestemp\n    \n    public double addint a int b \n        SystemoutprintlnInside addint a int b\n        double s  a  b\n        return s\n    \n    public double adddouble a double b \n        SystemoutprintlnInside adddouble a double b\n        double s  a  b\n        return s\n    \n    public void testEmployee e \n        SystemoutprintlnInside testEmployee e\n    \n    public void testManager e \n        SystemoutprintlnInside testManager m\n    \nChapter 20  Inher ItanCe\n762Inside addint a int b\nInside adddouble a double b\nInside addint a int b\nInside addint a int b\nInside adddouble a double b\nInside adddouble a double b\nInside testEmployee e\nInside testManager m\nInside testEmployee e\nThe compiler knows only the compiletime type the declared type of the actual and the formal \nparameters Look at the otaddf1 s2  method call The types of actual parameters are float  and short  \nThere is no addfloat short  method in the OverloadingTest  class The compiler tries to widen the \ntype of the first argument to a double  type and it finds a match based on the first parameter adddouble \ndouble  Still the second parameter type does not match the actual type is short  and the formal type is \ndouble  Java allows automatic widening from short  to double  The compiler converts the short  type to the \ndouble  type and binds the addf1 s2  call to the adddouble double  method When ottestmgr  is \ncalled the compiler looks for an exact match and in this case it finds one testManager m  and binds \nthe call to this version of the test  method Suppose the testManager m  method is not present in the \nOverloadingTest  class The compiler will bind the ottestmgr  call to the testEmployee e  method \nbecause a Manager  type can be widened using upcasting to an Employee  type automatically\nSometimes overloaded methods and automatic type widening may confuse the compiler resulting in a \ncompiletime error Consider Listings 2018  and 2019  for an Adder  class with an overloaded add  method \nand how to test it\nListing 2018  The A dder Class Which Has an Overloaded add Method\n Adderjava\npackage comjdojoinheritance\npublic class Adder \n    public double addint a double b \n        return a  b\n    \n    public double adddouble a int b \n        return a  b\n    \n\nListing 2019  Testing the add Method of the Adder Class\n AdderTestjava\npackage comjdojoinheritance\npublic class AdderTest \n    public static void mainString args \n        Adder a  new Adder\n         A compiletime error\n        double d  aadd2 3\n    \nChapter 20  Inher ItanCe\n763An attempt to compile the AdderTest  class generates the following error\nAdderTestjava reference to add is ambiguous both method addintdouble in comjdojo\ninheritanceAdder and method adddoubleint in comjdojoinheritanceAdder match at line 7 column 18\nThe error message states that the compiler is not able to decide which one of the two add  methods \nin the Adder  class to call for the aadd3 7  method invocation The compiler is confused in deciding if it \nshould widen the int type of 3 to make it double  type 30 and call the adddouble int  or if it should widen \nthe int type of 7 to make it double  type 70 and call the addint double  In situations like this you need to \nhelp the compiler by using a typecast as follows\ndouble d1  aadddouble 2 3  OK  Will use adddouble int\ndouble d2  aadd2 double 3  OK  Will use addint double\n Inheritance and\u00a0Constructors\nAn object has two things state and behavior Instance variables in a class represent the state of its objects \nInstance methods represent the behavior of its objects Each object of a class maintains its own state When \nyou create an object of a class memory is allocated for all instance variables declared in the class and \nall instance variables declared in its ancestors at all levels Your Employee  class declares a name  instance \nvariable When you create an object of the Employee  class the memory is allocated for its name  instance \nvariable When an object of the Manager  class is created memory is allocated for the name  field that is present \nin its superclass Employee  After all a manager has a similar state as that of an employee A manager behaves \nsimilar to an employee Lets look at an example Consider two classes U and V as shown\npublic class U \n    private int id\n    protected String name\n\npublic class V extends U \n    protected double salary\n    protected String address\n\nFigure 203  depicts the memory allocation when objects of classes U and V are created When an object \nof class U is created memory is allocated only for the instance variables that are declared in class U When an \nobject of class V is created memory is allocated for all instance variables in class U and class V\nFigure 203  Memor y allocation for an object includes all instance variable of the class and all its ancestorsChapter 20  Inher ItanCe\n764Lets get to the main topic of discussion for this section which is constructors Constructors are not \nmembers of a class and they are not inherited by subclasses They are used to initialize instance variables \nWhen you create an object of a class the object contains instance variables from the class and all of its \nancestors To initialize the instance variables of ancestor classes the constructors of ancestor classes must \nbe called Consider the following two classes CSuper  and CSub  as shown in Listings 2020  and 2021  The \nCTest  class in Listing 2022  is used to create an object of the CSub  class\nListing 2020  A CS uper Class with a NoArgs Constructor\n CSuperjava\npackage comjdojoinheritance\npublic class CSuper \n    public CSuper \n        SystemoutprintlnInside CSuper constructor\n    \n\nListing 2021  A CS ub Class Which Inherits from the CSuper Class and Has a NoArgs Constructor\n CSubjava\npackage comjdojoinheritance\npublic class CSub extends CSuper \n    public CSub \n        SystemoutprintlnInside CSub constructor\n    \n\nListing 2022  A Tes t Class Which Demonstrates That Constructors for All Ancestors Are Called When an \nObject of a Class Is Created Starting at the Top of the Class Hierarchy and Going Down\n CTestjava\npackage comjdojoinheritance\npublic class CTest \n    public static void mainString args \n        CSub cs  new CSub\n    \n\nInside CSuper constructor\nInside CSub constructor\nThe output of the CTest  class shows that the constructor of the CSuper  class is called first and then the \nconstructor of the CSub  class In fact the constructor of the Object  class is called before the constructor of \nthe CSuper  class You cannot print the fact the constructor of the Object  class is called because the Object  \nclass is not your class and therefore you cannot modify it The question is How does the constructor of \nthe CSuper  class get called The answer to this question is based on the rule that when an object of a class \nis created memory is allocated for all instance variables including instance variables in all its ancestor \nclasses Instance variables for all classes must be initialized by calling their constructors The compiler \nhelps you to enforce this rule to a great extent The compiler injects the call to the immediate ancestors \nnoargs constructor as the first statement in every constructor you add to your class The keyword super  is \nused in many contexts It also refers to the immediate ancestor of a class If it is followed by parentheses Chapter 20  Inher ItanCe\n765it refers to the constructor of the superclass If a superclass constructor accepts parameters you can pass \na list of parameters within parentheses similar to a method call The following are examples of calling the \nconstructor of a superclass\n Call noargs constructor of superclass\nsuper\n Call superclass constructor with a String argument\nsuperHello\n Call superclass constructor with two double arguments\nsuper105 892\nYou can call the constructor of the superclass explicitly or let the compiler inject the call to the no\nargs constructor for you When you compile the CSuper  and CSub  classes the compiler modifies their \nconstructors code which looks as shown in Listings 2023  and 2024 \nListing 2023  Com piler Injection of a super Call to Call the Immediate Ancestors NoArgs Constructor\n CSuperjava\npackage comjdojoinheritance\npublic class CSuper \n    public CSuper \n        super    Injected by the compiler\n        SystemoutprintlnInside CSuper constructor\n    \n\nListing 2024  Com piler Injection of a super Call to Call the Immediate Ancestors NoArgs Constructor\n CSubjava\npackage comjdojoinheritance\npublic class CSub extends CSuper \n    public CSub \n        super    Injected by the compiler\n        SystemoutprintlnInside CSub constructor\n    \n\n Tip the keyword super  refers to the immediate ancestor of a class You can call superclass constructors \nusing the super  keyword only as the first statement inside a constructor\nYou can also call the noargs constructor or any other constructors of the superclass explicitly as the first \nstatement inside constructors of your class The compiler injects the noargs constructor call only if you have \nnot added one explicitly Lets try to improve your Employee  and Manager  classes Lets add a constructor \nto the Employee  class that accepts the name of the employee as a parameter You will call the new class \nEmployee2  as shown in Listing 2025 Chapter 20  Inher ItanCe\n766Listing 2025  Employee2 Class Which Is a Modified Version of the Original Employee Class and Has a \nConstructor That Accepts a String Argument\n Employee2java\npackage comjdojoinheritance\npublic class Employee2 \n    private String name  Unknown\n    public Employee2String name \n        thisname  name\n    \n    public void setNameString name \n        thisname  name\n    \n    public String getName \n        return name\n    \n\nLets call your new Manager  class Manager2  which inherits from the Employee2  class\n Manager2java\npackage comjdojoinheritance\n Wont compile\npublic class Manager2 extends Employee2 \n     No code for now\n\nThe previous code for the Manager2  class does not compile It generates the following compiletime \nerror\nError423 constructor Employee2 not found in class comjdojoinheritanceEmployee2\nYou have not added any constructor for the Manager2  class Therefore the compiler will add a noargs \nconstructor for it It will also try to inject a super  call as the first statement inside the noargs constructor \nwhich will call the noargs constructor of the Employee2  class However the Employee2  class does not have a \nnoargs constructor This is the reason that you get the previous error The code for the Manager2  class looks \nas follows after it is modified by the compiler You may notice that that the super  call is invalid because \nthe Employee2  class does not have a noargs constructor\n Code for Manager2 class after compiler injects a noargs constructor with a call to \nsuper\npackage comjdojoinheritance\n Wont compile\npublic class Manager2 extends Employee2 \n     Injected by the compiler\n    public Manager2 \n         Injected by the compiler\n         Calls the nonexistent noargs constructor of Employee2 class\n        super\n    \nChapter 20  Inher ItanCe\n767So how do you fix the Manager2  class There are many ways to fix it Some of the ways you can fix the \nManager2  class are as follows\nYou can add a noargs constructor to the Employee2  class like so\npublic class Employee2 \n     A noargs constructor\n    public Employee2 \n    \n     All other code for class remains the same \n\nAfter adding a noargs constructor to the Employee2  class the code for the Manager2  class will compile \nfine\nYou can add a noargs constructor to the Manager2  class and explicitly call the constructor of the \nEmployee2  class with a String  argument as follows\npublic class Manager2 extends Employee2 \n    public Manager2 \n         Call constructor of Employee2 class explicitly\n        superUnknown\n    \n\nYou can add a constructor to the Manager2  class which takes a String  argument and passes the \nargument value to the Employee2  class constructor This way you can create a Manager2  by passing the name \nof the Manager2  as a parameter to its constructor\npublic class Manager2 extends Employee2 \n    public Manager2String name \n         Call constructor of Employee2 class explicitly\n        supername\n    \n\nNormally the third option is used where you would provide a way to create an object of the Manager2  \nclass with the managers name Note that the Manager2  class does not have access to the name instance \nvariable of the Employee2  class Still you can initialize the name instance variable in the Employee2  class \nfrom the Manager2  class using the super  keyword and invoking the constructor of the Employee2  class \nListing 2026  has the complete code for the Manager2  class that will compile Listing 2027  has code to test \nthe Manager2  class and its output shows that it works as expected\n Tip ever y class must call the constructor of its superclass from its constructors directly or indirectly If \nthe superclass does not have a noargs constructor you must call any other constructors of the superclass \nexplicitly as is done in Listing 2026 Chapter 20  Inher ItanCe\n768Listing 2026  A M anager2 Class That Has a Constructor That Accepts a String Argument and Calls the \nConstructor of the Employee2 Class Explicitly\n Manager2java\npackage comjdojoinheritance\npublic class Manager2 extends Employee2 \n    public Manager2String name \n        supername\n    \n\nListing 2027  A Test Class to Test the Manager2 Class\n Manager2Testjava\npackage comjdojoinheritance\npublic class Manager2Test \n    public static void mainString args \n        Manager2 mgr  new Manager2John Jacobs\n        String name  mgrgetName\n        SystemoutprintlnManager name   name\n    \n\nManager name John Jacobs\nWe need to discuss a few more rules about using the constructors of the superclass from the subclass \nConsider the following definition of classes X and Y which are in two different packages\n Xjava\npackage comjdojoinheritancepkg1\npublic class X \n     X has packagelevel access\n    X \n    \n\n Yjava\npackage comjdojoinheritancepkg2\nimport comjdojoinheritancepkg1X\npublic class Y extends X \n    public Y \n    \n\nThe code for class Y would not compile It generates a compiletime error as follows\nError7   X is not public in comjdojoinheritancepkg1X cannot be accessed from \noutside package\nThe error states that the noargs constructor in class X has a packagelevel access Therefore it cannot \nbe accessed from class Y which is in a different package You received this error because the compiler will \nmodify the class Y definition as followsChapter 20  Inher ItanCe\n769 Compiler modified version of class Y\n Yjava\npackage comjdojoinheritancepkg2\nimport comjdojoinheritancepkg1X\npublic class Y extends X \n    public Y \n         Injected by the compiler to call X constructor\n        super\n    \n\nThe noargs constructor of class X has a packagelevel access Therefore it can only be accessed from \nthe comjdojoinheritancepkg1  package How do you fix class Y It is tricky to suggest a solution in such a \ncase The solution depends on the design that is used behind the creation of class X and class Y However for \nthe class Y to compile you must create a constructor for the class X which has a public or protected access \nso it can be accessed from class Y\nHere is another rule for using constructors along with inheritance The superclass constructor must \nbe called explicitly or implicitly from inside the constructor of a class using the super  keyword However \nthe access to a superclass constructor from a class is controlled by the access level of the constructor of the \nsuperclass Sometimes consequences of the access level of the constructor of a class could be that it cannot \nbe accessed at all Consider the following definition of the class called NoSubclassingAllowed \npublic class NoSubclassingAllowed \n    private NoSubclassingAllowed \n    \n     Other code goes here\n\nThe NoSubclassingAllowed  class has explicitly declared a private  constructor A private  constructor \ncannot be accessed from anywhere including subclasses For a subclass to exist the subclass must be able \nto call at least one of the constructors of its superclass This concludes that the NoSubclassingAllowed  \nclass cannot be inherited by any other classes This is one of the ways to disable inheritance for a class The \nfollowing code will not compile which tries to subclass the NoSubclassingAllowed  class which has no \naccessible constructors\n Wont compile\npublic class LetUsTryInVain extends NoSubclassingAllowed \n\nOne thing you may notice is that no one can create an object of the NoSubclassingAllowed  class \nbecause its constructor is not accessible from outside Classes like this provide methods that create their \nobject and return it to the caller This is also a way to control and encapsulate object creation of a class\nRecall from Chapter 9 that you can call a constructor of a class from another constructor of the same \nclass using the this  keyword and the call must be the first statement in the constructors body When you \nlook at the rule to call another constructor of the same class and constructor of the superclass you would \nfind that both state that the call must be the first statement inside the body of the constructor The result \nof these two rules is that from one constructor either you can use this  to call another constructor of the \nsame class or super  to call a constructor of the superclass but not both This rule also ensures that the \nconstructor of the superclass is always called once and only onceChapter 20  Inher ItanCe\n770 Method Hiding\nA class also inherits all nonprivate static  methods from its superclass Redefining an inherited static  \nmethod in a class is known as method hiding The redefined static  method in a subclass is said to hide \nthe static  method of its superclass Recall that redefining a nonstatic method in a class is called method \noverriding Listing 2028  contains code for a MHidingSuper  class which has a static print  method \nListing 2029  has the code for a MHidingSub  class that inherits from the MHidingSuper  class It redefines \nthe print  method which hides the print  method in the MHidingSuper  class The print  method in \nMHidingSub  is an example of method hiding\nListing 2028  A MHidin gSuper Class That Has a Static Method\n MHidingSuperjava\npackage comjdojoinheritance\npublic class MHidingSuper \n    public static void print \n        SystemoutprintlnInside MHidingSuperprint\n    \n\nListing 2029  A MHidin gSub Class That Hides the print of Its Superclass\n MHidingSubjava\npackage comjdojoinheritance\npublic class MHidingSub extends MHidingSuper \n    public static void print \n        SystemoutprintlnInside MHidingSubprint\n    \n\nAll r ules about the redefined method name access level return type and exception for method \nhiding are the same as for method overriding Refer to the Method Overriding section for more detailed \ndiscussion on these rules One rule that is different for method hiding is the binding rule Early binding is \nused for static methods Based on the compiletime type of the expression the compiler determines what \ncode will be executed at runtime for a static  method call Note that you can use the class name as well as a \nreference variable to invoke a static  method There is no ambiguity about method binding when you use a \nclass name to invoke a static  method The compiler binds the static  method that is defined or redefined \nin the class If a class does not define or redefine the static  method the compiler binds the method that \nthe class inherits from its superclass If the compiler does not find a definedredefinedinherited method in \nthe class it generates an error Listing 2030  contains the code that demonstrates the early binding rules for \nmethod hiding for static methods of a class\nListing 2030  A Tes t Class to Demonstrate Method Hiding\n MHidingTestjava\npackage comjdojoinheritance\npublic class MHidingTest \n    public static void mainString args \n        MHidingSuper mhSuper  new MHidingSub\n        MHidingSub mhSub  new MHidingSub\n        Systemoutprintln1Chapter 20  Inher ItanCe\n771         1\n        MHidingSuperprint\n        mhSuperprint\n        Systemoutprintln2\n         2\n        MHidingSubprint\n        mhSubprint\n        MHidingSuper mhSubprint\n        Systemoutprintln3\n         3\n        mhSuper  mhSub\n        mhSuperprint\n        MHidingSub mhSuperprint\n    \n\n1\nInside MHidingSuperprint\nInside MHidingSuperprint\n2\nInside MHidingSubprint\nInside MHidingSubprint\nInside MHidingSuperprint\n3\nInside MHidingSuperprint\nInside MHidingSubprint\nThe test code has three sections labeled 1 2 and 3 Lets discuss how early binding is performed by \nthe compiler in each section\n 1\nMHidingSuperprint\nmhSuperprint\nThe first call MHidingSuperprint  is made using a class name The compiler binds this call to \nexecute the print  method of the MHidingSuper  class The second call mhSuperprint  is made \nusing the reference variable mhSuper  The compiletime type or declared type of the mhSuper  variable is \nMHidingSuper  Therefore the compiler binds this call to execute the print  method of the MHidingSuper  \nclass\n 2\nMHidingSubprint\nmhSubprint\nMHidingSupermhSubprint\nThe first two calls in section 2 are similar to the two calls in section 1 They are bound to the  \nprint  method of the MHidingSub  class The third call MHidingSuper mhSubprint  needs  \na little explanation The compiletime type of the mhSub  variable is MHidingSub  When you use a  \ntypecast MHidingSuper  on the mhSub  variable the compiletime type of the expression MHidingSuper Chapter 20  Inher ItanCe\n772mhSub  becomes MHidingSuper  When you call the print  method on this expression the compiler binds it \nto its compiletime type which is MHidingSuper  Therefore the third method call in section 2 is bound to \nthe print  method of the MHidingSuper  class\n 3\nmhSuper  mhSub\nmhSuperprint\nMHidingSubmhSuperprint\nThe first statement in section 3 assigns a reference of MHidingSub  object to the mhSuper  reference \nvariable After the first statement is executed the mhSuper  variable is referring to an object of the MHidingSub  \nclass When the first call to the print  method is made the compiler looks at the compiletime type or \ndeclared type of the mhSuper  variable which is MHidingSuper  Therefore the compiler binds the call \nmhSuperprint  to the print  method of the MHidingSuper  class The second call to the print  method \nis bound to the print  method of the MHidingSub  class because the typecast MHidingSub  makes the type \nof the entire expression as MHidingSub \n Ti p a static  method of a class cannot hide an instance method of its superclass If you want to invoke \na hidden method of the superclass from inside a class you need to qualify the hidden method call with the \nsuperclass name For example if you want to call the print  method of the MHidingSuper  class from \ninside the MHidingSub  class you need to use MHidingSuperprint  Inside the MHidingSub  class the \ncall to the print  method without using the class name or a variable refers to the hiding method print  \nof the MHidingSub  class\n Field Hiding\nA field declaration  static  or nonstatic in a class hides the inherited field with the same name in its \nsuperclass The type of the field and its access level are not considered in the case of field hiding Field hiding \noccurs solely based on the field name Early binding is used for field access That is the compilertime type \nof the class is used to bind the field access Consider the following declaration of two classes G and H\npublic class G \n    protected int x  200\n    protected String y  Hello\n    protected double z  105\n\npublic class H extends G \n    protected int x  400         Hides x in class G\n    protected String y  Bye    Hides y in class G\n    protected String z  OK     Hides z in class G\n\nThe field declarations x y and z in class H hide the inherited fields x y and z in class G It is to be \nemphasized that the same field name in a class alone hides a field of its superclass Data types of the hidden \nand the hiding fields are immaterial For example the data type of z in class G is double  whereas the data \ntype of z in class H is String  Still the field z in class H hides the field z in class G The simple names of fields Chapter 20  Inher ItanCe\n773x y and z in class H refer to the hiding fields not inherited fields Therefore if you use the simple name x in \nclass H it refers to the field x declared in class H not in class G If you want to refer to the field x in class G from \ninside class H you need to use the keyword super  for example superx \nIn Listing 2031  the FHidingSuper  class declares fields num and name  In Listing 2032  the FHidingSub  \nclass inherits from the FHidingSuper  class and it inherits the num and name fields from it The print  \nmethod of the FHidingSub  class prints the values of the num and name  fields The print  method uses \nsimple names of num and name  fields and they refer to the inherited fields from the FHidingSuper  class \nWhen you run the FHidingTest  class in Listing 2033  the output shows that the FHidingSub  class really \ninherits num and name  fields from its superclass\nListing 2031  FHidin gSuper Class with Two Protected Instance Fields\n FHidingSuperjava\npackage comjdojoinheritance\npublic class FHidingSuper \n    protected int num  100\n    protected String name  John Jacobs\n\nListing 2032  FHidin gSub Class Which Inherits from the FHidingSuper Class and Inherits Fields num and \nname\n FHidingSubjava\npackage comjdojoinheritance\npublic class FHidingSub extends FHidingSuper \n    public void print \n        Systemoutprintlnnum   num\n        Systemoutprintlnname   name\n    \n\nListing 2033  A Tes t Class to Demonstrate Field Inheritance\n FHidingTestjava\npackage comjdojoinheritance\npublic class FHidingTest \n    public static void mainString args \n        FHidingSub fhSub  new FHidingSub\n        fhSubprint\n    \n\nnum 100\nname John Jacobs\nConsider the definition of class FHidingSub2  as shown in Listing 2034 Chapter 20  Inher ItanCe\n774Listing 2034  A FHidin gSub2 Class That Inherits from FHidingSuper and Declares Two Variables with the \nSame Name as Declared in Its Superclass\n FHidingSub2java\npackage comjdojoinheritance\npublic class FHidingSub2 extends FHidingSuper \n     Hides num field in FHidingSuper class\n    private int num  200\n     Hides name field in FHidingSuper class\n    private String name  Wally Inman\n    public void print \n        Systemoutprintlnnum   num\n        Systemoutprintlnname   name\n    \n\nThe FHidingSub2  class inherits from the FHidingSuper  class It declares two fields num and name  which \nhave the same names as the two fields declared in its superclass This is a case of field hiding The num and \nname  fields in FHidingSub2  hide the num and name  fields that are inherited from the FHidingSuper  class \nWhen the num and name  fields are used by their simple names inside the FHidingSub2  class they refer to \nthe fields declared in the FHidingSub2  class not to the inherited fields from the FHidingSuper  class This is \nverified by running the FHidingTest2  class as shown in Listing 2035 \nListing 2035  A Tes t Class to Demonstrate Field Hiding\n FHidingTest2java\npackage comjdojoinheritance\npublic class FHidingTest2 \n    public static void mainString args \n        FHidingSub2 fhSub2  new FHidingSub2\n        fhSub2print\n    \n\nnum 200\nname Wally Inman\nThe FHidingSub2  class has four fields two inherited  num and name  and two declared  num and name  \nIf you want to refer to the inherited fields from the superclass you need to qualify the field names with the \nkeyword super  For example supernum  and supername  inside FHidingSub2  refer to the num and name  fields \nin the FHidingSuper  class\nThe print  method of the FHidingSub3  class in Listing 2036  uses the keyword super  to access hidden \nfields of the superclass and uses the simple names of the fields to access fields from its own class The output \nof Listing 2037  verifies this\nListing 2036  A FHidin gSub3 Class That Demonstrates How to Access Hidden Fields of Superclass Using \nthe super Keyword\n FHidingSub3java\npackage comjdojoinheritance\npublic class FHidingSub3 extends FHidingSuper \n     Hides the num field in FHidingSuper classChapter 20  Inher ItanCe\n775    private int num  200\n     Hides the name field in FHidingSuper class\n    private String name  Wally Inman\n    public void print \n         FHidingSub3num\n        Systemoutprintlnnum   num\n         FHidingSupernum\n        Systemoutprintlnsupernum   supernum\n         FHidingSub3name\n        Systemoutprintlnname   name\n         FHidingSupername\n        Systemoutprintlnsupername   supername\n    \n\nListing 2037  A Tes t Class That Accesses Hidden Fields\n FHidingTest3java\npackage comjdojoinheritance\npublic class FHidingTest3 \n    public static void mainString args \n        FHidingSub3 fhSub3  new FHidingSub3\n        fhSub3print\n    \n\nnum 200\nsupernum 100\nname Wally Inman\nsupername John Jacobs\nRecall that when an object is created the Java runtime allocates memory for all instance variables in \nthe class of the object and all of its ancestors When you create an object of the FHidingSub2  or FHidingSub3  \nclass memory will be allocated for the four instance variables as shown in Figure\u00a0 204 \nFigure 204  Memor y layout for objects of FHidingSuper and FHidingSub2 classesChapter 20  Inher ItanCe\n776Heres a summary of the field hiding rules\n\t Field hiding occurs when a class declares a variable with the same name as an \ninherited variable from its superclass\n\t Field hiding occurs only based on the name of the field Access level data type \nand the type of field  static  or nonstatic are not considered for field hiding For \nexample a static  field can hide an instance field A field of int type can hide a field \nof String  type and so on A private  field in a class can hide a protected  field in its \nsuperclass A public  field in a class can hide a protected  field in its superclass\n\t A class should use the keyword super  to access the hidden fields of the superclass \nThe class can use the simple names to access the redefined fields in its body\n Disabling Inheritance\nYou can disable subclassing for a class by declaring the class final  You have seen the use of the final  \nkeyword before for declaring constants The same final  keyword is used in a class declaration A final  class \ncannot be subclassed The following snippet of code declares a final  class named Security \npublic final class Security \n     Code goes here\n\nThe following declaration of class CrackedSecurity  will not compile\n Wont compile Cannot inherit from Security\npublic final class CrackedSecurity extends Security \n     Code goes here\n\nYou can also declare a method as final  A final  method cannot be overridden or hidden by a subclass \nSince a final  method cannot be overridden or hidden a call to a final  method may be inlined by a code \noptimizer for better performance\npublic class A \n    public final void m1 \n         Code goes here\n    \n    public void m2 \n         Code goes here\n    \n\npublic class B extends A \n     Cannot override Am1 here because it is final in class A\n     OK to override m2 because it is not final in class A\n    public void m2 \n         Code goes here\n    \nChapter 20  Inher ItanCe\n777You will find many classes and methods in the Java class libraries that are declared final Most notably \nthe String  class is final  Why would you declare a class or a method as final  In other words why would \nyou want to prevent subclassing of a class or overridinghiding of a method The main reasons for doing this \nare security correctness and performance If your class is important for security reasons you do not want \nsomeone to inherit from your class and mess with the security that your class is supposed to implement \nSometimes you declare a classmethod final  to preserve the correctness of the program A final  method \nmay result in better performance at runtime because a code optimizer is free to inline the final  method \ncalls\n Sealed Classes\nAnother way to disable inheritance is the sealed class feature introduced in Java 17 It allows you to define \na class and exactly what classes can subclass it The compiler will enforce that no other classes may extend \nyour class For example imagine you want to define a class Security which can only have two subclasses \nPassword and Lock You could define the classes as follows for example\npublic abstract sealed class Security permits Password Lock \n       code goes here\n\npublic final class Password   \npublic nonsealed class Lock   \nEvery subclass of a sealed class must belong in the same module or if an unnamed module the same \npackage They must also define their status final sealed or nonsealed The last one nonsealed is the first \nkeyword in Java to have a hyphen within it and denotes that the inheritance is open to all classes Exactly one \nof those modifiers must be used It is not possible for a class to be both final and sealed Note that although \nLock permits other classes to extend it any reference that is of type Security will necessarily be an instance \nassignable to either Password or Lock\nAlternatively instead of using the permits keyword you can specify all of the subclasses within the \nsame class and the compiler will use this as the exhaustive list of subclasses for example\npublic abstract sealed class Security \n code here\n      public final class Password   \n      public final class Lock   \n\n Abstract Classes and\u00a0Methods\nSometimes you may create a class just to represent a concept rather than to represent objects Suppose you \nwant to develop classes to represent different shapes A shape is just an idea or a concept It does not exist in \nreality Suppose someone asks you to draw a shape Your immediate response would be What shape do you \nwant me to draw If someone asks you to draw a circle or a rectangle it makes sense to you Java lets you \ncreate a class whose objects cannot be created Its purpose is just to represent an idea which is common to \nobjects of other classes Such a class is called an abstract  class The term concrete class is used to denote a \nclass that is not abstract and whose objects can be created So far all your classes have been concrete classesChapter 20  Inher ItanCe\n778You need to use the abstract  keyword in the class declaration to declare an abstract class For example \nthe following code declares a Shape  class abstract\npublic abstract  class Shape \n     No code for now\n\nBecause the Shape  class has been declared abstract you cannot create its object even though it has a \npublic  constructor the default one added by the compiler You can declare a variable of an abstract class \nas you do for a concrete class The following code snippet shows some valid and invalid uses of the Shape \nclass\nShape s       OK\nnew Shape  A compiletime error Cannot create a Shape object\nIf you look at the definition of the Shape  class it looks the same as any other concrete classes except \nthe use of the abstract  keyword in the declaration A class has instance variables and instance methods to \ndefine the state and behavior of its objects By declaring a class abstract you indicate that the class has some \nincomplete method definitions behaviors for its objects and it must be considered incomplete for object \ncreation purposes\nWhat is an incomplete method in a class A method that has a declaration but no body is an \nincomplete method Missing body of a method does not mean an empty body It means no body The \nbraces that follow the methods declaration indicate the body of the method In the case of an incomplete \nmethod the braces are replaced with a semicolon If a method is incomplete you must indicate it by using \nthe abstract  keyword in the methods declaration Your Shape  class does not know how to draw a shape \nuntil you mention a specific shape However one thing is for sureyou should be able to draw a shape no \nmatter what kind of shape it is In this case you know the behavior name  draw  but you do not know how \nto implement it Therefore draw  is a good candidate to be declared as an abstract method or incomplete \nmethod in the Shape  class The Shape  class looks as follows with an abstract draw  method\npublic abstract class Shape \n    public Shape \n    \n    public abstract void draw\n\nWhen you declare a class abstract it does not necessarily mean that it has at least one abstract method \nAn abstract class may have all concrete methods It may have all abstract methods It may have some \nconcrete and some abstract methods If you have an abstract class it means that an object of that class \ncannot exist However if a class has an abstract method either declared or inherited it must be declared \nabstract Declaring a class as abstract is like placing an under construction sign in front of a building If \nan under construction sign is placed in front of a building it is not supposed to be used not supposed \nto be created in the case of a class It does not matter whether the building is complete or not An under \nconstruction sign is enough to indicate that it cannot be used However if some parts of the building are \nincomplete like a class having abstract methods you must place an under construction sign in front of it \nmust declare the class abstract to avoid any mishap in case someone attempts to use itChapter 20  Inher ItanCe\n779 Tip You cannot create objects of an abstract  class If a class has an abstract  method declared or \ninherited  the class must be declared abstract  If a class does not have any abstract  methods you can still \ndeclare the class abstract  an abstract  method is declared the same way as any other method except that \nits body is indicated by only a semicolon\nListing 2038  has the complete code for this Shape  class\nListing 2038  An Abs tract Shape Class with One Instance Variable Two Constructors and One Abstract \nMethod\n Shapejava\npackage comjdojoinheritance\npublic abstract class Shape \n    private String name\n    public Shape \n        thisname  Unknown shape\n    \n    public ShapeString name \n        thisname  name\n    \n    public String getName \n        return thisname\n    \n    public void setNameString name \n        thisname  name\n    \n     Abstract methods\n    public abstract void draw\n    public abstract double getArea\n    public abstract double getPerimeter\n\nEach shape will have a name The name instance variable stores the name of the shape The getName  \nand setName  methods let you read and change the name of the shape respectively Two constructors \nlet you set the name of the shape or leave the name as the default name Unknown shape  A shape does \nnot know how to draw so it has declared its draw  method abstract  A shape also does not know how to \ncompute its area and perimeter so it has declared getArea  and getPerimeter  methods abstract\nAn abstract class guarantees the use of inheritance at least theoretically Otherwise an abstract class \nby itself is useless For example until someone supplies the implementations for the abstract methods of the \nShape  class its other parts instance variables concrete methods and constructors are of no use You create \nsubclasses of an abstract  class which override the abstract  methods providing implementations for them \nListing 2039  has code for a Rectangle  class which inherits from the Shape  class\nListing 2039  A Re ctangle Class Which Inherits from the Shape Class\n Rectanglejava\npackage comjdojoinheritance\npublic class Rectangle extends Shape \n    private final double widthChapter 20  Inher ItanCe\n780    private final double height\n    public Rectangledouble width double height \n         Set the shape name as Rectangle\n        superRectangle\n        thiswidth  width\n        thisheight  height\n    \n     Provide an implementation for inherited abstract draw method\n    Override\n    public void draw \n        SystemoutprintlnDrawing a rectangle\n    \n     Provide an implementation for inherited abstract getArea method\n    Override\n    public double getArea \n        return width  height\n    \n     Provide an implementation for inherited abstract getPerimeter method\n    Override\n    public double getPerimeter \n        return 20  width  height\n    \n\nNote that you have not declared the Rectangle  class abstract which means that it is a concrete class and \nits objects can be created An abstract  method is also inherited by a subclass like any other methods Since \nthe Rectangle  class is not declared abstract  it must override all three abstract  methods of its superclass \nand provide implementations for them If the Rectangle  class does not override all abstract methods of \nits superclass and provide implementation for them it is considered incomplete and must be declared \nabstract  Your Rectangle  class overrides the draw  getArea  and getPerimeter  methods of the \nShape  class and provides implementation body within braces for them The instance variables width  and \nheight  are used to keep track of the width and height of the rectangle Inside the constructor you call the \nconstructor of the Shape  class using the super  keyword superRectangle  to set its name  Listing 2040  \nhas code for a Circle  class which inherits from the Shape  class It also overrides three abstract methods of \nthe Shape  class and provides implementations for them\nListing 2040  A Circ le Class Which Inherits from the Shape Class\n Circlejava\npackage comjdojoinheritance\npublic class Circle extends Shape \n    private final double radius\n    public Circledouble radius \n        superCircle\n        thisradius  radius\n    \n     Provide an implementation for inherited abstract draw method\n    Override\n    public void draw \n        SystemoutprintlnDrawing a circle\n    Chapter 20  Inher ItanCe\n781     Provide an implementation for inherited abstract getArea method\n    Override\n    public double getArea \n        return MathPI  radius  radius\n    \n     Provide an implementation for inherited abstract getPerimeter method\n    Override\n    public double getPerimeter \n        return 20  MathPI  radius\n    \n\nIt is time to use your abstract Shape  class along with its concrete subclasses Rectangle  and Circle  \nNote that the only restriction that is applied to an abstract  class when it is used in code is that you cannot \ncreate its objects Apart from this restriction you can use it the same way you can use a concrete class For \nexample you can declare a variable of an abstract  class type you can call methods of the abstract  class \nusing that variable etc How do you call a method on a Shape  variable if you cannot create an object of the \nShape  class This is a good point Consider the following snippet of code\n Upcasting at work\nShape s  new Rectangle20 50\n Late binding at work sgetArea will call the getArea method of the Rectangle class\ndouble area  sgetArea\nIf you look at the previous code it makes sense The first statement creates a Rectangle  and assigns \nits reference to a variable of the Shape  class which is a simple case of upcasting In the second statement \nyou are calling the getArea  method using the s variable The compiler only verifies the existence of the \ngetArea  method in the Shape  class which is the declared type of the s variable The compiler does not \ncare whether the getArea  method in the Shape  class is incomplete abstract or not It does not care if the \ngetArea  method is abstract  in the Shape  class because it is an instance method and it knows that late \nbinding at runtime will decide which code for the getArea  method will be executed All it cares about is \nthe existence of a method declaration of the getArea  method At runtime the late binding process finds \nthat the variable s is referring to a Rectangle  and it calls the getArea  method of the Rectangle  class Is it \nnot unlike having ones cake and eating it toocan you have an abstract  class incomplete class and use it \ntoo If you look at the previous two lines of code you would find that these magical two statements involve \nso many concepts of objectoriented programming abstract  class abstract  method upcasting method \noverriding late binding and runtime polymorphism All of these features are involved in the previous two \nstatements thereby giving you the ability to write generic and polymorphic code Consider a ShapeUtil  \nclass as shown in Listing 2041 \nListing 2041  A Sh apeUtil Class Having Utility Methods to Draw Any Shapes and Print Details About Them\n ShapeUtiljava\npackage comjdojoinheritance\npublic class ShapeUtil \n    public static void drawShapesShape list \n        for Shape s  list \n             Draw the shape no matter what it is\n            sdraw  Late binding\n        \n    Chapter 20  Inher ItanCe\n782    public static void printShapeDetailsShape list \n        for Shape s  list \n             Gather details about the shape\n            String name  sgetName             Late Binding\n            double area  sgetArea             Late binding\n            double perimeter  sgetPerimeter  Late binding\n             Print details\n            SystemoutprintlnName   name\n            SystemoutprintlnArea   area\n            SystemoutprintlnPerimeter   perimeter\n        \n    \n\nThe ShapeUtil  class contains two static  methods drawShapes  and printShapeDetails  Both \naccept an array of Shape  objects as a parameter The drawShapes  method draws all the shapes by calling \nthe draw  method of each element in the array passed to it The printShapeDetails  method prints \ndetailsname area and perimeterof the shapes passed to it The beauty of the code in the ShapeUtil  \nclass is that it never refers to any subclasses of the Shape  class It has no knowledge about the Rectangle  or \nCircle  class at all It does not even care if a Rectangle  class or a Circle  class exists although the code will \nwork with Rectangles  Circles  and objects of any descendants of the Shape  class You may argue that you \ncould have written the same code even if you did not declare the Shape  class as abstract  So what is the big \ndeal about declaring the Shape  class as abstract You are getting two advantages by declaring the Shape  class \nas abstract \n\t If you did not declare the Shape  class abstract  you were forced to provide \nimplementations for the three abstract  methods in the class Since the Shape  class \ndoes not know what shape object it will take the form of it is not appropriate for it \nto provide implementations for these methods For now lets assume that you can \nhandle this issue by providing an empty body for the draw  method and returning \nzero or maybe a negative number from the getArea  and getPerimeter  \nmethods in the Shape  class Lets move to the next advantage which is more \ncompelling\n\t You are forced to declare the Shape  class as abstract  because you had declared three \nabstract  methods in it The greatest advantage of declaring an abstract  method in \na class is to force its subclasses to override and provide implementation for it The \nabstract  methods in the Shape  class forced the Rectangle  and Circle  subclasses \nto override them and provide implementations for them Was that not what you \nwanted\nListing 2042  contains the code that tests the ShapeUtil  class along with the Shape  Rectangle  and \nCircle  classes It creates an array of Shape  objects It populates one element of the array with a Rectangle  \nand another with a Circle  It passes the array to the drawShapes  and printShapeDetails  methods of \nthe ShapeUtil  class which draws the shapes and prints their details according to the type of objects placed \nin the array\nListing 2042  A Tes t Class to Test Shape Rectangle Circle and the ShapeUtil Class\n ShapeUtilTestjava\npackage comjdojoinheritance\npublic class ShapeUtilTest \n    public static void mainString args Chapter 20  Inher ItanCe\n783         Create some shapes draw and print their details\n        Shape shapeList  new Shape2\n        shapeList0  new Rectangle20 40    Upcasting\n        shapeList1  new Circle50            Upcasting\n         Draw all shapes\n        ShapeUtildrawShapesshapeList\n         Print details of all shapes\n        ShapeUtilprintShapeDetailsshapeList\n    \n\nDrawing a rectangle\nDrawing a circle\nName Rectangle\nArea 80\nPerimeter 120\nName Circle\nArea 7853981633974483\nPerimeter 3141592653589793\nWe are finished discussing the main rules of declaring classes and methods abstract  However there \nare many other rules that govern the use of abstract  classes and methods in a Java program Most of those \nrules if not all are listed here All rules point to only one basic rule  An abstract class should be subclassed \nto be useful and the subclass should override and provide implementation for the abstract methods \n\t A class may be declared abstract  even if it does not have an abstract  method\n\t A class must be declared abstract  if it declares or inherits an abstract  method \nIf the class overrides and provides implementations for all inherited abstract  \nmethods and does not declare any abstract  methods it does not have to be \ndeclared abstracta lthough it could be declared abstract \n\t You cannot create an object of an abstract  class However you can declare a \nvariable of the abstract  class type and call methods using it\n\t An abstract  class cannot be declared final  Recall that a final  class cannot be \nsubclassed which conflicts with the requirement of an abstract  class that it must be \nsubclassed to be useful in a true sense\n\t An abstract  class should not declare all constructors private  Otherwise the \nabstract  class cannot be subclassed Note that constructors of all ancestor classes \nincluding an abstract  class are always invoked when an object of a class is created \nWhen you create an object of a Rectangle  class constructors for the Object  class \nand the Shape  class are also invoked If you declare all constructors of an abstract  \nclass private  you cannot create a subclass for your abstract  class which makes it \nthe same as declaring an abstract final  class\n\t An abstract  method cannot be declared static  Note that an abstract  method \nmust be overridden and implemented by a subclass A static  method cannot be \noverridden However it can be hiddenChapter 20  Inher ItanCe\n784\t An abstract  method cannot be declared private  Recall that a private  method is \nnot inherited and hence it cannot be overridden The requirement for an abstract  \nmethod is that a subclass must be able to override and provide implementation for it\n\t An abstract  method cannot be declared native  strictfp  or synchronized  These \nkeywords refer to implementation details of a method The native  keyword denotes \nthat a method is implemented in native code as opposed to Java code The strictfp  \nkeyword denotes that the code inside a method uses FPstrict rules for floatingpoint \ncomputations The strictfp keyword was made obsolete in Java 17 as FPstrict is now \nalways enabled The synchronized  keyword denotes that the object on which the \nmethod is invoked must be locked by the thread before it can execute the methods \ncode Since an abstract  method does not have an implementation the keywords \nthat imply an implementation cannot be used for an abstract  method\n\t An abstract  method in a class can override an abstract  method in its superclass \nwithout providing an implementation The subclass abstract  method may refine \nthe return type or exception list of the overridden abstract  method Consider the \nfollowing code Class B overrides the abstract m1  method of class A and it does \nnot provide its implementation It only removes one exception from the throws  \nclause Class C overrides the m1  method of class B and provides implementation for \nit Note that the change in return type or exception list as shown in the m1  method \nfor class B and class C must follow the rules of method overriding\npublic abstract class A \n    public abstract void m1 throws CE1 CE2\n\npublic abstract class B extends A \n    public abstract void m1 throws CE1\n\npublic class C extends B \n    public void m1 \n         Code goes here\n    \n\n\t A concrete instance method may be overridden by an abstract  instance method \nThis can be done to force the subclasses to provide implementation for that method \nAll classes in Java inherit equals  hashCode  and toString  methods of the \nObject  class Suppose you have a class CA and you want all its subclasses to override \nand provide implementation for the equals  hashCode  and toString  \nmethods of the Object  class You need to override these three methods in class CA \nand declare them abstract  like so\npublic abstract class CA \n    public abstract int hashCode\n    public abstract boolean equalsObject obj\n    public abstract String toString\n     Other code goes here\n\n\t In this case concrete methods of the Object  class have been overridden by abstract  \nmethods in the CA class All concrete subclasses of CA are forced to override and \nprovide implementations for the equals  hashCode  and toString  methodsChapter 20  Inher ItanCe\n785 Method Overriding and\u00a0Generic Method Signatures\nJava 5 introduced the concept of generic types Java lets you declare generic methods When the code with \ngenerics types is compiled the generic types are transformed into raw types The process that is used to \ntransform the generictype parameter information is known as type erasure  Consider the GenericSuper  \nclass in Listing 2043  It has a generictype parameter T It has two methods m1  and m2  Its m1  method \nuses the generic type T as its parameter type Its m2  method defines a new generic type to use as its \nparameter type\nListing 2043  A Sam ple Class That Uses Generic Type Parameters\n GenericSuperjava\npackage comjdojoinheritance\npublic class GenericSuperT \n    public void m1T a \n         Code goes here\n    \n    public P extends Employee void m2P a \n         Code goes here\n    \n\nWhen the GenericSuper  class is compiled the erasure transforms the code during compilation and the \nresulting code as compiled in the bytecode would look like Listing 2044 \nListing 2044  The G enericSuper Class Transformed Code During Compilation After Erasure Is Used\n GenericSuperjava\npackage comjdojoinheritance\npublic class GenericSuper \n    public void m1Object a \n         Code goes here\n    \n    public void m2Employee a \n         Code goes here\n    \n\nThe GenericSub  class in Listing 2045  inherits the GenericSuper  class\nListing 2045  A Gener icSub Class Inherits from the GenericSuper Class and Overrides m1 and m2 \nMethods\n GenericSubjava\npackage comjdojoinheritance\npublic class GenericSub extends GenericSuper \n    Override\n    public void m1Object a \n         Code goes here\n    Chapter 20  Inher ItanCe\n786    Override\n    public void m2Employee a \n         Code goes here\n    \n\nIn the GenericSub  class the m1  and m2  methods override the corresponding methods in the \nGenericSuper  class If you compare the methods m1  and m2  between Listings 2043  and 2045  for \noverriding rules you would think that they do not have the same signature because the code in Listing 2043   \nuses generics The rule for checking for override equivalent method signature is that if a method uses \ngeneric parameters you need to compare its erasure not the generic version of its declaration When \nyou compare erasure of m1  and m2  method declarations in the GenericSuper  class in Listing 2044  \nwith m1  and m2  method declarations in Listing 2045  you would find that m1  and m2  methods are \noverridden in the GenericSub  class\n Typo Danger in\u00a0Method Overriding\nSometimes it is easy to get it wrong when you try to override a method in a class It may seem that you have \noverridden a method when it is not overridden Consider the following two classes C1 and C2\n C1java\npackage comjdojoinheritance\npublic class C1 \n    public void m1double num \n        SystemoutprintlnInside C1m1   num\n    \n\n C2java\npackage comjdojoinheritance\npublic class C2 extends C1 \n    public void m1int num \n        SystemoutprintlnInside C2m1   num\n    \n\nThe intent was that the m1  method in class C2 overrides the m1  method of class C1 However this is \nnot true It is a case of method overloading not method overriding The m1  method in C2 is overloaded \nm1double num  is inherited from class C1 and m1int num  is declared in C2 Things become more difficult \nwhen you start running your program and you do not get the desired results Consider the following code \nsnippet\nC1 c  new C2\ncm110  Which method is called   C1m or C2m2\nWhat should be printed when you execute the previous code It prints the following\nInside C1m1 100Chapter 20  Inher ItanCe\n787Are you surprised to see the output of the previous snippet of code Lets discuss in detail what happens \nwhen the previous snippet of code is compiled and executed When the compiler comes across the second \nstatement cm110  it does the following thing it finds out the compiletime type of the reference variable \nc which is C1\nIt looks for a method named m1 in C1 The argument value 10 passed to the method m1  is an int \nThe compiler looks for a method named m1 inherited or declared in C1 which takes an int parameter It \nfinds that class C1 has a method m1double num  which accepts a double  parameter It tries type widening \nconversion and finds that the m1double num  method in class C1 can be used for the cm110  method call \nAt this time the compiler binds the method signature for the call Note that the compiler binds the method \nsignature not the method code The method code is bound at runtime because m1  is an instance method \nThe compiler does not decide which m1  methods code will be executed for cm110  Keep in mind that \nthe compilers decision is solely based on its knowledge about class C1 When cm110  is compiled the \ncompiler does not know or care about the existence of any other class for example C2 You can see what \ncode is generated for the cm110  method call by the Java compiler You need to use the javap  command\nline utility with a c option to disassemble the compiled code as follows You need to pass the fully qualified \nname of the class to the javap  command\njavap c fullyqualifiedclassname\nFor the previous code snippet that contains the cm110  call javap  will print instructions that are \ngenerated by the compiler I show only one instruction\n12  invokevirtual    14  Method comjdojoinheritance C1m1DV\nThe invokevirtual  instruction is used to denote a call to an instance method that will use late binding \nThe 14 it may be different for you indicates the method table entry number which is the entry for the \nC1m1DV  method The syntax may be a little cryptic for you The character D denotes double  which is the \nparameter type and V denotes void  which is the return type of the method m1 \nAt runtime when the JVM attempts to run cm110  it uses the late binding mechanism to find the \nmethod code that it will execute Note that the JVM will search for the m1DV  method signature which is the \ncompiler syntax for void m1double  It starts the search by looking at the runtime type of c which is class C2 \nClass C2 does not have a method named m1 which accepts a parameter of type double  The search moves up \nin the class hierarchy to class C1 The JVM finds the method in class C1 and it executes it This is the reason \nthat you got the output that indicates that m1double num  in the class C1 is called for cm110 \nSuch mistakes are very difficult to hunt down You avoid such mistakes by using the Override  \nannotation You have already seen this annotation many times in this book For more information about \nannotations refer to the second volume of this series More Java 17  The annotation has compiler support \nThe compiler will make sure a method that is annotated with the Override  annotation really overrides a \nmethod in its superclass or interface which we cover in the next chapter Otherwise it will generate an \nerror Using the  Override  annotation is easy Just add it to the method declaration anywhere before the \nmethods return type The following code for class C2 uses Override  annotation for the m1  method\npublic class C2 extends C1 \n    Override\n    public void m1int num \n        SystemoutprintlnInside C2m1   num\n    \nChapter 20  Inher ItanCe\n788When you compile the previous code for class C2 the compiler will generate an error stating that the \nmethod m1  in class C2 does not override any method in its superclass Using the Override  annotation \nwith a method that is supposed to override a superclass method saves you a lot of debugging time Note that \nthe Override  annotation does not change the way method overriding works It is used as an indicator to the \ncompiler that it needs to make sure the method really overrides the method of its superclass\n Isa Hasa and\u00a0Partof Relationships\nA software application which is designed based on an objectoriented paradigm consists of interacting \nobjects Objects of one class may be related to objects of another class in some ways Isa hasa and partof \nare the three most commonly used relationships that exist between objects of two classes We have already \ndiscussed that an isa relationship is modeled using inheritance between two classes For example the \nrelationship  A parttime manager isa manager is modeled by inheriting the PartTimeManager  class from \nthe Manager  class\nSometimes an object of a class contains an object of another class which indicates a wholepart \nrelationship This relationship is called aggregation  It is also known as hasa  relationship The example \nof hasa relationship is  A person has an address  As a wholepart relationship the person represents the \nwhole and the address represents the part Java does not have any special feature that lets you indicate a \nhasa relationship in your code In Java code aggregation is implemented by using an instance variable in \nthe whole which is of the type part In this example the Person  class will have an instance variable of type \nAddress  as follows Note that an object of the Address  class is created outside of a Person  class and passed \nin to the Person  class constructor\npublic class Address \n     Code goes here\n\npublic class Person \n     Person hasa Address\n    private Address addr\n    public PersonAddress addr \n        thisaddr  addr\n    \n     Other code goes here\n\nComposition  is a special case of aggregation in which the whole controls the life cycle of the part It is \nalso known as a partof  relationship Sometimes hasa and partof relationships are used interchangeably \nThe main difference between aggregation and composition is that in composition the whole controls the \ncreationdestruction of the part In composition the part cannot exist by itself Rather the part is created \nand destroyed as a part of the whole Consider the relationship  A CPU is partof a computer  You can also \nrephrase the relationship as  A computer has a CPU  Does the existence of a CPU outside a computer make \nsense The answer is no It is true that a computer and a CPU represent a wholepart relationship However \nthere are some more constraints to this wholepart relationship and that is The existence of a CPU makes \nsense only inside a computer  You can implement composition in Java code by declaring an instance \nvariable of a type part and creating the part object as part of creation of the whole as shown here A CPU is \ncreated when a Computer  is created The CPU is destroyed when the computer is destroyed\npublic class CPU \n     Code goes here\nChapter 20  Inher ItanCe\n789public class Computer \n     CPU partof Computer\n    private CPU cpu  new CPU\n     Other code goes here\n\nJava has a special class type called inner class which can also be used to represent composition An \nobject of an inner class can exist only within an object of its enclosing class The enclosing class would be the \nwhole and the inner class would be the part You can represent the partof relationship between CPU and \ncomputer using an inner class as follows\npublic class Computer \n    private CPU cpu  new CPU\n     CPU is an inner class of Computer\n    private class CPU \n         Code goes here\n    \n     Other code goes here for Computer class\n\nCompare this implementation of composition between a computer and a CPU with the previous one \nWhen you use an inner class an object of the CPU class cannot exist without an object of the Computer  class \nThis restriction may be problematic when the object of the same class say CPU is part of another object in a \ncomposition relationship\nComposition also denotes ownerowned relationship A computer is an owner and a CPU is owned by \nthe computer The owned object cannot exist without the owner object Typically but not necessarily the \nowned object is destroyed when the owner object is destroyed Sometimes when the owner object is being \ndestroyed it passes the reference of the owned object to another owner In such cases the owned object \nsurvives the death of its current owner The point to note is that the owned object always has an owner\nSometimes programmers get confused between the choice of using inheritance and composition and \nthey use inheritance instead of composition You can find this kind of mistake in the Java class library where \nthe javautilStack  class is inherited from the javautilVector  class A Vector  is a list of objects A \nStack  is also a list of objects but is not simply a list of objects as Vector  is A Stack  is supposed to allow you \nto add an object to its top and remove an object from its top However a Vector  allows you to addremove \nan object at any position Since the Stack  class inherits from the Vector  class it also inherits methods \nthat will let you addremove an object at any position which are simply wrong operations for a stack The \nStack  class should have used composition to use a Vector  object as its internal representation rather than \ninheriting from it The following code snippet shows the correct use of a hasa relationship between the \nStack  and Vector  classes\npublic class Stack \n     Stack hasa Vector\n    private Vector items  new Vector\n     Other code goes here\n\n Ti p Whenever you are in doubt in choosing between composition and inheritance  give preference to \ncomposition Both let you share the code however inheritance forces your class to be in a specific class \nhierarchy Inheritance also creates a subtype whereas composition is used to create a new typeChapter 20  Inher ItanCe\n790 PatternMatching Switch\nJava 17 introduced an enhancement to the switch statements and expressions that allows you to switch \nbased on the type of the given object Although you should usually rely on polymorphism and inheritance \nand implement the behavior into the classes themselves this is not always an option There will be cases \nwhen using a switch expression or statement is a better or only option The syntax is similar to the instanceof \noperator but as applied to the case label of a switch statement or expression\nFor example imagine that you want to print out the type and some custom values of an object based on \nwhat class it is an instance of and you dont have the ability to change those classes The object might be an \nEmployee Manager or Clerk Here is the method\npublic static String getFormattedStringObject o \n    return switch o \n        case Employee e  StringformatEmployee ID is d egetId\n        case Manager m  StringformatManager salary is f mgetSalary\n        case Clerk c  StringformatClerk total sales is f cgetTotalSales\n        default  otoString\n    \n\nIf you want to further decide on when to do things you can also use guard statements or conditions \nusing the  operator The following example is if you want to treat senior managers differently\npublic static String getFormattedStringObject o \n    return switch o \n        case Employee e  StringformatEmployee ID is d egetId\n        case Manager m  misSenior Manager\n        case Manager m  StringformatManager salary is f mgetSalary\n        case Clerk c  StringformatClerk total sales is f cgetTotalSales\n        default  otoString\n    \n\nPattern matching in switch is a preview feature in Java 17 so you must use the enablepreview \ncommand option to enable it when running Java and when compiling\n No Multiple Inheritance of\u00a0Classes\nTypically a class signifies implementation Java does not support multiple inheritance of implementation \nThat is a class in Java cannot have more than one superclass Inheritance lets a class inherit implementation \nandor interface from its superclass In the case of implementation inheritance the superclass provides \nimplementation for functionality that its subclass inherits and reuses For example the Employee  class has \nimplemented the getName  and setName  methods which are inherited by the Manager  class In the case \nof interface inheritance the superclass provides specification for functionality that its subclass inherits and \nimplements Note that declaring abstract  methods in Java defines a specification whereas declaring a \nconcrete nonabstract method defines an implementation For example the Shape  class has a specification \nfor a draw  method which is inherited by its subclasses eg Rectangle  and Circle  It does not provide \nany implementation for the draw  method All concrete subclasses of the Shape  class must provide \nimplementation for its draw  methodChapter 20  Inher ItanCe\n791Multiple inheritance is defined as having a class inherit from more than one superclass It poses \nsome problems when a class inherits an implementation from multiple superclasses Suppose there are \ntwo classes Singer  and Employee  and both provide implementation for processing salary say a pay  \nmethod Further suppose you have a class SingerEmployee  which inherits from the Singer  and Employee  \nclasses The new class SingerEmployee  inherits the pay  method from two different superclasses which \nhave different implementations When the pay  method is invoked on a SingerEmployee  which pay  \nmethod should be usedfrom the Employee  class or from the Singer  class\nMultiple inheritance makes a programmers job as well as a language designers job complex Java \nsupports multiple inheritance of interfaces or types not implementations It has a construct called \ninterface which is different from a class An interface can inherit from multiple interfaces A class can \nimplement multiple interfaces Javas approach to support only multiple inheritance of types avoids \nproblems for programmers as well as its designers Multipletype inheritance is easier to understand and \ndesign than the multipleimplementation inheritance\n Summary\nInheritance lets you define a class based on the definition of another class Inheritance is one of the \ntechniques to implement inclusion polymorphism It promotes code reuse It lets you write code in terms of \na class that works for the class and all its subclasses The subclass inherits members of its superclass based \non some rules Constructors are not members of a class and they are not inherited by subclasses\nThe keyword extends  is used to inherit a class from another class If a class declaration does not contain \nthe keyword extends  the class implicitly inherits from the Object  class Inheritance creates a treelike class \nhierarchythe Object  class being at the top of all class hierarchies The Object  class itself does not have a \nsuperclass\nJava supports two types of binding early binding and late binding In early binding the compiler \ndetermines the fields and methods that will be accessed based on the compiletime type of the references \naccessing the fields and methods Java uses early binding for accessing all types of fields and static methods \nIn late binding the runtime type of the reference variable determines the method that is executed \nInheritance along with late binding makes it possible to use runtime polymorphism in Java Java uses late \nbinding for accessing instance methods\nA variable of a superclass can always be assigned a reference of its subclasses This is called \nupcasting When a variable of a subclass is typecast and assigned to a variable of the superclass it is called \ndowncasting For a downcasting to succeed at runtime the variable of the superclass must contain a \nreference of the subclass or one of the subclasses of the subclass The instanceof  operator is used to test \nwhether a reference variable is an instance of a specific class\nYou can declare abstract classes and methods The keyword abstract  is used to declare abstract classes \nand methods Abstract classes cannot be instantiated If a class contains an abstract method the class must \nbe declared abstract A class can be declared abstract even if it contains no abstract methods Abstract \nmethods are supposed to be overridden and provided an implementation by subclasses\nA subclass may access the constructors methods and fields of its superclass using the keyword super  \nThe call to access the constructor of the superclass must be the first statement in the constructor of the \nsubclass\nRedefining the static methods of a superclass inside a subclass is called method hiding A field with \nthe same name as a field in the superclass hides the field in the superclass and it is called field hiding \nThe hidden methods may be accessed from the subclass using the superclass name as the qualifier for the \nmethod You can use the keyword super  to access the hidden fields from the subclass\nClasses and methods may be declared final  A final  class cannot be subclassed A final  method \ncannot be overridden Declaring all constructors of a class private  also stops subclassing for that classChapter 20  Inher ItanCe\n792EXERCISES\n 1 What keyword do you use in a class declaration to inherit your class from another \nclass\n 2 What are the names of the superclass and subclass in the following class \ndeclaration\npublic class Letter extends Document\n 3 Write the fully qualified name of the superc lass of class A which is declared as \nfollows\npublic class A \n\n 4 how many superclasses can a class have in Java\n 5 What keyword do you use to call the constructor of the superclass Write the \nstatement that calls the superclass constructor which takes a string as an \nargument the argument value is Hello \n 6 What types of members of a superclass are inherited by a subclass public  \nprivate  protected  and package level\n 7 name the annotation that you should use when you override a method in your \nclass so the compiler can verify your intent of overriding the method\n 8 how do you call an overridden instance method of a superclass from a subclass \nConsider the following snippet of code\npublic class A \n    public void print \n        SystemoutprintlnA\n    \n\npublic class B extends A \n    Override\n    public void print \n         Your one line code goes here \n        SystemoutprintlnB\n    \n   public static void mainString args \n       new Bprint\n   \n\nComplete the code inside the print  method of class B so when you run class B \nit should print the following You are to call the print  method of class A\nA\nBChapter 20  Inher ItanCe\n793 9 Write the reasons why the follo wing class declaration does not compile\npublic abstract final class A \n     Code goes here\n\n 10 Write the reasons why the follo wing declarations of class B and class C do not \ncompile\npublic class A \n    public Aint x \n    \n\npublic class B extends A \n\npublic class C extends A \n    public C \n    \n\n 11 What is the difference between method overloading and method overriding\n 12 Consider the follo wing declarations for class A and class B What will be printed \nwhen class B is run Is the declaration of method m1  in class B a case of method \noverriding or method overloading explain your answer\npublic class A \n    public void m1int x \n        SystemoutprintlnAm1   x\n    \n\npublic class B extends A \n    public void m1Integer x \n        SystemoutprintlnBm1   x\n    \n    public static void mainString args \n        B b  new B\n        bm1100\n    \n\n 13 Consider the follo wing two class declarations\npublic class A \n\npublic class B extends A \nChapter 20  Inher ItanCe\n794One of the following statements does not compile Describe the reason behind the \ncompiletime error and fix it Identify examples of upcasting and downcasting in the \nfollowing statements\nA a  new B\nB b  new B\na  b\nb  a\n 14 What is the difference between early binding and late binding Which type of \nbinding is solely decided by the compiler\n 15 Write the output when the follo wing class B is run this exercise is to test your \nknowledge of early binding and late binding\npublic class A \n    public void m1 \n        SystemoutprintlnAm1\n    \n    public static void m2 \n        SystemoutprintlnAm2\n    \n\npublic class B extends A \n    Override\n    public void m1 \n        SystemoutprintlnBm1\n    \n    public static void m2 \n        SystemoutprintlnBm2\n    \n    public static void mainString args \n        A a  new B\n        am1\n        am2\n        Bam2\n        Am2\n        Bm2\n    \n\n 16 name the operator that you are supposed to use before downcasting a reference \nso the downcasting always succeedsChapter 20  Inher ItanCe\n795 17 Write the output of the follo wing snippet of code\npublic class A \n\npublic class B extends A \n\nA a  new B\nSystemoutprintlna instanceof A   a instanceof A\nSystemoutprintlna instanceof B   a instanceof B\nSystemoutprintlna instanceof Object   a instanceof Object\nSystemoutprintlnnull instanceof A   null instanceof A\nSystemoutprintlnnull instanceof B   null instanceof B\n 18 explain why the following declaration for class B does not compile\npublic abstract class A \n    public abstract void print\n\npublic class B extends A \n\n 19 explain why the following declaration for class B does not compile\npublic class A \n    private A \n        SystemoutprintlnHello\n    \n\npublic class B extends A \n\n 20 Write the output when the follo wing class B is run this exercise is to test your \nknowledge of field hiding method overriding and use of the super  keyword to call \nthe method of the superclass\npublic class A \n    protected int x  100\n    public A \n        Systemoutprintlnx    x\n    \n    public void print \n        Systemoutprintlnx    x\n    \nChapter 20  Inher ItanCe\n796public class B extends A \n    private final int x  200\n    public B \n        Systemoutprintlnx    x\n    \n    Override\n    public void print \n        superprint\n        Systemoutprintlnx    x\n    \n    public static void mainString args \n        A a  new B\n        aprint\n    \n797\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307421CHAPTER 21\nInterfaces\nIn this chapter you will learn\n\t What interfaces are\n\t How to declare interfaces\n\t How to declare abstract default private and static methods in interfaces\n\t How to fully and partially implement interfaces in a class\n\t How to evolve interfaces after they are published\n\t How to inherit an interface from other interfaces\n\t Using the instanceof  operator with interfaces\n\t What marker interfaces are\n\t How interfaces can be used to implement polymorphism\n\t How dynamic binding applies to method calls on interfacetype variables\n\t What functional interfaces are and how to use them\nAll example programs in this chapter are a member of a jdojointerfaces  module as declared in \nListing 211 \nListing 211  The D eclaration of a jdojointerfaces Module\n moduleinfojava\nmodule jdojointerfaces \n    exports comjdojointerfaces\n\n What Is an\u00a0Interface\nAn interface  is a very important concept in Java The knowledge of a Java developer is incomplete unless \nthey understand the role of interfaces It is better understood by examples than by a formal definition Lets \ndiscuss a simple example that will set the stage for the detailed discussion about the need for interfaces \nbefore we provide its formal definitionChapter 21  Interfa Ces\n798A Java application consists of interacting objects An object interacts with other objects by sending \nmessages The ability of an object to receive messages is implemented by providing methods in the objects \nclass Suppose there is a class called Person  which provides a walk  method The walk  method gives \nthe ability to receive a walk message to every object of the Person  class Lets define the Person  class as \nfollows\npublic class Person \n    private String name\n    public PersonString name \n        thisname  name\n    \n    public void walk \n        Systemoutprintlnname   a person is walking\n    \n\nAn object of the Person  class will have a name that will be set in its constructor When it receives a \nwalk message that is when its walk  method is called it prints a message on the standard output\nLets create a utility class named Walkables  which is used to send a specific message to a collection \nof objects Lets assume that you want to add a letThemWalk  static method to the Walkables  class which \naccepts an array of Person  objects It sends a walk message to all the elements in the array You can define \nyour Walkables  class as follows The method does what its name suggests that is it lets everyone walk\npublic class Walkables \n    public static void letThemWalkPerson list \n        for Person person  list \n            personwalk\n        \n    \n\nThe following snippet of code can be used to test the Person  and Walkable s classes\npublic class WalkablesTest \n    public static void mainString args \n        Person persons  new Person3\n        persons0  new PersonJack\n        persons1  new PersonJeff\n        persons2  new PersonJohn\n         Let everyone walk\n        WalkablesletThemWalkpersons\n    \n\nJack a person is walking\nJeff a person is walking\nJohn a person is walkingChapter 21  Interfa Ces\n799So far you dont see any problem with the design of the Person  and Walkables  classes right They \nperform the actions they were designed to perform The design of the Person  class guarantees that its objects \nwill respond to a walk message By declaring the Person  array as the parameter type for the letThemWalk  \nmethod in the Walkables  class the compiler makes sure that the call to personsiwalk  is valid because \na Person  object is guaranteed to respond to the walk message\nLets expand this project by adding a new class called Duck  which represents a duck in the real world \nWe all know that a duck can also walk A duck can do many other things that a person can or cannot do \nHowever for the purpose of our discussion well focus on only the walking ability of ducks You can define \nyour Duck  class as follows\npublic class Duck \n    private String name\n    public DuckString name \n        thisname  name\n    \n    public void walk \n        Systemoutprintlnname   a duck is walking\n    \n\nYou may notice that there is a similarity between the Person  class and the Duck  An object of both \nclasses can respond to a walk message as both of them provide a walk  method However the similarity \nbetween the two classes ends right there They are not linked in any other ways at all except for the fact \nthat both of them have the Object  class as their common ancestor The introduction of the Duck  class has \nexpanded the walking ability of objects in your application Before there were ducks only people could walk \nAfter you add the Duck  class ducks can walk as well\nNow you want to let ducks walk using your Walkables  class Can your Walkables  class let the ducks \nwalk No It cannot let the ducks walk unless you make some changes The ability of a Duck  to walk does \nnot pose any problem for the existing Walkables  class The problem at this point is that the letThemWalk  \nmethod has declared its parameter type as an array of Person  A Duck  is not a Person  You cannot write \ncode shown here A Duck  object cannot be assigned to a reference variable of the type Person  The following \nsnippet of code will not compile\nPerson list  new Person3\nlist0  new PersonJack\nlist1  new DuckJeff  A compiletime error\nlist2  new PersonJohn\nWalkablesletThemWalklist\nHow do you solve this problem so your Walkables  class will let a person and a duck walk together \nThere are three ways to solve this problem with your existing knowledge of the Java programming language \nNote that we are not talking about interfaces at this point You will solve this problem efficiently and \ncorrectly using interfaces at the end of this section Lets just forget about the title of this chapter for now so \nyou can appreciate the important role that an interface plays in Java programming The three ways to solve \nthis problem are as follows\n\t Change the parameter type of the letThemWalk  method of the Walkables  class \nfrom an array of Person  to an array of Object  Use reflection to invoke the walk  \nmethod on all elements of the passedin array Do not worry about the term \nreflection at this pointChapter 21  Interfa Ces\n800\t Define a new static method called letDucksWalkDuck ducks  in the Walkables  \nclass Call this method when you want ducks to walk\n\t Inherit the Person  and Duck  classes from a common ancestor class say Animal  class \nand add a walk  method in the Animal  class Change the parameter type of the \nletThemWalk  method of the Walkables  class from an array of Person  to an array of \nAnimal \nLets look at the three solutions in detail\n Proposed Solution 1\nYou can implement the first solution by adding the two methods to the Walkables  class as shown\n Walkablesjava\nimport javalangreflectMethod\npublic class Walkables \n    public static void letThemWalkObject list \n        for Object obj  list \n             Get the walk method reference\n            Method walkMethod  getWalkMethodobj\n            if walkMethod  null \n                try \n                     Invoke the walk method\n                    walkMethodinvokeobj\n                 catch Exception e \n                    eprintStackTrace\n                \n            \n        \n    \n    public static Method getWalkMethodObject obj \n        Class c  objgetClass\n        try \n            Method walkMethod  cgetMethodwalk\n            return walkMethod\n         catch NoSuchMethodException e \n             walk method does not exist\n        \n        return null\n    \n\nThe getWalkMethod  method looks for a walk  method in the specified objects class If it finds a \nwalk  method it returns the reference of the method Otherwise it returns null  You have changed the \nparameter type of the letThemWalk  method from an array of Person  to an array of Object  You can use the \nfollowing snippet of code to test the modified Walkables  class\nObject list  new Object4\nlist0  new PersonJack\nlist1  new DuckJeff\nlist2  new PersonJohnChapter 21  Interfa Ces\n801list3  new Object  Does not have a walk method\n Let everyone walk\nWalkablesletThemWalklist\nJack a person is walking\nJeff a duck is walking\nJohn a person is walking\nThe output shows that your solution works It lets persons and ducks walk together At the same time \nit does not force an object to walk if that object does not know how to walk You passed four objects to the \nletThemWalk  method and no attempt was made to invoke the walk  method on the fourth element of \nthe array because the Object  class does not have a walk  method\nLets reject this solution for the very simple reason that you used reflection to invoke the walk  method \non all objects passed in and you relied on the fact that all objects that know how to walk will have a method \nnamed walk  This solution is easily and silently broken if you change the method name say in the Person  \nclass from walk  to walkMe  Your program will keep working without any errors but when you call the \nletThemWalk  method with a Person  object its changed walkMe  method will not be invoked\n Proposed Solution 2\nLets look at the second proposed solution You propose to add a new method letDucksWalk  to your \nWalkables  class as shown\npublic class Walkables \n    public static void letThemWalkPerson list \n        for Person person  list \n            personwalk\n        \n    \n    public static void letDucksWalkDuck list \n        for Duck duck  list \n             duckwalk\n        \n    \n\nThis solves the problem in the sense that it will let\u00a0all ducks walk However it is not an ideal solution \neither It still will not let persons and ducks walk together Another problem with this solution is extensibility \nIt is not an extensible solution If you look at the two methods letThemWalk  and letDucksWalk  you will \nfind that except for the parameter types Person  and Duck  they have the same logic What happens if you add \na new class called Cat whose objects can walk too This solution would force you to add another method \nletCatsWalkCat cats  to the Walkables  class Therefore you should reject this solution because it is \nnot extensibleChapter 21  Interfa Ces\n802 Proposed Solution 3\nLets look at the third proposed solution It proposes to inherit the Person  class and the Duck  class from \na common ancestor class say Animal  which has a walk  method It will also make you change the \nparameter of the letThemWalk  method in the Walkables  class from a Person  array to an Animal  array \nThis solution is very close to the one you are looking for and it may be considered a good solution in some \nsituations However you reject this solution for the following two reasons\n\t This solution forces you to have a common ancestor in your class hierarchy For \nexample all classes whose objects know how to walk must have the same ancestor \ndirect or indirect Suppose you create a new class called Dog whose object can walk \nUnder this proposed solution the Dog class must be inherited from the Animal  class \nso you can use the letThemWalk  method to let a Dog walk Sometimes you want to \nadd the walking ability to objects of a class which is already inherited from another \nclass In such cases it is not possible to change the superclass of the existing classes \nto the Animal  class\n\t Suppose you go forward with this solution You add a new class called Fish  which \ninherits the Animal  class An object of the Fish  class does not know how to walk \nBecause the Fish  class is inherited from the Animal  class it will also inherit the \nwalk  method which is the ability to walk Definitely you will need to override the \nwalk  method inside the Fish  class Now the question arises how should the Fish  \nclass implement the walk  method Should it respond by stating I am a fish and I \ndo not know how to walk Should it throw an exception stating It is illegal to ask a \nfish to walk\nYou can see that the third solution seems to be a very close solution However it is not an ideal one It \nalso proves a point that inheritance is a good thing to use in Java programs but it does not always provide an \nideal solution\n An Ideal Solution\nYou are looking for a solution that provides two things\n\t A single method letThemWalk  in the Walkables  class should be able to send a \nwalk message to ie invoke the walk  method on all objects that are passed to \nit as its parameter This method should work with all types of objects that can walk \nwhich you have now or you will have in the future\n\t If you want to add the ability to walk to objects of an existing class you should not be \nforced to change the superclass of the class\nInterfaces in Java provide a perfect solution in this scenario Before we start discussing interfaces in \ndetail lets complete the solution to the problem presented in this section First you need to define an \ninterface For now just think of an interface as a programming construct\nAn interface is declared using the keyword  interface   which can have abstract  method declarations \nNote that an abstract  method does not have a body Each interface should be given a name Your interface \nis named Walkable  It contains one method called walk  The complete code for your Walkable  interface is \nshown in Listing 212 Chapter 21  Interfa Ces\n803Listing 212  The D eclaration for a Walkable Interface\n Walkablejava\npackage comjdojointerfaces\npublic interface Walkable \n    void walk\n\nAll c lasses whose objects can walk should implement the Walkable  interface A class can implement \none or more interfaces using the keyword implements  in its declaration By implementing an interface a \nclass guarantees that it will provide an implementation for all abstract  methods declared in the interface \nor the class must declare itself abstract  For now lets ignore the second part and assume that the class \nimplements all abstract  methods of the interfaces it implements If a class implements the Walkable  \ninterface it must provide an implementation for the walk  method\nObjects of the Person  and Duck  classes need the ability to walk You need to implement the Walkable  \ninterface to these classes Listings 213  and 214  have the complete revised code for these classes\nListing 213  The R evised Person Class Which Implements the Walkable Interface\n Personjava\npackage comjdojointerfaces\npublic class Person implements Walkable  \n    private String name\n    public PersonString name \n        thisname  name\n    \n    public void walk \n        Systemoutprintlnname   a person is walking\n    \n\nListing 214  The R evised Duck Class Which Implements the Walkable Interface\n Duckjava\npackage comjdojointerfaces\npublic class Duck implements Walkable  \n    private String name\n    public DuckString name \n        thisname  name\n    \n    public void walk \n        Systemoutprintlnname   a duck is walking\n    \n\nNote that the declarations of the revised classes have a minor difference from their original declarations \nBoth of them have a new  implements Walkable  clause added to their declarations Since both of \nthem implement the Walkable  interface they must provide the implementation for the walk  method \nas declared in the Walkable  interface You did not have to define a fresh walk  method as you had it \nimplemented from the very beginning If these classes did not have a walk  method you had to add it to \nthem at this stageChapter 21  Interfa Ces\n804Before you revise the code for your Walkables  class lets look at other things that you can do with the \nWalkable  interface Like a class an interface defines a new reference type When you define a class it defines \na new reference type and it lets you declare variables of that type Similarly when you define a new interface \neg Walkable  you can define a reference variable of the new interface type The variable scope could be \nlocal instance static or a method parameter The following declaration is valid\n w is a reference variable of type Walkable\nWalkable w\nYou cannot create an object of an interface type The following code is invalid\n A compiletime error\nnew Walkable\nYou can create an object of only a class type However an interfacetype variable can refer to any object \nwhose class implements that interface Because the Person  and Duck  classes implement the Walkable  \ninterface a reference variable of the Walkable  type can refer to an object of these classes\nWalkable w1  new PersonJack  OK\nWalkable w2  new DuckJeff     OK\n A compiletime error as the Object class does not implement the Walkable interface\nWalkable w3  new Object\nWhat can you do with the reference variable of an interface type You can access any members of the \ninterface using its referencetype variable Since your Walkable  interface has only one member which is the \nwalk  method you can write code as shown\n Let the person walk\nw1walk\n Let the duck walk\nw2walk\nWhen you invoke the walk  method on w1 it invokes the walk  method of the Person  object because \nw1 is referring to a Person  object When you invoke the walk  method on w2 it invokes the walk  method \nof the Duck  object because w2 is referring to a Duck  object When you call a method using a reference variable \nof an interface type it calls the method on the object to which it is referring With this knowledge about an \ninterface lets revise the code for your Walkables  class Listing 215  contains the revised code Note that in \nthe revised code for the letThemWalk  method all you had to do was to change the parameter type from \nPerson  to Walkable  Everything else remains the same\nListing 215  The R evised Walkables Class\n Walkablesjava\npackage comjdojointerfaces\npublic class Walkables \n    public static void letThemWalkWalkable list \n        for Walkable w  list \n            wwalk\n        \n    \nChapter 21  Interfa Ces\n805Listing 216  shows how to test your revised classes with the Walkable  interface It creates an array of \nthe Walkable  type Declaring an array of an interface type is allowed because an array provides a shortcut \nto create many variables of the same type This time you can pass objects of the Person  class as well as the \nDuck  class in one array of the Walkable  type to the letThemWalk  method of the Walkables  class which lets \neveryone walk together as shown in the output\nListing 216  A Tes t Class to Test the Revised Person Duck and Walkables Classes\n WalkablesTestjava\npackage comjdojointerfaces\npublic class WalkablesTest \n    public static void mainString args \n        Walkable w  new Walkable3\n        w0  new PersonJack\n        w1  new DuckJeff\n        w2  new PersonJohn\n         Let everyone walk\n        WalkablesletThemWalkw\n    \n\nJack a person is walking\nJeff a duck is walking\nJohn a person is walking\nHow will your existing code change if you want to create a new class called Cat whose objects should \nhave the ability to walk You might be surprised to see that you do not need to change anything in your \nexisting code The Cat class should implement the Walkable  interface and that is all Listing 217  contains \nthe code for the Cat class\nListing 217  A Ca t Class\n Catjava\npackage comjdojointerfaces\npublic class Cat implements Walkable \n    private String name\n    public CatString name \n        thisname  name\n    \n    public void walk \n        Systemoutprintlnname   a cat is walking\n    \n\nYou can use the following snippet of code to test the new Cat class with the existing code Looking at the \noutput you have made persons ducks and cats walk together by using the Walkable  interface This is one of \nthe uses of an interface in Javait lets you put otherwise unrelated classes under one umbrella\nWalkable w  new Walkable4\nw0  new PersonJack\nw1  new DuckJeffChapter 21  Interfa Ces\n806w2  new PersonJohn\nw3  new CatJace\n Let everyone walk\nWalkablesletThemWalkw\nJack a person is walking\nJeff a duck is walking\nJohn a person is walking\nJace a cat is walking\nYou have achieved the objective of making different kinds of objects walk together using the interface \nconstruct So what is an interface anyway\nAn interface in Java defines a reference type to specify an abstract concept It is implemented by \nclasses that provide an implementation of the concept Prior to Java 8 an interface could contain only \nabstract methods Java 17 allows an interface to have static private and default methods that can also \ncontain implementation However interfaces cannot have nonfinal variables Interfaces let you define a \nrelationship between unrelated classes through the abstract concept In our example the Walkable  interface \nrepresented a concept that enabled you to treat the two unrelated classes of Person  and Duck  the same way \nbecause both implemented the same concept of walking\nIt is time to go over details of how to create and use interfaces in a Java program As we discuss the \ntechnical details of interfaces we also go over proper uses and common misuses of interfaces\n Declaring an\u00a0Interface\nAn interface can be declared as a toplevel interface a nested interface or an annotation type We discuss \nnested interfaces later in this chapter Annotationtype interfaces are discussed in the second volume of \nthis series More Java 17  We use the term interface  to mean a toplevel interface The general incomplete \nsyntax for declaring an interface is as follows\nmodifiers interface interfacename \n    constantdeclaration\n    methoddeclaration\n    nestedtypedeclaration\n\nAn in terface declaration starts with an optional list of modifiers Like a class an interface can have a \npublic or packagelevel scope The keyword public  is used to indicate that the interface has a public scope \nA public interface can be referred to from anywhere in the application Referring to an interface across \nmodules depends on module accessibility rules as discussed in Chapter 10 Absence of a scope modifier \nindicates that the interface has a packagelevel scope An interface with a packagelevel scope can be \nreferred to only within the members of its package\nThe keyword interface  is used to declare an interface The keyword is followed by the name of the \ninterface The name of an interface is a valid Java identifier An interface body follows its name which is \nplaced inside braces Members of an interface are declared inside the body In a special case the body of an \ninterface can be empty The following is the simplest interface declaration\npackage comjdojointerfaces\ninterface Updatable \n     The interface body is empty\nChapter 21  Interfa Ces\n807This code declares an interface named Updatable  which has a packagelevel scope It can be used only \ninside the comjdojointerfaces  package because it has a packagelevel scope It does not contain any \nmember declarations\nLike a class an interface has a simple name and a fully qualified name The identifier that follows the \nkeyword interface is its simple name The fully qualified name of an interface is formed by using its package \nname and the simple name separated by a dot In the previous example Updatable  is the simple name and \ncomjdojointerfacesUpdatable  is the fully qualified name The rules of using simple and fully qualified \nnames of an interface are the same as those of a class\nThe following code declares an interface named ReadOnly  It has a public scope That is the definition \nof the ReadOnly  interface is available anywhere in the same module or other modules depending on the \nmodule accessibility rules\npackage comjdojointerfaces\npublic interface ReadOnly \n     The interface body is empty\n\nAn interface declaration is implicitly abstract You can declare Updatable  and ReadOnly  interfaces \nas follows without changing their meanings In other words an interface declaration is always abstract  \nwhether you declare it abstract  explicitly or not\nabstract interface Updatable \n     The interface body is empty\n\npublic abstract interface ReadOnly \n     The interface body is empty\n\n Note  Interfaces in Ja va are implicitly abstract  Using the keyword abstract  in their declarations is \nobsolete and it should not be used in new programs the previous examples are only for illustration purposes\n Declaring Interface Members\nAn interface can have three types of members\n\t Constant fields\n\t Abstract static private and default methods\n\t Static types nested interfaces and classes\nNote that an interface declaration is much like a class declaration except that an interface cannot have \nmutable instance and class variables Unlike a class an interface cannot be instantiated All members of an \ninterface are implicitly public\n Ti p Up to Ja va 8 all types of members in an interface were implicitly public Java 9 and above allow you to \nhave private methods in an interface which we discuss later in this chapterChapter 21  Interfa Ces\n808 Constant Field Declarations\nYou can declare constant fields in an interface as shown in Listing 218  It declares an interface named \nChoices  which has declarations of two int fields YES and NO\nListing 218  Declaring Fields in an Interface\n Choicesjava\npackage comjdojointerfaces\npublic interface Choices \n    public static final int YES  1\n    public static final int NO  2\n\nAll fields in an in terface are implicitly public  static  and final  Although the interface declaration \nsyntax permits the use of these keywords in a field declaration their use is redundant It is recommended \nnot to use these keywords when declaring fields in an interface The Choices  interface can be declared as \nfollows without changing its meaning\npublic interface Choices \n    int YES  1\n    int NO  2\n\nYou can access the fields in an interface using the dot notation in the form of the following\ninterfacenamefieldname\nYou can use ChoicesYES  and ChoicesNO  to access the values of YES and NO fields in the Choices  \ninterface Listing 219  demonstrates how to use the dot notation to access fields of an interface\nListing 219  Acces sing Fields of an Interface\n ChoicesTestjava\npackage comjdojointerfaces\npublic class ChoicesTest \n    public static void mainString args \n        SystemoutprintlnChoicesYES    ChoicesYES\n        SystemoutprintlnChoicesNO    ChoicesNO\n    \n\nChoicesYES  1\nChoicesNO  2\nFields in an interface are always final  whether the keyword final  is used in their declaration or \nnot This implies that you must initialize a field at the time of declaration You can initialize a field with a \ncompiletime or runtime constant expression Since a final  field constant field is assigned a value only \nonce you cannot set the value of the field of an interface except in its declaration The following snippet of \ncode generates a compiletime error\nChoicesYES  5  A compiletime errorChapter 21  Interfa Ces\n809The following snippet of code shows some valid and invalid field declarations for an interface\n All fields declarations are valid in the ValidFields interface \npublic interface ValidFields \n    int X  10\n     You can use one field to initialize another if the referenced\n     field is declared before the one that references it\n    int Y  X\n    double N  X  105\n    boolean YES  true\n    boolean NO  false\n     Assuming Test is a class that exists\n    Test TEST  new Test\n\n Examples of invalid field declarations \npublic interface InvalidFields \n    int X       Invalid X is not initialized\n    int Y  Z    Invalid Forward referencing of Z is not allowed\n    int Z  10  Valid by itself\n    Test TEST    Invalid TEST is not initialized assuming a Test class exists\n\n Tip It is a convention to use all uppercase letters in the name of a field in an interface to indicate tha t they \nare constants however Java does not impose any restrictions on naming the fields of an interface as long as \nthey follow the naming rules for identifiers fields of an interface are always public  however the accessibility \nof public  fields from outside the declaring package depends on the scope of the interface for example if an \ninterface is dec lared to have a packagelevel scope its fields are not accessible outside the package because \nthe interface itself is not accessible outside the package even though its fields are public \nYou are advised not to declare an interface to only have constant fields in it The proper and most \ncommonly used use of an interface is to declare a set of methods to define APIs If you want to group \nconstants in one construct use an enum not an interface If you cannot use an enum then use a class to \ndeclare your constants Using an enum provides type safety and compiletime checks for your constants \nEnums are covered in Chapter 22\n Method Declarations\nYou can declare four types of methods in an interface\n\t Abstract methods\n\t Static methods\n\t Default methods\n\t Private methodsChapter 21  Interfa Ces\n810Prior to Java 8 you could declare only abstract  methods in interfaces The modifiers static  default  \nand private  are used to declare static default and private methods respectively The lack of a static  \ndefault  or private  modifier makes a method abstract  The following is an example of an interface with all \nfour types of methods\ninterface AnInterface \n     An abstract method\n    int m1\n     A static method\n    static int m2 \n     The method implementation goes here\n    \n     A default method\n    default int m3 \n     The method implementation goes here\n    \n     A private method\n    private int m4 \n     The method implementation goes here\n    \n\nThe following sections discuss each method type declaration in detail\n Abstract Method Declarations\nThe main purpose of declaring an interface is to create an abstract specification or concept by declaring \nzero or more abstract methods All method declarations in an interface are implicitly abstract and public \nunless they are declared static  or default  Like in a class an abstract  method in an interface does not \nhave an implementation The body of the abstract  method is always represented by a semicolon not by a \npair of braces The following snippet of code declares an interface named Player \npublic interface Player \n    public abstract void play\n    public abstract void stop\n    public abstract void forward\n    public abstract void rewind\n\nThe Player  interface has four methods play  stop  forward  and rewind  The Player  interface \nis a specification for an audiovideo player A real player for example a DVD player will provide the \nconcrete implementation of the specification by implementing all four methods of the Player  interface\nUse of the abstract  and public  keywords in a method declaration in an interface is redundant even \nthough allowed by the compiler because a method in an interface is implicitly abstract and public The \nprevious declaration of the Player  interface can be rewritten as follows without changing its meaning\npublic interface Player \n    void play\n    void stop\n    void forward\n    void rewind\nChapter 21  Interfa Ces\n811Abstract method declarations in an interface may include parameters a return type and a throws  \nclause The following snippet of code declares an ATM interface It declares four methods If the account \ninformation is wrong the login  method throws an AccountNotFoundException  The withdraw  method \nthrows an InsufficientBalanceException  when the user attempts to withdraw an amount that will reduce \nthe balance to an amount lower than the required minimum balance amount\npublic interface ATM \n    boolean loginint account throws AccountNotFoundException\n    boolean depositdouble amount\n    boolean withdrawdouble amount throws InsufficientBalanceException\n    double getBalance\n\nAbstract methods of an interface are inherited by classes that implement the interface and classes \noverride them to provide an implementation This implies that an abstract method in an interface cannot be \ndeclared final as the final  keyword in a method declaration indicates that the method is final and it cannot \nbe overridden However a class may declare the overridden method of an interface final indicating that the \nsubclasses cannot override the method\n Static Method Declarations\nLets refer to the code for the Walkables  class shown in Listing 215  It is a utility class that contains a static \nmethod called letThemWalk  Creating such a utility class for providing static methods for working with \nan interface was common prior to Java 8 You will find a number of interfaceutility class pairs in the Java \nlibrary for example CollectionCollections  PathPaths  ChannelChannels  ExecutorExecutors  \netc Following this convention you named your interfaceutility class pair as WalkableWalkables  Java \ndesigners realized the necessity of the extra utility classes along with interfaces From Java 8 you can have \nstatic methods in interfaces A static methods declaration contains the static  modifier They are implicitly \npublic You can redefine the Walkable  interface as shown in Listing 2110  to include the letThemWalk  \nmethod and get rid of the Walkables  class altogether\nListing 2110  The R evised Walkable Interface with an Additional Static Convenience Method\n Walkablejava\npackage comjdojointerfaces\npublic interface Walkable \n     An abstract method\n    void walk\n     A static convenience method\n    public static void letThemWalkWalkable list \n        for Walkable w  list \n            wwalk\n        \n    \n\nYou can use the static methods of an interface using the dot notation\ninterfacenamestaticmethodChapter 21  Interfa Ces\n812The following snippet of code calls the WalkableletThemWalk  method\nWalkable w  new Walkable4\nw0  new PersonJack\nw1  new DuckJeff\nw2  new PersonJohn\nw3  new CatJace\n Let everyone walk\nWalkableletThemWalkw\nJack a person is walking\nJeff a duck is walking\nJohn a person is walking\nJace a cat is walking\nUnlike static methods in a class static methods in an interface are not inherited by implementing \nclasses or subinterfaces An interface that inherits from another interface is called a subinterface There is \nonly one way to call the static methods of an interface by using the interface name A static method m of \nan interface I must be called using Im  You can use the unqualified name m of the method to call it only \nwithin the body of the interface or when you import the method using a static import  statement\n Default Method Declarations\nA default method in an interface is declared with the modifier default  A default method provides a default \nimplementation of the method for the class that implements the interface but does not override the default \nmethod\nThe default methods were introduced in Java 8 Prior to Java 8 interfaces could have only abstract \nmethods Why were default methods added in Java 8 The short answer is that they were added so the \nexisting interfaces may evolve At this point the answer may be hard to understand Lets look at an example \nto clear this up\nSuppose prior to Java 8 you wanted to create a specification for movable objects to describe their \nlocations in a 2D plane Lets create the specification by creating an interface named Movable  as shown in \nListing 2111 \nListing 2111  A Mo vable Interface\n Movablejava\npackage comjdojointerfaces\npublic interface Movable \n    void setXdouble x\n    void setYdouble y\n    double getX\n    double getY\n\nThe interface declares four abstract methods The setX  and setY  methods let Movable  change \nthe location using the absolute positioning The getX  and getY  methods return the current location in \nterms of the x and y coordinatesChapter 21  Interfa Ces\n813Consider the Pen class in Listing 2112  It implements the Movable  interface and as part of the \nspecification it provides implementation for the four methods of the interface The class contains two \ninstance variables called x and y to track the location of the pen\nListing 2112  A Pen C lass That Implements the Movable Interface\n Penjava\npackage comjdojointerfaces\npublic class Pen implements Movable \n    private double x\n    private double y\n    public Pen \n         By default the pen is at 00 00\n    \n    public Pendouble x double y \n        thisx  x\n        thisy  y\n    \n    Override\n    public void setXdouble x \n        thisx  x\n    \n    Override\n    public void setYdouble y \n        thisy  y\n    \n    Override\n    public double getX \n        return x\n    \n    Override\n    public double getY \n        return y\n    \n    Override\n    public String toString \n        return Pen  x     y  \n    \n\nThe following snippet of code uses the Movable  interface and the Pen class\n Create a Pen and assign its reference to a Movable variable\nMovable p1  new Pen\nSystemoutprintlnp1\n Move the Pen\np1setX100\np1setY50\nSystemoutprintlnp1Chapter 21  Interfa Ces\n814Pen00 00\nPen100 50\nSo far there is nothing extraordinary going on with the Movable  interface and the Pen class Suppose \nthe Movable  interface is part of a library that you have developed You have distributed the library to your \ncustomers Customers have implemented the Movable  interface in their classes\nNow comes a twist in the story Some customers have requested that the Movable  interface include \nspecifications for changing the location using relative coordinates They want you to add a move  method to \nthe Movable  interface as follows The requested part is shown in boldface\npublic interface Movable \n    void setXdouble x\n    void setYdouble y\n    double getX\n    double getY\n    void movedouble deltaX double deltaY\n\nYou are a nice business person you always want a happy customer You oblige the customer You make \nthe changes and redistribute the new version of your library After a few hours you get calls from several \nangry customers They are angry because the new version of the library broke their existing code Lets \nanalyze what went wrong\nPrior to Java 8 all methods in an interface were implicitly abstract Therefore the new method \nmove  is an abstract method All classes that are implementing the Movable  interface must provide the \nimplementation for the new method Note that customers already have several classes for example the Pen \nclass which implement the Movable  interface All those classes will not compile anymore unless the new \nmethod is added to those classes The moral of the story is that prior to Java 8 it was not possible to add \nmethods to an interface after it was distributed to the public without breaking the existing code\nJava libraries have published hundreds of interfaces which were used thousands of times by customers \nworldwide Java designers were in a dire need of a way to evolve the existing interfaces without breaking \nthe existing code They explored several solutions Default methods were the accepted solution to evolve \ninterfaces A default method can be added to an existing interface It provides a default implementation \nfor the method All classes implementing the interface will inherit the default implementation thus not \nbreaking them Classes may choose to override the default implementation\nA default method is declared using the keyword default  A default method cannot be declared abstract \nor static It must provide an implementation Otherwise a compiletime error occurs Listing 2113  shows \nthe revised code for the Movable  interface It contains a default method called move  that is defined in terms \nof the existing four methods\nListing 2113  The M ovable Interface with a Default Method\n Movablejava\npackage comjdojointerfaces\npublic interface Movable \n    void setXdouble x\n    void setYdouble y\n    double getX\n    double getYChapter 21  Interfa Ces\n815     A default method\n    default void movedouble deltaX double deltaY \n        double newX  getX  deltaX\n        double newY  getY  deltaY\n        setXnewX\n        setYnewY\n    \n\nAny existing classes including the Pen class that implement the Movable  interface will continue to \ncompile and work as before The new move  method with its default implementation is available for all \nthose classes Listing 2114  shows the old and new methods of the Movable  interface with the Pen class\nListing 2114  Testing the New Movable Interface with the Existing Pen Class\n MovableTestjava\npackage comjdojointerfaces\npublic class MovableTest \n    public static void mainString args \n         Create a Pen and assign its reference to a Movable variable\n        Movable p1  new Pen\n        Systemoutprintlnp1\n         Move the Pen using absolute coordinates\n        p1setX100\n        p1setY50\n        Systemoutprintlnp1\n         Move the Pen using relative coordinates\n        p1move50 20\n        Systemoutprintlnp1\n    \n\nPen00 00\nPen100 50\nPen150 70\nAnother common us e of default methods is to declare optional methods in an interface Consider a \nNamed  interface as shown in Listing 2115 \nListing 2115  A Name d Interface Using Default Methods to Provide Optional Methods\n Namedjava\npackage comjdojointerfaces\npublic interface Named \n    void setNameString name\n    default String getName \n        return John Doe\n    \n    default void setNicknameString nickname \n        throw new UnsupportedOperationExceptionsetNickname\n    Chapter 21  Interfa Ces\n816    default String getNickname \n        throw new UnsupportedOperationExceptiongetNickname\n    \n\nThe interface provides specifications for getting and setting the official name and nickname Not \neverything has a nickname The interface provides methods to get and set the nickname as default methods \nmaking them optional If a class implements the Named  interface it can override the setNickname  and \ngetNickname  methods to provide implementation if the class supports a nickname Otherwise the class \ndoes not have to do anything for these methods They simply throw a runtime exception to indicate they \nare not supported The interface declares the getName  method as default and provides a sensible default \nimplementation for it by returning John Doe  as the default name The classes implementing the Named  \ninterface are expected to override the getName  method to return the real name\nThis has just touched the tip of the iceberg in terms of the benefits and power that default methods \nhave brought to the Java language It has given a new life to the existing Java APIs In Java 8 default methods \nwere added to several interfaces in the Java library to provide more expressiveness and functionality for the \nexisting APIs\nWhat are the similarities and differences between a concrete method in a class and a default method in \nan interface\n\t Both provide an implementation\n\t Both have access to the keyword this  in the same way That is the keyword this  is \nthe reference of the object on which the method is called\n\t The major difference lies in the access to the state of the object A concrete method \nin a class can access the instance variables of the class However a default method \ndoes not have access to the instance variables of the class implementing the \ninterface The default method has access to the other members of the interface for \nexample other methods constants and type members For example the default \nmethod in the Movable  interface is written using the other member methods getX  \ngetY  setX  and setY \n\t Needless to say both types of methods can use their parameters\n\t Both methods can have a throws  clause\nWe are not done with default methods yet We will discuss their roles in inheritance shortly\n Private Methods in\u00a0an\u00a0Interface\nJDK 8 introduced static and default methods to interfaces If you had to perform the same logic multiple \ntimes in these methods you had no choice but to repeat the logic or move the logic to another class to hide \nthe implementation Consider the interface named Alphabet  as shown in Listing 2116 \nListing 2116  An In terface Named Alphabet Having Two Default Methods Sharing Logic\n Alphabetjava\npackage comjdojointerfaces\npublic interface Alphabet \n    default boolean isAtOddPoschar c \n        if CharacterisLetterc \n            throw new RuntimeExceptionNot a letter   c\n        Chapter 21  Interfa Ces\n817        char uc  CharactertoUpperCasec\n        int pos  uc   64\n        return pos  2  1\n    \n    default boolean isAtEvenPoschar c \n        if CharacterisLetterc \n            throw new RuntimeExceptionNot a letter   c\n        \n        char uc  CharactertoUpperCasec\n        int pos  uc   64\n        return pos  2  0\n    \n\nThe isAtOddpos  and isAtEvenPos  methods check if the specified character is at an odd or even \nposition alphabetically assuming we are dealing with only English alphabets The logic assumes that A \nand a are at position 1 B and b are at position 2 etc Notice that the logic in two methods differs \nonly in the return  statements The entire body of these methods is identical except for the last statements \nWe need to refactor this logic Moving the common logic to another method and calling the new method \nfrom both methods would be the ideal case However you dont want to do this in JDK 8 because interfaces \nsupport only public methods Doing so will make the third method public which will expose it to the outside \nworld which you dont want to do\nJava 9 came to the rescue and lets you declare private methods in interfaces Listing 2117  shows the \nrefactored version of the Alphabet  interface using a private method that contains the common logic used \nby the two methods This time we named the interface AlphabetJdk9  just to make sure I could include both \nversions in the source code The two existing methods become oneliners\nListing 2117  An In terface Named AlphabetJdk9 That Uses a Private Method\n AlphabetJdk9java\npackage comjdojointerfaces\npublic interface AlphabetJdk9 \n    default boolean isAtOddPoschar c \n        return getPosc  2  1\n    \n    default boolean isAtEvenPoschar c \n        return getPosc  2  0\n    \n    private int getPoschar c \n        if CharacterisLetterc \n            throw new RuntimeExceptionNot a letter   c\n        \n        char uc  CharactertoUpperCasec\n        int pos  uc   64\n        return pos\n    \nChapter 21  Interfa Ces\n818Before JDK 9 all methods in an interface were implicitly public Remember these simple rules that \napply to all programs in Java\n\t A private  method is not inherited and therefore cannot be overridden\n\t A final  method cannot be overridden\n\t An abstract  method is inherited and is meant to be overridden\n\t A default  method is an instance method and provides a default implementation it \ncan be overridden\nYou need to follow a few rules while declaring methods in an interface All combinations of modifiers\nabstract  public  private  static  and final are not supported because they do not make sense \nTable\u00a0 211  lists a combination of modifiers supported and not supported in method declarations of \ninterfaces Note that the final  modifier is not allowed in method declarations for interfaces According to \nthis list you can have a private method in an interface that is either a nonabstract nondefault instance \nmethod or a static method\n Nested Type Declarations\nA nested type declaration in an interface defines a new reference type You can declare a class interface \nenum and annotation as nested types We have not discussed enum and annotation yet so we will restrict \nthe discussion to nested interfaces and classes in this section An interfaceclass declared inside an interface \nis called a nested interfaceclass\nAn interface and a class define new reference types so do a nested interface and a nested class \nSometimes a type makes more sense as a nested type Suppose you have an ATM interface and you want to \ndefine another interface called ATMCard  The ATMCard  interface can be defined as a toplevel interface or a \nnested interface of ATM Since an ATM card is used with an ATM it might make more sense to define ATMCard  as \na nested interface of the ATM interface Since you are defining ATMCard  as a nested interface of ATM you can \nalso drop the ATM  from its name and you can name it just Card  as shownTable 211  Supp orted Modifiers in Method Declarations in Interfaces\nModifiers Supported Description\npublic static Yes Supported since JDK 8\npublic abstract Yes Supported since JDK 1\npublic default Yes Supported since JDK 8\nprivate static Yes Supported since JDK 9\nPrivate Yes Supported since JDK 9 This is a nonabstract instance method\nprivate abstract No This combination does not make sense A private method is not \ninherited so it cannot be overridden whereas an abstract method \nmust be overridden to be useful\nprivate default No This combination does not make sense A private method is not \ninherited so it cannot be overridden whereas a default method is \nmeant to be overridden if neededChapter 21  Interfa Ces\n819public interface ATM \n    boolean loginint account throws AccountNotFoundException\n    boolean depositdouble amount\n    boolean withdrawdouble amount throws InsufficientFundsException\n    double getBalance\n     Card is a nested interface You can omit the keywords public and static\n    public static interface Card \n        String getNumber\n        String getSecurityCode\n        LocalDate getExpirationDate\n        String getCardHolderName\n    \n\nA nes ted interface is always accessed through its enclosing interface In the previous snippet of code \nATM is a toplevel interface or simply an interface and Card  is a nested interface The ATM interface is also \ncalled an enclosing interface for the Card  interface The fully qualified name of the ATM and Card  interfaces \nare comjdojointerfacesATM  and comjdojointerfacesATMCard  respectively All nested types are \nimplicitly public and static The previous snippet of code used the keywords public  and static  to declare \nthe ATMCard  interface which is redundant\nYou can also declare a nested class inside an interface You may not understand the use of a nested \nclass described in this section until you know how to implement an interface which is described in the next \nsection The following discussion is included here to complete the discussion about the nested types of an \ninterface You may revisit this section after reading about how to implement an interface in the next few \nsections\nIt is not common to declare a nested class inside an interface However you should not be surprised \nif you find an interface that declares a nested class as its member What advantage does it offer to have a \nnested class inside an interface There is only one advantage of doing this and it is a better organization \nof related entities interfaces and classes Suppose you want to develop a Job interface that will let the user \nsubmit a job to a job scheduler The following is the code for the Job interface\npublic interface Job \n    void runJob\n\nSuppose each department must submit a job every day even if they do not have something to run It \nsuggests that sometimes you need an empty job or a job with nothing real to do The developer of the Job \ninterface may provide a constant which represents a trivial implementation of the Job interface as listed in \nListing 2118  It has a nested class called EmptyJob  which implements the enclosing Job interface\nListing 2118  The J ob Interface with a Nested Class and a Constant Field\n Jobjava\npackage comjdojointerfaces\npublic interface Job \n     A nested class\n    class EmptyJob implements Job \n        private EmptyJob \n             Do not allow outside to create its object\n        Chapter 21  Interfa Ces\n820        Override\n        public void runJob \n            SystemoutprintlnNothing serious to run\n        \n    \n     A constant field\n    Job EMPTYJOB  new EmptyJob\n     An abstract method\n    void runJob\n\nIf a dep artment does not have a meaningful job to submit it can use the JobEMPTYJOB  constant as a \njob The fully qualified name of the EmptyJob  class is comjdojointerfacesJobEmptyJob  Note that the \nenclosing interface Job provides an additional namespace for the EmptyJob  class Inside the Job interface \nthe EmptyJob  class can be referred to by its simple name of EmptyJob  However outside the Job interface \nit must be referred to as JobEmptyJob  You may notice that a trivial job object is represented by the Job\nEMPTYJOB  constant You have made the constructor for the EmptyJob  nested class private so no one outside \nthe interface can create its object Listing 2119  shows how to use the class Typically in such cases you \nwould make the constructor of the JobEmptyJob  class private so its object cannot be created outside the Job \ninterface because the EMPTYJOB  constant already provides an object of this class\nListing 2119  A Tes t Program to Test the Job Interface and Its Nested EmptyJob Class\n JobTestjava\npackage comjdojointerfaces\npublic class JobTest \n    public static void mainString args \n        submitJobJobEMPTYJOB\n    \n    public static void submitJobJob job \n        jobrunJob\n    \n\nNothing serious to run\n An Interface Defines a\u00a0New Type\nAn interface defines a new reference type You can use an interface type anywhere you can use a reference \ntype For example you can use an interface type to declare a variable instance static or local or to declare \na parameter type in a method as a return type of a method etc\nConsider the following interface declaration named Swimmable  which declares a method swim  as \nshown in Listing 2120  The SwimmableTest  class in Listing 2121  shows how to use the Swimmable  interface \nas a reference data typeChapter 21  Interfa Ces\n821Listing 2120  The Declaration for a Swimmable Interface\n Swimmablejava\npackage comjdojointerfaces\npublic interface Swimmable \n    void swim\n\nListing 2121  A Test Class That Demonstrates the Use of an Interface Type as a Variable Type\n SwimmableTestjava\npackage comjdojointerfaces\npublic class SwimmableTest \n     Interface type to define instance variable\n    private Swimmable iSwimmable\n     Interface type to define parameter type for a constructor\n    public SwimmableTestSwimmable aSwimmable \n        thisiSwimmable  aSwimmable\n    \n     Interface type to define return type of a method\n    public Swimmable getSwimmable \n        return thisiSwimmable\n    \n     Interface type to define parameter type for a method\n    public void setSwimmableSwimmable newSwimmable \n        thisiSwimmable  newSwimmable\n    \n    public void letItSwim \n         Interface type to declare a local variable\n        Swimmable localSwimmable  thisiSwimmable\n         An interface variable can be used to invoke any method\n         declared in the interface and the Object class\n        localSwimmableswim\n    \n\nThe SwimmableTest  class uses the new type defined by the Swimmable  interface in a number of ways \nThe purpose of the class is just to demonstrate the use of an interface as a new type It uses the Swimmable  \ninterface as a type to declare the following\n\t An instance variable named iSwimmable \n\t A parameter named aSwimmable  for its constructor\n\t The return type of its getSwimmable  method\n\t A parameter named newSwimmable  for its setSwimmable  method\n\t A local variable named localSwimmable  inside its letItSwim  method Inside \nthe method you could have invoked swim  directly on the instance variable \niSwimmable  We used a local variable just to demonstrate that an interface type can \nbe used anywhere a type can be usedChapter 21  Interfa Ces\n822At this point two questions about interfaces need to be answered\n\t What object in memory does a variable of an interface type refer to\n\t What can you do with a variable of an interface type\nBecause an interface defines a reference type what object in memory does a variable of an interface \ntype refer to Lets expand on this question with an example You have a Swimmable  interface and you can \ndeclare a reference variable of type Swimmable  as follows\nSwimmable sw\nWhat is the value of the variable sw at this point A variable of a reference data type refers to an object \nin memory To be precise lets rephrase the question as What object in memory does sw refer to You \ncannot answer this question completely at this point The partial and unexplained answer is that a variable \nof an interface type refers to an object in memory whose class implements that interface The answer will \nbe clearer when we discuss implementing an interface in the next section You cannot create an object of an \ninterface type An interface is implicitly abstract and it does not have a constructor That is you cannot use \nan interface type with the new operator to create an object The following code would not compile\nSwimmable sw2  new Swimmable  A compiletime error\nIn this statement the use of the new operator causes the compiletime error not the Swimmable sw2  \npart The Swimmable sw2  part is a variable declaration which is valid\nHowever one thing is certain a variable of an interface type can refer to an object in memory This \nscenario is depicted in Figure\u00a0 211 \nLets answer the second question What can you do with the variable of an interface type All rules for a \nreferencetype variable equally apply to a variable of an interface type A few important things that you can \ndo with a variable of a reference type are as follows\n\t You can assign a reference of an object in memory including a null  reference value\nSwimmable sw2  null\n\t You can access any constant fields declared in an interface using a variable of the \ninterface type or directly using the interface name It is preferred to access the \nconstants of an interface using the interface name Consider the Choices  interface \nwith two constants called YES and NO You can access the value of the two constants \nusing the simple name of the interface as ChoicesYES  and ChoicesNO  and using \nthe interface reference variable sw2YES  and sw2NO Figure 211   A Sw immabletype variable sw referring to an object in memoryChapter 21  Interfa Ces\n823\t You can use a variable of an interface type to invoke any methods declared in the \ninterface For example a variable of the Swimmable  type can invoke the swim  \nmethod as follows\nSwimmable sw3  get an object instance of the Swimmable type\nsw3swim\n\t A variable of an interface type can invoke any method of the Object  class This rule \nis not very obvious However if you think carefully it is a very simple and important \nrule A variable of an interface type can refer to an object in memory No matter what \nobject in memory it refers to the object will always be of a class type All classes in \nJava must have the Object  class as their directindirect parent As a result all objects \nin Java have access to all methods of the Object  class Therefore it is logical to allow \nan interfacetype variable to access all methods of the Object  class The following \nsnippet of code calls the hashCode  getClass  and toString  methods of the \nObject  class using a Swimmable type variable\nSwimmable sw4  get a Swimmable type object\nint hc  sw4hashCode\nClass c  sw4getClass\nString str  sw4toString\n\t Another important rule to remember is that an instance or static variable of an \ninterface type is initialized to null  by default As is the case with all types of local \nvariables a local variable of an interface type is not initialized by default You must \nexplicitly assign it a value before you can use it\n Implementing an\u00a0Interface\nAn interface defines a specification for objects about the ways they will communicate with other objects A \nspecification is a contract or agreement for an objects behavior It is very important that you understand the \ndifference between the two terms specification  or contract  and implementation  A specification is a set of \nstatements and implementation is the realization of those statements\nLets take a realworld example The statement Jack will give ten dollars to John on June 8 2014 \nis a specification When Jack gives ten dollars to John on June 8 2014 the specification is executed You \ncan restate it as when Jack gives ten dollars to John on June 8 2014 the specification is implemented \nSometimes while discussing interfaces a specification is also referred to as a contract a protocol an \nagreement a plan or a draft No matter which term you use to refer to a specification it is always abstract \nThe implementation of a specification could be partial or complete Jack may give seven dollars to John on \nJune 8 2014 and in that case the specification has not been implemented completely\nAn interface specifies a protocol that an object guarantees to offer when it interacts with other objects \nIt specifies the protocol in terms of abstract and default methods A specification is implemented at some \ntime by someone and so is the case with an interface An interface is implemented by a class When a class \nimplements an interface the class provides implementations for all abstract methods of the interface A \nclass may provide a partial implementation of the abstract methods of the interface and in that case the \nclass must declare itself abstractChapter 21  Interfa Ces\n824A class that implements an interface or interfaces uses an implements  clause to specify the name of \nthe interface An implements  clause consists of the keyword implements  followed by a commaseparated list \nof interface types A class can implement multiple interfaces Lets focus on a class implementing only one \ninterface for now The general syntax for a class declaration that implements an interface looks as follows\nmodifiers class className implements commaseparatedlistofinterfaces \n     Class body goes here\n\nSuppose there is a Fish  class\npublic class Fish \n     Code for Fish class goes here\n\nNow you want to implement the Swimmable  interface in the Fish  class The following code shows the \nFish  class and declares that it implements the Swimmable  interface\npublic class Fish implements Swimmable  \n     Code for the Fish class goes here\n\nThe text in boldface font shows the changed code This code for the Fish  class will not compile A class \ninherits all abstract and default methods from the interfaces it implements Therefore the Fish  class inherits \nthe abstract swim  method from the Swimmable  interface A class must be declared abstract if it contains \ninherited or declared abstract methods You have not declared the Fish  class abstract This is the reason \nthe previous declaration will not compile In the following code the Fish  class overrides the swim  method \nto provide an implementation\npublic class Fish implements Swimmable \n      Override and implement the swim method\n    Override\n    public void swim \n         Code for swim method goes here\n    \n     More code for the Fish class goes here\n\nThe class that implements an interface must override to implement all abstract methods declared in \nthe interface Otherwise the class must be declared abstract Note that default methods of an interface are \nalso inherited by the implementing classes The implementing classes may choose but are not required \nto override the default methods The static methods in an interface are not inherited by the implementing \nclasses\nA class implementing interfaces can have other methods that are not inherited from the implemented \ninterfaces Other methods can have the same name and different number andor types of parameters than \nthe one declared in the implemented interfaces\nIn this case the only requirement for the Fish  class is that it must have a swim  method which \naccepts no parameters and returns void  as declared in the Swimmable  interface The following code defines \ntwo swim  methods in the Fish  class The first one with no parameters implements the swim  method \nof the Swimmable  interface The second one swimdouble distanceInYards  has nothing to do with the \nSwimmable  interface implementation by the Fish  classChapter 21  Interfa Ces\n825public class Fish implements Swimmable \n     Override the swim method in the Swimmable interface\n    Override\n    public void swim \n         More code goes here\n    \n     A valid method for the Fish class This method declaration has nothing to do\n     with the Swimmable interfaces swim method\n    public void swimdouble distanceInYards \n         More code goes here\n    \n\nListing 2122  shows the complete code for the Fish  class A Fish  object will have a name which is \nsupplied in its constructor It implements the swim  method of the Swimmable interface to print a message \non the standard output\nListing 2122  Code for the Fish Class That Implements the Swimmable Interface\n Fishjava\npackage comjdojointerfaces\npublic class Fish implements Swimmable \n    private String name\n    public FishString name \n        thisname  name\n    \n    Override\n    public void swim \n        Systemoutprintlnname   a fish is swimming\n    \n\nHow do you create an object of a class that implements an interface You create an object of a class the \nsame way by using the new operator with its constructor whether it implements an interface or not You can \ncreate an object of the Fish  class as follows\n Create an object of the Fish class\nFish fifi  new FishFifi\nWhen you execute the statement new FishFifi  it creates an object in memory and that objects \ntype is Fish  the type defined by its class When a class implements an interface its object has one more \ntype which is the type defined by the implemented interface In your case the object created by executing \nhas two types Fish  and Swimmable  In fact it has a third type too which is the Object  type by virtue of the \nFish  class inheriting the Object  class which happened by default Since an object of the Fish  class has two \ntypes Fish  and Swimmable  you can assign the reference of a Fish  object to a variable of the Fish  type as well \nas to a variable of the Swimmable  type The following code summarizes this\nFish guppi  new FishGuppi\nSwimmable hilda  new FishHildaChapter 21  Interfa Ces\n826The variable guppi  is of the Fish  type It is referring to the Guppi  fish object There is no surprise in the \nfirst assignment a Fish  object being assigned to a variable of the Fish  type The second assignment is also \nvalid because the Fish  class implements the Swimmable  interface and every object of the Fish  class is also \nof the Swimmable  type At this point hilda  is a variable of the Swimmable  type It is referring to the Hilda fish \nobject The following assignment is always valid\n A Fish is always Swimmable\nhilda  guppi\nHowever the other way is not valid Assigning a variable of the Swimmable  type to a variable of the Fish  \ntype generates a compiletime error\n A Swimmable is not always a Fish\nguppi  hilda  A compiletime error\nWhy does the previous assignment generate a compiletime error The reason is very simple An \nobject of the Fish  class is always Swimmable  because the Fish  class implements the Swimmable  interface \nSince a variable of the Fish  type can only refer to a Fish  object which is always Swimmable  the assignment \nhilda  guppi  is always valid However a variable of the Swimmable  type can refer to any object whose class \nimplements the Swimmable  interface not necessarily only to a Fish  object For example consider a class \nTurtle  which implements the Swimmable  interface\npublic class Turtle implements Swimmable \n    Override\n    public void swim \n        SystemoutprintlnA turtle can swim too\n    \n\nYou can assign an object of the Turtle  class to the hilda  variable\nhilda  new Turtle  OK  A Turtle is always Swimmable\nIf the assignment guppi  hilda  is allowed at this point a Fish  variable guppi  will be referring to a \nTurtle  object This would be a disaster The Java runtime would throw an exception even if the compiler \nhad allowed this assignment This kind of assignment is not allowed for the following reason\nA Fish is always Swimmable However not every Swimmable is a Fish\nSuppose you know programmatically for sure that a variable of the Swimmable  type contains reference \nto a Fish  object If you want to assign the Swimmable type variable to a variable of the Fish  type you can do \nso by using a typecast as shown\n The compiler will pass it The runtime may throw a ClassCastException\nguppi  Fishhilda\nThe compiler will not complain about this statement It assumes that you have made sure that the hilda  \nvariable is referring to a Fish  object and the cast Fish hilda  will succeed at runtime If by any chance \nthe hilda  variable is not referring to a Fish  object the Java runtime will throw a ClassCastException  For \nexample the following snippet of code will pass the compiler check but will throw a ClassCastException Chapter 21  Interfa Ces\n827Fish fred  new FishFred\nSwimmable turti  new Turtle\n OK for the compiler but not OK for the runtime turti is a Turtle not a Fish at\n runtime fred can refer to only a Fish not a Turtle\nfred  Fish turti\nListing 2123  shows the short but complete code that lets you test the Fish  class and the Swimmable  \ninterface\nListing 2123  Demons trating That a Variable of an Interface Can Store the Reference of the Object of the \nClass Implementing the Interface\n FishTestjava\npackage comjdojointerfaces\npublic class FishTest \n    public static void mainString args \n        Swimmable finny  new FishFinny\n        finnyswim\n    \n\nFinny a fish is swimming\n Implementing Interface Methods\nWhen a class fully implements an interface it provides an implementation for all abstract methods of the \ninterface by overriding those methods A method declaration in an interface includes constraints or rules \nfor the method For example a method may declare a throws  clause in its declaration The throws  clause \nin the method declaration is a constraint for the method If the throws  clause declares some checked \nexceptions the caller of that method must be ready to handle them Methods in an interface are implicitly \npublic This defines another constraint on the methods which states that all methods of an interface are \naccessible publicly with an assumption that the interface itself is accessible publicly Consider a Banker  \ninterface defined as follows\npublic interface Banker \n    double withdrawdouble amount throws InsufficientFundsException\n    void depositdouble amount throws FundLimitExceededException\n\nThe Banker  interface declares two methods called withdraw  and deposit  Consider the following \nimplementation of the Banker  interface in the MinimumBalanceBank  class The overridden methods in this \nclass have the same constraints as defined in the Banker  interface Both methods are declared public  and \nboth of them throw the same exception as declared in their declarations in the Banker  interface\npublic class MinimumBalanceBank implements Banker \n    public double withdrawdouble amount throws InsufficientFundsException \n         Code for this method goes here\n    Chapter 21  Interfa Ces\n828    public void depositdouble amount throws FundLimitExceededException \n         Code for this method goes here\n    \n\nConsider the following implementation of the Banker  interface in the NoLimitBank  class The \nNoLimitBank  has rules that a customer can have unlimited overdraft wish it happened in reality and there \nis no upper limit on the balance NoLimitBank  dropped the throws  clause when it overrode the withdraw  \nand deposit  methods of the Banker  interface\npublic class NoLimitBank implements Banker \n    public double withdrawdouble amount \n         Code for this method goes here\n    \n    public void depositdouble amount \n         Code for this method goes here\n    \n\nThe code for NoLimitBank  is valid even though its two methods that overrode the Banker  interface \nmethods dropped the throws  clause Dropping constraints exceptions in this case is allowed when a class \noverrides an interface method An exception in the throws  clause imposes a restriction that the caller must \nhandle the exception If you use the Banker  type to write the code here is how you will call the withdraw  \nmethod\nBanker b  get a Banker type object\ntry \n    double amount  bwithdraw100090\n     More code goes here\n catch InsufficientFundsException e \n     Handle the exception here\n\nAt compile time when the bwithdraw  method is called the compiler forces you to handle the \nexception thrown from the withdraw  method because it knows the type of the variable b is Banker  and \nthe Banker  types withdraw  method throws an InsufficientFundsException  If you assign an object \nof NoLimitBank  to the variable b in the previous code no exception will be thrown from the withdraw  \nmethod of the NoLimitBank  class when bwithdraw  is called even though the call to the withdraw  \nmethod is inside a trycatch  block The compiler cannot check the runtime type of variable b Its safety \ncheck is based on the compiletime type of the variable b It would never be a problem if the runtime \nthrows a fewer number of exceptions or no exceptions than expected in the code Consider the following \nimplementation of the Banker  interface by the UnstablePredictableBank  class\n The following code will not compile\npublic class UnstablePredictableBank implements Banker \n    public\ndouble withdrawdouble amount throws InsufficientFundsException ArbitraryException \n         Code for this method goes here\n    Chapter 21  Interfa Ces\n829    public void depositdouble amount throws FundLimitExceededException \n         Code for this method goes here\n    \n\nThis time the withdraw  method adds a new exception ArbitraryException  which adds a new \nconstraint to the overridden method Adding constraints to an overridden method is never allowed \nConsider the following snippet of code\nBanker b  new UnstablePredictableBank\ntry \n    double amount  bwithdraw100090\n     More code goes here\n catch InsufficientFundsException e \n     Handle exception here\n\nThe compiler does not know that at runtime the variable b which is of type Banker  will refer to an \nobject of the UnstablePredictableBank  type Therefore the compiler will force you to handle only the \nInsufficientFundsException  when you call bwithdraw  What happens when ArbitraryException  \nis thrown from the withdraw  method at runtime Your code is not ready to handle it This is the reason \nthat you cannot add new exceptions to a method declaration in a class which overrides a method in its \nimplemented interface\nIf a class overrides a method of the implemented interface that method must be declared public Recall \nthat all methods in an interface are implicitly public and public is the least restricting scope modifier for a \nmethod Declaring a method in the class that overrides an interface method as private protected or package \nlevel is like restricting the scope of the overridden method like placing more constraints The following \nsnippet of code will not compile because the withdraw  and deposit  methods are not declared public\n Code would not compile\npublic class UnstablePredictableBank implements Banker\n     withdraw method must be public\n    private double withdrawdouble amount throws InsufficientFundsException \n         Code for this method goes here\n    \n     deposit method must be public\n    protected  void depositdouble amount throws FundLimitExceededException \n         Code for this method goes here\n    \n\nUse a general rule of thumb to check if adding or dropping a constraint is allowed in a class method \nwhich overrides an interfaces method Write code using an interfacetype variable that is assigned to an \nobject of the class that implements the interface If the code makes sense to you of course it has to make \nsense to the compiler too it is allowed Otherwise it is not allowed Suppose J is an interface which \ndeclares a method m1  Suppose the class C implements the interface J and it modifies the declaration of \nthe method m1  If the following code makes sense and compiles the modification in the m1  declaration \ninside the class C is fine\nJ obj  new C  Or any object of any subclass of C\nobjm1Chapter 21  Interfa Ces\n830Another rule of thumb is to see if the overriding method in the class is relaxing the restrictions declared \nin the interface for the same method If an overriding method relaxes the constraints of the overridden \nmethod it is fine Otherwise the compiler will generate an error\n Implementing Multiple Interfaces\nA class can implement multiple interfaces All interfaces that a class implements are listed after the keyword \nimplements  in the class declaration Interface names are separated by a comma By implementing multiple \ninterfaces the class agrees to provide the implementation for all abstract methods in all interfaces Suppose \nthere are two interfaces called Adder  and Subtractor  declared as follows\npublic interface Adder \n    int addint n1 int n2\n\npublic interface Subtractor \n    int subtractint n1 int n2\n\nIf an ArithOps  class implements the two interfaces its declaration would look as shown\npublic class ArithOps implements Adder Subtractor \n     Override the add method of the Adder interface\n    Override\n    public int addint n1 n2 \n        return n1  n2\n    \n     Override the subtract method of the Subtractor interface\n    Override\n    public int subtractint n1 int n2 \n        return n1   n2\n    \n     Other code for the class goes here\n\nThere is no limit on the maximum number of interfaces implemented by a class When a class \nimplements an interface its objects get an additional type If a class implements multiple interfaces \nits objects get as many new types as the number of implemented interfaces Consider the object of the \nArithOps  class which can be created by executing new ArithOps  The object of the ArithOps  class gets \ntwo additional types which are Adder  and Subtractor  The following snippet of code shows the result of \nthe object of the ArithOps  class getting two new types You can treat an object of ArithOps  as ArithOps  type \nAdder  type or Subtractor  type Of course every object in Java can always be treated as an Object  type\nArithOps a  new ArithOps\nAdder b  new ArithOps\nSubtractor c  new ArithOps\nb  a\nc  a\nLets look at a more concrete and complete example You already have two interfaces Walkable  and \nSwimmable  If a class implements the Walkable  interface it must provide the implementation for the walk  \nmethod If you want an object of a class to be treated as the Walkable  type the class would implement Chapter 21  Interfa Ces\n831the Walkable  interface The same argument goes for the Swimmable  interface If a class implements both \ninterfaces Walkable  and Swimmable  its objects can be treated as a Walkable  type as well as a Swimmable  \ntype The only thing that the class must do is to provide implementation for both the walk  and swim  \nmethods Lets create a Turtle  class which implements both of these interfaces A Turtle  object will have \nthe ability to walk as well as swim\nListing 2124  contains the code for the Turtle  class A turtle can bite too You have added this behavior \nto the Turtle  objects by adding a bite  method to the Turtle  class Note that adding the bite  method \nto the Turtle  class has nothing to do with implementations of the two interfaces A class which implements \ninterfaces can have any number of additional methods of its own\nListing 2124  A Tur tle Class Which Implements the Walkable and Swimmable Interfaces\n Turtlejava\npackage comjdojointerfaces\npublic class Turtle implements Walkable Swimmable \n    private String name\n    public TurtleString name \n        thisname  name\n    \n     Adding a bite method to the Turtle class\n    public void bite \n        Systemoutprintlnname   a turtle is biting\n    \n     Implementation for the walk method of the Walkable interface\n    Override\n    public void walk \n        Systemoutprintlnname   a turtle is walking\n    \n     Implementation for the swim method of the Swimmable interface\n    Override\n    public void swim \n        Systemoutprintlnname   a turtle is swimming\n    \n\nListing 2125  shows using a Turtle  object as a Turtle  type Walkable  type and Swimmable  type\nListing 2125  Using the Turtle Class\n TurtleTestjava\npackage comjdojointerfaces\npublic class TurtleTest \n    public static void mainString args \n        Turtle turti  new TurtleTurti\n         Using Turtle type as Turtle Walkable and Swimmable\n        letItBiteturti\n        letItWalkturti\n        letItSwimturti\n    \n    public static void letItBiteTurtle t \n        tbite\n    Chapter 21  Interfa Ces\n832    public static void letItWalkWalkable w \n        wwalk\n    \n    public static void letItSwimSwimmable s \n        sswim\n    \n\nTurti a turtle is biting\nTurti a turtle is walking\nTurti a turtle is swimming\nNote that a Turtle type variable can access all three methods bite  walk  and swim like so\nTurtle t  new TurtleTurti\ntbite\ntwalk\ntswim\nWhen you use a Turtle  object as the Walkable  type you can access only the walk  method When you \nuse a Turtle  object as the Swimmable  type you can access only the swim  method The following snippet of \ncode demonstrates this rule\nTurtle t  new TurtleTrach\nWalkable w  t\nwwalk  OK  Using w you can access only the walk method of Turtle object\nSwimmable s  t\nsswim  OK  Using s you can access only the swim method\n Implementing an\u00a0Interface Partially\nA class agrees to provide an implementation for all abstract methods of the interfaces it implements \nHowever a class does not have to provide implementations for all methods In other words a class can \nprovide partial implementations of the implemented interfaces Recall that an interface is implicitly \nabstract  means incomplete If a class does not provide a full implementation of interfaces it must be \ndeclared abstract means incomplete Otherwise the compiler will refuse to compile the class Consider an \ninterface named IABC  that has three methods m1  m2  and m3 \npackage comjdojointerfaces\npublic interface IABC \n    void m1\n    void m2\n    void m3\n\nSuppose a class named ABCImpl  implements the IABC  interface and it does not provide \nimplementations for all three methodsChapter 21  Interfa Ces\n833package comjdojointerfaces\n A compiletime error\npublic class ABCImpl implements IABC \n     Provides implementation for only one method of the IABC interface\n    Override\n    public void m1 \n         Code for the method goes here\n    \n\nThe previous code for the ABCImpl  class would not compile It agrees to provide implementations for all \nthree methods of the IABC  interface However the body of the class does not keep the promise It provides \nan implementation for only one method m1  Because the class ABCImpl  did not provide implementations \nfor the other two methods of the IABC  interface the ABCImpl  class is incomplete which must be declared \nabstract to indicate its incompleteness If you attempt to compile the ABCImpl  class the compiler will \ngenerate the following errors\nError314 class comjdojointerfacesABCImpl should be declared abstract it does not \ndefine method m2 of interface comjdojointerfacesIABC\nError314 class comjdojointerfacesABCImpl should be declared abstract it does not \ndefine method m3 of interface comjdojointerfacesIABC\nThe compiler error is loud and clear It states that the ABCImpl  class must be declared abstract because it \ndid not implement the m2  and m3  methods of the IABC  interface The following snippet of code fixes the \ncompiler error by declaring the class abstract\npackage comjdojointerfaces\npublic abstract class ABCImpl implements IABC \n    Override\n    public void m1 \n         Code for the method goes here\n    \n\nThe implication of declaring a class as abstract is that it cannot be instantiated The following code will \ngenerate a compiletime error\nnew ABCImpl  A compiletime error ABCImpl is abstract\nThe only way to use the ABCImpl  class is to inherit another class from it and provide the missing \nimplementations for the m2  and m3  methods of the IABC  interface The following is the declaration for a \nnew class DEFImpl  which inherits from the ABCImpl  class\npackage comjdojointerfaces\npublic class DEFImpl extends ABCImpl \n     Other code goes here\n    Override\n    public void m2 \n         Code for the method goes here\n    Chapter 21  Interfa Ces\n834    Override\n    public void m3 \n         Code for the method goes here\n    \n\nThe DEFImpl  class provides implementations for the m2  and m3  methods of the ABCImpl  class Note \nthat the DEFImpl  class inherits the m1  m2  and m3  methods from its superclass ABCImpl  The compiler \ndoes not force you to declare the DEFImpl  class as an abstract class anymore You can still declare the \nDEFImpl  class abstract if you want to\nYou can create an object of the DEFImpl  class because it is not abstract What are the types of an object \nof the DEFImpl  class It has four types DEFImpl  ABCImpl  Object  and IABC  An object of the DEFImpl  class is \nalso of the ABCImpl  type because DEFImpl  inherits from ABCImpl  An object of the ABCImpl  class is also of type \nIABC  because ABCImpl  implements IABC  interface Since a DEFImpl  is an ABCImpl  and an ABCImpl  is an IABC  \nit is logical that a DEFImpl  is also an IABC  This rule has been demonstrated by the following snippet of code \nAn object of the DEFImpl  class has been assigned to variables of DEFImpl  Object  ABCImpl  and IABC  types\nDEFImpl d  new DEFImpl\nObject obj  d\nABCImpl a  d\nIABC ia  d\n The SupertypeSubtype Relationship\nImplementing an interface to a class establishes a supertypesubtype relationship The class becomes a \nsubtype of all the interfaces it implements and all interfaces become a supertype of the class The rule of \nsubstitution applies in this supertypesubtype relationship The rule of substitution is that a subtype can \nreplace its supertype everywhere Consider the following class declaration for a class C which implements \nthree interfaces J K and L\npublic class C implements J K L \n     Code for class C goes here\n\nThe previous code establishes supertypesubtype relationship between the three interfaces J K and \nL and the class C Recall that an interface declaration defines a new type Suppose that you have already \ndeclared three interfaces J K and L The three interface declarations define three types type J type K \nand type L The declaration of the class C defines a fourth type type C What is the relationship between \nthe four types J K L and C Class C is a subtype of types J K and L type J is a supertype of type C type \nK is a supertype of type C and type L is a supertype of type C The implication of this supertypesubtype \nrelationship is that wherever a value of type J K or L is required you can safely substitute a value of type C \nThe following snippet code demonstrates this rule\nC cObject  new C\n cObject is of type C  It can always be used where J K or L type is expected\nJ jobject  cObject  OK\nK kobject  cObject  OK\nL lobject  cObject  OKChapter 21  Interfa Ces\n835 Interface Inheritance\nAn interface can inherit from another interface Unlike a class an interface can inherit from multiple \ninterfaces Consider the Singer  Writer  and Player  interfaces shown in Listings 2126  through 2128 \nListing 2126  A Sin ger Interface\n Singerjava\npackage comjdojointerfaces\npublic interface Singer \n    void sing\n    void setRatedouble rate\n    double getRate\n\nListing 2127  A Writ er Interface\n Writerjava\npackage comjdojointerfaces\npublic interface Writer \n    void write\n    void setRatedouble rate\n    double getRate\n\nListing 2128  A Pl ayer Interface\n Playerjava\npackage comjdojointerfaces\npublic interface Player \n    void play\n    void setRatedouble rate\n    default double getRate \n        return 3000\n    \n\nAll thr ee types of professionals singers writers and players perform their jobs and they are paid The \nthree interfaces contain two types of methods One type of method signifies the job they do for example \nsing  write  and play  Another type of method signifies their minimum hourly rates The Singer  and \nWriter  interfaces have declared the setRate  and getRate  methods abstract letting the implementing \nclasses specify their implementation The Player  interface declares the setRate  method abstract and \nprovides a default implementation for the getRate  method\nLike a class inheriting from another class an interface uses the keyword extends  to inherit from other \ninterfaces The keyword extends  is followed by a commaseparated list of inherited interface names \nThe inherited interfaces are known as superinterfaces and the interface inheriting them is known as \nsubinterface An interface inherits the following members of its superinterfaces\n\t Abstract and default methods\n\t Constant fields\n\t Nested typesChapter 21  Interfa Ces\n836 Tip an interface does not inherit sta tic or private methods from its superinterfaces\nAn interface may override the inherited abstract and default methods that it inherits from its \nsuperinterfaces If the interface contains constant fields and nested types with the same names as the \ninherited constant fields and nested types from the superinterfaces the constant fields and nested types in \nthe interface are said to hide the respective names of their inherited counterparts\nSuppose you want to create an interface to represent charity singers who do not charge for singing \nA charity singer is also a singer You will create an interface named CharitySinger  that inherits from the \nSinger  interface as shown\npublic interface CharitySinger extends Singer \n\nAt this point the CharitySinger  interface inherits the three abstract methods from the Singer  interface \nAny class implementing the CharitySinger  interface will need to implement those three methods Because \ncharity singers do not charge for singing the CharitySinger  interface may override the setRate  and \ngetRate  methods and provide a default implementation using the default methods shown in Listing 2129 \nListing 2129  A Ch aritySinger Interface\n CharitySingerjava\npackage comjdojointerfaces\npublic interface CharitySinger extends Singer \n    Override\n    default void setRatedouble rate \n         A noop method\n    \n    Override\n    default double getRate \n        return 00\n    \n\nThe setRate  method is a noop The getRate  method returns zero The class that implements the \nCharitySinger  interface will need to implement the sing  method and provide an implementation for it \nThe class will inherit the default methods setRate  and getRate \nIt is possible that the same person is a singer as well as a writer You can create an interface named \nSingerWriter  which inherits from the two interfaces Singer  and Writer  as shown in Listing 2130 \nListing 2130  A Sin gerWriter Interface That Inherits from Singer and Writer Interfaces\n SingerWriterjava\npackage comjdojointerfaces\npublic interface SingerWriter extends Singer Writer \n     No code\n\nHow many methods does the SingerWriter  interface have It inherits three abstract methods from \nthe Singer  interface and three abstract methods from the Writer  interface It inherits methods setRate  \nand getRate  twiceonce from the Singer  interface and once from the Writer  interface These methods Chapter 21  Interfa Ces\n837have the same declarations in both superinterfaces and they are abstract This does not cause a problem \nas both methods are abstract The class that implements the SingerWriter  interface will need to provide \nimplementation for both methods only once\nListing 2131  shows the code for a Melodist  class that implements the SingerWriter  interface Note \nthat it overrides the setRate  and getRate  methods only once\nListing 2131  A Melo dist Class That Implements the SingerWriter Interface\n Melodistjava\npackage comjdojointerfaces\npublic class Melodist implements SingerWriter \n    private String name\n    private double rate  50000\n    public MelodistString name \n        thisname  name\n    \n    Override\n    public void sing \n        Systemoutprintlnname   is singing\n    \n    Override\n    public void setRatedouble rate \n        thisrate  rate\n    \n    Override\n    public double getRate \n        return rate\n    \n    Override\n    public void write \n        Systemoutprintlnname   is writing\n    \n\nThe following snippet of code shows how to use the Melodist  class\nSingerWriter purcell  new MelodistHenry Purcell\npurcellsetRate70000\npurcellwrite\npurcellsing\nHenry Purcell is writing\nHenry Purcell is singing\nA person may sing as well as play games Lets create a SingerPlayer  interface to represent this kind of \nperson Lets inherit the interface from the Singer  and Player  interfaces as shown\npublic interface SingerPlayer extends Singer Player \n     No code for now\nChapter 21  Interfa Ces\n838Trying to compile the SingerPlayer  interface results in the following error\nSingerPlayerjava4 error interface SingerPlayer inherits abstract and default for \ngetRate from types Player and Singer\nThe error resulted from the conflict in the two inherited versions of the getRate  method The Singer  \ninterface declares the getRate  method abstract and the Player  interface declares it default This causes a \nconflict The compiler cannot decide which method to inherit This kind of conflict may arise when multiple \nversions of the same default method are inherited from different superinterfaces Consider the following \ndeclaration of the CharitySingerPlayer  interface\npublic interface CharitySingerPlayer extends CharitySinger Player \n\nTrying to compile the CharitySingerPlayer  interface results in the following error\nCharitySingerPlayerjava4 error interface CharitySingerPlayer inherits unrelated defaults for\ngetRate from types CharitySinger and Player\nCharitySingerPlayerjava4 error interface CharitySingerPlayer inherits abstract and \ndefault for setRatedouble from types CharitySinger and Player\nThis time the error is because of two reasons\n\t The interface inherits two default getRate  methods one from the CharitySinger  \ninterface and one from the Player  interface\n\t The interface inherits a default setRate  method from the CharitySinger  interface \nand an abstract setRate  method from the Player  interface\nThis type of conflict was not possible before Java 8 as the default methods were not available The \ncompiler does not know which method to inherit when it encounters a combination of abstractdefault or \ndefaultdefault method To resolve such conflicts the interface needs to override the method in the interface \nThere are several ways to resolve the conflictall involve overriding the conflicting method in the interface\n\t You can override the conflicting method with an abstract method\n\t You can override the conflicting method with a default method and provide a new \nimplementation\n\t You can override the conflicting method with a default method and call one of the \nmethods of the superinterfaces\nLets resolve the conflict in the SingerPlayer  interface Listing 2132  contains a declaration for the \ninterface that overrides the getRate  method with an abstract getRate  method Any class implementing \nthe SingerPlayer  interface will have to provide an implementation for the getRate  method\nListing 2132   Overriding the Conflicting Method with an Abstract Method\n SingerPlayerjava\npackage comjdojointerfaces\npublic interface SingerPlayer extends Singer Player \n     Override the getRate method with an abstract method\n    Override\n    double getRate\nChapter 21  Interfa Ces\n839The declaration in Listing 2133  for the SingerPlayer  interface resolves the conflict by overriding \nthe getRate  method with a default getRate  method which simply returns a value 70000 Any class \nimplementing this SingerPlayer  interface will inherit the default implementation of the getRate  method\nListing 2133  Overriding the Conflicting Method with a Default Method\n SingerPlayerjava\npackage comjdojointerfaces\npublic interface SingerPlayer extends Singer Player \n     Override the getRate method with a default method\n    Override\n    default double getRate \n         return 70000\n    \n\nSometimes an interface may want to access the overridden default methods of its superinterfaces \nJava 8 introduced a new syntax for calling the overridden default methods of direct superinterfaces from an \ninterface The new syntax uses the keyword super  as shown\nsuperinterfacenamesupersuperinterfacedefaultmethodarg1 arg2\n Tip Using the keyword super  only the default methods of the direct superinterfaces can be accessed \naccessing default methods of the superinterfaces of superinterfaces are not supported by the syntax  You \ncannot access the abstract methods of the superinterfaces using this syntax\nListing 2134  contains the declaration for the SingerPlayer  interface that resolves the conflict by \noverriding the getRate  method with a default getRate  method The method calls the getRate  \nmethod of the Player  interface using the PlayersupergetRate  call multiplies the value by 35 and \nreturns it It simply implements a rule that a SingerPlayer  is paid minimum 35 times what a Player  is paid \nAny class implementing the SingerPlayer  interface will inherit the default implementation of the getRate  \nmethod\nListing 2134  Overriding the Conflicting Method with a Default Method That Calls the Method in the \nSuperinterface\n SingerPlayerjava\npackage comjdojointerfaces\npublic interface SingerPlayer extends Singer Player\n     Override the getRate method with a default method that calls the\n     Player superinterface getRate method\n    Override\n    default double getRate \n        double playerRate  PlayersupergetRate\n        double singerPlayerRate  playerRate  35\n        return singerPlayerRate\n    \nChapter 21  Interfa Ces\n840Listing 2135  contains the code for the CharitySingerPlayer  interface It overrides the setRate  \nmethod with an abstract method and the getRate  method with a default method The getRate  method \ncalls the default getRate  method of the Player  interface\nListing 2135  Overriding the Conflicting Methods in the CharitySinger Interface\n CharitySingerPlayerjava\npackage comjdojointerfaces\npublic interface CharitySingerPlayer extends CharitySinger Player \n     Override the setRate method with an abstract method\n    Override\n    void setRatedouble rate\n     Override the getRate method with a default method that calls the\n     Player superinterface getRate method\n    Override\n    default double getRate \n        return PlayersupergetRate\n    \n\n The SuperinterfaceSubinterface Relationship\nInterface inheritance establishes a superinterfacesubinterface  also called supertypesubtype  relationship \nWhen the interface CharitySinger  inherits from the Singer  interface the Singer  interface is known \nas the superinterface of the CharitySinger  interface and the CharitySinger  interface is known as the \nsubinterface of the Singer  interface An interface can have multiple superinterfaces and an interface can \nbe a subinterface for multiple interfaces A reference of a subinterface can be assigned to a variable of the \nsuperinterface Consider the following snippet of code to demonstrate the use of superinterfacesubinterface \nrelationship Comments in the code explain why an assignment will succeed or fail\npublic interface Shape \n     Code goes here\n\npublic interface Line extends Shape \n     Code goes here\n\npublic interface Circle extends Shape \n     Code goes here\n\nThe following is sample code that you can write using these interfaces with comments explaining what \nthe code is supposed to do\nShape shape  get an object reference of a Shape\nLine line  get an object reference of a Line\nCircle circle  get an object reference of a Circle\n More code goes here \nshape  line     Always fine A Line is always a Shape\nshape  circle  Always fine A Circle is always a ShapeChapter 21  Interfa Ces\n841 A compiletime error A Shape is not always a Line A Shape may be a Circle\n Must use a cast to compile\nline  shape\n OK with the compiler The shape variable must refer to a Line at runtime\n Otherwise the runtime will throw a ClassCastException\nline Line shape\n Inheriting Conflicting Implementations\nBefore Java 8 it was not possible for a class to inherit multiple implementations nonabstract methods \nfrom multiple supertypes Introduction of default methods made it possible for a class to inherit conflicting \nimplementations from its superclass and superinterfaces When a class inherits a method with the same \nsignature from multiple paths superclass and superinterfaces Java uses the three simple rules in order to \nresolve the conflict\n\t The superclass always wins  If a class inherits a method abstract or concrete from \nits superclass and a method with the same signature from one of its superinterfaces \nthe superclass wins That is the class inherits the method of the superclass and the \nmethods in the superinterfaces are ignored This rule treats a default method in an \ninterface as a fallback if the same method is not available in the class through the \nclass hierarchy\n\t The most specific superinterface wins  This rule is used if the first rule did not resolve \nthe conflict If the inherited default method comes from multiple superinterfaces \nthe method from the most specific superinterface is inherited by the class\n\t The class must override the conflicting method  This rule is used if the previous \ntwo rules did not resolve the conflict In this case the developer must override the \nconflicting method in the class\nLets discuss different scenarios where these three rules will apply\n The Superclass Always Wins\nThis rule is simple to apply If a class inherits or declares a method the methods with the same signature in \nthe superinterfaces will be ignored\n Example 1\nConsider the following two classes Employee  and Manager \npublic abstract class Employee \n    private double rate\n    public abstract void setRatedouble rate\n    public double getRate \n        return rate\n    \n\npublic abstract class Manager extends Employee implements CharitySinger \n     Code goes here\nChapter 21  Interfa Ces\n842The Manager  class inherits from the Employee  class The following five methods are available to the \nManager  class for inheritance\n\t The abstract CharitySingersing  method\n\t The default CharitySingersetRate  method\n\t The default CharitySingergetRate  method\n\t The abstract EmployeesetRate  method\n\t The concrete EmployeegetRate  method\nThere is no conflict for the sing  method Therefore the Manager  class inherits the sing  method \nfrom the CharitySinger  interface There are two choices for the setRate  and getRate  methods \nThe two methods are available in the superclass Therefore the Manager  class inherits the setRate  and \ngetRate  methods from the Employee  class\n Example 2\nThe superclass always wins rule implies that the methods declared in the Object  class cannot be \noverridden with a default method in an interface The following declaration for the Runner  interface will not \ncompile\n Wont compile\npublic interface Runner \n    void run\n     Not allowed\n    Override\n    default String toString \n        return WhoCares\n    \n\nBefore I give the reasons behind this rule lets assume that the Runner  interface compiles Suppose a \nThinker  class implements the Runner  interface as shown\npublic class Thinker implements Runner \n    Override\n    public void run \n        Systemoutprintln\n    \n     Which method is inherited   ObjecttoString or RunnertoString\n\nThe Thinker  class has two choices for inheriting the toString  method one from the superclass \nObject  and one from the superinterface Runner  Remember that the superclass always wins and therefore \nthe Thinker  class inherits the toString  method from the Object  class not the Runner  interface This \nargument is true for all methods in the Object  class and all classes Because such default methods in an \ninterface will never be used by any class it is not allowed for interfaces to override the methods of the Object  \nclass with a default methodChapter 21  Interfa Ces\n843 Example 3\nDefault methods in interfaces cannot be declared final for two reasons\n\t Default methods are intended to be overridden in classes\n\t If a default method is added in an existing interface all implementing classes should \ncontinue to work if they contain a method with the same signature\nConsider a Sizeable  interface and a Bag class that implement the interface\npublic interface Sizeable \n    int size\n\npublic class Bag implements Sizeable \n    private int size\n    Override\n    public int size \n        return size\n    \n    public boolean isEmpty \n        return size  0\n    \n     More code goes here\n\nThe Bag class overrides the size  method of the Sizeable  interface The class contains an additional \nconcrete method called isEmpty  There is no problem at this point Now the designer of the Sizeable  \ninterface decides to add a default isEmpty  method to the interface that will look as follows\npublic interface Sizeable \n    int size\n     A new default method Cannot declare it final\n    default boolean isEmpty \n        return size  0\n    \n\nAfter the new default isEmpty  method is added to the Sizeable  interface the Bag class will continue \nto work The class simply overrides the default isEmpty  method of the Sizeable  interface If it were \nallowed to declare the default isEmpty  method final it would have resulted in an error as a final method is \nnot allowed to be overridden The rule not to allow a final default method ensures backward compatibility \nThe existing class will continue to work if the class contains a method and a default method with the same \nsignature is added in the interfaces the class implementsChapter 21  Interfa Ces\n844 The Most Specific Superinterface Wins\nThis rule tries to resolve the inheritance of a conflicting method with the same signature from multiple \ninterfaces If the same method abstract or default is inherited from multiple superinterfaces through \ndifferent paths the most specific path is used Suppose I1 is an interface with a method m I2 is a \nsubinterface of I1 and I2 overrides the method m If a class Test  implements both interfaces I1 and I2  \nit has two choices of inheriting the m method I1m  and I2m  In this case I2m  is considered most \nspecific as it overrides I1m  The rules can be summarized as follows\n\t Make a list of all choices of the method with the same signature that are available \nfrom different superinterfaces\n\t Remove all methods from the list that have been overridden by others in the list\n\t If you are left with only one choice that is the method the class will inherit\nConsider the following Employee  class It implements the Singer  and SingerPlayer  interfaces\npublic class Employee implements Singer SingerPlayer \n     Code goes here\n\nThere are no conflicts in inheriting the play  method which is inherited from the Player  interface \nThere is no conflict in inheriting the sing  method as both superinterfaces lead to the same sing  \nmethod that is in the Singer  interface Which setRate  method is inherited by the Employee  class You \nhave the following choices\n\tSingersetRate\n\tSingerPlayersetRate\nBoth choices lead to an abstract setRate  method Therefore there is no conflict However the \nSingerPlayersetRate  method is most specific in this case as it overrides the SingersetRate  \nmethod\nWhich getRate  method is inherited by the Employee  class You have the following choices\n\tSingergetRate\n\tSingerPlayergetRate\nThe SingergetRate  method has been overridden by the SingerPlayergetRate  method \nTherefore SingergetRate  is removed as a choice which leaves you only one choice SingerPlayer\ngetRate  Therefore the Employee  class inherits the default getRate  method from the SingerPlayer  \ninterface\n The Class Must Override the\u00a0Conflicting Method\nIf the previous two rules were not able to resolve the conflicting methods inheritance the class must \noverride the method and choose what it wants to do inside the method It may implement the method in \na completely new way or it may choose to call one of the methods in the superinterfaces You can call the \ndefault method of one of the superinterfaces of a class using the following syntax\nsuperinterfacenamesupersuperinterfacedefaultmethodarg1 arg2Chapter 21  Interfa Ces\n845If you want to call one of the methods in the superclass of a class you can use the following syntax\nclassnamesupersuperclassmethodarg1 arg2\nConsider the following declaration for a MultiTalented  class which inherits from the Singer  and \nPlayer  interfaces\n Wont compile\npublic abstract class MultiTalented implements Singer Player \n\nThis class declaration will not compile The class inherits the sing  play  and setRate  methods \nwithout any conflicts There are two choices to inherit the getRate  method\n\t The abstract SingergetRate  method\n\t The default PlayergetRate  method\nNone of the two versions of the getRate  method is more specific than the other In this case the \nMultiTalented  class must override the getRate  method to resolve the conflict The following code for the \nMultiTalented  class will compile\npublic abstract class MultiTalented implements Singer Player \n     A MultiTalented is paid the rate of a Player plus 20000\n    Override\n    public double getRate \n         Get the default rate for a Player from the Player interface\n        double playerRate  PlayersupergetRate\n        double rate  playerRate  20000\n        return rate\n    \n\nThe class overrides the getRate  method to resolve the conflict The method calls the default \ngetRate  method of the Player  interface and performs other logic The class is still declared abstract as it \ndoes not implement abstract methods from the Singer  and Player  interfaces\n The instanceof Operator\nYou can use the instanceof  operator to evaluate if a referencetype variable refers to an object of a specific \nclass or a specific interface implemented by its class It is a twooperand operator and it evaluates to a \nboolean  value The general syntax of the instanceof  operator is as follows\nreferencevariable instanceof referencetype\nConsider the following snippet of code that defines two interfaces  Generous  and Munificent  and four \nclasses Giver  GenerousGiver  MunificentGiver  and StingyGiver \npublic interface Generous \n    void give\nChapter 21  Interfa Ces\n846public interface Munificent extends Generous \n    void giveALot\n\npublic class Giver \n\npublic class GenerousGiver extends Giver implements Generous \n    Override\n    public void give \n    \n\npublic class MunificentGiver extends Giver implements Munificent \n    Override\n    public void give \n    \n    Override\n    public void giveALot \n    \n\npublic final class StingyGiver extends Giver \n    public void giveALittle \n    \n\nFigure 212  shows a class diagram of these interfaces and classes\nEvery expression in Java has two types a compiletime type and a runtime type The compiletime type \nis also known as the static type or the declared type The runtime type is also known as the dynamic type or \nthe actual type The compiletime type of an expression is known at compile time The runtime type of an \nexpression is known when the expression is actually executed Consider the following statement\nMunificent john  new MunificentGiver\nFigure 212  A class diagram showing the relationship between interfaces and classes Generous Munificent \nObject Giver GenerousGiver MunificentGiver and StingyGiverChapter 21  Interfa Ces\n847This code involves one variable declaration Munificent john  and one expression new \nMunificentGiver  The compiletime type of the variable john  is Munificent  The compiletime type \nof the expression new MunificentGiver  is MunificentGiver  At runtime the variable john  will have a \nreference to an object of the MunificentGiver  class and its runtime type will be MunificentGiver  The \nruntime type for the expression new MunificentGiver  will be the same as its compiletime type which is \nMunificentGiver \nThe instanceof  operator performs compiletime check as well as runtime check At compile time it \nchecks if it is possible for its lefthand operand to point to an instance of its righthand operand type It is \nallowed for the lefthand operand to point to the null  reference If it is possible for the lefthand operand \nto have a reference of its righthand operand type the code passes the compiler check For example the \nfollowing code would compile and print true  at runtime\nMunificent john  new MunificentGiver\nif john instanceof Munificent \n    Systemoutprintlntrue\n else \n    Systemoutprintlnfalse\n\nLooking at the compiletime type of john  which is Munificent  the compiler is assured that john  \nwill refer to either null  or to an object whose class implements the Munificent  interface Therefore the \ncompiler will not complain about the john instanceof Munificent  expression\nConsider the following snippet of code which compiles and prints false \nGiver donna  new Giver\nif donna instanceof Munificent \n    Systemoutprintlntrue\n else \n    Systemoutprintlnfalse\n\nThe compiletime type of the variable donna  is Giver  At runtime it also points to an object of the Giver  \ntype That is its runtime type is Giver  When the compiler attempts to compile the donna instanceof \nMunificent  expression it asks a question Is it possible that the variable donna  whose compiletime type \nis Giver  may point to an object of a class that implements the Munificent  interface The answer is yes \nAre you getting confused by the answer The compiler does not look at the whole statement Giver donna \n new Giver  in the previous snippet of code when it evaluates the instanceof  operator It just looks \nat the compiletime type of variable donna  which is Giver  The Giver  class itself does not implement the \nMunificent  interface However any subclass of the Giver  class might implement the Munificent  interface \nand the variable donna  may refer to the object of any such classes For example it is possible to write code as \nshown\nGiver donna  new MunificentGiver\nIn this case the compiletime type of the variable donna  remains the Giver  type However at runtime \nit will refer to an object whose class implements the Munificent  interface The job of the compiler is just \nto make sure about a possibility that may be true  or false  at runtime When the variable donna  refers to \nan object of the Giver  class the donna instanceof Munificent  expression will return false  at runtime \nbecause the Giver  class does not implement the Munificent  interface When the variable donna  refers to \nan object of the MunificentGiver  class the donna instanceof Munificent  expression will return true  at \nruntime because the MunificentGiver  class implements the Munificent  interfaceChapter 21  Interfa Ces\n848The following snippet of code will compile and print false \nGiver kim  new StingyGiver\nif kim instanceof Munificent \n    Systemoutprintlntrue\n else \n    Systemoutprintlnfalse\n\nConsider a variation of the previous code as follows\nStingyGiver jim  new StingyGiver\nif jim instanceof Munificent   A compiletime error\n    Systemoutprintlntrue\n else \n    Systemoutprintlnfalse\n\nThis time the compiler will refuse to compile the code Lets apply the logic and try to figure out \nwhat is wrong with the code The compiler will generate an error about the jim instanceof Munificent  \nexpression It is saying that it knows for sure that there is no possibility at runtime that the variable jim \ncan refer to an object whose class implements the Munificent  interface How can the compiler be so sure \nabout this possibility It is easy You have declared the StingyGiver  class as final which means it cannot \nbe subclassed This implies that the variable jim whose compiletime type is StingyGiver  can only refer to \nan object whose class is StingyGiver  The compiler also knows that the StingyGiver  class and its ancestor \nclasses do not implement the Munificent  interface With all this reasoning the compiler determines that \nyou have a logical error in your program and you need to fix it\nIf the instanceof  operator returns true  at runtime it means that its lefthand operand can be safely \ncast to the type represented by its righthand operand Typically your logic will be as follows when you need \nto use the instanceof  operator\nABC a  null\nDEF d  null\nif x instanceof ABC \n     Safe to cast x to ABC type\n    a  ABC x\n else if x instanceof DEF \n     Safe to cast x to DEF type\n    d  DEF x\n\nThis can be reduced using the following patternmatching instanceof syntax introduced in JDK 16\nif x instanceof ABC a \n     a is ABC type variable here\n else if x instanceof DEF d \n     d is DEF type variable here\nChapter 21  Interfa Ces\n849If the lefthand operand of the instanceof  operator is null  or a reference variable which points to null  \nat runtime it returns false  The following snippet of code will also print false \nGiver ken  null\nif ken instanceof Munificent \n    Systemoutprintlntrue\n else \n    Systemoutprintlnfalse\n\nYou can conclude that if v instanceof XYZ  returns true  you can assume the following two things safely\n\tv is not null  That is v is pointing to a valid object in memory\n\t The cast XYZ v  will always succeed That is the following code is guaranteed to \nwork at runtime without a ClassCastException \nXYZ x  XYZ v\n Marker Interfaces\nYou can declare an interface with no members Note that an interface can have members in two ways by \ndeclaring its own members or by inheriting members from its superinterfaces When an interface has no \nmembers declared or inherited it is known as a marker  interface A marker interface is also called a tag \ninterface\nWhat is the use of a marker interface Why would any class implement a marker interface As the name \nsuggests a marker interface is used to mark the class with a special meaning that can be used in a particular \ncontext The meaning added to a class by a marker interface depends on the context The developer of the \nmarker interface has to document the meaning of the interface and the consumer of the interface will make \nuse of its intended meaning For example lets declare a marker interface called Funny  as follows The \nmeaning of this Funny  interface is up to the developer who uses it\npublic interface Funny \n     No code goes here\n\nEvery interface defines a new type so does a marker interface Therefore you can declare a variable of \ntype Funny \nFunny simon  an object of a class that implements the Funny interface\nWhat can you access using the variable simon  which is of type Funny  You cannot access anything using \nthe simon  variable except all methods of the Object  class You could do that without implementing the \nFunny  interface to your class too Typically a marker interface is used with the instanceof  operator to check \nif a referencetype variable refers to an object whose class implements the marker interface For example \nyou may write code like this\nObject obj  any java object\n\nif obj instanceof Funny \n     obj is an object whose class implements the Funny interface Display a message on theChapter 21  Interfa Ces\n850     standard output that we are using a Funny object Or do something that is intended\n     by the developer of the Funny interface\n    SystemoutprintlnUsing a Funny object\n\nThe Java API has many marker interfaces Two of the marker interfaces in the Java class library are \njavalangCloneable  and javaioSerializable  If a class implements the Cloneable  interface it \nmeans that the developer of that class intended to allow the cloning of the objects of that class You need \nto take additional steps of overriding the clone  method of the Object  class in your class so the clone  \nmethod can be called on objects of your class because the clone  method has been declared protected \nin the Object  class Even though your class overrides the clone  method the object of your class cannot \nbe cloned until your class implements the Cloneable  marker interface You can see that implementing \nthe Cloneable interface associates a meaning to the class that its object can be cloned When the clone  \nmethod of the Object  class is invoked Java performs a check if the objects class implements the Cloneable  \ninterface If the objects class does not implement the Cloneable  interface it throws an exception at runtime\nJava 5 introduced annotations  To define an annotation you use the keyword interface but they are \nnot actually interfaces at all They are similar to marker interfaces in that they mark something They can be \nused to associate a meaning to any element for example a class a method a variable a package etc of a \nJava program Annotations are covered in detail in More Java 17  You have seen one annotation many times \nthe Override annotation which marks a method\n Functional Interfaces\nAn interface with just one abstract method is known as a functional  interface You can remember this with \nthe acronym SAM single abstract method The static and default methods are not counted to designate \nan interface a functional interface No additional steps other than what we have already discussed are \nneeded to declare an interface as functional As part of version 8 Java introduced the concept of functional \ninterfaces which can be implemented by method references and lambda expressions This book has shown \nexamples of these in previous chapters but did not name them functional interfaces as we had not covered \ninterfaces yet\nThe Walkable  and Swimmable  interfaces are examples of functional interfaces because they contain only \none abstract method The Singer  interface is an example of a nonfunctional interface because it contains \nmore than one abstract method You can annotate a functional interface with the FunctionalInterface  \nannotation and the compiler will verify the annotated interface really contains only one abstract method \notherwise the interface declaration will not compile The following is an example of a functional interface \nannotated with the FunctionalInterface  annotation\nFunctionalInterface\npublic interface Runner \n    public void run\n\nSince the abstract method in this interface has no parameters and a void return type it can be \nimplemented by any lambda expression that has no arguments and does not return a value Note that you \ncannot use var here because you need to tell Java which functional interface you are implementing for \nexample\nRunner r    SystemoutprintlnRunningChapter 21  Interfa Ces\n851Functional interfaces can have any sort of method For example the Predicate interface that is provided \nas part of the JDK is something like the following\npublic interface Predicate \n      boolean testObject o\n\nIt can be implemented using a lambda expression like so this Predicate would return true if the given \nobject is not null\nPredicate p  Object o  o  null\nFunctional interfaces can appear anywhere a normal Java type can appear such as a field type variable \ntype or parameter type They can also be implemented by a method reference as long as the method \nreferenced matches the method signature of the abstract method of the functional interface For example \nthe Objects nonNull method could be used to have the same meaning as the previous example\nPredicate p  ObjectsnonNull\nFunctional interfaces are covered in much more detail in More Java 17  but now you should have a basic \nunderstanding of how they are used\n Comparing Objects\nWhen you have a group of objects sometimes you may want to order them based on some criteria The \njavalangComparable  and javautilComparator  are two commonly used interfaces for the purpose of \nordering objects I discuss both interfaces in this section\n Using the\u00a0Comparable Interface\nA class implements the Comparable  interface if objects of the class need to be compared for sorting \npurposes For example you may want to compare two objects of a Person  class when sorting a collection \nof persons in an array or a list The criteria you use to compare the two objects depend on the context For \nexample when you need to display many persons you may want to display them sorted by their last names \nperson IDs addresses or telephone numbers\nThe ordering on the objects of a class that is imposed by the Comparable  interface is also called the \nclasss natural ordering The Comparable  interface contains an abstract compareTo  method that takes one \nparameter The method returns zero if the two objects being compared are considered equal it returns a \nnegative integer if the object is less than the specified parameter it returns a positive integer if the object is \ngreater than the specified parameter The Comparable  interface is a generic interface declared as follows\npublic interface ComparableT \n    public int compareToT o\n\nThe String  class and wrapper classes  Integer  Double  Float  etc implement the Comparable \ninterface The String  classs compareTo  method sorts strings lexicographically All wrapper classes for the \nnumeric primitive types compare the two objects numericallyChapter 21  Interfa Ces\n852It is typical to compare objects of the same type The following class declaration for the class A \nimplements the ComparableA  interface using A as its generic type which states that the class A supports \nonly comparing objects of its own type\npublic class A implement ComparableA \n    public int compareToA a \n         Code goes here\n    \n\nListing 2136  contains the code for a ComparablePerson  class that implements the \nComparableComparablePerson  interface In the compareTo  method first you compare the two objects \nbased on their last names If the last names are the same you compare their first names You have used the \ncompareTo  method of the String  class to compare the last and first names of two comparable persons \nNote that the compareTo  method does not handle null  values\nListing 2136  A Com parablePerson Class That Implements the Comparable Interface\n ComparablePersonjava\npackage comjdojointerfaces\npublic class ComparablePerson implements ComparableComparablePerson \n    private String firstName\n    private String lastName\n    public ComparablePersonString firstName String lastName \n        thisfirstName  firstName\n        thislastName  lastName\n    \n    public String getFirstName \n        return firstName\n    \n    public void setFirstNameString firstName \n        thisfirstName  firstName\n    \n    public String getLastName \n        return lastName\n    \n    public void setLastNameString lastName \n        thislastName  lastName\n    \n     Compares two persons based on their last names If last names are\n     the same use first names\n    Override\n    public int compareToComparablePerson anotherPerson \n        int diff  getLastNamecompareToanotherPersongetLastName\n        if diff  0 \n            diff  getFirstNamecompareToanotherPersongetFirstName\n        \n        return diff\n    Chapter 21  Interfa Ces\n853    Override\n    public String toString \n        return getLastName     getFirstName\n    \n\nListing 2137  contains the code that tests the ComparablePerson  class by sorting its objects in an array \nThe output shows that objects of the ComparablePerson  class are sorted by last name and first name\nListing 2137  A Tes t Class to Test the ComparablePerson Class and the Comparable Interface\n ComparablePersonTestjava\npackage comjdojointerfaces\nimport javautilArrays\npublic class ComparablePersonTest \n     public static void mainString args \n        ComparablePerson persons  new ComparablePerson \n                new ComparablePersonJohn Jacobs\n                new ComparablePersonJeff Jacobs\n                new ComparablePersonWally Inman\n        SystemoutprintlnBefore sorting\n        printpersons\n         Sort the persons list\n        Arrayssortpersons\n        SystemoutprintlnnAfter sorting\n        printpersons\n    \n    public static void printComparablePerson persons \n        forComparablePerson person persons\n            Systemoutprintlnperson\n        \n    \n\nBefore sorting\nJacobs John\nJacobs Jeff\nInman Wally\nAfter sorting\nInman Wally\nJacobs Jeff\nJacobs John\n Using the\u00a0Comparator Interface\nThe Comparable  interface which I explained in the previous section imposes a specified ordering on objects \nof a class Sometimes you may want to specify a different ordering for objects of the class from the ordering \nspecified in the class by the Comparable  interface Sometimes you may want to specify a particular ordering \nfor the objects of a class that does not implement the Comparable  interface For example you may want to \nspecify ordering on objects of the ComparablePerson  class based on the first name and the last name as Chapter 21  Interfa Ces\n854opposed to the ordering specified by its compareTo  method of the Comparable  interface which is the last \nname and the first name The Comparator  interface lets you specify a custom ordering on objects of any \nclass Typically the Java API dealing with a collection of objects requires a Comparator  object to specify a \ncustom ordering The Comparator  interface is a generic interface\npublic interface ComparatorT \n    int compareT o1 T o2\n    boolean equalsObject obj\n     Default and static methods are not shown here\n\nThe Comparator  interface has been overhauled in Java 8 Several static and default methods have been \nadded to the interface We discuss some of the new methods in this chapter\nTypically you do not need to implement the equals  method of the Comparator  interface Every class \nin Java inherits the equals  method from the Object  class and that is fine in most cases The compare  \nmethod takes two parameters and it returns an integer It returns a negative integer zero or a positive \ninteger if the first argument is less than equal to or greater than the second argument respectively \nListings 2138  and 2139  contain two implementations of the Comparator  interface one compares two \nComparablePerson  objects based on their first names and another based on their last names\nListing 2138  A Com parator Comparing ComparablePersons Based on Their First Names\n FirstNameComparatorjava\npackage comjdojointerfaces\nimport javautilComparator\npublic class FirstNameComparator implements ComparatorComparablePerson \n    Override\n    public int compareComparablePerson p1 ComparablePerson p2 \n        String firstName1  p1getFirstName\n        String firstName2  p2getFirstName\n        int diff  firstName1compareTofirstName2\n        return diff\n    \n\nListing 2139  A Com parator Comparing ComparablePersons Based on Their Last Names\n LastNameComparatorjava\npackage comjdojointerfaces\nimport javautilComparator\npublic class LastNameComparator implements ComparatorComparablePerson \n    Override\n    public int compareComparablePerson p1 ComparablePerson p2 \n        String lastName1  p1getLastName\n        String lastName2  p2getFirstName\n        int diff  lastName1compareTolastName2\n        return diff\n    \nChapter 21  Interfa Ces\n855Using a Comparator  is easy Create its object and pass it to the methods that take a collection of objects \nand a comparator to compare them For example to sort an array of ComparablePerson  objects pass the \narray and a FirstNameComparator  to the static sort  method of the Arrays  class\nComparablePerson persons  create and populate the array\n Sort the persons array based on first name\nComparator fnComparator  new FirstNameComparator\nArrayssortpersons fnComparator\nYou can use a similar logic to sort the array based on the last name\n Sort the persons array based on last name\nComparator lnComparator  new LastNameComparator\nArrayssortpersons lnComparator\nPrior to Java 8 if you wanted to sort the array based on the first name and then the last name you \nneeded to create another implementation of the Comparator  interface Thanks to Java 8s introducing default \nmethods to interfaces you do not need to create a new implementation of the Comparator  interface The \nComparator  class contains a thenComparing  default method declared as follows\ndefault ComparatorT thenComparingComparator super T other\nThe method takes a Comparator  as an argument and returns a new Comparator  The new Comparator  is \nused for ordering if the two objects being compared are equal using the original Comparator  The following \nsnippet of code combines the first name and last name Comparator s to create a new Comparator \n Sort using first name then last name\nComparator firstLastComparator  fnComparatorthenComparinglnComparator\nArrayssortpersons firstLastComparator\n Ti p Y ou can chain the call to the thenComparing  method to create a Comparator  that imposes \nordering on several nested levels\nThere is another useful addition to the Comparator  interface in Java 8 a default method named \nreversed  The method returns a new Comparator  that imposes the reverse ordering of the original \nComparator  If you want to sort the array based on first name then last name in descending order you can \ndo so as follows\n Sort using first name then last name in reversed order\nComparator firstLastReverseComparator  firstLastComparatorreversed\nArrayssortpersons firstLastReverseComparator\nComparators do not handle null  values well Typically they throw a NullPointerException  Java 8 \nadded the following two useful nullfriendly convenience static methods to the Comparator  interface\n\tstatic T ComparatorT nullsFirstComparator super T comparator\n\tstatic T ComparatorT nullsLastComparator super T comparatorChapter 21  Interfa Ces\n856These methods take a Comparator  and return a nullfriendly Comparator  that places the null values first \nor last You can use these methods as follows\n Sort using first name then last name placing null values first\nComparator nullFirstComparator  ComparatornullsFirstfirstLastComparator\nArrayssortpersons nullFirstComparator\nListing 2140  uses an object of this class to sort objects of the ComparablePerson  class As the output \nindicates this time you can sort a list of comparable persons based on their first names and last names If \nyou want to sort a list of objects of the ComparablePerson  in any other order you need to use an object of the \nComparator  interface that imposes the desired order\nListing 2140  A Tes t Class That Uses a Comparator Object to Sort ComparablePerson Objects\n ComparablePersonTest2java\npackage comjdojointerfaces\nimport javautilArrays\nimport javautilComparator\npublic class ComparablePersonTest2 \n    public static void mainString args \n        ComparablePerson persons  new ComparablePerson\n            new ComparablePersonJohn Jacobs\n            new ComparablePersonJeff Jacobs\n            new ComparablePersonWally Inman\n        SystemoutprintlnOriginal array\n        printpersons\n         Sort using first name\n        ComparatorComparablePerson fnComparator  new FirstNameComparator\n        Arrayssortpersons fnComparator\n        SystemoutprintlnnAfter sorting on first name\n        printpersons\n         Sort using last name\n        ComparatorComparablePerson lnComparator  new LastNameComparator\n        Arrayssortpersons lnComparator\n        SystemoutprintlnnAfter sorting on last name\n        printpersons\n         Sort using first name then last name\n        ComparatorComparablePerson firstLastComparator\n                 fnComparatorthenComparinglnComparator\n        Arrayssortpersons firstLastComparator\n        SystemoutprintlnnAfter sorting on first then last name\n        printpersons\n         Sort using first name then last name in reversed order\n        ComparatorComparablePerson firstLastReverseComparator\n                 firstLastComparatorreversed\n        Arrayssortpersons firstLastReverseComparator\n        SystemoutprintlnnAfter sorting on first then last name in reversed\n        printpersons\n         Sort using first name then last name using null first\n        ComparatorComparablePerson nullFirstComparator\n                 ComparatornullsFirstfirstLastComparator\n        ComparablePerson personsWithNulls  new ComparablePersonChapter 21  Interfa Ces\n857            new ComparablePersonJohn Jacobs\n            null\n            new ComparablePersonJeff Jacobs\n            new ComparablePersonWally Inman\n            null\n        ArrayssortpersonsWithNulls nullFirstComparator\n        SystemoutprintlnnAfter sorting on first then last name \n                 using null first\n        printpersonsWithNulls\n    \n    public static void printComparablePerson persons \n        for ComparablePerson person  persons \n            Systemoutprintlnperson\n        \n    \n\nOriginal array\nJacobs John\nJacobs Jeff\nInman Wally\nAfter sorting on first name\nJacobs Jeff\nJacobs John\nInman Wally\nAfter sorting on last name\nInman Wally\nJacobs John\nJacobs Jeff\nAfter sorting on first then last name\nJacobs Jeff\nJacobs John\nInman Wally\nAfter sorting on first then last name in reversed\nInman Wally\nJacobs John\nJacobs Jeff\nAfter sorting on first then last name using null first\nnull\nnull\nJacobs Jeff\nJacobs John\nInman WallyChapter 21  Interfa Ces\n858 Polymorphism One Object Many Views\nPolymorphism  refers to the ability of an object to take on many forms I use the term view instead of the \nterm form  The term view gives better understanding of polymorphism in the context of interfaces Lets \nrephrase the definition of polymorphism it is an ability of an object to provide its different views Interfaces \nlet you create a polymorphic object Consider the Turtle  class declaration shown in Listing 2124  It \nimplements the Swimmable  and Walkable  interfaces You create a Turtle  object as shown\nTurtle turti  new TurtleTurti\nBecause the Turtle  class implements the Walkable  and Swimmable  interfaces you can treat the turti  \nobject as a Walkable  or a Swimmable \nWalkable turtiWalkable  turti\nSwimmable turtiSwimmable  turti\nSince every class in Java is inherited from the Object  class you can also treat the turti  object as an \nObject \nObject turiObject  turti\nFigure 213  shows four different views of the same Turtle  object Note that there is only one object \nwhich is of the Turtle  class When you look at a house from different directions top front back left right \netc you get different views of the same house Nevertheless there is only one house When you are looking \nat a house from its front you do not get to see its other views for example the back view or the left view Like \na house a Java object can exhibit different views of itself which is called polymorphism\nFigure 213   Polymorphism one object many views Four different views of a Turtle objectChapter 21  Interfa Ces\n859What defines a particular view of a Java object and how do you get that view of the object A view is \nsomething that is available for an outsider in technical terms for clients or users of the class The set of \nmethods accessible to clients defined in a type a class or an interface defines a view of an object of that \ntype For example the Walkable  type defines one method walk  If you get a Walkable  view of an object \nit means that you have access to only the walk  method of that object Similarly if you have a Swimmable  \nview of an object you can access only the swim  method of that object How about having a Turtle  view \nof a Turtle  object The Turtle  class defines three methods bite  walk  and swim  It also inherits \nmethods from the Object  class Therefore if you have a Turtle  view of an object you can access all methods \nthat are available in the Turtle  class directly declared or inherited from its superclass and superinterfaces \nEvery class in Java is inherited directly or indirectly from the Object  class By virtue of this every object in \nJava has at least two views one view defined by the set of methods that are available declared or inherited \nin the objects class and another view defined by the set of methods defined in the Object  class When you \nare using the Object  view of an object you can access methods of only the Object  class\nYou get different views of an object by accessing it using reference variables of different types For \nexample to get the Walkable  view of a Turtle  object you do any of the following things\nTurtle t  new TurtleTurti\nWalkable w2  t              w2 gives Walkable view of the Turtle object\nWalkable w3  new Turtle  w3 gives Walkable view of the Turtle object\nWith this knowledge of a Java object that can support different views lets look at the use of the \ninstanceof  operator It is used to test if an object supports a specific view or not Consider the following \nsnippet of code\nObject anObject  get any object reference\nifanObject instanceof Walkable \n     anObject has a Walkable view\n    Walkable w  Walkable anObject\n     Now access the Walkable view of the object using w\n else \n     anObject does not have a Walkable view\n\nThe anObject  variable refers to an object The instanceof  operator is used to test if the object to \nwhich the anObject  variable refers supports a Walkable  view Note that just defining a walk  method in a \nclass does not define a Walkable  view for the objects of that class The class must implement the Walkable  \ninterface and implement the walk  method in order for its object to have a Walkable  view A view of an \nobject is synonymous with its type Recall that implementing an interface on a class gives the objects of that \nclass an additional type ie an additional view How many views can an object of a class have There is no \nlimit An object of a class can have the following views\n\t A view that is defined by its class type\n\t Views that are defined by all superclasses direct or indirect of its class\n\t Views that are defined by all interfaces implemented by its class or superclasses \ndirect or indirectChapter 21  Interfa Ces\n860 Dynamic Binding and\u00a0Interfaces\nJava uses dynamic binding also known as runtime binding or late binding when a method is invoked using \na variable of an interface type Consider the following snippet of code\nWalkable john  a Walkable object reference\njohnwalk\nThe variable john  has two types a compiletime type and a runtime type Its compiletime type is its \ndeclared type which is Walkable  The compiler knows about the compiletime type of a variable When \nthe code johnwalk  is compiled the compiler has to verify that this call is valid according to all pieces of \ninformation that are available at compile time The compiler adds instruction similar to the following for the \njohnwalk  method invocation\ninvokeinterface 5   1 InterfaceMethod comjdojointerfacesWalkablewalkV\nThe previous instruction states that the johnwalk  method invocation is being made on a variable of \nan interface type Walkable  The object to which the variable john  refers at runtime is its runtime type The \ncompiler does not know about the runtime type of the variable john The variable john  may refer to an object \nof a Person  class a Turtle  class a Duck  class or any other class that implements the Walkable  interface The \ncompiler does not state which implementation of the walk  method should be used when johnwalk  is \nexecuted The runtime decides the implementation of the walk  method to invoke as follows\n 1 It gets the information about the class of the object to which the variable john  \nrefers For example consider the following snippet of code\nWalkable john  new PersonJohn  john refers to a Person object\njohnwalk\nHere the class type of the object to which the variable john  refers at runtime is Person \n 2 It looks for the walk  method implementation in the class that is determined \nin the previous step If the walk  method implementation is not found in that \nclass the runtime looks for the walk  methods implementation in the ancestor \nclass recursively\n 3 If the walk  methods implementation is found in the previous step it is \nexecuted as soon as it is found That is if the walk  methods implementation \nis found in the class of the object to which the variable john  refers the runtime \nexecutes that method implementation and it does not look for the method any \nfurther in its ancestor class\n 4 If the walk  methods implementation is not found in the class hierarchy \nthe inheritance hierarchy of the superinterfaces implemented by the class \nis searched If a walk  method is found using the most specific rules of \nfinding methods in interfaces described previously that method is invoked \nif it is a default method If multiple default walk  methods are found an \nIncompatibleClassChangeError  is thrown If an abstract walk  method is \nfound an AbstractMethodError  is thrown\n 5 If the walk  methods implementation is still not found a NoSuchMethodError  is \nthrown If all classes are consistently compiled you should not get this errorChapter 21  Interfa Ces\n861 Summary\nAn interface is a specification that is meant to be implemented by classes An interface may contain \nmembers that are static constants abstract methods default methods static methods and nested types An \ninterface cannot have instance variables An interface cannot be instantiated\nAn interface with no members is known as a marker interface An interface with only one abstract \nmethod is known as a functional interface that can be implemented by a method reference or lambda \nexpression\nA class implements interfaces The keyword implements  is used in a class declaration to implement \ninterfaces The class implementing an interface inherits all members from the interface except the static \nmethods If the class inherits abstract methods from the implemented interfaces it needs to override \nthem and provide an implementation or the class should declare itself abstract The class implementing \ninterfaces are is a subtype of the implemented interfaces and the implemented interfaces are supertypes \nof the class If a class inherits the same methods from multiple supertypes superclasses or superinterfaces \nwith the same signature in such a case the method from the superclass takes precedence if all methods are \ninherited from superinterfaces the most specific method is used if there are still multiple candidates the \nclass must override the method to resolve the conflict\nAn interface may inherit from other interfaces The keyword extends  is used in the interface declaration \nto specify all inherited interfaces The interfaces from which the interface is inherited are known as \nsuperinterfaces and the interface itself is known as a subinterface A subinterface inherits all members \nof its superinterfaces except their static methods A conflict may arise if an interface inherits a method \ncombination defaultdefault or defaultabstract with the same signature from multiple superinterfaces \nThe conflict is resolved in two steps the most specific candidate is used if there are multiple most specific \ncandidates the interface must override the conflicting method\nBefore Java 8 it was not possible without breaking the existing code to change interfaces after they \nare published From Java 8 you can add default and static methods to existing interfaces Until Java 9 all \nmethods in an interface were implicitly public and you were not allowed to have private methods Java \nallows you to have private methods in an interface\nDynamic binding is used when an abstract or default method is called using a variable of an interface \ntype Static binding is used when the static methods of an interface are called Note that the static methods of \nan interface can be called using only one syntax\nInterfaceNamestaticMethodNamearg1 arg2\nEXERCISES\n 1 What are interfaces in Java What is a marker interface What is a functional \ninterface\n 2 What keyword do you use to implement an interface to a class\n 3 how many interfaces can a class implement\n 4 What keyword do you use in an interface declaration to inherit from other \ninterfaces\n 5 Can you dec lare instance variables in an interface\n 6 Which version of Ja va se allows you to have private methods in an interface\n 7 What kinds of methods in an interface can be declared private Can you have an \nabstract private method in an interface If not explain your answerChapter 21  Interfa Ces\n862 8 What interface do you implement in a class to implement natural sorting for the \nobjects of the class What interface do you use to implement custom sorting for the \nobjects of the class\n 9 Describe the reason tha t the following interface declaration does not compile and \nsuggest a fix\npublic interface Choices \n    int YES\n    int NO  1\n    private int CANCEL  2\n\n 10 What is wrong with the following interface declaration\npublic interface ScheduledJob \n    public void run \n        SystemoutprintlnRunning the job\n    \n\n 11 Consider the follo wing declaration of an interface named Greeting \ninterface Greeting \n    void sayHello\n\nCreate a class named Greeter  that implements the Greeting  interface in such a \nway that when the following snippet of code is executed it prints Hello  on the \nstandard output\nGreeting g  new Greeter\ngsayHello\n 12 the following interface declaration does not compile Describe the reason and \nsuggest a fix\npublic final interface Colorable \n    public void color\n\n 13 Is the follo wing interface declaration valid What is the special name for an \ninterface like the Sensitive  interface\npublic interface Sensitive \n     No code goes here\n\n 14 Will the follo wing interface declaration compile If not give the reason\nFunctionalInterface\npublic interface Runner \n    public void run\nChapter 21  Interfa Ces\n863 15 Is the follo wing declaration for the Printer  interface a valid functional interface \ndeclaration Describe your reasons for how it fits or does not fit the definition of a \nfunctional interface\nFunctionalInterface\npublic interface Printer \n    public void print\n    public default void sayHello \n        SystemoutprintlnHello\n    \n\n 16 Consider the follo wing declarations\npublic interface Greeting \n    default void greet \n        SystemoutprintlnHello\n    \n\npublic class EnglishGreeting implements Greeting \n\npublic class HispanicGreeting implements Greeting \n    Override\n    public void greet \n        SystemoutprintlnOla\n    \n\nWhat will the output be when the following snippet of code is executed\nGreeting usGreeting  new EnglishGreeting\nGreeting mxGreeting  new HispanicGreeting\nusGreetinggreet\nmxGreetinggreet\n 17 Consider the follo wing partial declaration of an Item  class\npublic class Item implements ComparableItem \n    private String name\n    private double price\n     Your code goes here \n\nComplete the Item  class by adding the needed constructor to allow for initial \nvalues for the name and price of the item also add getters and setters for the \ntwo instance variables add the required method so the class implements the \nComparableItem  interface the natural order for sorting items is by their \nnames\n 18 Create a custom comparator classa class that implements the \nComparatorItem  interface the comparator class will sort the objects of the \nItem  class by price and then by nameChapter 21  Interfa Ces\n864 19 Consider the follo wing declarations for the Greeting  interface and the Greeter  \nclass\npublic interface Greeting \n    default void greet \n        SystemoutprintlnNamaste\n    \n\npublic class Greeter implements Greeting \n    Override\n    public void greet \n         Calls the greet method of the Greeting interface here \n        SystemoutprintlnHello\n    \n\nComplete the code in the greet  method of the Greeter  class by adding one \nstatement as the first statement in the method the statement should call the \ngreet  method of the Greeting  interface When the following snippet of code is \nexecuted it should print Namaste  and Hello each word on a separate line\nGreeting g  new Greeter\nggreet\nthe expected output is as follows\nNamaste\nHello865\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307422CHAPTER 22\nEnum Types\nIn this chapter you will learn\n\t What enum types are\n\t How to declare enum types and enum constants\n\t How to use enums in switch  statements\n\t How to associate data and methods to enum constants\n\t How to declare nested enums\n\t How to implement interfaces to an enum type\n\t How to perform a reverse lookup for enum constants\n\t How to use EnumSet  to work with ranges of enum constants\nAll example programs in this chapter are a member of a jdojoenums  module as declared in Listing 221 \nListing 221  The D eclaration of a jdojoenums Module\n moduleinfojava\nmodule jdojoenums \n    exports comjdojoenums\n\n What Is an\u00a0Enum Type\nAn enum also known as enumeration and enumerated data type lets you create an ordered list of constants \nas a type Before we discuss what an enum is and why we need it lets consider a problem and solve it using \nJava features that were available before enum which was introduced in Java 5 Suppose you are working on \na defect tracking application in which you need to represent the severity of a defect The application lets you \nspecify the severity of a defect as low medium high and urgent A typical way to represent the four types of \nseverity before Java 5 was to declare four int constants in a class say Severity  as shown in Listing 222 Chapter 22  enum types\n866Listing 222  A Se verity Class with a Few Constants\n Severityjava\npackage comjdojoenums\npublic class Severity \n    public static final int LOW  0\n    public static final int MEDIUM  1\n    public static final int HIGH  2\n    public static final int URGENT  3\n\nSuppose you want to write a utility class named DefectUtil  that has a method to compute the projected \nturnaround days for a defect based on its severity The code for the DefectUtil  class may look as shown in \nListing 223 \nListing 223  A Defe ctUtil Class\n DefectUtiljava\npackage comjdojoenums\npublic class DefectUtil \n    public static int getProjectedTurnaroundDaysint severity \n        int days  0\n        switch severity \n            case SeverityLOW\n                days  30\n                break\n            case SeverityMEDIUM\n                days  15\n                break\n            case SeverityHIGH\n                days  7\n                break\n            case SeverityURGENT\n                days  1\n                break\n        \n        return days\n    \n     Other code for the DefectUtil class goes here\n\nThe following are a few problems with this approach in handling the severity of a defect\n\t Since a severity is represented as an integer constant you can pass any integer value \nto the getProjectedTurnaroundDays  method not just 0 1 2 and 3 which are the \nvalid values for the severity type You may want to add a check inside this method so \nonly valid severity values can be passed to it Otherwise the method may throw an \nexception However that does not solve the problem forever You will need to update \nthe code that checks for valid severity values whenever you add new severity typesChapter 22  enum types\n867\t If you change the value for a severity constant you must recompile the code that \nuses it to reflect the changes When you compile the DefectUtil  class Severity\nLOW is replaced with 0 SeverityMEDIUM  is replaced with 1 and so on If you change \nthe value for the constant LOW in the Severity  class to 10 you must recompile the \nDefectUtil  class to reflect this change Otherwise the DefectUtil  class will still \nkeep using the value 0\n\t When you save the value of the severity on disk its corresponding integer value will \nbe saved for example 0 1 2 etc not the string values LOW MEDIUM  HIGH  etc You \nmust maintain a separate map to convert from an integer value to its corresponding \nstring representation for all severity types\n\t When you print the severity value of a defect it will print an integer for example 0 1 \n2 etc An integer value for a severity does not mean anything to end users\n\t Severity types of defects have a specific order For example a LOW severity defect is \ngiven less priority than a MEDIUM  severity defect Since severity is being represented \nby an arbitrary number you must write code using hardcoded values to maintain \nthe order of the constants defined in the Severity  class Suppose you add another \nseverity type of VERYHIGH  which has less priority than URGENT  and more priority \nthan HIGH  Now you must change the code that handles ordering of severity types \nbecause you have added one in the middle of the existing severity types\n\t There is no automatic way except by hard coding that will let you list all severity \ntypes\nYou would agree that representing the severity types using integer constants is difficult to maintain \nThat was the only easily implemented solution available before Java 5 to define enumerated constants You \ncould have solved this problem effectively before Java 5 However the amount of code you had to write was \ndisproportionate to the problem The enum type in Java 5 solves this problem in a simple and effective way\nAccording to the MerriamWebster online dictionary the term enumerate means to specify one \nafter another  This is exactly what the enum type lets you do It lets you specify constants in a specific order \nThe constants defined in an enum type are instances of that enum type You define an enum type using the \nkeyword enum  Its simplest general syntax is\naccessmodifier enum enumtypename \n     List of comma separated names of enum constants\n\nThe access modifier for an enum is the same as the access modifier for a class public  private  \nprotected  or package level The enum type name is a valid Java identifier The body of the enum type is \nplaced within braces following its name The body of the enum type can have a list of commaseparated \nconstants and other elements that are similar to the elements you have in a class for example instance \nvariables methods etc Most of the time the enum body includes only constants The following code \ndeclares an enum type called Gender  which declares three constantsNA MALE  and FEMALE \npublic enum Gender \n    NA MALE FEMALE  The semicolon is optional in this case\n\n Ti p It is a convention to name the enum constants in uppercase  the semicolon after the last enum \nconstant is optional if there is no code that follows the list of constantsChapter 22  enum types\n868Listing 224  declares a public enum type called Severity  with four enum constants LOW MEDIUM  HIGH  \nand URGENT \nListing 224  Declaration of a Severity Enum\n Severityjava\npackage comjdojoenums\npublic enum Severity \n    LOW MEDIUM HIGH URGENT\n\nA public enum type can be accessed from anywhere in the application Accessibility rules across \nmodules for enum types are the same as for other types which this book covered in Chapter 10\nJust like a public class you need to save the code in Listing 224  in a file named Severityjava  When \nyou compile the code the compiler will create a Severityclass  file Note that except for the use of the \nenum  keyword and the body part everything for the Severity  enum type looks the same as if it were a class \ndeclaration In fact Java implements an enum type as a class The compiler does a lot of work for an enum \ntype and generates code for it that is essentially a class You need to place an enum type in a package as you \nhave been placing all classes in a package You can use an import  statement to import an enum type as you \nimport a class type into a compilation unit\nYou declare a variable of an enum type the same way you declare a variable of a class type\n Declare defectSeverity variable of the Severity enum type\nSeverity defectSeverity\nYou can assign null  to an enumtype variable like so\nSeverity defectSeverity  null\nWhat other values can you assign to an enumtype variable An enum type defines two things\n\t The enum constants which are the only valid values for its type\n\t The order for those constants\nThe Severity  enum type defines four enum constants Therefore a variable of the Severity  enum \ntype can have only one of the four values LOW MEDIUM  HIGH  and URGENT or null  You can use dot notation \nto refer to the enum constants by using the enum type name as the qualifier The following snippet of code \nassigns values to a variable of Severity  enum type\nSeverity low  SeverityLOW\nSeverity medium  SeverityMEDIUM\nSeverity high  SeverityHIGH\nSeverity urgent  SeverityURGENT\nYou cannot instantiate an enum type The following code that attempts to instantiate the Severity  \nenum type results in a compiletime error\nSeverity badAttempt  new Severity  A compiletime error\n Tip an enum type acts as a type as well as a factor y It declares a new type and a list of valid instances of \nthat type as its constantsChapter 22  enum types\n869An enum type also assigns an order number or position number called an ordinal  to all of its \nconstants The ordinal starts with zero and it is incremented by one as you move from first to last in the list \nof constants The first enum constant is assigned the ordinal value of zero the second of 1 the third of 2 and \nso on The ordinal values assigned to constants declared in the Severity  enum type are 0 to LOW 1 to MEDIUM  \n2 to HIGH  and 3 to URGENT  If you change the order of the constants in the enum type body or add new ones \ntheir ordinal values will change accordingly\nEach enum constant has a name The name of an enum constant is the same as the identifier specified \nfor the constant in its declaration For example the name for the LOW constant in the Severity  enum type is \nLOW \nYou can read the name and the ordinal of an enum constant using the name  and ordinal  methods \nrespectively Each enum type has a static method named values  that returns an array of constants in the \norder they are declared in its body The program in Listing 225  prints the name and ordinal of all enum \nconstants declared in the Severity  enum type\nListing 225  Listing Name and Ordinal of Enum Type Constants\n ListEnumConstantsjava\npackage comjdojoenums\npublic class ListEnumConstants \n    public static void mainString args \n        forSeverity s  Severityvalues \n            String name  sname\n            int ordinal  sordinal\n            Systemoutprintlnname    ordinal  \n        \n    \n\nLOW0\nMEDIUM1\nHIGH2\nURGENT3\n The Superclass of\u00a0an\u00a0Enum Type\nAn enum type is similar to a Java class type In fact the compiler creates a class when an enum type is \ncompiled You can treat an enum type as a class type for all practical purposes However there are some \nrules that apply only to the enum type An enum type can also have constructors fields and methods Did \nwe not say that an enum type cannot be instantiated In other words new Severity  is invalid Why do \nyou need constructors for an enum type if it cannot be instantiated\nHere is the reason why you need constructors for an enum type An enum type is instantiated only in \nthe code generated by the compiler All enum constants are objects of the same enum type These instances \nare created and named the same as the enum constants in the code generated by the compiler The \ncompiler is playing the tricks The compiler generates code for an enum type similar to the one shown next \nThe following sample code is just to give you an idea of what goes on behind the scenes The actual code \ngenerated by the compiler may be different from the one shown For example the code for the valueOf  Chapter 22  enum types\n870method gives you a sense that it compares the name with enum constant names and returns the matching \nconstant instance In reality the compiler generates code for a valueOf  method that makes a call to the \nvalueOf  method in the Enum  superclass\n Transformed code for Severity enum type declaration\npackage comjdojoenums\npublic final class Severity extends Enum \n    public static final Severity LOW\n    public static final Severity MEDIUM\n    public static final Severity HIGH\n    public static final Severity URGENT\n     Create constants when class is loaded\n    static \n         LOW     new SeverityLOW 0\n         MEDIUM  new SeverityMEDIUM 1\n         HIGH    new SeverityHIGH 2\n         URGENT  new SeverityURGENT 3\n    \n     The private constructor to prevent direct instantiation\n    private SeverityString name int ordinal \n        supername ordinal\n    \n    public static Severity values \n        return new Severity  LOW MEDIUM HIGH URGENT \n    \n    public static Severity valueOfString name \n        if LOWnameequalsname \n            return LOW\n        \n        if MEDIUMnameequalsname \n            return MEDIUM\n        \n        if HIGHnameequalsname \n             return HIGH\n        \n        if URGENTnameequalsname \n            return URGENT\n        \n        throw new IllegalArgumentExceptionInvalid enum constant   name\n    \n\nBy looking at the transformed code for the Severity  enum declaration the following points can be \nmade\n\t Every enum type implicitly extends the javalangEnum  class This means that all \nmethods defined in the Enum  class can be used with all enum types Table\u00a0 221  lists \nthe methods that are defined in the Enum  class\n\t An enum type is implicitly final In some situations discussed later the compiler \ncannot declare it as final as it has done in the sample code for the Severity  classChapter 22  enum types\n871\t The compiler adds two static methods values  and valueOf  to every enum type \nThe values  method returns the array of enum constants in the same order they  \nare declared in the enum type You have seen the use of the values  method in \nListing 225  The valueOf  method is used to get the instance of an enum type \nusing the constant name as a string For example SeverityvalueOfLOW   \nwill return the SeverityLOW  constant The valueOf  method facilitates  \nreverse lookupfrom a string value to an enumtype value\n\t The Enum  class implements the javalangComparable  and javaioSerializable  \ninterfaces This means instances of every enum type can be compared and \nserialized The Enum  class makes sure that during the deserialization process no other \ninstances of an enum type are created than the ones declared as the enum constants \nYou can use the compareTo  method to determine if one enum constant is declared \nbefore or after another enum constant Note that you can also determine the order of \ntwo enum constants by comparing their ordinals The compareTo  method does the \nsame with one more check that is the enum constants being compared must be of \nthe same enum type The following code snippet shows how to compare two enum \nconstants\nSeverity s1  SeverityLOW\nSeverity s2  SeverityHIGH\n s1compareTos2 returns s1ordinal   s2ordinal\nint diff  s1compareTos2\nif diff  0 \n    Systemoutprintlns1   occurs after   s2\n else \n    Systemoutprintlns1   occurs before   s2\n\nTable 221  List of Methods in the Enum Class That Are Available in All Enum Types\nMethod Name Description\npublic final String name Returns the name of the enum constant exactly as declared in the enum \ntype declaration\npublic final int ordinal Returns the order or position of the enum constant as declared in the \nenum type declaration\npublic final boolean \nequalsObject otherReturns true  if the specified object is equal to the enum constant \nOtherwise it returns false  Note that an enum type cannot be \ninstantiated directly and it has a fixed number of instances which are \nequal to the number of enum constants it declares It implies that the  \noperator and the equals  method return the same result when they \nare used on two enum constants\npublic final int hashCode Returns the hash code value for an enum constant\npublic final int\ncompareToE oCompares the order of this enum constant with the order of the \nspecified enum constant It returns the difference in ordinal value of this \nenum constant and the specified enum constant Note that to compare \ntwo enum constants they must be of the same enum type Otherwise a \nruntime exception is thrown\ncontinued Chapter 22  enum types\n872 Using Enum Types in\u00a0switch Statements\nYou can use enum types in switch  statements When the switch  expression is of an enum type all case \nlabels must be unqualified enum constants of the same enum type The switch  statement deduces the enum \ntype name from the type of its expression You may include a default label\nListing 226  contains a revised version of the DefectUtil  class using a switch  statement Now you \ndo not need to handle the exceptional case of receiving a null  value in the severity  parameter inside the \ngetProjectedTurnaroundDays  method If the enum expression of the switch  statement evaluates to null  \nit throws a NullPointerException \nListing 226  A Re vised Version of the DefectUtil Class Using the Severity Enum\n DefectUtiljava\npackage comjdojoenums\npublic class DefectUtil \n    public static int getProjectedTurnaroundDaysSeverity severity \n        int days  0\n        switch severity Method Name Description\npublic final ClassE \ngetDeclaringClassReturns the Class  object for the class that declares the enum constant \nTwo enum constants are considered to be of the same enum type if \nthis method returns the same class object for both Note that the Class  \nobject returned by the getClass  method which every enum type \ninherits from the Object  class might not be the same as the class object \nreturned by this method When an enum constant has a body the \nactual class of the object for that enum constant is not the same as the \ndeclaring class actually it is one of the subclasses of the declaring class\npublic String toString By default it returns the name of the enum constant which is the \nsame as the return value of the name  method Note that this method \nis not declared final and hence you can override it to return a more \nmeaningful string representation for each enum constant\npublic static T extends \nEnumT T valueOfClassT \nenumType String nameReturns an enum constant of the specified enum type and name For \nexample you can use the following code to get the LOW enum constant \nvalue of the Severity  enum type in your code\nSeverity lowSeverity  EnumvalueOfSeverityclass LOW\nprotected final \nObject clone throws \nCloneNotSupportedExceptionThe Enum  class redefines the clone  method It declares the method \nfinal so it cannot be overridden by any enum type The method always \nthrows an exception This is done intentionally to prevent cloning of \nenum constants This makes sure that only one set of enum constants \nexists for each enum type\nprotected final void \nfinalizeThe Enum  class is declared final so that it cannot be overridden by any \nenum type It provides an empty body Since you cannot create an \ninstance of an enum type except its constants it makes no sense to \nhave a finalize  method for your enum typeTable 221  continued Chapter 22  enum types\n873             Must use the unqualified name LOW not SeverityLOW\n            case LOW\n                days  30\n                break\n            case MEDIUM\n                days  15\n                break\n            case HIGH\n                days  7\n                break\n            case URGENT\n                days  1\n                break\n        \n        return days\n    \n\nOr us ing a switch expression\n    public static int getProjectedTurnaroundDaysSeverity severity \n        return switch severity \n            case LOW  30\n            case MEDIUM  15\n            case HIGH  7\n            case URGENT  1\n        \n    \n Associating Data and\u00a0Methods to\u00a0Enum Constants\nGenerally you declare an enum type just to have some enum constants as you have done in the Severity  \nenum type Since an enum type is actually a class type you can declare pretty much everything inside \nan enum type body that you can declare inside a class body Lets associate one data element projected \nturnaround days with each of your Severity  enum constants You will name your enhanced Severity  \nenum type SmartSeverity  Listing 227  contains the code for the SmartSeverity  enum type which is very \ndifferent from the code for the Severity  enum type\nListing 227  A Smar tSeverity Enum Type Declaration That Uses Fields Constructors and Methods\n SmartSeverityjava\npackage comjdojoenums\npublic enum SmartSeverity \n    LOW30 MEDIUM15 HIGH7 URGENT1\n     Declare an instance variable\n    private int projectedTurnaroundDays\n     Declare a private constructor\n    private SmartSeverityint projectedTurnaroundDays \n        thisprojectedTurnaroundDays  projectedTurnaroundDays\n    Chapter 22  enum types\n874     Declare a public method to get the turnaround days\n    public int getProjectedTurnaroundDays \n        return projectedTurnaroundDays\n    \n\nLets discuss the new things that are in the SmartSeverity  enum type\n\t It declares an instance variable called projectedTurnaroundDays  which will store \nthe value of the projected turnaround days for each enum constant\n Declare an instance variable\nprivate int projectedTurnaroundDays\n\t It defines a private constructor which accepts an int parameter It stores the value of \nits parameter in the instance variable You can add multiple constructors to an enum \ntype If you do not add a constructor a noargs constructor is added You cannot add \na public or protected constructor to an enum type All constructors in an enum type \ndeclaration go through parameter and code transformations by the compiler and \ntheir access levels are changed to private Many things are added or changed in the \nconstructor of an enum type by the compiler As a programmer you do not need to \nknow the details of the changes the compiler makes\n Declare a private constructor\nprivate SmartSeverityint projectedTurnaroundDays \n    thisprojectedTurnaroundDays  projectedTurnaroundDays\n\n\t It declares a public method getProjectedTurnaroundDays  which returns the \nvalue of the projected turnaround days for an enum constant or the instance of the \nenum type\n\t The enum constant declarations have changed to LOW30 MEDIUM15 HIGH7 \nURGENT1  This change is not obvious Now every enum constant name is followed \nby an integer value in parentheses for example LOW30  This syntax is shorthand \nfor calling the constructor with an int parameter type When an enum constant \nis created the value inside the parentheses will be passed to the constructor that \nyou have added By simply using the name of the enum constant eg LOW  in the \nconstant declaration you invoke a default noargs constructor\nThe program in Listing 228  tests the SmartSeverity  enum type It prints the names of the constants \ntheir ordinals and their projected turnaround days Note that the logic to compute the projected turnaround \ndays is encapsulated inside the declaration of the enum type itself The SmartSeverity  enum type combines \nthe code for the Severity  enum type and the getProjectedTurnaroundDays  method in the DefectUtil  \nclass You do not have to write a switch  statement anymore to get the projected turnaround days Each \nenum constant knows about its projected turnaround days\nListing 228  A Tes t Class to Test the SmartSeverity Enum Type\n SmartSeverityTestjava\npackage comjdojoenums\npublic class SmartSeverityTest \n    public static void mainString args Chapter 22  enum types\n875        for SmartSeverity s  SmartSeverityvalues \n            String name  sname\n            int ordinal  sordinal\n            int days  sgetProjectedTurnaroundDays\n            Systemoutprintlnname  name   ordinal  ordinal\n                      days  days\n        \n    \n\nnameLOW ordinal0 days30\nnameMEDIUM ordinal1 days15\nnameHIGH ordinal2 days7\nnameURGENT ordinal3 days1\n Associating a\u00a0Body to\u00a0an\u00a0Enum Constant\nSmartSeverity  is an example of adding data and methods to an enum type The code in the \ngetProjectedTurnaroundDays  method is the same for all enum constants You can also associate a \ndifferent body to each enum constant The body can have fields and methods The body for an enum \nconstant is placed inside braces following its name If the enum constant accepts arguments its body follows \nits argument list The syntax for associating a body to an enum constant is as follows\naccessmodifier enum enumtypename \n    CONST1 \n         Body for CONST1 goes here\n    \n    CONST2 \n         Body for CONST2 goes here\n    \n    CONST3argumentslist \n         Body of CONST3 goes here\n    \n     Other code goes here\n\nIt is a little different game when you add a body to an enum constant The compiler creates an \nanonymous class which inherits from the enum type It moves the body of the enum constant to the body of \nthat anonymous class Anonymous classes are covered in more detail in the second volume of this series We \nuse it briefly to complete the discussion of the enum type For now you can think of it just as a different way \nof declaring a class and at the same time creating objects of that class\nConsider an ETemp  enum type as shown\npublic enum ETemp \n    C1 \n         Body of constant C1\n        public int getValue \n            return 100\n        \n    Chapter 22  enum types\n876    C2\n    C3\n\nThe body of the ETemp  enum type declares three constants C1 C2 and C3 You have added a body to the \nC1 constant The compiler will transform the code for ETemp  into something like the following code\npublic enum ETemp \n    public static final ETemp C1  new ETemp \n         Body of constant C1\n        public int getValue \n            return 100\n        \n    \n    public static final ETemp C2  new ETemp\n    public static final ETemp C3  new ETemp\n     Other code goes here\n\nNote that the constant C1 is declared of type ETemp  and assigned an object using an anonymous \nclass The ETemp  enum type has no knowledge of the getValue  method defined in the anonymous \nclass Therefore it is useless for all practical purposes because you cannot call the method as ETemp\nC1getValue \nTo let the client code use the getValue  method you must declare a getValue  method for the ETemp  \nenum type If you want all constants of ETemp  to override and provide implementation for this method \nyou need to declare it as abstract  If you want it to be overridden by some but not all constants you \nneed to declare it nonabstract and provide a default implementation for it The following code declares a \ngetValue  method for the ETemp  enum type which returns 0\npublic enum ETemp \n    C1 \n         Body of constant C1\n        public int getValue \n            return 100\n        \n    \n    C2\n    C3\n     Provide the default implementation for the getValue method\n    public int getValue \n        return 0\n    \n\nThe C1 constant has its body which overrides the getValue  method and returns 100 Note that the \nconstants C2 and C3 do not have to have a body they do not need to override the getValue  method Now \nyou can use the getValue  method on the ETemp  enum type\nThe following code rewrites the previous version of ETemp  and declares the getValue  method \nabstract  An abstract  method for an enum type forces you to provide a body for all constants and \noverride that method Now all constants have a body The body of each constant overrides and provides \nimplementation for the getValue  methodChapter 22  enum types\n877public enum ETemp \n    C1 \n         Body of constant C1\n        public int getValue \n            return 100\n        \n    \n    C2 \n         Body of constant C2\n        public int getValue \n            return 0\n        \n    \n    C3 \n         Body of constant C3\n        public int getValue \n            return 0\n        \n    \n     Make the getValue method abstract\n    public abstract int getValue\n\nLets enhance your SmartSeverity  enum type You are running out of good names for your enum type \nYou will name the new one SuperSmartSeverity  Listing 229  has the code\nListing 229  Using a Body for Enum Constants\n SuperSmartSeverityjava\npackage comjdojoenums\npublic enum SuperSmartSeverity \n    LOWLow Priority 30 \n        Override\n        public double getProjectedCost \n            return 10000\n        \n    \n    MEDIUMMedium Priority 15 \n        Override\n        public double getProjectedCost \n            return 20000\n        \n    \n    HIGHHigh Priority 7 \n        Override\n        public double getProjectedCost \n            return 30000\n        \n    Chapter 22  enum types\n878    URGENTUrgent Priority 1 \n        Override\n        public double getProjectedCost \n            return 50000\n        \n    \n     Declare instance variables\n    private final String description\n    private final int projectedTurnaroundDays\n     Declare a private constructor\n    private SuperSmartSeverityString description\n            int projectedTurnaroundDays \n        thisdescription  description\n        thisprojectedTurnaroundDays  projectedTurnaroundDays\n    \n     Declare a public method to get the turn around days\n    public int getProjectedTurnaroundDays \n        return projectedTurnaroundDays\n    \n     Override the toString method in the Enum class to return description\n    Override\n    public String toString \n        return thisdescription\n    \n     Provide getProjectedCost abstract method so all constants\n     override and provide implementation for it in their body\n    public abstract double getProjectedCost\n\nThe following are new features in the SuperSmartSeverity  enum type\n\t It has added an abstract method getProjectedCost  to return the projected cost of \neach type of severity\n\t It has a body for each constant that provides implementation for the \ngetProjectedCost  method Note that declaring an abstract method in an enum \ntype forces you to provide a body for all its constants\n\t It has added another parameter to the constructor which is a nicer name for the \nseverity type\n\t It has overridden the toString  method in the Enum  class The toString  method \nin the Enum  class returns the name of the constant Your toString  method returns \na brief and more intuitive name for each constant\n Tip typically  you do not need to write this kind of complex code for an enum type Java enum is very \npowerful It has features for you to utilize if you need them\nThe code in Listing 2210  demonstrates the use of the new features added to the SuperSmartSeverity  \nenum typeChapter 22  enum types\n879Listing 2210  A Test Class to Test the SuperSmartSeverity Enum Type\n SuperSmartSeverityTestjava\npackage comjdojoenums\npublic class SuperSmartSeverityTest \n    public static void mainString args \n        for SuperSmartSeverity s  SuperSmartSeverityvalues \n            String name  sname\n            String desc  stoString\n            int ordinal  sordinal\n            int projectedTurnaroundDays  sgetProjectedTurnaroundDays\n            double projectedCost  sgetProjectedCost\n            Systemoutprintlnname  name\n                      description  desc\n                      ordinal  ordinal\n                      turnaround days\n                     projectedTurnaroundDays\n                      projected cost  projectedCost\n        \n    \n\nnameLOW descriptionLow Priority ordinal0 turnaround days30 projected cost10000\nnameMEDIUM descriptionMedium Priority ordinal1 turnaround days15 projected \ncost20000\nnameHIGH descriptionHigh Priority ordinal2 turnaround days7 projected cost30000\nnameURGENT descriptionUrgent Priority ordinal3 turnaround days1 projected \ncost50000\n Comparing Two Enum Constants\nYou can compare two enum constants in three ways\n\t Using the compareTo  method of the Enum  class\n\t Using the equals  method of the Enum  class\n\t Using the  operator\nThe compareTo  method of the Enum  class lets you compare two enum constants of the same enum \ntype It returns the difference in ordinal for the two enum constants If both enum constants are the \nsame it returns zero The following snippet of code will print 3 because the difference of the ordinals for \nLOWordinal0  and URGENTordinal3  is 3 A negative value means the constant being compared occurs \nbefore the one being compared against\nSeverity s1  SeverityLOW\nSeverity s2  SeverityURGENT\nint diff  s1compareTos2\nSystemoutprintlndiff\n3Chapter 22  enum types\n880Suppose you have another enum called BasicColor  as shown in Listing 2211 \nListing 2211  A Bas icColor Enum\n BasicColorjava\npackage comjdojoenums\npublic enum BasicColor \n    RED GREEN BLUE\n\nThe following snippet of code will not compile because it tries to compare the two enum constants \nwhich belong to different enum types\nint diff  BasicColorREDcompareToSeverityURGENT  A compiletime error\nYou can use the equals  method of the Enum  class to compare two enum constants for equality An \nenum constant is equal only to itself Note that the equals  method can be invoked on two enum constants \nof different types If the two enum constants are from different enum types the method returns false \nSeverity s1  SeverityLOW\nSeverity s2  SeverityURGENT\nBasicColor c  BasicColorBLUE\nSystemoutprintlns1equalss1\nSystemoutprintlns1equalss2\nSystemoutprintlns1equalsc\ntrue\nfalse\nfalse\nYou can also use the equality operator   to compare two enum constants for equality Both operands \nto the  operator must be of the same enum type Otherwise you get a compiletime error\nSeverity s1  SeverityLOW\nSeverity s2  SeverityURGENT\nBasicColor c  BasicColorBLUE\nSystemoutprintlns1  s1\nSystemoutprintlns1  s2\n A compiletime error Cannot compare Severity and BasicColor enum types\nSystemoutprintlns1  c\ntrue\nfalseChapter 22  enum types\n881 Nested Enum Types\nYou can have a nested enum type declaration You can declare a nested enum type inside a class an \ninterface or another enum type Nested enum types are implicitly static You can also declare a nested enum \ntype static explicitly in its declaration Since an enum type is always static whether you declare it or not \nyou cannot declare a local enum type eg inside a methods body You can use any of the access modifiers \npublic  private  protected  or package level for a nested enum type Listing 2212  shows the code that \ndeclares a nested public  enum type named Gender  inside a Person  class\nListing 2212  A Gender E num Type as a Nested Enum Type Inside a Person Class\n Personjava\npackage comjdojoenums\npublic class Person \n    public enum Gender MALE FEMALE NA\n\nThe PersonGender  enum type can be accessed from anywhere in the same module because it has been \ndeclared public Accessing it in other modules depends on module accessibility rules You need to import \nthe enum type to use its simple name in other packages as shown in the following code\n Testjava\npackage comjdojoenumspkg1\nimport comjdojoenumsPersonGender\npublic class Test \n    public static void mainString args \n        Gender m  GenderMALE\n        Gender f  GenderFEMALE\n        Systemoutprintlnm\n        Systemoutprintlnf\n    \n\nMALE\nFEMALE\nYou can also use the simple name of an enum constant by importing the enum constants using static \nimports The following code snippet uses MALE  and FEMALE  which are simple names of constants of the \nPersonGender  enum type Note that the first import  statement is needed to import the Gender  type itself to \nuse its simple name in the code\n Testjava\npackage comjdojoenumspkg1\nimport comjdojoenumsPersonGender\nimport static comjdojoenumsPersonGender\npublic class Test \n    public static void mainString args \n        Gender m  MALE\n        Gender f  FEMALEChapter 22  enum types\n882        Systemoutprintlnm\n        Systemoutprintlnf\n    \n\nMALE\nFEMALE\nYou can also nest an enum type inside another enum type or an interface The following are valid enum \ntype declarations\npublic enum OuterEnum \n    C1 C2 C3\n    public enum NestedEnum \n        C4 C5 C6\n    \n\npublic interface MyInterface \n    int operation1\n    int operation2\n    public enum AnotherNestedEnum \n        CC1 CC2 CC3\n    \n\n Implementing an\u00a0Interface to\u00a0an\u00a0Enum Type\nAn enum type may implement interfaces The rules for an enum type implementing an interface are \nthe same as the rules for a class implementing an interface An enum type is never inherited by another \nenum type Therefore you cannot declare an enum type as abstract This also implies that if an enum type \nimplements an interface it must also provide implementation for all abstract methods in that interface The \nprogram in Listing 2213  declares a Command  interface\nListing 2213  A Comm and Interface\n Commandjava\npackage comjdojoenums\npublic interface Command \n    void execute\n\nThe program in Listing 2214  declares an enum type called CommandList  that implements the Command  \ninterface Each enum constant implements the execute  method of the Command  interface Alternatively \nyou can implement the execute  method in the enum type body and omit the implementations from some \nor all enum constants Listing 2215  demonstrates using the enum constants in the CommandList  enum type \nas Command  typeChapter 22  enum types\n883Listing 2214   A CommandList Enum Type Implementing the Command Interface\n CommandListjava\npackage comjdojoenums\npublic enum CommandList implements Command \n    RUN \n        Override\n        public void execute \n            SystemoutprintlnRunning\n        \n    \n    JUMP \n        Override\n        public void execute \n            SystemoutprintlnJumping\n        \n    \n     Force all constants to implement the execute method\n    Override\n    public abstract void execute\n\nListing 2215  Using the CommandList Enum Constants as Command Types\n CommandTestjava\npackage comjdojoenums\npublic class CommandTest \n    public static void mainString args \n         Execute all commands in the command list\n        forCommand cmd  CommandListvalues \n            cmdexecute\n        \n    \n\nRunning\nJumping\n Reverse Lookup for\u00a0Enum Constants\nYou can get the reference of an enum constant if you know its name or position in the list This is known \nas reverse lookup  based on the name or ordinal of an enum constant You can use the valueOf  method \nwhich is added by the compiler to an enum type to perform reverse lookup based on a name You can use \nthe array returned by the values  method which is added by the compiler to an enum type to perform \nreverse lookup by ordinal The order of the values in the array that is returned by the values  method is \nthe same as the order in which the enum constants are declared The ordinal of enum constants starts at Chapter 22  enum types\n884zero This implies that the ordinal value of an enum constant can be used as an index in the array that is \nreturned by the values  method The following snippet of code demonstrates how to reverse lookup enum \nconstants\nSeverity low1  SeverityvalueOfLOW  A reverse lookup using a name\nSeverity low2  Severityvalues0      A reverse lookup using an ordinal\nSystemoutprintlnlow1\nSystemoutprintlnlow2\nSystemoutprintlnlow1  low2\nLOW\nLOW\ntrue\nThe reverse lookup for enum constants is case sensitive If you use an invalid constant name with the \nvalueOf  method an IllegalArgumentException  is thrown For example SeverityvalueOflow  \nwill throw an IllegalArgumentException  stating that no enum constant called low exists in the Severity  \nenum\n Range of\u00a0Enum Constants\nThe Java API provides a javautilEnumSet  collection class to work with ranges of enum constants of an \nenum type The implementation of the EnumSet  class is very efficient Suppose you have an enum type called \nDay as shown in Listing 2216 \nListing 2216  A Da y Enum Type\n Dayjava\npackage comjdojoenums\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nYou can work with a range of days using the EnumSet  class for example you can get\u00a0all days between \nMONDAY  and FRIDAY  An EnumSet  can contain enum constants only from one enum type Listing 2217  \ndemonstrates how to use the EnumSet  class to work with the range for enum constants\nListing 2217  A Tes t Class to Demonstrate How to Use the EnumSet Class\n EnumSetTestjava\npackage comjdojoenums\nimport javautilEnumSet\npublic class EnumSetTest \n    public static void mainString args \n         Get all constants of the Day enum\n        EnumSetDay allDays  EnumSetallOfDayclass\n        printallDays All days \n         Get all constants from MONDAY to FRIDAY of the Day enum\n        EnumSetDay weekDays  EnumSetrangeDayMONDAY DayFRIDAY\n        printweekDays Weekdays Chapter 22  enum types\n885         Get all constants that are not from MONDAY to FRIDAY of the Day enum\n         Essentially we will get days representing weekends\n        EnumSetDay weekends  EnumSetcomplementOfweekDays\n        printweekends Weekends \n    \n    public static void printEnumSetDay days String msg \n        Systemoutprintmsg\n        for Day d  days \n            Systemoutprintd   \n        \n        Systemoutprintln\n    \n\nAll days MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\nWeekdays MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY\nWeekends SATURDAY SUNDAY\n Summary\nLike a class and an interface an enum defines a new reference type in Java An enum type consists of a \npredefined ordered set of values which are known as the elements or constants of the enum type Constants \nof the enum type have a name and an ordinal You can obtain the reference of an enum constant using its \nname and ordinal and vice versa Typically an enum type is used to define typesafe constants\nAn enum type has several things that a class has It has constructors instance variables and methods \nHowever the constructors of an enum type are implicitly private An enum type can also implement \ninterfaces just as a class can\nYou can declare a variable of the enum type The variable can be assigned null  or one of the constants \nof the enum type Every enum type is implicitly inherited from the javalangEnum  class An enum type can \nimplement interfaces An enum type can be used in the switch  statement or expression Java provides an \nefficient implementation of an EnumSet  class to work with a range of enum constants of a specific enum type\nQUESTIONS AND EXERCISES\n 1 What are enum types in Java\n 2 What is the superclass of all enums in Java\n 3 Can an enum in Ja va extend another enum\n 4 Can an enum in Ja va implement one or more interfaces\n 5 Is the follo wing enum declaration valid If yes how many enum constants does it \ndeclare\npublic enum Gender \n   MALE FEMALE\nChapter 22  enum types\n886 6 Consider the follo wing declaration for an enum named Day\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nGiven a string F rIDay how will you look up the DayF rIDay enum constant\n 7 Consider the follo wing declaration for an enum named Day\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nhow will you look up the ordinal for Day sunDay\n 8 Consider the follo wing declaration for an enum named Day\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nComplete the following snippet of code that will print the ordinal of tues Day from \nthe Day enum It should print 1\nString dayName  TUESDAY\nint ordinal   Complete this statement \nSystemoutprintlnordinal\n 9 Consider the follo wing declaration for an enum named Day\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nuse a foreach loop to print the name of each day with its ordinal like mOnDay0 \ntues Day1 etc\n 10 Write the output for the follo wing snippet of code\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nEnumSetDay es  EnumSetrangeDayTUESDAY DayFRIDAY\nforDay d  es \n    Systemoutprintfsdn dname dordinal\n\n 11 Write the output for the follo wing snippet of code\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nEnumSetDay es \n    EnumSetcomplementOfEnumSetrangeDayTUESDAY DayFRIDAYChapter 22  enum types\n887forDay d  es \n    Systemoutprintfsdn dname dordinal\n\n 12 Consider the follo wing declaration for an enum named Country \npublic enum Country \n    BHUTANBhutan BT\n    BRAZILBrazil BR\n    FIJIFiji FJ\n    INDIAIndia IN\n    SPAINSpain ES\n    private final String fullName\n    private final String isoName\n    private CountryString fullName String isoName \n        thisfullName  fullName\n        thisisoName  isoName\n    \n    public String fullName \n        return thisfullName\n    \n    public String isoName \n        return thisisoName\n    \n    Override\n    public String toString \n        return thisfullName\n    \n\nWrite the output when the following snippet of code is executed\nforCountry c  Countryvalues \n    Systemoutprintfsd s sn\n          cname cordinal c cisoName\n\n 13 Consider the follo wing declaration for a Gender  enum\npublic enum Gender \n    MALE FEMALE\n\nmodify the code for the Gender enum so that the output of the following snippet \nof code is as shown in the expected output section that follows the code you are \nsupposed to change the code for the Gender enum  not the following snippet of \ncode\nforGender c  Gendervalues \n    Systemoutprintfsn c\nChapter 22  enum types\n888expected output\nMale\nfemale\n 14 suppose Color  is an enum Is the following declaration of a MyFavColor  enum \nvalid If not explain your answer\npublic enum MyFavColor extends Color \n    WHITE BLACK\n\n 15 What will the output be when the following snippet of code is run\npublic enum Day \n    MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY\n\nDay days  DayFRIDAY DayMONDAY DayWEDNESDAY\nSystemoutprintlnArraystoStringdays\nArrayssortdays\nSystemoutprintlnArraystoStringdays\n 16 What will the output of the following snippet of code be\npublic enum Gender \n    MALE FEMALE NA\n\nSystemoutprintlnGenderMALE  GenderMALE\nSystemoutprintlnGenderMALEequalsGenderMALE889\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg101007978148427307423CHAPTER 23\nJava Shell\nIn this chapter you will learn\n\t What the Java shell is\n\t What the JShell tool and the JShell API are\n\t How to configure the JShell tool\n\t How to use the JShell tool to evaluate snippets of Java code\n\t How to use the JShell API to evaluate snippets of Java code\nAll example programs in this chapter are a member of a jdojojshell  module as declared in \nListing\u00a0 231 \nListing 231  The D eclaration of a jdojojshell Module\n moduleinfojava\nmodule jdojojshell \n    exports comjdojojshell\n    requires jdkjshell\n\nBefore you begin reading this chapter lets clarify the usage of the following three phrases that are used \nfrequently in this chapter\n\t The JShell commandline tool or the JShell tool\n\tjshell\n\t The JShell API\nIn this chapter the main topic of discussion is JShell which can be used as a commandline tool and \nas a Java API The JShell commandline tool refers to the capability of JShell being used as a command\nline tool The JShell commandline tool is named jshell  all lowercase which is installed as a jshell\nexe file in the JDKHOMEbin  directory when you install the JDK on Windows The JShell API refers to the \ncapability of JShell as a Java APIChapter 23  Java Shell\n890 What Is the\u00a0Java Shell\nThe Java shell which is called JShell is a commandline tool that provides an interactive way to access \nthe Java programming language It lets you evaluate snippets of Java code instead of forcing you to write \nan entire Java program It is a REPL  readevalprint loop for Java JShell is also an API that you can use to \ndevelop an application to provide the same functionality as the JShell commandline tool\nThe ReadEvalPrint loop  REPL  is a commandline tool also known as interactive language shell that \nlets users evaluate snippets of code quickly without having to write a complete program The name REPL  \ncomes from the three primitive functions in Lisp read  eval  and print used in a loop The read  function \nreads the user input and parses it into a data structure the eval  function evaluates the parsed user input to \nyield a result the print  function prints the result After the result is printed the tool is ready to accept user \ninput again hence triggering a readevalprint loop The term REPL  is used for an interactive tool that lets \nyou interact with a programming language Figure\u00a0 231  shows a conceptual diagram for a REPL  A UNIX shell \nor a Windows command prompt acts like a REPL  that reads an operating system command executes it prints \nthe output and waits to read another command\nWhy was JShell added in JDK 9 One of the main reasons was the feedback from academia that Java has \na steep learning curve Other programming languages such as Lisp Python Ruby Groovy and Clojure have \nbeen supporting REPL  for a long time Just to write a Hello world program in Java you have to resort to \nan editcompileexecute loop ECEL that involves writing a full program compiling it and executing it If \nyou need to make a change you must repeat these steps Apart from some other housekeeping work such as \ndefining the directory structure compiling and executing the program the following is the minimum you \nhave to write to print a Hello world message in a program in Java\n HelloWorldjava\npublic class HelloWorld \n    public static void mainString args \n        SystemoutprintlnHello world\n    \n\nThis program when executed prints a message on the console Hello world  Writing a full \nprogram to evaluate a simple expression such as this is overkill This was the main reason academia was \nmoving away from teaching Java as the initial programming language to students Java designers listened to \nthe feedback from teaching communities and introduced the JShell tool in JDK 9 To achieve the same as the \nHelloWorld program you need to write only one line of code on a jshell  command promptFigure 231  A concep tual diagram for a readevalprint loopChapter 23  Java Shell\n891jshell SystemoutprintlnHello world\nHello world\njshell\nThe first line is the code you enter on the jshell  command prompt the second line is the output After \nprinting the output the jshell  prompt returns and you can enter another Java expression to evaluate\n Tip Java 11 introduced the ability to run a single file of Java source code You still need to define a class \nwith a main method  For example you could create a file named HelloWorldjava  with the source code \nlisted previously and run  java HelloWorldjava  on the command line Java will compile and execute \nthe code You can also use options like classpath  or modulepath  as you would with a normal Java \ncommand You can use the source  option to specify the Java version compatibility of the source code For \nexample to specify Java 17 you would run  java source 17 HelloWorldjava  on the command line\nThe JDK ships with a JShell commandline tool and the JShell  API\u00a0All features supported by the tool \nare also supported by the API\u00a0That is you can run snippets of code using the tool or programmatically \nusing the API\u00a0You should be able to distinguish between the two using the context in this discussion Most \nof the chapter is devoted to explaining the tool At the end we include a section describing the API with an \nexample\nJShell is not a new language or a new compiler It is a tool and an API used to access the Java \nprogramming language interactively For beginners it provides a way to explore the Java programming \nlanguage quickly For experienced developers it provides a quick way to see results of a code snippet \nwithout having to compile and run an entire program It also provides a way to quickly develop a prototype \nusing an incremental approach You add a snippet of code get immediate feedback and add another \nsnippet of code until your prototype is complete\n The JShell Architecture\nThe Java compiler does not recognize snippets such as method declarations or variable declarations by \nthemselves Only classes and import  statements can be toplevel constructs which can exist by themselves \nOther types of snippets have to be part of a class JShell lets you execute snippets of Java code and lets you \nevolve them\nThe guiding principle for the current JShell architecture is to use the existing Java language support and \nother Java technologies in the JDK to keep it compatible with the current and future versions of the language \nAs the Java language evolves over time so will its support in JShell with little or no modification to the JShell \nimplementation Figure\u00a0 232  shows the highlevel architecture of JShellChapter 23  Java Shell\n892The JShell tool uses version 2 of JLine which is a Java library for handling console input The standard \nJDK compiler does not know how to parse and compile snippets of Java code Therefore the JShell \nimplementation has its own parser that parses snippets and determines the type of snippets for example a \nmethod declaration a variable declaration etc Once the snippet type is determined the snippet is wrapped \nin a synthetic class using the following rules\n\t Import statements are used as is  That is all import  statements are placed as is at \nthe top of the synthetic class\n\t Variables methods and class declarations become static members of a synthetic \nclass\n\t Expressions and statements are wrapped in a synthetic method of a synthetic class\nAll synthetic classes belong to a package called REPL  Once snippets are wrapped the wrapped source \ncode is analyzed and compiled by the standard Java compiler using the Compiler API\u00a0The compiler takes \nthe wrapped source code in string format as input and compiles it into bytecode which is stored in memory \nThe generated bytecode is sent over a socket to a remote process running a JVM for loading and execution \nSometimes existing snippets loaded into the remote JVM need to be replaced by the JShell tool which it \naccomplishes using the Java Debugger API\nFigure 232  The JShell architectureChapter 23  Java Shell\n893 Starting the\u00a0JShell Tool\nJDK 17 ships with a JShell tool which is located in the JDKHOMEbin  directory The tool is named jshell   \nIf you installed JDK 17\u00a0in the Cjava17  directory on Windows you will have an executable file named  \nCjava17binjshellexe  which is the JShell tool To start the JShell tool you need to open a command \nprompt and enter the jshell  command\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell\nEntering the jshell  command on the command prompt may give you an error\nCJavaFunjshell\njshell is not recognized as an internal or external command\noperable program or batch file\nCJavaFun\nThis error indicates that the JDKHOMEbin  directory is not included in the PATH  environment variable \non your computer If you installed JDK 17\u00a0in the Cjava17  directory the JDKHOME  is Cjava17  for you \nTo fix this error you either include the Cjava17bin  directory in the PATH  environment variable or use \nthe full path of the jshell  command which would be Cjava17binjshell  The following sequence of \ncommands show you how to set the PATH  environment variable on Windows and run the JShell  tool\nCJavaFunSET PATHCjava17binPATH\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell\nThe following command shows you how to use the full path of the jshell  command to launch the tool\nCJavaFunCjava17binjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell\nWhen jshell  is launched successfully it prints a welcome message with its version information It also \nprints the command which is help intro  You can use this command to print a short introduction to the \ntool itself\njshell help intro\n\n  intro\n\n  The jshell tool allows you to execute Java code getting immediate results\n  You can enter a Java definition variable method class etc like   int x  8\n  or a Java expression like   x  x\n  or a Java statement or import\n  These little chunks of Java code are called snippetsChapter 23  Java Shell\n894\n  There are also jshell commands that allow you to understand and\n  control what you are doing like   list\n\n  For a list of commands help\njshell\nIf you need help on the tool you can enter the command help  on jshell  to print a list of commands \nwith their short descriptions\njshell help\nThe output is not shown here\njshell\n Ti p NetBeans and other ID es have integrated support for the JShell tool You can open the JShell prompt \nfrom within the NetBeans ID e by choosing the tools  Open Java platform Shell menu the NetBeans JShell \nprompt offers you all the features of the jshell  commandline tool and a lot moreall using UI options For \nexample NetBeans lets you save all your code snippets as a class using its Save to Class toolbar option It \nalso lets you autocomplete your code as it does in a normal Java editor IntelliJ ID ea has a builtin JShell and \neclipse and visual Studio Code have extensions for using JShell within the ID e\nYou can use several commandline options with the jshell  command to pass values to the tool itself \nFor example you can pass values to the compiler used to parse and compile snippets and to the remote JVM \nused to executeevaluate snippets Run the jshell  program with a help  option to see a list of all available \nstandard options Run it with a helpextra  or X option to see a list of all available nonstandard options \nFor example using these options you can set class path and module path for the JShell  tool We explain \nthese options later in this chapter\nYou can also customize the startup scripts for the jshell  tool using the commandline start  option \nYou can use DEFAULT  and PRINTING  as arguments to this option The DEFAULT  argument starts jshell  with \nseveral import  statements so you do not need to import commonly used classes while you use jshell  The \nfollowing two commands launch the jshell  the same way\n\tjshell\n\tjshell start DEFAULT\nYou can use the Systemoutprintln  method to print messages to the standard output You can \nlaunch jshell  using the start  option with a PRINTING  argument which will include all versions of the \nSystemoutprint  Systemoutprintln  and Systemoutprintf  methods as print  println  \nand printf  toplevel methods This will allow you to use print  println  and printf  methods on \njshell  instead of their longer versions Systemoutprint  Systemoutprintln  and Systemout\nprintf \nCJavaFunjshell start PRINTING\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell printlnhello\nhello\njshellChapter 23  Java Shell\n895You can repeat the start  option when you launch jshell  to include the default import  statements \nand the printing methods\nCJavaFunjshell start DEFAULT start PRINTING\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell\n Exiting the\u00a0JShell Tool\nTo exit jshell  enter exit  on the jshell  prompt and press Enter The command prints a goodbye message \nexits the tool and returns you to the command prompt\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell exit\n  Goodbye\nCJavaFun\nThe JShell  tool is forgiving in a number of ways If you use a keyword in a Java construct that is not \nsupported it simply ignores it You can use partial commands If the partial command you entered can be \nautocompleted to a unique command name the tool would work as if you entered the full command For \nexample edit  and exit  are two commands starting with e If you enter ex instead of exit  jshell  will \ninterpret it as an exit  command for you\njshell ex\n  Goodbye\nCJavaFun\nIf you enter e you will receive an error because there are multiple possible commands starting with e\njshell e\n  Command e is ambiguous edit exit env\n  Type help for help\njshell\n What Are Snippets and\u00a0Commands\nYou can use the JShell tool to\n\t Evaluate snippets of Java code which are simply called snippets  in JShell \nterminology\n\t Execute commands which are used to query the JShell state and set the JShell \nenvironment\nTo distinguish commands from snippets all commands start with a slash   You have already seen \na few of them in previous sections such as exit  and help  Commands are used to interact with the tool \nitself such as to customize its output print help exit the tool and print the history of commands and \nsnippets This book will explain more commands later If you are interested in learning all the available \ncommands use the help  commandChapter 23  Java Shell\n896Using the JShell tool you write a fragment of Java code at a time and evaluate it Those fragments of \ncode are known as snippets  Snippets must follow the syntax specified in the Java Language  Specification  \nSnippets can be\n\t Import declarations\n\t Class declarations\n\t Interface declarations\n\t Method declarations\n\t Field declarations\n\t Statements\n\t Expressions\n Ti p Y ou can use all Java language constructs in JShell except for package declarations all snippets in \nJShell occur in an internal package named REPL  and inside an internal synthetic class\nThe JShell tool knows when you are done entering a snippet When you press Enter the tool will either \nexecute the snippet if it is complete or take you to the next line and wait for you to complete the snippet If a \nline begins with   it means the snippet is not complete and you need to enter more text to complete the \nsnippet The default prompt for more input which is   can be customized Here are a few examples\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell 2  2\n1  4\njshell 2 \n    2\n2  4\njshell 2\n3  2\njshell\nWhen you enter 2  2  and press Enter jshell  considers it as a complete snippet an expression \nIt evaluates the expression and prints feedback that the expression was evaluated to 4 and the result was \nassigned to a variable named 1 The variable named 1 was automatically generated by the tool This book \nwill explain variables generated by tools in more detail later When you enter 2  and press Enter jshell  \nprompts you to enter more input because 2  is not a complete snippet in Java When you enter 2 on the \nsecond line the snippet is complete jshell  evaluates the snippet and prints feedback When you enter 2 \nand press Enter jshell  evaluates the snippet because 2 is a complete expression by itselfChapter 23  Java Shell\n897 Evaluating Expressions\nYou can execute any valid Java expression in jshell  The following examples evaluate two expressions that \nadd and multiply numbers\njshell 2  2\n1  4\njshell 90  6\n2  540\nWhen you evaluate an expression jshell  prints feedback if the expression evaluates to a value In \nthese cases 2  2  evaluates to 4 and 90  6  evaluates to 540  The value of an expression is assigned to a \nvariable The feedback contains the name of the variable and the value of the expression In the first case the \nfeedback 1  4  means that the expression 2  2  evaluated to 4 and the result was assigned to a variable \nnamed 1 Similarly the expression 90  6  was evaluated to 540  and the value was assigned to a variable \nnamed 2 You can use these variable names in other expressions You can print their values by simply \nentering their names\njshell 1\n1  4\njshell 2\n2  540\njshell Systemoutprintln1\n4\njshell Systemoutprintln2\n540\n Ti p In jshell  you do not need to terminate a statement with a semicolon as you must do in a Java \nprogram the tool will insert the missing semicolons for you\nIn Java every variable has a data type In these examples what are the data types of the variables named \n1 and 2 In Java 2  2  evaluates to an int  and 90  6  evaluates to a double  Therefore the data types \nfor the 1 and 2 variables should be int and double  respectively How do you verify this Lets first do it the \nhard way You can cast 1 and 2 to an Object  and invoke the getClass  method on them which should \ngive you Integer  and Double  Note that primitive values of int and double  types are boxed to Integer  and \nDouble  reference types in these examples when you cast them as an Object \njshell 2  2\n1  4\njshell 90  6\n2  540\njshell Object1getClass\n3  class javalangInteger\njshell Object2getClass\n4  class javalangDouble\njshellChapter 23  Java Shell\n898There is an easier way to determine the data types of variables created by jshell you just tell jshell  \nto give you verbose feedback and it will print the data types of the variables it creates and much more The \nfollowing commands set the feedback mode to verbose  and evaluate the same expressions\njshell set feedback verbose\n  Feedback mode verbose\njshell 2  2\n1  4\n  created scratch variable 1  int\njshell 90  6\n2  540\n  created scratch variable 2  double\njshell\nNotice that jshell  printed the data types of the variables named 1 and 2 as int and double  \nrespectively It will be helpful for beginners to execute the following command using a retain  option so \nthe verbose feedback mode persists  across the jshell  sessions\njshell set feedback retain verbose\nYou can also use the vars  command to list all variables defined in jshell \njshell vars\n    int 1  4\n    double 2  540\njshell\nIf you want to use the normal  feedback mode again use the following command\njshell set feedback retain normal\n  Feedback mode normal\nJshell\nYou are not limited to evaluating simple expressions such as 2  2  You can evaluate any Java \nexpression The following example evaluates string concatenation expressions and uses methods of the \nString  class It also shows you how to use for loops\njshell Hello   world   2017\n1  Hello world 2017\njshell 1length\n2  17\njshell 1toUpperCase\n3  HELLO WORLD 2017\njshell 1split \n4  String3  Hello world 2017 \njshell forString s  4 \n        Systemoutprintlns\n    \nHello\nworld\n2017\nJshellChapter 23  Java Shell\n899 Listing Snippets\nWhatever you enter in jshell  ends up being part of a snippet Every snippet is assigned a unique snippet ID \nwhich you can use to refer to the snippet later for example to drop the snippet The list  command lists all \nsnippets It has the following forms\n\tlist\n\tlist all\n\tlist start\n\tlist snippetname\n\tlist snippetid\nThe list  command without an argumentoption prints all userentered active snippets which may \nalso have been opened from a file using the open  command\nUse the all  option to list all snippetsactive inactive erroneous and startup\nUse the start  option to list only the startup snippets The startup snippets are cached and the start  \noption prints the cached snippets It prints startup snippets even if you have dropped them in the current \nsession\nSome of the snippet types have a name eg variablemethod declarations and all snippets have an \nID\u00a0Using the name or ID of a snippet with the list  command prints the snippet identified by that name or \nID\u00a0The list  command prints a list of snippets in the following format\nsnippetid  snippetsourcecode\nsnippetid  snippetsourcecode\nsnippetid  snippetsourcecode\n\nThe JShell  tool generates unique snippet IDs They are s1 s2 s3  for startup snippets 1 2 3  for \nvalid snippets and e1 e2 e3  for erroneous snippets The following jshell  session shows you how to list \nsnippets using the list  command The examples use the drop  command to drop snippets using a snippet \nname as well as a snippet ID\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell list\njshell 2  2\n1  4\njshell list\n   1  2  2\njshell int x  100\nx  100\njshell list\n   1  2  2\n   2  int x  100\njshell list all\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofileChapter 23  Java Shell\n900  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\n   1  2  2\n   2  int x  100\njshell list start\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\njshell string str  String type is misspelled as string\n  Error\n  cannot find symbol\n    symbol   class string\n  string str  String type is misspelled as string\n  \njshell list\n   1  2  2\n   2  int x  100\njshell list all\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\n   1  2  2\n   2  int x  100\n  e1  string str  String type is misspelled as string\njshell drop 1\n  dropped variable 1\njshell list\n   2  int x  100\njshell drop x\n  dropped variable x\njshell list\njshell list all\n  s1  import javaioChapter 23  Java Shell\n901  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\n   1  2  2\n   2  int x  100\n  e1  string str  String type is misspelled as string\njshell exit\n  Goodbye\nThe names of variables methods and classes become the snippet names Note that Java allows you to \nhave a variable a method and a class with the same name because they occur in their own namespaces You \ncan use the names of these entities to list them using the list  command\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell list x\n  No such snippet x\njshell int x  100\nx  100\njshell list x\n   1  int x  100\njshell void x \n  created method x\njshell list x\n   1  int x  100\n   2  void x \njshell void xint n \n  created method xint\njshell list x\n   1  int x  100\n   2  void x \n   3  void xint n \njshell class x \n  created class x\njshell list x\n   1  int x  100\n   2  void x \n   3  void xint n \n   4  class x \njshell exit\n  GoodbyeChapter 23  Java Shell\n902 Editing Snippets\nThe JShell tool offers several ways to edit snippets and commands You can use navigation keys listed in \nTable\u00a0 231  to navigate on the command line while entering snippets and commands in jshell  You can use \nkeys listed in Table\u00a0 232  to edit text entered on a line in jshell \nIt is hard to edit multiline snippets in jshell  even though you have access to a rich set of edit key \ncombinations The tool designer realized this problem and provided a builtin snippet editor You can \nconfigure the tool to use the platformspecific snippet editor of your choice Refer to the section entitled \nSetting the Snippet Editor for more information on how to set up your own editor\nYou need to use the edit  command to start editing a snippet The command takes three forms\n\tedit snippetname\n\tedit snippetid\n\tedit\nYou can use the snippet name or snippet ID to edit a specific snippet The edit  command without an \nargument opens all active snippets in an editor for editing By default the edit  command opens a builtin \neditor called JShell Edit Pad and it is shown in Figure\u00a0 233 Table 232  Keys to Modify Text in the JShell Tool\nKey Description\nDelete Deletes character under the cursor\nBackspace Deletes character before the cursor\nCtrlK Deletes the text from the cursor to the end of the line\nMetaD or AltD Deletes the text from the cursor to the end of the word\nCtrlW Deletes the text from the cursor to the previous whitespace\nCtrlY Pastes or yanks the most recently deleted text into the line\nMetaY or AltY After CtrlY this key combination cycles through previously deleted textTable 231  Navigation Keys While Editing in the JShell Tool\nKey Description\nEnter Enters the current line\nLeft arrow Moves one character backward\nRight arrow Moves one character forward\nCtrlA Moves to the beginning of the line\nCtrlE Moves to the end of the line\nMetaB or AltB Moves a word backward\nMetaF or AltF Moves a word forwardChapter 23  Java Shell\n903JShell Edit Pad is written in Swing and it shows a JFrame  with a JTextArea  and three JButton s If you \nedit snippets make sure to click the Accept button before exiting the window so that the editing takes effect \nIf you cancel out or exit the editor without accepting the changes your edits will be lost\nIf you know the name of a variable a method or a class you can edit it using its name The following \njshell  session creates a variable methods and a class with the same name x and uses the edit x  \ncommand to edit them all at once\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell int x  100\nx  100\njshell void x\n  created method x\njshell void x int n \n  created method xint\njshell class x\n  created class x\njshell 2  2\n5  4\njshell edit x\nThe edit x  command opens all snippets with the name x in JShell Edit Pad as shown in Figure\u00a0 234  \nYou can edit these snippets accept the changes and exit the editing to continue with the jshell  session\nFigure 233  The b uiltin JShell editor called JShell Edit PadChapter 23  Java Shell\n904 Rerunning Previous Snippets\nIn a commandline tool like jshell  youll often want to rerun previous snippets You can use the updown \narrows to navigate through the snippetcommand history and then press the Enter key when you are on a \nprevious snippetcommand You can also use one of the three commands to rerun previous snippets not \ncommands\n\t\n\tsnippetid\n\tn\nThe  command reruns the last snippet The snippetid  command reruns the snippet identified \nby snippetid  The n  command reruns the nth last snippet For example 1 reruns the last snippet \n2 reruns the second last snippet and so on The  and 1 commands have the same effectthey both \nrerun the last snippet\n Declaring Variables\nYou can declare variables in jshell  as you do in Java programs A variable declaration may occur at the \ntop level inside a method or as a field declaration within a class The static  and final  modifiers are not \nallowed in toplevel variable declarations If you use them they will be ignored with a warning The static  \nmodifier specifies a class context and the final  modifier restricts you from changing the variables value \nYou are not allowed to use these modifiers because the tool allows you to declare freestanding variables that \nyou would like to experiment with by changing their values over time The following examples show you how \nto declare variables\nFigure 234  Editing snippets by nameChapter 23  Java Shell\n905jshell int x\nx  0\njshell int y  90\ny  90\njshell side  90\n  Error\n  cannot find symbol\n    symbol   variable side\n  side  90\n  \njshell static double radius  267\n  Warning\n  Modifier static   not permitted in toplevel declarations ignored\n  static double radius  267\n  \nradius  267\njshell String str  new StringHello\nstr  Hello\njshell\nUsing an undeclared variable in toplevel expressions generates an error Notice the use of an \nundeclared variable named side  in the previous example which generated an error We will show you later \nthat you can use an undeclared variable inside a methods body\nIt is also possible to change the data type of a variable You can declare a variable named x as an int and \nredeclare it later as a double  or a String  The following examples show this feature\njshell int x  10\nx  10\njshell int y  x  2\ny  12\njshell double x  271\nx  271\njshell y\ny  12\njshell String x  Hello\nx  Hello\njshell y\ny  12\njshell\nNotice that the value of the variable named y did not change or was not reevaluated when the data type \nor the value of x changed\nYou can also drop a variable using the drop  command which takes the variable name as an argument \nThe following command will drop the variable named x\njshell drop xChapter 23  Java Shell\n906You can list all variables in jshell  using the vars  command It will list userdeclared variables and \nthe variables automatically declared by jshell  which happens while jshell  evaluates resultbearing \nexpressions The command has the following forms\n\tvars\n\tvars variablename\n\tvars variablesnippetid\n\tvars start\n\tvars all\nThe command without an argument lists all active variables in the current session If you use a snippet \nname or ID it lists the variable declaration with that snippet name or ID\u00a0If you use it with the start  option \nit lists all variables added to the startup script If you use it with the all  option it lists all variables including \nfailed overwritten dropped and startup The following examples show you how to use the vars  command\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell vars\njshell 2  2\n1  4\njshell vars\n    int 1  4\njshell int x  20\nx  20\njshell vars\n    int 1  4\n    int x  20\njshell String str  Hello\nstr  Hello\njshell vars\n    int 1  4\n    int x  20\n    String str  Hello\njshell double x  9099\nx  9099\njshell vars\n    int 1  4\n    String str  Hello\n    double x  9099\njshell drop x\n  dropped variable x\njshell vars\n    int 1  4\n    String str  Hello\njshellChapter 23  Java Shell\n907 Import Statements\nYou can use import  statements in jshell  Recall that in a Java program all types in the javalang  \npackage are imported by default To use types from other packages you need to add appropriate import  \nstatements in your compilation unit We start with an example We try to create three objects a String  a \nListInteger  and a ZonedDateTime  Note that the String  class is in the javalang  package the List  and \nInteger  classes are in the javautil  and javalang  packages respectively and the ZonedDateTime  class is \nin the javatime  package\njshell String str  new StringHello\nstr  Hello\njshell ListInteger nums  Listof1 2 3 4 5\nnums  1 2 3 4 5\njshell ZonedDateTime now  ZonedDateTimenow\n  Error\n  cannot find symbol\n    symbol   class ZonedDateTime\n  ZonedDateTime now  ZonedDateTimenow\n  \n  Error\n  cannot find symbol\n    symbol   variable ZonedDateTime\n  ZonedDateTime now  ZonedDateTimenow\n                      \njshell\nThe examples generate an error if you try to use the ZonedDateTime  class from the javatime  package \nWe are also expecting a similar error when we try to create a List  because it is in the javautil  package \nwhich is not imported in a Java program by default\nThe sole purpose of the JShell tool is to make developers lives easier when evaluating snippets To \nachieve this goal the tool imports all types from a few packages by default What are those default packages \nwhose types are imported You can print a list of all active imports  in jshell  using the imports  command\njshell imports\n    import javaio\n    import javamath\n    import javanet\n    import javaniofile\n    import javautil\n    import javautilconcurrent\n    import javautilfunction\n    import javautilprefs\n    import javautilregex\n    import javautilstream\njshell\nNotice the default import  statement that imports all types from the javautil  package This is the \nreason that you can use List  without importing it You can also add your own imports to jshell  The \nfollowing example shows you how to import the ZonedDateTime  class and use it You will get different output \nwhen jshell  prints the value of the current date with the time zoneChapter 23  Java Shell\n908jshell imports\n    import javautil\n    import javaio\n    import javamath\n    import javanet\n    import javautilconcurrent\n    import javautilprefs\n    import javautilregex\njshell import javatime\njshell imports\n    import javaio\n    import javamath\n    import javanet\n    import javaniofile\n    import javautil\n    import javautilconcurrent\n    import javautilfunction\n    import javautilprefs\n    import javautilregex\n    import javautilstream\n    import javatime\njshell ZonedDateTime now  ZonedDateTimenow\nnow  20170819T1301330607082000500AmericaChicago\njshell\nNote that any imports you add to the jshell  session will be lost when you exit the session You can also \ndrop import  statementsthe default imports and the ones you added You need to know the snippet ID to \ndrop a snippet The IDs for startup snippets are s1 s2 s3 etc and for userdefined snippets they are 1 2 3 \netc The following examples show you how to add and drop import  statements in jshell \nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell import javatime\njshell ListInteger list  Listof1 2 3 4 5\nlist  1 2 3 4 5\njshell ZonedDateTime now  ZonedDateTimenow\nnow  20170219T2108088020990600AmericaChicago\njshell list all\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\n   1  import javatime\n   2  ListInteger list  Listof1 2 3 4 5Chapter 23  Java Shell\n909   3  ZonedDateTime now  ZonedDateTimenow\njshell drop s5\njshell drop 1\njshell list all\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\n   1  import javatime\n   2  ListInteger list  Listof1 2 3 4 5\n   3  ZonedDateTime now  ZonedDateTimenow\njshell imports\n    import javaio\n    import javamath\n    import javanet\n    import javaniofile\n    import javautilconcurrent\n    import javautilfunction\n    import javautilprefs\n    import javautilregex\n    import javautilstream\njshell ListInteger list2  Listof1 2 3 4 5\n  Error\n  cannot find symbol\n    symbol   class List\n  ListInteger list2  Listof1 2 3 4 5\n  \n  Error\n  cannot find symbol\n    symbol   variable List\n  ListInteger list2  Listof1 2 3 4 5\n                        \njshell import javautil\n    update replaced variable list reset to null\njshell ListInteger list2  Listof1 2 3 4 5\nlist2  1 2 3 4 5\njshell list all\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunction\n  s8  import javautilprefsChapter 23  Java Shell\n910  s9  import javautilregex\n s10  import javautilstream\n   1  import javatime\n   2  ListInteger list  Listof1 2 3 4 5\n   3  ZonedDateTime now  ZonedDateTimenow\n  e1  ListInteger list2  Listof1 2 3 4 5\n   4  import javautil\n   5  ListInteger list2  Listof1 2 3 4 5\njshell imports\n    import javaio\n    import javamath\n    import javanet\n    import javaniofile\n    import javautilconcurrent\n    import javautilfunction\n    import javautilprefs\n    import javautilregex\n    import javautilstream\n    import javautil\njshell\n Method Declarations\nYou can declare and call methods in jshell  You can declare toplevel methods which are methods that are \nentered in jshell  directly and are not inside any class You can also declare classes see the next section \nwith methods In this section we show you how to declare and call toplevel methods You can also call \nmethods of existing classes The following example declares a method named square  and calls it\njshell long squareint n \n       return n  n\n    \n  created method squareint\njshell square10\n2  100\njshell long n2  square37\nn2  1369\njshell\nForward references are allowed inside a methods body That is you can refer to methods or variables \nwhich are not declared yet inside a methods body The method being declared cannot be called until all \nmissing references are defined\njshell long multiplyint n \n        return multiplier  n\n    \n  created method multiplyint however it cannot be invoked until variable multiplier is \ndeclared\njshell multiply10Chapter 23  Java Shell\n911  attempted to call method multiplyint which cannot be invoked until variable multiplier \nis declared\njshell int multiplier  2\nmultiplier  2\njshell multiply10\n6  20\njshell void printCubeint n \n        SystemoutprintfCube of d is dn n cuben\n    \n  created method printCubeint however it cannot be invoked until method cubeint is \ndeclared\njshell long cubeint n \n        return n  n  n\n    \n  created method cubeint\njshell printCube10\nCube of 10 is 1000\njshell\nThis example declares a method named multiplyint n  It multiplies the argument with a variable \nnamed multiplier  which has not been declared yet Notice the feedback after you declare this method \nThe feedback clearly states that you cannot call the multiply  method until you declare the multiplier  \nvariable Calling the method generates an error Later the multiplier  variable is declared and the \nmultiply  method is called successfully\n Ti p Y ou can also declare a recursive method using a forward reference\n Type Declarations\nYou can declare all types such as classes interfaces enums and annotations in jshell  as you do in Java The \nfollowing jshell  session creates a class named Counter  creates its object and calls its methods\njshell class Counter \n        private int counter\n        public synchronized int next \n            return counter\n        \n   \n        public int current \n            return counter\n        \n    \n  created class Counter\njshell Counter c  new Counter\nc  Counter25bbe1b6\njshell ccurrent\n3  0\njshell cnextChapter 23  Java Shell\n9124  1\njshell cnext\n5  2\njshell ccurrent\n6  2\njshell\nYou can use the types  command to print a list of all declared types in jshell  The command has the \nfollowing forms\n\ttypes\n\ttypes typename\n\ttypes snippetid\n\ttypes start\n\ttypes all\nThe command without an argument lists the current active jshell  classes interfaces enums and \nannotations Commands with a type name and a snippet ID argument list types with the specified name \nand specified snippet ID respectively The command with the start  option lists the automatically added \nstartup types The command with the all  option lists all types including failed overwritten dropped and \nstartup The following jshell  is a continuation of the previous example session it shows how to print all \nactive types defined in a jshell  session\njshell types\n    class Counter\njshell\nThe Counter  class is small You may quickly realize that it is not easy to enter the source code for bigger \nclasses on a command line You may want to use your favorite Java source code editor such as NetBeans to \nwrite the source code and quickly test your classes in jshell  You can open a source code file as a source \ninput in jshell  using the open  command The syntax is as follows\nopen filepath\nYou can find the source code for the Counter  class in the bj9fsrcjdojojshellCounterjava  file \nThe following jshell  session shows you how to open the saved Counterjava  file in jshell  It is assumed \nthat you have saved the source code for this book in C on Windows If you are using another operating \nsystem just follow the file path naming convention for your operating system and your directory structure to \nuse the following example\njshell open Cbj9fsrcjdojojshellCounterjava\njshell Counter c  new Counter\nc  Counter25bbe1b6\njshell ccurrent\n3  0\njshell cnext\n4  1\njshell cnextChapter 23  Java Shell\n9135  2\njshell ccurrent\n6  2\njshell\nNote that the source code for the Counter  class does not contain a package declaration because jshell  \ndoes not allow you to declare a class or any type in a package All types that you declare in jshell  are \nconsidered static types of an internal synthetic class However you may want to test your own class that is in \na package You can use an already compiled class which is in a package in jshell  You will usually need it \nwhen you are using libraries to develop your application and you want to experiment with your application \nlogic by writing snippets against library classes You will need to set the class path using the env  command \nso your classes may be found\nA Person  class in the comjdojojshell  package is included in the books source code The class \ndeclaration is shown in Listing 232 \nListing 232  The S ource Code for a Person Class\n Personjava\npackage comjdojojshell\npublic class Person \n    private String name\n    public Person \n        thisname  Unknown\n    \n    public PersonString name \n        thisname  name\n    \n    public String getName \n        return name\n    \n    public void setNameString name \n        thisname  name\n    \n\nThe following jshell  session sets the class path on Windows assuming the source code for this book \nwas stored in C Use the syntax for the class path string for your operating system and the source code \nlocation on your computer if they are different from the assumed\njshell env classpath CJavaFunbuildmodulesjdojojshell\n  Setting new options and restoring state\njshell Person guy  new PersonMartin Guy Crawford\n  Error\n  cannot find symbol\n    symbol   class Person\n  Person guy  new PersonMartin Guy Crawford\n  \n  Error\n  cannot find symbol\n    symbol   class Person\n  Person guy  new PersonMartin Guy Crawford\n                   Chapter 23  Java Shell\n914Do you know the reason for this error We used the simple name of the class Person  without importing \nit and jshell  was not able to locate the class We need to import the Person  class or use its fully qualified \nname The following is a continuation of this jshell  session that fixes this error\njshell import comjdojojshellPerson\njshell Person guy  new PersonMartin Guy Crawford\nguy  comjdojojshellPerson192b07fd\njshell guygetName\n9  Martin Guy Crawford\njshell guysetNameForrest Butts\njshell guygetName\n11  Forrest Butts\njshell\n Setting the\u00a0Execution Environment\nIn the previous section you learned how to set the classpath using the env  command The command can \nbe used to set many other components of the execution context such as the module path You can also use it \nto resolve modules so you can use types in modules on jshell  Its complete syntax is as follows\nenv classpath path modulepath path addmodules modules\naddexports mpn\nThe env  command without arguments prints values for the current execution context The class\npath  option sets the class path The modulepath  option sets the module path The addmodules  option \nadds modules to the default set of root modules so they can be resolved The  addexports  option exports \nnonexported packages from a module to a set of modules These options have the same meanings as they \nhave when used with the javac  and java  commands\n Tip On the command line these options must start with two dashes hyphens  for example module\npath  In jshell  they can start with one dash or two dashes For example both modulepath  and  \n modulepath  are allowed in jshell \nWhen you set the execution context the current session is reset and all previously executed snippets in \nthe current session are replayed in quiet mode That is the replayed snippets are not shown However errors \nduring the replay will be shown\nYou can set the execution context using the env  reset  and reload  commands Each of these \ncommands has different effects The meaning of the context options such as classpath  and modulepath  \nis the same You can list all options that can be used to set the execution context using the command help \ncontext \nLets walk through an example of using the modulerelated settings using the env  command You \ncreated a jdojointro  module in Chapter 3 The module contains a package named comjdojointro  but \nit does not export the package Now you want to call the static mainString args  method of the Welcome  \nclass in the nonexported package Here are the steps you need to perform in jshell Chapter 23  Java Shell\n915 1 Set the module path so the module will be found\n 2 Resolve the module by adding it to the default set of root modules You can do \nthis using the addmodules  option with the env  command\n 3 Export the package using the addexports  command The snippets entered \nin jshell  are executed in an unnamed module so you will need to export the \npackage to all unnamed modules using the ALLUNNAMED  keyword If you do not \nsupply target modules in the addexports  option ALLUNNAMED  is assumed and \nthe package is exported to all unnamed modules\n 4 Option ally import the comjdojointroWelcome  class if you want to use its \nsimple name in snippets\n 5 Now you will be able to call the Welcomemain  method from jshell \nThe following jshell  session shows you how to perform these steps It is assumed that you are \nlaunching the jshell  session with CJavaFun  as the current directory and the CJavaFunbuildmodules\njdojointro  directory contains the compiled code for the jdojointro  module If your directory structure \nand the current directory are different substitute the directory paths used in the session with yours\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell env modulepath buildmodulesjdojointro\n  Setting new options and restoring state\njshell env addmodules jdojointro\n  Setting new options and restoring state\njshell env addexports jdojointrocomjdojointroALLUNNAMED\n  Setting new options and restoring state\njshell import comjdojointroWelcome\njshell Welcomemainnull\nWelcome to Java 17\njshell env\n     addmodules jdojointro\n     modulepath buildmodulesjdojointro\n     addexports jdojointrocomjdojointroALLUNNAMED\njshell\n No Checked Exceptions\nIn a Java program if you call a method that throws checked exceptions you must handle those exceptions \nusing a trycatch  block or by adding a throws  clause The JShell tool is supposed to be a quick and easy way \nto evaluate snippets so you do not need to handle checked exceptions in your snippets If a snippet throws a \nchecked exception when its executed jshell  will print the stack trace and continue\njshell FileReader fr  new FileReadersecretstxt\n    javaioFileNotFoundException thrown secretstxt The system cannot find the file \nspecified\n        at FileInputStreamopen0 Native Method\n        at FileInputStreamopen FileInputStreamjava196\n        at FileInputStreaminit FileInputStreamjava139\n        at FileInputStreaminit FileInputStreamjava94Chapter 23  Java Shell\n916        at FileReaderinit FileReaderjava58\n        at 11\njshell\nThis snippet threw a FileNotFoundException  because a file named secretstxt  does not exist in the \ncurrent directory If the file existed you were able to create a FileReader  without having to use a trycatch  \nblock Note that if you try to use this snippet inside a method the normal Java syntax rule applies and your \nmethod declaration will not compile\njshell void readSecrets \n    FileReader fr  new FileReadersecretstxt\n     More code goes here\n    \n  Error\n   unreported exception javaioFileNotFoundException must be caught or declared to be \nthrown\n  FileReader fr  new FileReadersecretstxt\n                  \njshell\n Autocompletion\nThe JShell  tool has an autocompletion feature that you can invoke by entering partial text and pressing \nthe Tab key This feature is available when you are entering a command or a snippet The tool will detect \nthe context and help you autocomplete the command When there are multiple possibilities it shows \nall possibilities and you will need to enter one of them manually When it finds a unique possibility it \nwill complete the text To see the full description of autocomplete shortcuts use the help shortcuts  \ncommand There are three autocomplete key combinations\n\t Tab\n\t ShiftTabV\n\t ShiftTabI\nPress the Tab key in the middle of an expression and jshell  will complete the expression or show you \npossible options Pressing ShiftTabV lets you convert an expression into a variable declaration The V in \nthe shortcut stands for variable Pressing ShiftTabI lets you import types for unresolvable identifiers We \ndiscuss examples of these shortcuts in detail\nThe following is an example of the tool finding multiple possibilities You need to enter e and press \nTab Tab  in the command indicates that you need to press Tab\njshell e Tab\nedit env exit\npress tab again to see synopsis\njshell e Tab\nedit\nedit a source entry referenced by name or id\nenv\nview or change the evaluation context\nexitChapter 23  Java Shell\n917exit jshell\npress tab again to see full documentation\njshell\nThe tool detected that you were trying to enter a command because your text started with a slash   \nThere are three commands  edit  env  and exit  that start with e and they are printed for you Now you \nwill need to complete the command yourself by entering the rest of the command In the case of commands \nif you enter just enough text to make the command name unique and press Enter the tool will execute that \ncommand In this case you can enter ed en or ex and press Enter to execute the edit  env  or exit  \ncommand respectively If you are shown multiple options after you press Tab you can press Tab again to see \na description of all options Pressing Tab the third time shows you full documentation of all options If you \ntry this to autocomplete a Java expression you can view the entire Javadoc for Java entities such as a classs \nmethod\nYou can enter a slash   and press Tab to see a list of all available jshell  commands\njshell \n                    drop       edit       env        exit       help       history\nimports     list       methods     open       reload      reset      save       set\ntypes      vars\npress tab again to see synopsis\nThe following snippet creates a String  variable named str with an initial value of GoodBye \njshell String str  GoodBye\nstr  GoodBye\nContinuing with this jshell  session enter str  and press Tab\njshell strTab\ncharAt                chars                codePointAt            codePointBefore\ncodePointCount         codePoints            compareTo              compareToIgnoreCase\nconcat                contains               contentEquals          endsWith\nequals                equalsIgnoreCase       getBytes               getChars\ngetClass              hashCode              indexOf                intern\nisEmpty               lastIndexOf            length                matches\nnotify                notifyAll             offsetByCodePoints     regionMatches\nreplace                replaceAll             replaceFirst           split\nstartsWith             subSequence            substring              toCharArray\ntoLowerCase            toString              toUpperCase            trim\nwait\njshell str\nThis snippet printed all method names for the String  class that you can invoke on the variable str \nNotice that a few method names end with  and others end with only  This is not a bug If a method takes \nno arguments its name is followed with a  If a method takes arguments its name is followed with a \nContinuing with this example enter strsub  and press Tab\njshell strsub Tab\nsubSequence    substringChapter 23  Java Shell\n918This time the tool found two methods in the String  class that start with sub You can enter the entire \nmethod call strsubstring0 4  and press Enter  to evaluate the snippet\njshell strsubstring0 4\n2  Good\nAlternatively you can let the tool autocomplete the method name by entering strsubs  When you \nenter strsubs  and press Tab the tool completes the method name inserts a  and waits for you to enter \nthe arguments for the method\njshell strsubstring\nsubstring\njshell strsubstring\nNow you can enter the methods arguments and press Enter to evaluate the expression\njshell strsubstring0 4\n3  Good\njshell\nWhen a method takes arguments most likely you would like to see those arguments types You can see \nthe methods synopsis by pressing Tab after you enter the entire methodconstructor name and an opening \nparenthesis In the previous example if you enter strsubstring  and press Tab the tool will print the \nsynopsis for the substring  method\njshell strsubstring\nSignatures\nString Stringsubstringint beginIndex\nString Stringsubstringint beginIndex int endIndex\npress tab again to see documentation\njshell strsubstring\nNotice the output It says if you press Tab again it will show you the Javadoc for the substring  \nmethod In the following prompt we pressed Tab again to print the Javadoc If more of the Javadoc needs to \nbe displayed press the Tab again\nAt times you enter an expression and want to assign the value of the expression to a variable of the \nappropriate type Sometimes you know the type and sometimes you dont The JShell  tool will help you \nautocomplete the assignment part after you enter the complete expression Enter the complete expression \nand then press ShiftTab Now press V  which will autocomplete the expression assignment by adding the \nappropriate variable type and placing the cursor to the position where you can enter the variable name The \nsequence of key presses is as follows\n 1 Press Shift\n 2 Keep holding down Shift and press Tab\n 3 Release Tab\n 4 Release Shift\n 5 Press V \nLets walk through these steps Enter the expression 2  2  into jshell \njshell 2  2Chapter 23  Java Shell\n919Now press the sequence of keys as listed previously jshell  autocompletes the assignment expression \nand waits for you to enter the variable name\njshell int    2  2\nThe cursor is placed just before the  symbol Enter x as the variable name and press Enter\njshell int x  2  2\nx  4\njshell\nLets use the ShiftTabI shortcut to import a missing import for an unresolved identifier You need to \npress the key combination in the following order\n 1 Press Shift\n 2 Keep holding down Shift and press Tab\n 3 Release Tab\n 4 Release Shift\n 5 Press I\n 6 jshell  will print the possible import statements with option numbered 0 1 2 3 \netc jshell  waits for you to enter an option\n 7 Enter the option number and jshell  will execute the import  statement\nSuppose you want to use the LocalDate  class from the javatime  package The following jshell  \nsession will show you how to import the javatimeLocalDate  class using the shortcut keys You need to \npress the ShiftTabI shortcut just after entering LocalDate  on jshell \njshell LocalDate\n0 Do nothing\n1 import javatimeLocalDate\nChoice\nImported javatimeLocalDate\njshell LocalDatenow\n1  20170819\n History of\u00a0Snippets and\u00a0Commands\nJShell maintains a history of all commands and snippets that you enter in all sessions You can navigate \nthrough the history using the up and down arrow keys You can also use the history  command to print the \nhistory of all you typed in the current session\njshell 2  2\n1  4\njshell SystemoutprintlnHello\nHello\njshell history\n2  2Chapter 23  Java Shell\n920SystemoutprintlnHello\nhistory\njshell\nAt this point pressing the up arrow once shows history  pressing it twice shows Systemout\nprintlnHello  and pressing it three times shows 2  2  Pressing the up arrow a fourth time will show \nyou the last entered commandsnippet from the previous jshell  session If you want to execute a previously \nentered snippetcommand use the up arrow until the desired commandsnippet is shown and then press \nEnter to execute it Pressing the down arrow navigates you to the next command or snippet in the list \nSuppose you press the up arrow five times to navigate to the fifth last snippetcommand Now pressing \nthe down arrow will navigate you to the fourth last snippetcommand When you are at the first or the last \nsnippetcommand pressing the up arrow or the down arrow does nothing\n Reading JShell Stack Trace\nSnippets entered on jshell  are part of a synthetic class Java does not let you declare a toplevel method A \nmethod declaration must be part of a type When an exception is thrown in a Java program the stack trace \nprints the type names and the line numbers In jshell  an exception may be thrown from a snippet Printing \nthe synthetic class name and line numbers in such cases will be misleading and will make no sense to \ndevelopers The format for the location of the code in snippets in the stack trace is in this form\nat snippetname snippetidlinenumberinsnippet\nNote that some snippets may not have a name For example entering a snippet 2  2  will not give it a \nname Some snippets have names such as a snippet declaring a variable being assigned the same name as \nthe variables name the same goes with a method and a type declaration Sometimes you may have two \nsnippets with the same name for example by declaring a variable and a methodtype with the same name \njshell  assigns a unique snippet ID to all snippets You can find the ID of a snippet using the list all  \ncommand\nThe following jshell  session declares a divide  method and prints the exception stack trace with a \nruntime ArithmeticException  exception that is thrown when an integer is divided by zero\njshell int divideint x int y \n    return xy\n    \n  created method divideintint\njshell divide10 2\n2  5\njshell divide10 0\n  javalangArithmeticException thrown  by zero\n        at divide 12\n        at 31\njshell list all\n  s1  import javaio\n  s2  import javamath\n  s3  import javanet\n  s4  import javaniofile\n  s5  import javautil\n  s6  import javautilconcurrent\n  s7  import javautilfunctionChapter 23  Java Shell\n921  s8  import javautilprefs\n  s9  import javautilregex\n s10  import javautilstream\n   1  int divideint x int y \n       return xy\n       \n   2  divide10 2\n   3  divide10 0\njshell\nLets try to read the stack trace The last line at 31  is stating that the exception was caused at \nline 1 of snippet number 3 Notice in the output of the list all  command that snippet number 3 is the \nexpression divide10 0  that caused the exception The second line at divide 12  is indicating that \nthe second level in the stack trace is at line 2 of the snippet named divide  whose snippet ID is 1 and the line \nnumber is 2\n Reusing JShell Sessions\nYou can enter many snippets and commands in a jshell  session and may want to reuse them in other \nsessions  You can use the save  command to save commands and snippets to a file and use the open  \ncommand to load the previously saved commands and snippets The syntax for the save  command is as \nfollows\nsave option filepath\nHere option  can be one of the options all  history  and start  filepath  is the file path \nwhere the snippetscommands will be saved\nThe save  command with no option saves all active snippets in the current session Note that it does \nnot save any commands or failed snippets\nThe save  command with the all  option saves all snippets for the current session to the specified file \nincluding failed and startup snippets Note that it does not save any commands\nThe save  command with the history  option saves everything that you typed in jshell  since it was \nlaunched\nThe save  command with the start  option saves the default startup definitions to the specified file\nYou can reload the snippets from a file using the open  command The command takes the file name as \nan argument\nThe following jshell  session declares a class named Counter  creates its object and invokes methods \non the object Finally it saves all active snippets to a file named jshelljsh  Note that the file extension jsh  \nis customary for jshell  files You can use any other extension you want\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell class Counter \n       private int count\n       public synchronized int next \n         return count\n       Chapter 23  Java Shell\n922       public int current \n         return count\n       \n    \n  created class Counter\njshell Counter counter  new Counter\ncounter  Counter25bbe1b6\njshell countercurrent\n3  0\njshell counternext\n4  1\njshell counternext\n5  2\njshell countercurrent\n6  2\njshell save jshelljsh\njshell exit\n  Goodbye\nAt this point you should have a file named jshelljsh  in your current directory with the contents \nshown in Listing 233 \nListing 233  Con tents of the jshelljsh File\nclass Counter \n   private int count\n   public synchronized int next \n     return count\n   \n   public int current \n     return count\n   \n\nCounter counter  new Counter\ncountercurrent\ncounternext\ncounternext\ncountercurrent\nThe following jshell  session opens the jshelljsh  file which will replay all the snippets that were \nsaved in the previous session After opening the file you can start calling methods on the counter  variable\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell open jshelljsh\njshell countercurrent\n7  2\njshell counternext\n8  3\njshellChapter 23  Java Shell\n923 Resetting the\u00a0JShell State\nYou can reset the JShells execution state using the reset  command Executing this command has the \nfollowing effects\n\t All snippets you enter in the current session are lost so be careful before you execute \nthis command\n\t The startup snippets are reexecuted\n\t The execution state of the tool is restarted\n\t The jshell  configurations that were set using the set  command are retained\n\t The execution environment set using the env  command is retained\nThe following jshell  session declares a variable resets the session and attempts to print the variables \nvalue Note that on resetting a session all declared variables are lost so the variable previously declared is \nnot found\njshell int x  987\nx  987\njshell reset\n  Resetting state\njshell x\n  Error\n  cannot find symbol\n    symbol   variable x\n  x\n  \njshell\n Reloading the\u00a0JShell State\nSuppose you used many snippets in a jshell  session and exited the session Now you want to go back  \nand replay those snippets One way to do it is to start a new jshell  session and reenter those snippets  \nReentering several snippets in jshell  is a hassle There is an easy way to achieve thisby using the  \nreload  command The reload  command resets the jshell  state and replays all valid snippets and drop  \ncommands in the same sequence they were entered before You can use the restore  and quiet  options to \ncustomize its behavior\nThe reload  command without any options resets the jshell  state and replays the valid history from \none of the following prior actionsevents whichever occurred last\n\t Beginning of the current session\n\t When the last reset  command was executed\n\t When the last reload  command was executed\nYou can use the restore  option with the reload  command It resets and replays the history between \nthe following two actionsevents whichever are the last two\n\t The launch of jshell\n\t Execution of the reset  command\n\t Execution of the reload  commandChapter 23  Java Shell\n924The effect of executing the reload  command with the restore  option is a little tricky to understand \nIts primary purpose is to restore the previous execution state If you execute this command in the beginning \nof every jshell  session starting from the second session your session will contain all snippets you had ever \nexecuted in jshell  sessions This is a powerful feature That is you can evaluate snippets close jshell  \nrestart jshell  and execute the reload restore  command as your first command and you never lose any \nsnippets that you previously entered Sometimes you will execute the reset  command twice in a session \nand want to restore the state that existed between those two resets You can achieve this result by using this \ncommand\nThe following jshell  sessions create a variable in each session and restore the previous session by \nexecuting the reload restore  command in the beginning of each session The example shows that the \nfourth session uses the variable named x1 that was declared in the first session\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell int x1  10\nx1  10\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell reload restore\n  Restarting and restoring from previous state\n int x1  10\njshell int x2  20\nx2  20\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell reload restore\n  Restarting and restoring from previous state\n int x1  10\n int x2  20\njshell int x3  30\nx3  30\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell reload restore\n  Restarting and restoring from previous state\n int x1  10\n int x2  20\n int x3  30\njshell Systemoutprintlnx1 is   x1\nx1 is 10\njshellChapter 23  Java Shell\n925The reload  command displays the history that it replays You can use the quiet  option to suppress \nthe replay display You can use this option with or without the restore  option The quiet  option does not \nsuppress the error messages that may be generated while replaying the history The following example uses \ntwo jshell  sessions The first session declares a variable named x1 The second session uses the quiet  \noption with the reload  command Note that this time you did not see the replay display that the variable \nx1 was reloaded in the second session because you used the quiet  option\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell int x1  10\nx1  10\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell reload restore quiet\n  Restarting and restoring from previous state\njshell x1\nx1  10\njshell\n Configuring JShell\nUsing the set  command you can customize the jshell  session ranging from startup snippets and commands \nto setting a platformspecific snippet editor In this section we explain those customizations in detail\n Setting the\u00a0Snippet Editor\nThe JShell  tool comes with a default snippet editor In jshell  you can use the edit  command to edit all \nsnippets or a specific snippet The edit  command opens the snippet in an editor The snippet editor is a \nplatformspecific program such as notepadexe  on Windows that will be invoked to edit snippets You can \nuse the set  command with editor  as an argument to set or delete an editor setting The valid forms of the \ncommand are as follows\n\tset editor retain wait command\n\tset editor retain default\n\tset editor retain delete\nIf you use the retain  option the setting will persist across jshell  sessions\nIf you specify a command the command must be platformspecific That is you need to specify a \nWindows command on Windows a UNIX command on UNIX and so on The command may contain flags \nThe JShell  tool will save the snippets to be edited in a temporary file and will append the name of the \ntemporary file to the command You cannot work with jshell  while an editor is open If your editor exits \nimmediately you should specify the wait  option which will make jshell  wait until the editor is closed \nThe following command sets Notepad as an editor on Windows\njshell set editor retain notepadexeChapter 23  Java Shell\n926The default  option sets the snippet editor to the default editor The delete  option deletes the current \neditor setting If the retain  option is used with the delete  option the retained editor setting is deleted\njshell set editor retain delete\n  Editor set to default\njshell\nThe editor set in one of the following environment variables JSHELLEDITOR  VISUAL  or EDITOR takes \nprecedence over the default editor These environment variables are looked up for an editor in order If none \nof these environment variables is set the default editor is used The intent behind all these rules is to have \nan editor all the time and then use the default editor as a fallback The set editor  command without any \narguments and options prints information about the current editor setting\nThe following jshell  session sets Notepad as an editor on Windows Note that this example will not \nwork on platforms other than Windows where you need to specify your platformspecific program as an \neditor\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set editor\n  set editor default\njshell set editor retain notepadexe\n  Editor set to notepadexe\n  Editor setting retained notepadexe\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set editor\n  set editor retain notepadexe\njshell 2  2\n1  4\njshell edit\njshell set editor retain delete\n  Editor set to default\njshell exit\n  Goodbye\nCJavaFunSET JSHELLEDITORnotepadexe\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set editor\n  set editor notepadexe\njshellChapter 23  Java Shell\n927 Setting Feedback Mode\nWhen you execute a snippet or a command jshell  prints feedback The amount and format of the feedback \ndepends on the feedback mode  You can use one of the four predefined feedback modes or a custom \nfeedback mode\n\tsilent\n\tconcise\n\tnormal\n\tverbose\nThe silent  mode gives you no feedback at all and the verbose  mode gives you the most feedback \nThe concise  mode gives you the same feedback as the normal  mode but in a compact format The default \nfeedback mode is normal \nTable 233  shows the details of each builtin feedback mode The Prompt column contains the \nprompt where n indicates a new line Other columns show where a feedback is shown or not and if it is \nshown what the format of the feedback is Declaration Update and Command columns show whether \nthe feedbacks are shown for declarations updates to existing snippets and commands respectively The \nSnippet with a Value column shows the format of the feedback when a resultbearing snippet is entered\nThe command to set the feedback mode is as follows\nset feedback retain mode\nHere mode  is one of the four feedback modes Use the retain  option if you want to persist the \nfeedback mode across the jshell  sessions\nYou can also launch jshell  in a specific feedback mode\njshell feedback mode\nThe following command starts jshell  in verbose  feedback mode\nCJavaFunjshell feedback verboseTable 233  Features for BuiltIn Feedback Modes\nMode Prompt Declaration Update Command Snippet with a Value\nsilent  No No No No\nconcise jshell No No No name  value\nfor expressions only\nnormal njshell Yes No Yes name  value\nverbose njshell Yes Yes Yes name  value\nwith descriptionChapter 23  Java Shell\n928The following examples show you how to set different feedback modes\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell 2  2\n1  4\njshell set feedback verbose\n  Feedback mode verbose\njshell 2  2\n2  4\n  created scratch variable 2  int\njshell set feedback concise\njshell 2  2\n3  4\njshell set feedback silent\n 2  2\n SystemoutprintlnHello\nHello\n set feedback verbose\n  Feedback mode verbose\njshell 2  2\n6  4\n  created scratch variable 6  int\nThe feedback mode set in jshell  is temporary It is set only for the current session To persist the \nfeedback mode across jshell  sessions use the set  command with feedback  as an argument and retain  \nas an option\njshell set feedback retain\nThis command will persist the current feedback mode When you start jshell  again it will configure \nthe feedback mode that was set before you executed this command It is still possible to change the feedback \nmode temporarily in a session If you want to set a new feedback mode permanently you need to use the  \nset feedback mode  command and execute the command again to persist the new setting\nIt is also possible to set a new feedback mode and at the same time persist it for future sessions by \nusing the retain  option The following command will set the feedback mode to verbose  and retain it in \nfuture sessions\njshell set feedback retain verbose\nTo determine the current feedback mode execute the set  command with the feedback  argument \nIt prints the command used to set the current feedback mode on the first line followed by all available \nfeedback modes as shown\njshell set feedback\n  set feedback normal\n\n  Available feedback modes\n     concise\n     normalChapter 23  Java Shell\n929     silent\n     verbose\njshell\n Ti p When learning jshell  it is recommended you start it in verbose  feedback mode so you get a lot of \ndetails about the state of execution of your commands and snippets this will help you learn the tool faster\n Creating Custom Feedback Modes\nThe four preconfigured feedback modes are good to work with jshell  They provide you different levels \nof granularity to customize your jshell  You can have your own custom feedback mode We doubt you \nwill ever need a custom feedback mode but the feature is there if you need it Creating a custom feedback \nmode is a little more involved You have to write several customization steps Most likely you will want to \ncustomize a few items in a predefined feedback mode You can create a custom feedback mode from scratch \nor by copying one from an existing feedback mode and customizing it selectively The syntax to create a \ncustom feedback mode is as follows\nset mode mode oldmode commandquietdelete\nHere mode  is the name of the custom feedback mode for example kverbose oldmode  is the \nname of an existing feedback mode whose settings will be copied to the new mode Using the command  \noption displays information about the mode when it is set whereas using the quiet  option does not display \nany information when the mode is set The delete  option is used to delete the mode\nThe following command creates a new feedback mode called kverbose  by copying all settings from the \npredefined verbose  feedback mode\nset mode kverbose verbose command\nThe following command will persist the new feedback mode for future use\nset mode kverbose retain\nYou need to use the delete  option to delete a custom feedback mode You cannot delete a predefined \nfeedback mode If you persisted the custom feedback mode you can use the retain  option to delete it from \ncurrent and all future sessions The following command will delete the kverbose  feedback mode\nset mode kverbose delete retain\nAt this point there is no difference between the predefined verbose  mode and the custom kverbose  \nmode After you create a feedback mode you need to customize three settings\n\t Prompts\n\t Output truncation limits\n\t Output formatChapter 23  Java Shell\n930 Ti p Once you are done defining a custom feedback mode  you need to use the set feedback  \nnewmode  command to start using it\nYou can set two types of prompts for a feedback modethe main prompt and the continuation prompt \nThe main prompt is displayed when jshell  is ready to read a new snippetcommand The continuation \nprompt is displayed at the beginning of a line when you are entering a multiline snippet The syntax for \nsetting prompts is as follows\nset prompt mode prompt continuationprompt\nHere prompt  is the main prompt and continuationprompt  is the continuation prompt\nThe following command sets the prompts for the kverbose  mode\nset prompt kverbose njshellkverbose  more \nYou can set the maximum number of characters displayed for each type of actionevent for a feedback \nmode using the following command\nset truncation mode length selectors\nHere mode  is the feedback mode for which you set the truncation limit length  is the maximum \nnumber of characters displayed for the specified selectors selectors  is a commaseparated list of \nselectors that determines the context to which the truncation limit applies Selectors are predefined \nkeywords that represent specific contexts for example vardecl  is a selector that represents a variable \ndeclaration without initialization Use the following command for more information about setting the \ntruncation limits and selectors\nhelp set truncation\nThe following commands set the truncation limit to 80 characters for everything and to five characters \nfor a variable value or expression\nset truncation kverbose 80\nset truncation kverbose 5 expressionvarvalue\nNote that the most specific selector determines the actual truncation limit to be used The following \nsettings use two selectorsone for all types of snippets 80 characters and one for expressions and variable \nvalues five characters For an expression the second setting is the most specific setting In this case if \nyou have a variable whose value is more than five characters it will be truncated to five characters when \ndisplayed\nSetting the output format is a complex job You will need to set the format for all types of output you are \nexpecting based on the actionsevents We do not go through defining all types of output formats Use the \nfollowing command for more information about setting the output formats\nhelp set format\nThe syntax for setting the output format is as follows\nset format mode field format selectorsChapter 23  Java Shell\n931Here mode  is the name of the feedback mode for which you are setting the output format field  \nis the contextspecific format to define  format  is used for displaying the output format  can contain \nnames of predefined fields in bracesfor example name  type  value  etc which will be replaced \nwith actual values based on the context selectors  are selectors that determine the context in which this \nformat will be used\nThe following command sets a display format for feedback when an expression is added modified or \nreplaced for entered snippets The entire command is entered on one line\nset format kverbose display resultprecreated a temporary variable named name of type \ntype and initialized it with valuepost expressionaddedmodifiedreplacedprimary\nThe following jshell  session creates a new feedback mode called kverbose  by copying all settings from \nthe predefined verbose  feedback mode It customizes the prompts truncation limits and output formats It \nuses the verbose  and kverbose  feedback modes to compare jshell  behavior Note that all commands in the \nfollowing examples need to be entered on one line even though they sometimes appear on multiple lines in \nthe book\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set feedback\n  set feedback retain normal\n\n  Available feedback modes\n     concise\n     normal\n     silent\n     verbose\njshell set mode kverbose verbose command\n  Created new feedback mode kverbose\njshell set mode kverbose retain\njshell set prompt kverbose njshellkverbose  more \njshell set truncation kverbose 5 expressionvarvalue\njshell set format kverbose display resultprecreated a temporary variable named name \nof type type and initialized it with valuepost expressionaddedmodifiedreplaced\nprimary\njshell set feedback kverbose\n  Feedback mode kverbose\njshellkverbose 2 \nmore 2\n2  4\n  created a temporary variable named 2 of type int and initialized it with 4\njshellkverbose 111111  222222\n3  33333\n  created a temporary variable named 3 of type int and initialized it with 33333\njshellkverbose set feedback verbose\n  Feedback mode verbose\njshell 2 \n    2\n4  4Chapter 23  Java Shell\n932  created scratch variable 4  int\njshell 111111  222222\n5  333333\n  created scratch variable 5  int\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set feedback\n  set feedback retain normal\n\n  Retained feedback modes\n     kverbose\n  Available feedback modes\n     concise\n     kverbose\n     normal\n     silent\n     verbose\njshell\nIn these jshell  sessions you set the truncation limits for expressions and variable values to five \ncharacters for the kverbose  feedback mode This is why in the kverbose  feedback mode the value of the \nexpression 111111  222222  is printed as 33333  not as 333333  This is not a bug This was caused by your \nsetting\nNote that the command set feedback  shows the command used to set the current feedback mode \nand a list of available feedback modes which lists your new feedback mode named kverbose \nWhen you are creating a custom feedback mode it will be helpful to know all the settings for the existing \nfeedback modes You can print a list of all settings for all the feedback modes using the following command\nset mode\nYou can also print a list of all settings for a specific feedback mode by passing the mode name as an \nargument to the command The following command prints a list of all settings for the silent  feedback \nmode The first line in the output is the command used to create the silent  mode\njshell set mode silent\n  set mode silent quiet\n  set prompt silent    \n  set format silent display \n  set format silent err 6s\n  set format silent errorline      errn\n  set format silent errorpost n\n  set format silent errorpre    \n  set format silent errors 5s\n  set format silent name 1s\n  set format silent post n\n  set format silent pre    \n  set format silent type 2sChapter 23  Java Shell\n933  set format silent unresolved 4s\n  set format silent value 3s\n  set truncation silent 80\n  set truncation silent 1000 expressionvarvalue\n Setting Up\u00a0Startup Snippets\nYou can use the set  command with a start  argument to set up your startup snippets and commands \nStartup snippets and commands are automatically executed when you launch jshell  You have seen the \ndefault startup snippets that import types from a few commonly used packages Typically you would set the \nclass path and module path using an env  command and import  statements to your startup script\nYou can print a list of default startup snippets using the list start  command Note that this \ncommand prints the default startup snippets not the current startup snippets Remember you can also \ndrop startup snippets Default startup snippets include what you get when you start jshell  Current startup \nsnippets include the default startup snippets minus those you have dropped in the current jshell  session \nYou can use one of the following forms of the set  command to set startup snippetscommands\n\tset start retain file\n\tset start retain default\n\tset start retain none\nUsing the retain  option is optional If it is used the setting persists across jshell  sessions\nThe first form is used to set startup snippetscommands from a file When a reset  or a reload  \ncommand is executed in the current session the files contents will be used as startup snippetscommands \nOnce you set the startup code from a file jshell  caches the files contents for future use Modifying the files \ncontents does not affect the startup code until you set the startup snippetscommands again\nThe second form is used to set the startup snippetscommands to the builtin default\nThe third form is used to set an empty startup That is there will be no snippetscommands executed at \nstartup\nThe set start  command without any options or files shows the current startup setting If the startup was \nset from a file it shows the file name the startup snippets and the time at which the startup snippets were set\nConsider the following scenario The JavaFunbuildmodulesjdojojshell  directory in the books \nsource code contains a comjdojojshellPerson  class Lets test this class in jshell  and use the types from \nthe javatime  package To do this your startup settings will look like the contents shown in Listing 234 \nListing 234  Con tents of a File Named startupjsh\nenv classpath CJavaFunbuildmodulesjdojojshell\nimport javaio\nimport javamath\nimport javanet\nimport javaniofile\nimport javautil\nimport javautilconcurrent\nimport javautilfunction\nimport javautilprefs\nimport javautilregex\nimport javautilstream\nimport javatime\nimport comjdojojshell\nvoid printfString format Object args  Systemoutprintfformat args Chapter 23  Java Shell\n934Save the settings in a file named startupjsh  in your current directory If you save it in any other \ndirectory you can use an absolute path for this file while working with this example Note that the first \ncommand is a env classpath  command for Windows assuming that you stored the source code in the \nC directory Change the class path value according to your platform and the location of the books source \ncode on your computer\nNote the last snippet in the startupjsh  file It defines a toplevel function named printf  that is a \nwrapper for the Systemoutprintf  method The printf  function was included in the initial builds of \nthe JShell  tool by default Later it was removed If you want to use a short method name such as printf  \ninstead of Systemoutprintf  to print messages on the standard output you can include this snippet in \nyour startup script If you want to use println  and printf  toplevel methods in jshell  by default you \nneed to start jshell  as follows\nCJavaFunjshell start DEFAULT start PRINTING\nThe DEFAULT  argument will include all default import  statements and the PRINTING  argument will \ninclude all versions of the print  println  and printf  methods After you launch jshell  using this \ncommand execute the list start  command to see all startup import s and methods added by the two  \n start  options used in the command\nThe following jshell  sessions show you how to set the startup settings from a file and its usage in \nsubsequence sessions\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set start\n  set start default\njshell set start retain startupjsh\njshell Person p\n  created variable p however it cannot be referenced until class Person is declared\njshell reset\n  Resetting state\njshell Person p\np  null\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set start\n  set start retain startupjsh\n   startupjsh  Aug 20 2017 95811 AM \n  env classpath CJavaFunbuildmodulesjdojojshell\n  import javaio\n  import javamath\n  import javanet\n  import javaniofile\n  import javautil\n  import javautilconcurrent\n  import javautilfunction\n  import javautilprefs\n  import javautilregexChapter 23  Java Shell\n935  import javautilstream\n  import javatime\n  import comjdojojshell\n  void printfString format Object args  Systemoutprintfformat args \njshell Person p\np  null\njshell LocalDatenow\n15  20170820\njshell printf2  2  dn 2  2\n2  2  4\njshell\n Ti p Setting the startup snippetscommands does not take effect until you relaunch jshell  execute a  \nreset  or execute a reload  command Do not include a reset  or a reload  command in your  \nstartup file It will cause an infinite loop when your startup file loads\nThere are three predefined scripts whose names are as follows\n\tDEFAULT\n\tPRINTING\n\tJAVASE\nThe DEFAULT  script contains commonly used import statements as you have seen them in the Import \nStatements section The PRINTING  script defines toplevel JShell methods that redirect to the print  \nprintln  and printf  methods in PrintStream  as shown in this section The JAVASE  script imports all \nJava SE packages which is big and takes a few seconds to complete The following commands show you how \nto save these scripts as the startup script\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell printlnHello\n  Error\n  cannot find symbol\n    symbol   method printlnjavalangString\n  printlnHello\n  \njshell set start retain DEFAULT PRINTING\njshell exit\n  Goodbye\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell printlnHello\nHello\njshellChapter 23  Java Shell\n936Notice that using the println  method for the first time resulted in an error After saving the PRINTING  \nscript as the startup script and restarting the tool the method works\n Using JShell Documentation\nThe JShell  tool ships with extensive documentation Because it is a commandline tool it is a little harder \nto read the documentation on a command line You can use the help  or  command to display a list of \ncommands and their brief descriptions\njshell help\n  Type a Java language expression statement or declaration\n  Or type one of the following commands\n  list name or idallstart    list the source you have typed\n  edit name or id    edit a source entry referenced by name or id\n  drop name or id    delete a source entry referenced by name or id\n  \nYou can use a specific command as an argument to the help  command to get information about the \ncommand The following command prints information about the help  command itself\njshell help help\n\n  help\n\n  Display information about jshell\n  help\n       List the jshell commands and help subjects\n\n  help command\n       Display information about the specified command The slash must be included\n       Only the first few letters of the command are needed  if more than one\n       each will be displayed   Example   help li\n\n  help subject\n       Display information about the specified help subject Example help intro\nThe following commands will display information about the list  and set  commands Outputs are \nnot shown because they are long\njshell help list\n\njshell help set\n\nSometimes a command is used to work with multiple topics for example the set  command can be \nused to set the feedback mode a snippet editor startup scripts etc If you want to print information about a \nspecific topic of a command you can use the help  command in the following format\nhelp command topicnameChapter 23  Java Shell\n937The following command prints information about setting the feedback mode\njshell help set feedback\nThe following command prints information about creating a custom feedback mode\njshell help set mode\nUse the help  command with a subject as an argument to print information about the subject \nCurrently there are three predefined subjects intro  shortcuts  and context  The following command will \nprint an introduction to the JShell tool\njshell help intro\nThe following command will print a list of shortcuts and their descriptions that you can use in the JShell \ntool\njshell help shortcuts\nThe following command will print a list of options used to set the execution context These options are \nused with the env  reset  and reload  commands\njshell help context\n The JShell API\nThe JShell API gives you programmatic access to the snippet evaluation engine As a developer you may not \nuse this API\u00a0It is meant to be used by tools such as the NetBeans IDE that includes a UI equivalent of the \nJShell commandline tool to let developers evaluate snippets of code from inside the IDE instead of opening \na command prompt to do the same In this section we briefly introduce the JShell API and show its use with \na simple example\nThe JShell API is in the jdkjshell  module and the jdkjshell  package If you are using the JShell API \nyour module will need to read the jdkjshell  module The JShell  API is simple It consists mainly of three \nabstract classes and one interface\n\tJShell\n\tSnippet\n\tSnippetEvent\n\tSourceCodeAnalysis\nAn instance of the JShell  class represents a snippet evaluation engine This is the main class in the \nJShell  API\u00a0A JShell  instance maintains the state of all snippets as they are executed\nA snippet is represented by an instance of the Snippet  class A JShell  instance generates snippet events \nas it executes snippets\nA snippet event is represented by an instance of the SnippetEvent  interface A snippet event contains \nthe current and previous statuses of snippets the value of the snippet for a resultbearing snippet the source \ncode of the snippet that caused the event an Exception  object if an exception occurred during the snippet \nexecution etcChapter 23  Java Shell\n938An instance of the SourceCodeAnalysis  class provides source code analysis and suggestion features for \na snippet It answers questions like the following\n\t Is it a complete snippet\n\t Can this snippet be completed by appending a semicolon\nA SourceCodeAnalysis  instance also provides a list of suggestions for example for Tab completion and \naccessing the documentation This class is meant to be used by a tool providing the JShell functionality We \nwill not discuss it any further Refer to the Javadoc of this class if you are interested in exploring it further\nFigure 235  shows the use case diagram for the different components of the JShell API\u00a0In subsequent \nsections we explain these classes and their uses We will show you a complete example in the last section\n Creating a\u00a0JShell\nThe JShell  class is abstract It provides two ways to create its instances\n\t Using its static create  method\n\t Using a static builder class named JShellBuilder\nThe create  method returns a preconfigured JShell  instance The following snippet of code shows \nhow to create a JShell  using the create  method\n Create a JShell instance\nJShell shell  JShellcreate\nThe JShellBuilder  class lets you configure the JShell  instance by letting you specify a snippet ID \ngenerator a temporary variable name generator a print stream for printing the output an input stream to \nread snippets and an error output stream to log errors You can obtain an instance of the JShellBuilder  \nclass using the builder  static method of the JShell  class The following snippet of code shows how to use \nthe JShellBuilder  class to create a JShell  where myXXXStream  in the code are references to your stream \nobjects\nFigure 235   A use case diagram for the components of the JShell APIChapter 23  Java Shell\n939 Create a JShell instance\nJShell shell  JShellbuilder\n                     inmyInputStream\n                     outmyOutputStream\n                     errmyErrorStream\n                     build\nOnce you have a JShell  instance you can start evaluating snippets using its evalString snippet  \nmethod You can drop a snippet using its dropPersistentSnippet snippet  method You can append a \npath to the class path using its addToClasspathString path  method These three methods change the \nstate of the JShell  instance\n Ti p When you are done using a JShell  instance you need to call its close  method to free resources \nthe JShell  class implements the AutoCloseable  interface and therefore using a trywithresources  \nblock to work with a JShell  instance is the best way to ensure that it is closed when it is no longer in use a \nJShell  instance is mutable and not threadsafe\nYou can register snippet event handlers and JShell  shutdown event handlers using the onSnippetEvent \nConsumerSnippetEvent listener  and onShutdownConsumerJShell listener  methods of the \nJShell  class A snippet event is fired when the status of a snippet changes because it is evaluated the first \ntime or its status is updated because of evaluation of another snippet\nThe sourceCodeAnalysis  method in the JShell  class returns an instance of the SourceCodeAnalysis  \nclass which you can use for codeassist functionality\nOther methods in the JShell  class are used to query the state For example the snippets  types  \nmethods  and variables  methods return a list of all snippets all snippets with active type declarations \nsnippets with active method declarations and snippets with active variable declarations respectively\nThe eval  method is the most frequently used method in the JShell  class It evaluatesexecutes the \nspecified snippet and returns a ListSnippetEvent  You can query the snippet events in the list for the \nstate of execution The following is a snippet of code that uses the eval  method\n Create a snippet\nString snippet  int x  100\n Evaluate the snippet\nListSnippetEvent events  shellevalsnippet\n Process the results\neventsforEachSnippetEvent se  \n     Handle the snippet event here \n\n Working with\u00a0Snippets\nAn instance of the Snippet  class represents a snippet The class does not provide a way to create its objects \nYou supply snippets to a JShell  as strings and you receive instances of the Snippet  class as part of the \nsnippet events Snippet events also provide you with the previous and current statuses of a snippet If you \nhave a Snippet  object you can query its current status using the statusSnippet s  method of the JShell  \nclass which returns a SnippetStatus Chapter 23  Java Shell\n940 Tip the Snippet  class is immutable and threadsafe\nThere are several types of snippets in Java for example a variable declaration a variable declaration \nwith initialization a method declaration a type declaration etc The Snippet  class is an abstract class and \nthere is a subclass to represent each specific type of snippet Figure\u00a0 236  shows the class diagram for the \nSnippet  class and its descendants\nThe names of the subclasses of the Snippet  class are intuitive For example an instance of the \nPersistentSnippet  represents a snippet that is stored in a JShell  and can be reused such as a class \ndeclaration or a method declaration The Snippet  class contains the following methods\n\t String id\n\t String source\n\t SnippetKind kind\n\t SnippetSubKind subKind\nThe id  method returns a unique ID of the snippet and the source  method returns its source code \nThe kind  and subKind  methods return the type and subtype of a snippet\nThe type of a snippet is one of the constants of the SnippetKind  enum for example IMPORT  \nTYPEDECL  METHOD  VAR etc The subtype of a snippet provides more specific information about its type \nfor example if a snippet is a type declaration its subtype will tell you if it is a class interface enum or \nannotation declaration The subtype of a snippet is one of the constants of the SnippetSubKind  enum such \nas CLASSSUBKIND  ENUMSUBKIND  etc The SnippetKind  enum contains an isPersistent  property whose \nvalue is true  if the snippet of this kind is persistent and false  otherwise\nSubclasses of the Snippet  class add more methods to return specific information about the specific type \nof snippet For example the VarSnippet  class contains a typeName  method which returns the data type \nof the variable The MethodSnippet  class contains the parameterTypes  and signature  methods which \nreturn parameter types and the full signature of the method as a string\nA snippet does not contain its status A JShell  executes and holds the status of a Snippet  Note that \nexecuting a snippet may affect the status of other snippets For example a snippet declaring a variable \nmay change the status of a snippet declaring a method from valid to invalid or vice versa if the method was \nreferencing the variable If you need the current status of a snippet use the statusSnippet s  method of \nthe JShell  class which returns one of the following constants of the SnippetStatus  enum\nFigure 236  A class diagram for the Snippet class and its descendantsChapter 23  Java Shell\n941\tDROPPED  The snippet is inactive because it was dropped using the drop  method of \nthe JShell  class\n\tNONEXISTENT  The snippet is inactive because it does not yet exist\n\tOVERWRITTEN  The snippet is inactive because it has been replaced by a new snippet\n\tRECOVERABLEDEFINED  The snippet is a declaration snippet containing unresolved \nreferences The declaration has a valid signature and it is visible to other snippets It \ncan be recovered and used when other snippets change its status to VALID \n\tRECOVERABLENOTDEFINED  The snippet is a declaration snippet containing \nunresolved references The snippet has an invalid signature and it is not visible to \nother snippets It can be used later when its status changes to VALID \n\tREJECTED  The snippet is inactive because it failed compilation on initial evaluation \nand it is not capable of becoming valid with further changes to the JShell  state\n\tVALID  The snippet is valid in the context of the current JShell  state\n Handling Snippet Events\nA JShell  instance generates snippet events as part of snippet evaluation or execution You can handle \nsnippet events by registering event handlers using the onSnippetEvent  method of the JShell  class or \nby using the return value of the eval  method of the JShell  class which is a ListSnippetEvent  The \nfollowing snippet of code shows you how to process snippet events using the return value of the eval  \nmethod\ntry JShell shell  JShellcreate \n     Create a snippet\n    String snippet  int x  100\n    shellevalsnippet\n         forEachSnippetEvent se  \n              Snippet s  sesnippet\n              SystemoutprintfSnippet sn ssource\n              SystemoutprintfKind sn skind\n              SystemoutprintfSubKind sn ssubKind\n              SystemoutprintfPrevious Status sn sepreviousStatus\n              SystemoutprintfCurrent Status sn sestatus\n              SystemoutprintfValue sn sevalue\n        \n\n An Example\nLets look at the JShell API in action Listing 235  contains the complete code for a class named \nJShellApiTest  which is a member of the jdojojshell  moduleChapter 23  Java Shell\n942Listing 235  A JS hellApiTest Class to Test the JShell API\n JShellApiTestjava\npackage comjdojojshell\nimport jdkjshellJShell\nimport jdkjshellSnippet\nimport jdkjshellSnippetEvent\npublic class JShellApiTest \n    public static void mainString args \n         Create an array of snippets to evaluateexecute\n         them sequentially\n        String snippets  int x  100\n            double x  19089\n            long multiplyint value return value  multiplier\n            int multiplier  2\n            multiply200\n            mul99\n        \n        try JShell shell  JShellcreate \n             Register a snippet event handler\n            shellonSnippetEventJShellApiTestsnippetEventHandler\n             Evaluate all snippets\n            for String snippet  snippets \n                shellevalsnippet\n                Systemoutprintln\n            \n        \n    \n    public static void snippetEventHandlerSnippetEvent se \n         Print the details of this snippet event\n        Snippet snippet  sesnippet\n        SystemoutprintfSnippet sn snippetsource\n         Print the cause of this snippet event\n        Snippet causeSnippet  secauseSnippet\n        if causeSnippet  null \n            SystemoutprintfCause Snippet sn causeSnippetsource\n        \n        SystemoutprintfKind sn snippetkind\n        SystemoutprintfSubKind sn snippetsubKind\n        SystemoutprintfPrevious Status sn sepreviousStatus\n        SystemoutprintfCurrent Status sn sestatus\n        SystemoutprintfValue sn sevalue\n        Exception e  seexception\n        if e  null \n            SystemoutprintfException sn seexceptiongetMessage\n        \n    \nChapter 23  Java Shell\n943Snippet int x  100\nKind VAR\nSubKind VARDECLARATIONWITHINITIALIZERSUBKIND\nPrevious Status NONEXISTENT\nCurrent Status VALID\nValue 100\n\nSnippet double x  19089\nKind VAR\nSubKind VARDECLARATIONWITHINITIALIZERSUBKIND\nPrevious Status VALID\nCurrent Status VALID\nValue 19089\nSnippet int x  100\nCause Snippet double x  19089\nKind VAR\nSubKind VARDECLARATIONWITHINITIALIZERSUBKIND\nPrevious Status VALID\nCurrent Status OVERWRITTEN\nValue null\n\nSnippet long multiplyint value return value  multiplier\nKind METHOD\nSubKind METHODSUBKIND\nPrevious Status NONEXISTENT\nCurrent Status RECOVERABLEDEFINED\nValue null\n\nSnippet int multiplier  2\nKind VAR\nSubKind VARDECLARATIONWITHINITIALIZERSUBKIND\nPrevious Status NONEXISTENT\nCurrent Status VALID\nValue 2\nSnippet long multiplyint value return value  multiplier\nCause Snippet int multiplier  2\nKind METHOD\nSubKind METHODSUBKIND\nPrevious Status RECOVERABLEDEFINED\nCurrent Status VALID\nValue null\n\nSnippet multiply200\nKind VAR\nSubKind TEMPVAREXPRESSIONSUBKIND\nPrevious Status NONEXISTENT\nCurrent Status VALID\nValue 400\n\nSnippet mul99\nKind ERRONEOUS\nSubKind UNKNOWNSUBKINDChapter 23  Java Shell\n944Previous Status NONEXISTENT\nCurrent Status REJECTED\nValue null\n\nThe main  method creates the following six snippets and stores them in a String  array\n\tint x  100\n\tdouble x  19089\n\tlong multiplyint value return value  multiplier\n\tint multiplier  2\n\tmultiply200\n\tmul99\nA trywithresources  block is used to create a JShell  instance The snippetEventHandler  method \nis registered as a snippet event handler The method prints details about the snippet such as its source \ncode the source code of the snippet that caused the update in the snippet status the snippets previous and \ncurrent statuses its value etc Finally a foreach  loop is used to iterate through all the snippets and the \neval  method is called to execute them\nLets walk through the state of the JShell  engine when each of these snippets is executed\n\t When snippet 1 is executed the snippet did not exist so it transitions from a \nNONEXISTENT  to a VALID  status It is a variable declaration snippet and it evaluates  \nto 100\n\t When snippet 2 is executed it already existed Note that it declares the same \nvariable named x with a different data type Its previous status was VALID  and its \ncurrent status is VALID  too The execution of this snippet changes the status of \nsnippet 1 whose status changes from VALID  to OVERWRITTEN  because you cannot \nhave two variables with the same name\n\t Snippet 3 declares a method named multiply  which uses an undeclared \nvariable named multiplier  in its body so its status changes from NONEXISTENT  \nto RECOVERABLEDEFINED  The method is defined which means that it can be \nreferenced but cannot be invoked until a variable named multiplier  of appropriate \ntype is defined\n\t Snippet 4 defines a variable named multiplier  which makes snippet 3 valid\n\t Snippet 5 evaluates an expression that calls the multiply  method The \nexpression is valid and it evaluates to 400\n\t Snippet 6 evaluates an expression that calls a mul  method which you have never \ndefined The snippet is erroneous and is rejected\nTypically you will not use the JShell API and the JShell tool together However lets use them together \njust for fun The JShell API is just another API in Java and it can also be used inside the JShell tool The \nfollowing jshell  session instantiates a JShell  registers a snippet event handler and evaluates two snippets\nCJavaFunjshell\n  Welcome to JShell  Version 17\n  For an introduction type help intro\njshell set feedback silentChapter 23  Java Shell\n945 import jdkjshell\n JShell shell  JShellcreate\n shellonSnippetEventse  \n  SystemoutprintfSnippet sn sesnippetsource\n  SystemoutprintfPrevious Status sn sepreviousStatus\n  SystemoutprintfCurrent Status sn sestatus\n  SystemoutprintfValue sn sevalue\n \n shellevalint x  100\nSnippet int x  100\nPrevious Status NONEXISTENT\nCurrent Status VALID\nValue 100\n shellevaldouble x  10089\nSnippet double x  10089\nPrevious Status VALID\nCurrent Status VALID\nValue 10089\nSnippet int x  100\nPrevious Status VALID\nCurrent Status OVERWRITTEN\nValue null\n shellclose\n exit\nCJavaFun\n Summary\nThe Java shell which is called JShell is a commandline tool that provides an interactive way to access the \nJava programming language It lets you evaluate snippets of Java code instead of forcing you to write an \nentire Java program It is a REPL  for Java JShell is also an API that provides programmatic access to the REPL  \nfunctionality for the Java code for other tools such as IDEs\nYou can start the JShell commandline tool by running the jshell  program that is copied to the  \nJDKHOMEbin  directory when you install the JDK\u00a0The tool supports executing snippets and commands \nSnippets are pieces of Java code As snippets are evaluatedexecuted JShell maintains its state It also keeps \ntrack of the status of all entered snippets You can use commands to query the JShell state and configure the \njshell  environment To distinguish commands from snippets all the commands start with a slash  \nJShell contains several features that make developers more productive and provide a better user \nexperience such as autocompletion of code and displaying the Javadoc inside the tool It attempts to use \nthe already existing functionalities in the JDK such as the Compiler API to parse analyze and compile \nsnippets and the Java Debugger API to replace existing snippets with new ones in the JVM\u00a0Its design makes \nit possible to use new constructs in the Java language without any changes or with a few changes to the JShell \ntool itselfChapter 23  Java Shell\n946EXERCISES\n 1 What is Java shell\n 2 What command do you use to start the JShell commandline tool\n 3 What command do you use to exit the JShell commandline tool\n 4 What command do you use to print help in the JShell tool\n 5 how does the JShell tool differentiate between snippets and commands\n 6 Why cant you ha ve a package declaration in your snippet that you enter in jshell \n 7 What command do you use to list all active snippets all snippets and all startup \nsnippets\n 8 What command do you use to set the module path and the class path in the JShell \ntool\n 9 how do you run the previous snippet in jshell \n 10 What happens when a checked exception is thrown when you execute a snippet in \njshell \n 11 What key do you use for autocompleting code in the JShell tool\n 12 What key combination do you use to autoconvert an expression into a variable \ndeclaration of the appropriate type\n 13 What key combination do you use to autoimport an unresolved type in a snippet\n 14 What are the four builtin feedback modes in the JShell tool Which feedback mode \nare you supposed to use when learning the JShell tool Can you customize the \nbuiltin feedback mode\n 15 Write the command tha t sets the feedback mode to verbose  for the current and all \nfuture sessions\n 16 What is the effect of executing the reset  command\n 17 What is the effect of executing the reload  command\n 18 What commands do you use to save snippets in a jshell  session to a file and load \nsnippets from a file to a jshell  session\n 19 Describe the role of the JShell  Snippet  and SnippetEvent  classes in the \nJShell apI\n 20 how do you create an instance of the JShell  class\n 21 how do you get an instance of the Snippet  class in your program\n 22 how do you start the JShell tool so that you can use the println  function \nto print a message instead of using the Systemoutprintln  Show the \ncommand to make this setting permanent in the JShell tool947\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg1010079781484273074 APPENDIX A\nCharacter Encodings\nA character is the basic unit of a writing system for example a letter of the English alphabet and an \nideograph of an ideographic writing system such as Chinese and Japanese ideographs In the written \nform a character is identified by its shape also known as glyph  The identification of a character with its \nshape is not precise It depends on many factors for example a hyphen is identified as a minus sign in a \nmathematical expression and some Greek and Latin letters have the same shapes but they are considered \ndifferent characters in two written scripts Computers understand only numbers more precisely only bits \n0 and 1 Therefore it was necessary to convert with the advent of computers the characters into codes \nor bit combinations inside the computers memory so that the text sequence of characters could be \nstored and reproduced However different computers may represent different characters with the same bit \ncombinations which may lead to misinterpretation of text stored by one computer system and reproduced \nby another Therefore for correct exchange of information between two computer systems it is necessary \nthat one computer system understand unambiguously the coded form of the characters represented in bit \ncombinations produced by another computer system and vice versa Before we begin our discussion of some \nwidely used character encodings it is necessary to understand some commonly used terms\n\t An abstract character  is a unit of textual information for example the Latin capital \nletter A  A\n\t A character repertoire  is defined as the set of characters to be encoded A character \nrepertoire can be fixed or open In a fixed character repertoire once the set of \ncharacters to be encoded is decided it is never changed ASCII and POSIX portable \ncharacter repertoires are examples of fixed character repertoires In an open \ncharacter repertoire a new character may be added any time Unicode and Windows \nWestern European repertoires are examples of open character repertoires The Euro \ncurrency sign and Indian Rupee sign were added to Unicode because it is an open \nrepertoire\n\t A coded character set  is defined as a mapping from a set of nonnegative integers \nalso known as code positions code points code values character numbers and \ncode space to a set of abstract characters The integer that maps to a character \nis called the code point  for that character and the character is called an encoded \ncharacter  A coded character set is also called a character encoding coded character \nrepertoire character set definition or code page Figure A1 depicts two different \ncoded character sets both of them have the same character repertoire which is the \nset of three characters A B and C and the same code points which is the set of \nthree nonnegative integers 1 2 and 3Appendix A  ChArACter enCodings\n948To define a coded character set you need to specify three things\n\t A set of code points\n\t A set of characters\n\t A mapping between the set of code points and the set of characters\nThe number of bits used to represent a character determines how many distinct characters can be \nrepresented in a coded character set Some widely used coded character sets are outlined in the following \nsections\n ASCII\nASCII the American Standard Code for Information Interchange is a 7bit coded character set ASCII has 27 \n128 code points and so it represents 128 distinct characters whose numeric values range from 0 binary \n0000000 to 127 binary 1111111 The characters NUL and DELETE are represented by code points 0000000 and \n1111111 respectively There are historical reasons to assign these code points to NUL and DELETE characters \nIt was common to use punched paper tapes to store data for processing by the time ASCII was developed A 1 \nbit was used to represent a hole on the paper tape whereas a 0 bit represented the absence of a hole Since a row \nof seven 0 bits would be indistinguishable from blank tape the coding 0000000 would have to represent a NUL \ncharacter that is the absence of any effect Since holes once punched could not be erased but an erroneous \ncharacter could always be converted into 111111 this bit pattern was adopted as the DELETE character\nASCII uses the first 32 bit combinations or code points to represent control characters This range \nincludes the NUL character but not the DELETE character Therefore it leaves 95 bit combinations for \nprinting characters\n128All characters   32Control Characters   1DELETE  95Printing characters\nAll pr inting characters are arranged in the order that could be used for sorting purposes The SPACE \ncharacter is normally sorted before any other printing character Therefore the SPACE character is allocated \nthe first position among the printing characters The code point for the SPACE character in ASCII is 32 or \n1100000 The code point range of 4857 represents 09 digits range 6590 represents 26 uppercase letters \nAZ and range 97122 represents 26 lowercase letters az Modern computers use an 8bit combination also \nknown as a byte  as the smallest unit for storage Therefore on modern computers a 7bit ASCII character uses \n8 bits or 1 byte of memory of which the most significant bit is always set to 0 for example SPACE is stored as \n01100000 and DELETE is stored as 0111111 Table A1 contains the list of characters in the ASCII character setCoded Character SetI Coded Character SetII1\n2\n3A\nB\nC3\n2\n1A\nB\nC\nFigure A1  Two coded character sets having the same character repertoire and code pointsAppendix A  ChArACter enCodings\n949Table A1   ASCII Character Set\nDecimal Hexadecimal Binary Character Official Name\n0 0 0 NUL NULL\n1 1 1 SOH Start of heading\n2 2 10 STX Start of text\n3 3 11 ETX End of text\n4 4 100 EOT End of transmission\n5 5 101 ENQ Enquiry\n6 6 110 ACK Acknowledge\n7 7 111 BEL Bell\n8 8 1000 BS Backspace\n9 9 1001 TAB Horizontal tab\n10 0A 1010 LF Line feed new line\n11 0B 1011 VT Vertical tab\n12 0C 1100 FF Form feed new page\n13 0D 1101 CR Carriage return\n14 0E 1110 SO Shift out\n15 0F 1111 SI Shift in\n16 10 10000 DLE Data link escape\n17 11 10001 DC1 Device control 1\n18 12 10010 DC2 Device control 2\n19 13 10011 DC3 Device control 3\n20 14 10100 DC4 Device control 4\n21 15 10101 NAK Negative acknowledge\n22 16 10110 SYN Synchronous idle\n23 17 10111 ETB End of transmission block\n24 18 11000 CAN Cancel\n25 19 11001 EM End of medium\n26 1A 11010 SUB Substitute\n27 1B 11011 ESC Escape\n28 1C 11100 FS File separator\n29 1D 11101 GS Group separator\n30 1E 11110 RS Record separator\ncontinued Appendix A  ChArACter enCodings\n950Table A1  continued \nDecimal Hexadecimal Binary Character Official Name\n31 1F 11111 US Unit separator\n32 20 100000 SP Space\n33 21 100001  Exclamation mark\n34 22 100010  Quotation mark\n35 23 100011  Number sign\n36 24 100100  Dollar sign\n37 25 100101  Percent sign\n38 26 100110  Ampersand\n39 27 100111  Apostrophe\n40 28 101000  Left parenthesis\n41 29 101001  Right parenthesis\n42 2A 101010  Asterisk\n43 2B 101011  Plus sign\n44 2C 101100  Comma\n45 2D 101101  Hyphenminus\n46 2E 101110  Full stopperiod\n47 2F 101111  Solidusslash\n48 30 110000 0 Digit zero\n49 31 110001 1 Digit one\n50 32 110010 2 Digit two\n51 33 110011 3 Digit three\n52 34 110100 4 Digit four\n53 35 110101 5 Digit five\n54 36 110110 6 Digit six\n55 37 110111 7 Digit seven\n56 38 111000 8 Digit eight\n57 39 111001 9 Digit nine\n58 3A 111010  Colon\n59 3B 111011  Semicolon\n60 3C 111100  Lessthan sign\n61 3D 111101  Equals sign\ncontinued Appendix A  ChArACter enCodings\n951Table A1  continued \nDecimal Hexadecimal Binary Character Official Name\n62 3E 111110  Greaterthan sign\n63 3F 111111  Question mark\n64 40 1000000  Commercial at\n65 41 1000001 A Latin capital letter A\n66 42 1000010 B Latin capital letter B\n67 43 1000011 C Latin capital letter C\n68 44 1000100 D Latin capital letter D\n69 45 1000101 E Latin capital letter E\n70 46 1000110 F Latin capital letter F\n71 47 1000111 G Latin capital letter G\n72 48 1001000 H Latin capital letter H\n73 49 1001001 I Latin capital letter I\n74 4A 1001010 J Latin capital letter J\n75 4B 1001011 K Latin capital letter K\n76 4C 1001100 L Latin capital letter L\n77 4D 1001101 M Latin capital letter M\n78 4E 1001110 N Latin capital letter N\n79 4F 1001111 O Latin capital letter O\n80 50 1010000 P Latin capital letter P\n81 51 1010001 Q Latin capital letter Q\n82 52 1010010 R Latin capital letter R\n83 53 1010011 S Latin capital letter S\n84 54 1010100 T Latin capital letter T\n85 55 1010101 U Latin capital letter U\n86 56 1010110 V Latin capital letter V\n87 57 1010111 W Latin capital letter W\n88 58 1011000 X Latin capital letter X\n89 59 1011001 Y Latin capital letter Y\n90 5A 1011010 Z Latin capital letter Z\n91 5B 1011011  Left square bracketopening square bracket\n92 5C 1011100  Reverse solidusbackslash\ncontinued Appendix A  ChArACter enCodings\n952Table A1  continued \nDecimal Hexadecimal Binary Character Official Name\n93 5D 1011101  Right square bracketclosing square bracket\n94 5E 1011110  Circumflex accent\n95 5F 1011111  Low linespacing underscore\n96 60 1100000  Grave accent\n97 61 1100001 A Latin small letter A\n98 62 1100010 B Latin small letter B\n99 63 1100011 C Latin small letter C\n100 64 1100100 D Latin small letter D\n101 65 1100101 E Latin small letter E\n102 66 1100110 F Latin small letter F\n103 67 1100111 G Latin small letter G\n104 68 1101000 H Latin small letter H\n105 69 1101001 I Latin small letter I\n106 6A 1101010 J Latin small letter J\n107 6B 1101011 K Latin small letter K\n108 6C 1101100 L Latin small letter L\n109 6D 1101101 M Latin small letter M\n110 6E 1101110 N Latin small letter N\n111 6F 1101111 O Latin small letter O\n112 70 1110000 P Latin small letter P\n113 71 1110001 Q Latin small letter Q\n114 72 1110010 R Latin small letter R\n115 73 1110011 S Latin small letter S\n116 74 1110100 T Latin small letter T\n117 75 1110101 U Latin small letter U\n118 76 1110110 V Latin small letter V\n119 77 1110111 W Latin small letter W\n120 78 1111000 X Latin small letter X\n121 79 1111001 Y Latin small letter Y\n122 7A 1111010 Z Latin small letter Z\n123 7B 1111011  Left curly bracketopening curly bracket\ncontinued Appendix A  ChArACter enCodings\n953 8Bit Character Sets\nThe ASCII character set worked fine for the English language Representing the alphabets from other \nlanguages for example French and German led to the development of an 8bit character set An 8bit \ncharacter set defines 28 or 256 character positions whose numeric values range from 0 to 255 The bit \ncombination for an 8bit character set ranges from 00000000 to 11111111 The 8bit character set is divided into \ntwo parts The first part represents characters which are the same as in the ASCII character set The second \npart introduces 128 new characters The first 32 positions in the second part are reserved for control characters \nTherefore there are two control character areas in an 8bit character set 031 and 128159 Since the SPACE \nand DELETE characters are already defined in the first part an 8bit character set can accommodate 192 \nprinting characters 95  97 including SPACE\u00a0ISO Latin1 is one example of an 8bit character set\nEven an 8bit character set is not large enough to accommodate most of the alphabets of all languages \nin the world This led to the development of a bigger may be the biggest character set which is known as \nthe Universal Character Set UCS\n Universal MultipleOctet Coded Character Set UCS\nThe Universal MultipleOctet Coded Character Set simply known as UCS is intended to provide a single \ncoded character set for the encoding of written forms of all the languages of the world and of a wide range \nof additional symbols that may be used in conjunction with such languages It is intended not only to \ncover languages in current use but also languages of the past and such additions as may be required in the \nfuture The UCS uses a fouroctet one octet is 8 bits structure to represent a character However the most \nsignificant bit of the most significant octet is constrained to be 0 which permits its use for private internal \npurposes in a data processing system The remaining 31 bits allow us to represent more than two billion \ncharacters The four octets are named as follows\n\t The GroupOctet or G\n\t The PlaneOctet or P\n\t The RowOctet or R\n\t The CellOctet or C\nG is the most significant octet and C is the least significant octet So the whole code range for UCS is \nviewed as a fourdimensional structure composed of\n\t 128 groups\n\t 256 planes in each group\n\t 256 rows in each plane\n\t 256 cells in each rowTable A1  continued \nDecimal Hexadecimal Binary Character Official Name\n124 7C 1111100  Vertical linevertical bar\n125 7D 1111101  Right curly bracketclosing curly bracket\n126 7E 1111110  Tilde\n127 7F 1111111 DEL DELETEAppendix A  ChArACter enCodings\n954Two hexadecimal digits 09 AF specify the values of any octet The values of G are restricted to the \nrange 007F \u00a0The plane with G00 and P00 is known as the Basic Multilingual Plane BMP The row of \nBMP with R00 represents the same set of characters as 8bit ISO LatinI\u00a0Therefore the first 128 characters \nof ASCII ISO Latin1 and BMP with R00 match Characters 129th to 256th of ISO LatinI and those of BMP \nwith R00 match This makes UCS compatible with the existing 7bit ASCII and 8bit ISO LatinI\u00a0Further \nBMP has been divided into five zones\n\t Azone  It is used for alphabetic and symbolic scripts together with various symbols \nThe code position available for Azone ranges from 0000 to 4DFF \u00a0The code positions \n0000001F and 0080009F are reserved for control characters The code position \n007F is reserved for the DELETE character Thus it has 19903 code positions \navailable for graphics characters\n\t Izone  It is used for ChineseJapaneseKorean CJK unified ideographs Its range is \n4E009FFF  so 20992 code positions are available in this zone\n\t Ozone  It is used for Korean Hangul syllabic scripts and for other scripts Its range is \nA000D7FF  so 14336 code positions are available in this zone\n\t Szone  It is reserved for use with transformation format UTF16 The transformation \nformat UTF16 is described shortly Its range is D800DFFF  so 2048 code positions \nare available in this zone\n\t Rzone  It is known as the restricted zone It can be used only in special \ncircumstances One of the uses of this zone is for specific userdefined characters \nHowever in this case an agreement is necessary between the sender and the \nrecipient to communicate successfully Its range is E000FFFD so 8190 code \npositions are available in this zone\nUCS is closely related to another popular character set called Unicode which has been prepared by the \nUnicode Consortium Unicode uses a twooctet 16 bits coding structure and hence it can accommodate 216 \n 65536 distinct characters Unicode can be considered as the 16bit coding of the BMP of UCS\u00a0These two \ncharacter sets Unicode and UCS were developed and are maintained by two different organizations However \nthey cooperate to keep Unicode and UCS compatible If a computer system uses the Unicode character set to \nstore some text each character in the text has to be allocated 16 bits even if all characters in the text are from \nthe ASCII character set Note that the first 128 characters of Unicode match with those of ASCII and a character \nin ASCII can be represented only in 8 bits So to use 16 bits to represent all characters in Unicode is wasteful of \ncomputer memory An alternative would be to use 8 bits for all characters from ASCII and 16 bits for characters \noutside the range of ASCII\u00a0However this method of using different bits to represent different characters from \nUnicode has to be consistent and uniform resulting in no ambiguity when data is stored or interchanged \nbetween different computer systems This issue led to the development of the character encoding methods \nCurrently there are four character encoding methods specified in ISOIEC 106461\n\t UCS2\n\t UCS4\n\t UTF16\n\t UTF8\n UCS2\nThis is a twooctet BMP form of encoding which allows the use of two octets to represent a character from \nthe BMP \u00a0This is a fixedlength encoding method That is each character from BMP is represented by exactly \ntwo octetsAppendix A  ChArACter enCodings\n955 UCS4\nThis encoding method is also called the fouroctet canonical form of encoding which uses four octets for \nevery character in UCS\u00a0This is also a fixedlength encoding method\n UTF16 UCS Transformation Format 16\nOnce characters outside the BMP are used the UCS2 encoding method cannot be applied to represent \nthem In this case the encoding must switch over to use UCS4 which will just double the use of resources \nsuch as memory network bandwidth etc The transformation format UTF16 has been designed to avoid \nsuch a waste of memory and other resources which would have resulted in using the UCS4 encoding \nmethod The UTF16 is a variablelength encoding method In the UTF16 encoding method UCS2 is used \nfor all characters within BMP  and UCS4 is used for encoding the characters outside BMP \n UTF8 UCS Transformation Format 8\nThis is a variablelength encoding method which may use one to six octets to represent a character \nfrom UCS\u00a0All ASCII characters are encoded using one octet In the UTF8 format of character encoding \ncharacters are represented using one or more octets as shown in Table A2\nTable A2   List of Legal UTF8 Sequences\nNumber of Octets Bit Patterns Used UCS Code\n1 Octet 1 0xxxxxxx 000000000000007F\n2 Octet 1 110xxxxx\nOctet 2 10xxxxxx00000080000007FF\n3 Octet 1 1110xxxx\nOctet 2 10xxxxxx\nOctet 3 10xxxxxx000008000000FFFF\n4 Octet 1 11110xxx\nOctet 2 10xxxxxx\nOctet 3 10xxxxxx\nOctet 4 10xxxxxx00010000001FFFFF\n5 Octet 1 111110xx\nOctet 2 10xxxxxx\nOctet 3 10xxxxxx\nOctet 4 10xxxxxx\nOctet 5 10xxxxxx0020000003FFFFFF\n6 Octet 1 1111110x\nOctet 2 10xxxxxx\nOctet 3 10xxxxxx\nOctet 4 10xxxxxx\nOctet 5 10xxxxxx\nOctet 6 10xxxxxx040000007FFFFFFFAppendix A  ChArACter enCodings\n956The x in the table indicates either a 0 or a 1 Note that in UTF8 format an octet that starts with a 0 bit \nindicates that it is representing an ASCII character An octet starting with 110 bit combinations indicates that \nit is the first octet of the twooctet representation of a character And so on Also note that when an octet is \npart of a multioctet character representation the octet other than the first one starts with a 10bit pattern \nSecurity checks can be easily implemented for UTF8 encoded data UTF8 octet sequences which do not \nconform to the octet sequences shown in the table are considered invalid\n Java and\u00a0Character Encodings\nJava stores and manipulates all characters and strings as Unicode characters In serialization and bytecodes \nJava uses the UTF8 encoding of the Unicode character set All implementations of the Java virtual machine \nare required to support the character encoding methods as shown in Table A3\nJava supports UTF8 format with the following two significant modifications\n\t Java uses 16 bits to represent a NUL character in a class file whereas standard \nUTF8 uses only 8 bits This compromise has been made to make it easier for other \nlanguages to parse a Java class file where a NUL character is not allowed within a \nstring However in some cases Java uses standard UTF8 format to represent the \nNUL character\n\t Java recognizes only oneoctet twooctet and threeoctet UTF8 formats whereas \nstandard UTF8 format may use oneoctet twooctet threeoctet fouroctet five\noctet and sixoctet sequences This is because Java supports the Unicode character \nset and all characters from Unicode can be represented in one two or threeoctet \nformats of UTF8\nWhen you compile the Java source code by default the Java compiler assumes that the source code file \nhas been written using the platforms default encoding also known as local code page or native encoding \nThe platforms default character encoding is Latin1 on Windows and Solaris and MacRoman on Mac Note \nthat Windows does not use true Latin1 character encoding It uses a variation of Latin1 that includes fewer \ncontrol characters and more printing characters You can specify a file encoding name or code page name \nto control how the compiler interprets characters beyond the ASCII character set At the time of compiling Table A3   List of the Supported Character Encodings by a JVM\nCharacter Encoding Description\nASCII 7bit ASCII also known as ISO646US the basic Latin block of the Unicode \ncharacter set\nISO88591 ISO Latin Alphabet No 1 also known as ISO Latin1\nUTF8 8bit Unicode Transformation Format\nUTF16BE 16bit Unicode Transformation Format bigendian byte order Bigendian is \ndiscussed in Chapter 3\nUTF16LE 16bit Unicode Transformation Format littleendian byte order Littleendian is \ndiscussed in Chapter 3\nUTF16 16bit Unicode Transformation Format byte order specified by a mandatory \ninitial byte order mark either order accepted on input bigendian used on \noutputAppendix A  ChArACter enCodings\n957your Java source code you can pass the character encoding name used in your source code file to the Java \ncompiler The following command tells the Java compiler  javac  that the Java source code Testjava  has \nbeen written using a traditional Chinese encoding named Big5  Now the Java compiler will convert all \ncharacters encoded in Big5  to Unicode\njavac encoding Big5 Testjava\nThe JDK since version 9 supports UTF8based properties resource bundles There is a rare issue that \ncould arise where an ISO88591 properties file could be recognized as a valid UTF8 file To accommodate \nfor this the JDK provides a way to designate the encoding of resource bundles either ISO88591 or  \nUTF8  by setting the system property javautilPropertyResourceBundleencoding to either value959\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg1010079781484273074 APPENDIX B\nDocumentation Comments\nThe Java programming language lets you include comments in the source code that can be used to prepare \ndocumentation for the application Such comments are known as documentation comments or Javadoc \ncomments The JDK provides a javadoc  commandline tool to extract the documentation comments from \nthe source code and generate documentation in HTML format The javadoc  tool is located in the bin \ndirectory of the JDKHOME  directory For example if you have installed the JDK in the Cjava17  directory \nthe javadoc  tool will be located in the Cjava17bin  directory Execute the javadoc tool  with help  and  \n helpextra  to see all available options\nAlthough a documentation comment can appear anywhere in Java source code the javadoc  tool uses \nonly those documentation comments to generate the HTML pages that appear just before the declaration \nof classes nested classes interfaces enums annotations constructors methods and fields Note that the \ntool does not generate documentation for the documentation comments that are written for anonymous \nclasses package declarations and import declarations You need to write the documentation comments \nin a separate special file for a package which will be used by the tool to generate documentation for that \npackage\nA documentation comment starts with the  characters and ends with the  characters The leading \nasterisks   on each line of the documentation comment are ignored The following is an example of a \ndocumentation comment that is written for the Calc  class declaration\n Calcjava\npackage comjdojoutility\n\n  A utility class to perform basic calculations on numbers All\n  methods in this class are codestaticcode It provides methods\n  to perform addition subtraction multiplication and division\n \n  author Kishori Sharan\n \npublic final class Calc \n     Code for Calc class goes here\n\nIt is important to note that the documentation comment must appear just before the declaration of the \nprogram element for which it is intended Otherwise it will be ignored by the javadoc  tool or shown for the \nwrong element The following two documentation comments are not the sameAppendix B  document Ation comments\n960 Example 1 \n\n  This documentation comment is intended for the class declaration Xyz However it will be\n  ignored by the javadoc tool because there is a package declaration between this\n   documentation comment and the Xyz class declaration Note that a documentation comment for a\n  package declaration is written differently and it is not written in the source code\n \npackage comjdojoutility\npublic class Xyz \n     Code for Xyz class goes here \n\n Example 2 \npackage comjdojoutility\n\n  This documentation comment is intended for the class declaration Xyz It will be used by the\n  javadoc tool because it appears just before the Xyz class declaration\n \npublic class Xyz \n     Code for Xyz class goes here \n\n Writing Documentation Comments\nYou can write three types of comments in Java source code\n\t Singleline comments\n\t Multiline comments\n\t Documentation comments\nThe first two types of comments are freeform comments and they are meant for the developers to \nread The third type of comment is meant to be processed by the javadoc  tool to generate HTML documents \nfor the source code\nThe textual part of the documentation comment may include HTML tags and those tags will be \ninterpreted as HTML in the generated HTML document For example to display the text Hello  in boldface \nfont as part of the documentation comment you can write bHellob  as shown\n\n  You can include HTML tags in documentation comments This will display bHellob in\n  boldface font\n \n Ti p the javadoc  tool supports H tmL5\u00a0in documentation comments since Java 9Appendix B  document Ation comments\n961Apart from HTML tags you can also use some special tags A tag in a documentation comment is a \nspecial type of keyword that is interpreted and processed by the javadoc  tool Two types of tags can be used\n\t Block tags\n\t Inline tags\nA block tag is of the following form\ntagName tagText\nA block tag starts with an  character which is followed by the tag name The tag text follows the tag \nname The following is an example of a block tag which uses the author  block tag and Kishori Sharan  as \nthe tag text\nauthor Kishori Sharan\nA block tag must appear at the beginning of a line in a documentation comment Note that the \nasterisks whitespace and the  characters are ignored by the javadoc  tool if they appear at the \nbeginning of a line When I state that a block tag must appear at the beginning of a line I mean the \nbeginning of a line after ignoring these characters The following is an example of using the author  and \nsince  block tags The author  tag lets you specify an author name and the since  tag allows you to \nspecify the version since the API was introduced\n\n  A utility class to perform basic calculations on numbers All methods in this class are\n  codestaticcode It provides methods to perform addition subtraction multiplication\n  and division\n \n  author Kishori Sharan\n  since Version 10\n \npublic final class Calc \n     More code goes here\n\nIf a line in a documentation comment starts with an  character it will be interpreted as the start of a \nblock tag If you want to start a line with an  character without getting it interpreted as the start of a block \ntag you need to use the HTML entity 064  instead of the  character However an  character may appear \nas part of the text inside a line provided the prior character isnt a  which is explained more next\nThe associated text with a block tag may appear in multiple lines which include all text that follows the \ntag name until another block tag or the end of the documentation comment is encountered\nAn inline tag can appear anywhere in the documentation comment where text can appear It is of the \nform\ntagName tagTextAppendix B  document Ation comments\n962An inline tag is enclosed inside braces   and  The following is an example of a documentation \ncomment that uses a code text  inline tag to display the text n1  n2  in code font\n\n  An example of inline tag It computes code n1  n2\n \n Tip When you are writing a documentation comment  make sure that the first sentence of the description \nsection of the comment is a summary sentence the comment for a packa ge a class and a member is split \ninto two sections a summary section and a detail section the first sentence of the comment is displayed in the \nsummar y section and the entire comment is displayed in the detail section in the documentation\n List of\u00a0Block and\u00a0Inline Tags\nNot all tags can be used for the documentation comment in all contexts Table B1 contains the list contexts \nand the tags that can be used in those contexts There are several tags to support documentation comments \non a modules declaration and to enhance the generated Javadoc We discuss them in subsequent sections\nThe overview context in the table may not be obvious because there is no such construct as overview \nin the Java programming language The javadoc  tool lets you add documentation comments for the entire \napplication in one place which is called an overview comment The overview comment is displayed on the \noverview page that is generated by the tool We discuss an example of how to include an overview comment \nin the generated documentation later The following sections describe the tags in briefTable B1  List of Block and Inline Tags and the Contexts in Which They Can Be Used\nContext Available Tags\nOverview author see since serialField version code docRoot  \nindex link linkplain literal\nModule declaration author deprecated provides see since serialField uses  \nversion code docRoot index link linkplain  \nliteral\nPackage declaration author see since serialField version code docRoot  \nindex link linkplain literal\nType declaration author deprecated hidden param see since serialField  \nversion code docRoot index link linkplain  \nliteral\nConstructor and \nmethod declarationdeprecated exception hidden param return see since  \nserialData throws version code docRoot index  \ninheritDoc link linkplain literal\nField declaration deprecated hidden see since serial serialFieldcode  \ndocRoot index link linkplain literal valueAppendix B  document Ation comments\n963 author authornames\nThe author  tag adds the author name or names under the Author  section in the documentation  \nA documentation comment may contain multiple author  tags If you have multiple author names  \nyou can use only one author  tag to specify all author names or you can use a separate author  tag to \nspecify each author name If you use multiple author  tags all author names will be concatenated using a \nlocalespecific separator and placed under one Author  entry Table B2 shows the effects of using one and \nmultiple author  tags Note that the table shows only the Author  entry from the generated text\n deprecated explanationtext\nThe deprecated  tag is used to generate documentation for program elements that should no longer be \nused although they may function correctly The explanation text for this tag should explain why the program \nelement should not be used If there is a replacement for the deprecated program element the explanation \ntext should contain a link to or explanation about the replacement The following documentation comment \nuses the deprecated  tag for the Dummy  class It provides a link to the Dummy2  class which is the replacement \nclass\n\n  A dummy class\n \n  deprecated As of version 11 Use link comjdojoutilityDummy2 Dummy2 instead\n \npublic class Dummy \n\n exception classname description\nThe exception  tag is a synonym for the throws  tag Refer to the description of the throws  tag for detailsTable B2  The E ffects of Using One and Multiple author Tags in Documentation Comments\nDocumentation Comment Generated Author Entry\n\n A dummy class\n\n author Kishori Sharan\nAuthor \nKishori Sharan\n\n A dummy class\n\n author Kishori Sharan\n author Greg Langham\n author John Jacobs\nAuthor \nKishori Sharan Greg Langham John JacobsAppendix B  document Ation comments\n964 param parametername description\nThe param  is applicable only to classes methods and constructors It generates a Parameters  section with \nthe specified parametername  and the description  If the parameter is a type parameter the specified \nparametername  should be enclosed in angle brackets   The following is an example of using the param  \ntags to document the parameters of a method\n\n  Returns the result of multiplication of coden1code and\n  coden2code It may return incorrect result if the value of\n  the multiplication of coden1code and coden2code exceeds\n  the range of the codeintcode data type\n \n  param n1 The multiplicand\n  param n2 The multiplier\n  return Returns the result of multiplication of coden1code and coden2code\n \npublic static int multiplyint n1 int n2 \n    return n1  n2\n\nThe following is an example of using the param  tags to document the type parameters of a class\n\n  Wraps an object of any type\n \n  param T Type of the object wrapped in the Wrapper\n \npublic class WrapperT \n     Code for the Wrapper class goes here\n\n return description\nIt is valid only for methods It adds a Returns  section with the specified description  The specified \ndescription  should contain the return type and the description of value that is returned from the method \nRefer to the example of the param  tag to see how to use the return  tag in a documentation comment\n see reference\nIt adds a See Also  section with a link or text that points to the specified reference  A documentation \ncomment can have multiple see  tags All see  tags will be displayed under one See Also  section for a \ndocumentation comment You can specify the reference  in one of the three following forms\nsee text\nsee a hrefURLlabela\nsee packageClassnamemember label\nIn the first form the reference is specified as text that is enclosed in double quotes The javadoc  tool \nadds the specified text in the See Also  section without any linkAppendix B  document Ation comments\n965In the second form the reference is specified using an HTML anchor tag a tag The javadoc  tool \ngenerates a hyperlink that points to the specified URL If specified the specified label  is displayed as the \nlink text\nIn the third form the reference is specified to a class an interface a field a constructor or a method \nNote that if you are referencing a field a constructor or a method its name is preceded by a hash sign   \nnot a dot The javadoc  tool generates a link to the reference that has the specified label  as the visible text \nThe label is optional If the label is omitted the tool uses a suitable text for the link that is derived from the \nfirst argument to the see  tag The reference to the program element could use the fully qualified name or \na partial name The tool uses the same rules as the Java compiler to resolve the partial name of a program \nelement\nThe following is an example of how to use different forms of the see  tag It assumes that the Calc class \nis in the same package as the Dummy  class and the Calc  class contains the add  and multiply  methods\npackage comjdojoutility\n\n  A dummy class\n \n  see Online Java Tutorial\n  see a hrefhttpwwworaclecomOracle Websitea\n  see comjdojoutilityCalc Calculator\n  see comjdojoutilityCalcaddint int Add Method\n  see comjdojoutilityCalcmultiplyint int\n \npublic class Dummy \n\nThe generated See Also  section for the Dummy  class would look as shown\nSee Also \nOnline Java Tutorial Oracle Website Calculator Add Method\n        Calcmultiplyint int\n serial fielddescription or includeexclude\nThe javadoc  tool generates a Serialized Form  page that contains all pieces of information about serialized \nforms of all serialized classes The tool creates a See Also  section for serialized classes that contains \na link to the Serialized Form  page A class needs to implement the javaioSerializable  or java\nioExternalizable  interface to be added to the Serialized Form  page\nThe serial  tag is used to add a description for default serializable fields of a class The specified \ndescription will be added to the Serialized Form  page for the field The following is an example of using the \nserial  tag for a field\n\n  A dummy class\n \npublic class Dummy implements javaioSerializable \n    \n      serial The description for value field goes here\n     \n    private int value\nAppendix B  document Ation comments\n966You may include or exclude a package or a class from appearing on the Serialized Form  page by using \nthe include  or exclude  argument with the serial  tag If the serial  tag is used at both package and class \nlevels the classlevel tag takes precedence By default a serializable class that is public  or protected  is \nincluded in the Serialized Form  page The following documentation comment excludes the Dummy  class \nfrom the Serialized Form  page\n\n  A dummy class It will not appear on the serialized Form page\n \n  serial exclude\n \npublic class Dummy implements javaioSerializable \n    \n      serial The description for value field goes here\n     \n    private int value\n\n serialData datadescription\nA class that implements the javaioExternalizable  interface needs to implement the readExternal  \nand writeExternal  methods A serializable class may also implement the writeObject  readObject  \nwriteReplace  and readResolve  methods to customize the serialization of the objects of the class The \nserialData  tag may be used with the documentation comments of any of these six methods The data \ndescription text should describe the types and the order of the data in the serialized form\n serialField fieldname fieldtype  \nfielddescription\nA serializable class can include a serialPersistentFields  field that is an array of ObjectStreamField  The \nserialField  tag describes each component of that array The description of the elements will appear on \nthe Serialized Form  page The following documentation comment uses serialField  tags to document \nthe name  and the height  components of the ObjectStreamField \npackage comjdojoutility\nimport javaioObjectStreamField\nimport javaioSerializable\n\n  A class to represent a person\n \npublic class Person implements Serializable \n    private String name\n    private String gender\n    private double height\n    \n      serialField name String The name of the person\n      serialField height double The height of the person in feet\n     Appendix B  document Ation comments\n967    private static final ObjectStreamField serialPersistentFields\n             new ObjectStreamFieldname Stringclass\n               new ObjectStreamFieldheight doubleclass\n              \n\n since description\nThe since  tag adds a Since  section to the documentation The specified description  indicates the release \nof the software that added the program element being documented The following documentation comment \nshows how to use the since  tag\n\n  A dummy class\n \n  since 10\n \npublic class Dummy \n\n throws classname description\nThe throws  tag is a synonym for the exception  tag It adds a Throws  section to the documentation  \nIt is used to describe an exception that may be thrown from a constructor or a method Multiple throws   \ntags can be used in a documentation comment If a method throws a checked exception and there is no  \nthrows  tag the javadoc  tool will add one without a description to make sure that all checked exceptions \nare documented The following documentation comment for the divide  method shows how to use the \nthrows  tag If you do not provide the fully qualified name of the class the javadoc  tool will use the same \nsearch order as used by the Java compiler to resolve the partial class name\n\n  Returns the result of integer division of coden1code by\n  coden2code\n \n  param n1 The dividend\n  param n2 The divisor\n  return Returns the result of coden1  n2code\n  throws ArithmeticException If coden2code is zero\n \n public static int divideint n1 int n2 throws ArithmeticException \n    return n1  n2\n Appendix B  document Ation comments\n968 version versiontext\nThe version  tag adds a Version  section to the generated documentation The version text should contain \nthe current version of the program element The since  tag is used to specify the version of the software \nwhen a program element was added whereas the version  tag is used to specify the current version The \nfollowing documentation comment shows how to use the version  tag\n\n  A dummy class\n \n  since 10\n  version 16\n \npublic class Dummy \n\n code text\nIt displays the specified text in code font without interpreting the text as HTML markup or nested \ndocumentation comment tag It is equivalent to the following\ncodeliteral textcode\n docRoot\nIt resolves to the relative path of the root directory of the generated documents It is used in the URL part \nof links Suppose you have a file called myfilescopyrighthtml  that is located under the root directory of \nthe generated documents If you want to include a link to the copyrighthtml  file in your documentation \ncomment you can do the following\n\n  A dummy class   Please read\n  the a hrefdocRootmyfilescopyrighthtmlCopyrighta page\n \npublic class Dummy \n\n inheritDoc\nIt copies the documentation of a method from the nearest inheritable class or the implementable interface \nNote that for this tag to copy the documentation the method in which this tag appears must override a \nmethod in its parent class or implement a method of the implemented interface\nThis tag may be used only inside the main description in the documentation comment for a method \nor inside the text argument of return  param  and throws  tags for a method If it appears inside the main \ndescription it copies the main description of the overridden method If it appears in another tags text it \ncopies the tags text from the overridden method\nIf a method overrides a method in the parent class or implements a method of an interface the javadoc  \ntool automatically copies the documentation for the main description return  param  and throws  if the \nmain description of these tags is missing in the overriding methodAppendix B  document Ation comments\n969The following documentation comment demonstrates the use of the  inheritDoc  tag It is used \ninside the documentation comment for the getId  method of the SmartPerson  class It is used inside the \nmain description as well as the text section of the return  tag Note that the param  tag is missing from the \ngetId  method of the SmartPerson  class The javadoc  tool will automatically copy the documentation for \nthe param  tag from the getId  method of the Person  class\n\n   A class to represent a person\n \npublic class Person \n    \n      Returns the person id\n      param x The value to add to the id\n      return The person id\n     \n    public int getIdint x \n        return x  10\n    \n\n\n  A class to represent a smart person\n \npublic class SmartPerson extends Person \n    \n      inheritDoc\n      return inheritDoc\n     \n    public int getIdint x \n        return 20  x\n    \n\nThe generated documentation for the getId  method of the SmartPerson  class is as follows\ngetId\npublic int getIdint x\n    Returns the person id\n    Overrides\n    getId in class Person\n    Parameters\n    x  The value to add to the id\n    Returns\n    The person id\n link packageclassmember label\nIt inserts an inline link with the specified label  as the text for the link This tag generates a link that is similar \nto the link generated by one of the forms of the see  tag The main difference between the two is that this \ntag is an inline tag whereas the see  tag is a block tag The following documentation comment shows \nhow to use this tag The use of the following tag will create a link with the text add which will point to the \ndocumentation of the add  method of the Calc  classAppendix B  document Ation comments\n970\n  A dummy class   Please see\n  link comjdojoutilityCalcaddint int add method of the\n  Calc class to learn how to add two integers\n \n \npublic class Dummy \n\n linkplain packageclassmember label\nIt works similarly to the link  tag except that it displays the label for the link in plain text whereas the  \nlink  displays the label for the link in code font Refer to the description of the link  tag for more details\n literal text\nIt displays the specified text without interpreting it as HTML markup or a nested documentation comment \ntag Note that HTML tags are enclosed in angle brackets   If you want to use angle brackets in \ndocumentation comments you need to use the HTML entities  and  If you do not want to use HTML \nentities you can use this tag with your raw text For example it is valid to write literal x  y  anywhere \nin the documentation comment rather than writing x  y \n value packageclassfield\nIt is used to copy the value of a static  and final  field a constant field If it is used without the argument \nit copies the value of the constant field at its location The following documentation comments show how \nto use the value  tag In the documentation comment for the MULTIPLIER  field it uses the value  tag \nwithout an argument which will insert the value of the MULTIPLIER  field In the documentation comment \nfor the DIVISOR  field it uses both forms of the value  tag one with an argument and one without an \nargument The argument MULTIPLIER  refers to the MULTIPLIER  field of the same class\n\n  A dummy class\n \npublic class Dummy \n    \n      The MULTIPLIER is value\n     \n    public static final int MULTIPLIER  2000\n    \n      The value of MULTIPLIER is value MULTIPLIER\n      The value of DIVISOR is value\n     \n    public final static int DIVISOR  1000\nAppendix B  document Ation comments\n971The following is the generated documentation comment that shows the effects of using the value  tag\nMULTIPLIER\npublic static final int MULTIPLIER\nThe MULTIPLIER is 2000\nDIVISOR\npublic static final int DIVISOR\nThe value of MULTIPLIER  is 2000  The value of DIVISOR  is 1000 \n hidden\nThe hidden  block tag hides a program element from the generated API documentation There are ways to \nhide program elements from the generated Javadoc for example all private members of a type are not part \nof the Javadoc unless you specify the option with the javadoc  tool to include them Use the hidden  tag to \nhide program elements which are otherwise not possible to be excluded using any other options Typically \nI create a Test  class in each module to test my logic when I work on a chapter I can hide the Test  class from \nappearing in the Javadoc using the hidden  tag as shown\n Testjava\npackage comjdojoutility\n\n  hidden\n \npublic class Test \n    public static void mainString args \n         Code goes here\n    \n\n index keyword description\nThe index  inline tag can be used to tell the javadoc  tool to index a keyword It can appear in Javadoc as \nfollows\nindex keyword description\nHere keyword  is the keyword to be indexed and description  is the keywords description If the \nkeyword is a phrase consisting of multiple words enclose it in double quotes The following Javadoc tag is an \nexample of using the index  tag with a keyword jdojo \nindex jdojo Info site wwwjdojocom for the Java bookAppendix B  document Ation comments\n972 provides servicetype description\nThe provides  block tag can only be used in a modules declaration It documents an implementation of \na service provided by the module The description may specify how to obtain an instance of this service \nprovider and other details of the provider The following declaration of a module shows an example\n\n  provides comjdojoprimePrimeChecker Provides a generic implementation for the \nPrimeChecker\n                                         service\n \nmodule jdojoprimegeneric \n    requires comjdojoprime\n    provides comjdojoprimePrimeChecker with comjdojogenericGenericPrimeChecker\n\n uses servicetype description\nThe uses  block tag can only be used in a modules declaration It documents that a service may be used by \nthis module The description may specify the details of the provider The following declaration of a module \nshows an example\n\n  uses comjdojoprimePrimeChecker Loads the PrimeChecker services\n \nmodule jdojoprime \n    exports comjdojoprime\n    uses comjdojoprimePrimeChecker\n\n Documenting Packages\nA package declaration appears multiple times in an application There needs to be a simpler and separate \nway to document a package You can document a package by placing either of the following two files but not \nboth in the package directory along with the source files  java  files\n\tpackageinfojava\n\tpackagehtml\n Ti p i f both packageinfojava  and packagehtml  files are available the packageinfojava  file is \nused\nWhen you run the javadoc  tool it automatically uses the documentation in one of these two files as the \ndocumentation for your package The first sentence of the package documentation should be a summary \nstatement about the package The first sentence of the package documentation is displayed in the package \nsummary descriptionAppendix B  document Ation comments\n973 comjdojoutilitypackageinfojava file\nIt contains the package declaration with documentation comments for a package In a packageinfojava  \nfile a package is documented the same way as any other program elements are documented The content of \nthe packageinfojava  file for the comjdojoutility  package is as follows\n\n  Contains utility classes More description for\n  comjdojoutility package goes here\n  since 11\n  version 20\n \npackage comjdojoutility\n comjdojoutilitypackagehtml file\nIt is a regular HTML file with HTML tags The HTML contents within the body  and body  tags are used \nas the package documentation It does not contain a package declaration It does not use the  and  \ncharacters as the start and end of the documentation comment However you can use documentation tags \nthat are valid for the package The content of the packagehtml  file for the comjdojoutility  package is as \nshown\nhtml\n    body\n        Contains utility classes More description for\n        comjdojoutility package goes here\n        since 11\n        version 20\n    body\nhtml\n Overview Documentation\nThe overview documentation is used to write documentation for the entire application in a separate HTML \nfile There is no rule for naming the overview documentation file Generally it is named as overviewhtml  \nThe comment is placed inside the body  and body  tags in the HTML file You need to pass the path of \nthis file to the javadoc  tool using the overview  commandline option The following is a sample overview \ncomment contained in an HTML file\nhtml\nbody\n    API documentation for the dummy application More overview text goes here\n    author Kishori Sharan\n    version 20\nbody\nhtmlAppendix B  document Ation comments\n974 Including Unprocessed Files in\u00a0the\u00a0Documentation\nSometimes you may want to include some files in your Java documentation which you reference inside the \ndocumentation comments For example you may want to display graphics or source code The javadoc  tool \nlets you include files which it copies to the generated documentation directory without processing them \nYou need to create a directory called docfiles  under any package directory that contains java  source \nfiles and copy your extra files in that directory The javadoc  tool will copy all your files to the destination \ndirectory without processing them\n Skipping Source File Processing\nSometimes you may have some Java source files that you do not want the javadoc  tool to process For \nexample you may have some test files for which you do not want to generate documentation The javadoc  \ntool looks at the file name before it decides to process the content of the file If the file name is not a valid \nJava identifier it skips that file If you have a java  source file which the javadoc  tool should skip you need \nto name that file such that the name is not a valid Java identifier For example you may include a hyphen \n in the file name to skip it Note that this strategy of skipping source file processing is needed when you \nare using the javadoc  tool to generate documentation by passing it wildcards   or a package name If you \nsupply the javadoc  tool the list of source files to process you do not need to use this strategy\n An Example of\u00a0Documentation Comments\nListing B1 contains the declaration of a jdojoutility  module with documentation comments Listing B2 \ncontains the source code for a Calc  class It is a trivial class Its purpose is only to demonstrate how to write \ndocumentation comments It uses many of the tags I discussed earlier Note the use of the index  tag in the \ndocumentation comment for the Calc  class which will make the term jdojo  searchable in the generated \nJavadoc The term jdojo  is also searchable because it is part of many modules and packages\nListing B1  The D eclaration of a jdojoutility Module\n moduleinfojava\n\n  A utility module that shows you how to use documentation comments\n \n  author Kishori SHaran\n  since 20\n\nmodule jdojoutility \n    exports comjdojoutility\n\nListing B2  Calc C lass Source Code with Documentation Comment\n Calcjava\npackage comjdojoutility\n\n  A utility class to perform basic calculations on numbers\n  All methods in this class are codestaticcode It\n  provides methods to perform addition subtractionAppendix B  document Ation comments\n975  multiplication and division\n \n  index jdojo Visit wwwjdojocom for more info on Java books\n \n  author Kishori Sharan\n  since Version 10\n \npublic final class Calc \n    \n      Stop someone from instantiating this class This class is not\n      meant for instantiation as all its methods are\n      codestaticcode\n     \n    private Calc \n    \n    \n      Performs addition on two numbers It returns the result of\n      code n1  n2 codeas an codeintcode If the result\n      of coden1  n2code exceeds the range of the\n      codeintcode data type it will not return the correct\n      result For bigger numbers use link addlong long\n     \n      param n1 The first number\n      param n2 The second number\n      return Returns the value of coden1  n2code\n     \n    public static int addint n1 int n2 \n        return n1  n2\n    \n    \n      Performs addition on two numbers It returns the result of\n      coden1  n2code as a codelongcode\n     \n      param n1 The first number\n      param n2 The second number\n      return Returns the value of coden1  n2code\n     \n    public static long addlong n1 long n2 \n        return n1  n2\n    \n    \n      Returns the result of coden1   n2code\n     \n      param n1 The first number\n      param n2 The second number\n      return Returns the result of coden1   n2code\n     \n    public static int subtractint n1 int n2 \n        return n1   n2\n    Appendix B  document Ation comments\n976    \n      Returns the result of multiplication of coden1code and\n      coden2code It may return incorrect result if the value of\n      the multiplication of coden1code and coden2code\n      exceeds the range of the codeintcode data type\n     \n      param n1 The multiplicand\n      param n2 The multiplier\n      return Returns the result of multiplication of\n              coden1code and coden2code\n    \n    public static int multiplyint n1 int n2 \n        return n1  n2\n    \n    \n      Returns the result of integer division of coden1code by\n      coden2code\n     \n      param n1 The dividend\n      param n2 The divisor\n      return Returns the result of coden1  n2code\n      throws ArithmeticException If coden2code is zero\n     \n    public static int divideint n1 int n2 throws ArithmeticException \n        return n1  n2\n    \n\n Running the\u00a0javadoc Tool\nYou need to run the javadoc  commandline tool to generate HTML pages for your documentation \ncomments in the source files  java  files It is easier to generate the Javadoc for multiple modules if you \nplace the source code for all your modules into one directory which contains a subdirectory named after \neach module In the source code supplied with this book we created a directory JavaFundocsrc  which \ncontains the source code for the jdojoutility  and jdojojshell  modules The contents of the docsrc  \nsubdirectory are as follows For these examples of running the javadoc  tool we assume that the following \nfiles contain documentation comments\n\tJavaFundocsrcjdojojshellcomjdojojshellJShellApiTestjava\n\tJavaFundocsrcjdojojshellcomjdojojshellPersonjava\n\tJavaFundocsrcjdojojshellmoduleinfojava\n\tJavaFundocsrcjdojoutilitycomjdojoutilityCalcjava\n\tJavaFundocsrcjdojoutilitycomjdojoutilitypackageinfojava\n\tJavaFundocsrcjdojoutilitymoduleinfojava\n\tJavaFundocsrcoverviewhtmlAppendix B  document Ation comments\n977The overviewhtml  file is the overview documentation file for the documentation There is a package\ninfojava  file for the comjdojoutility  package Calcjava  is a Java source file The moduleinfojava  \nfile contains the module declaration for the jdojoutility  module If you copied the source code for this \nbook in CJavaFun  the CJavaFundocsrc  directory contains the java  source files for the two modules \nThe syntax to run the javadoc  tool is as follows\njavadoc options argsfilepaths\noptions  is zero or more commandline options for the javadoc  tool Options are used to customize \nthe output For example the d option lets you specify the output directory where the javadoc  tool will \nstore all generated output files and the module  option lets you specify the names of the modules whose \ndocumentation you want to generate\nThe argsfilepaths  lets you include arguments for the tool in files Sometimes the comment text \nfor the javadoc  tool becomes too big Some command prompts have limitations on how many characters \ncan be entered as part of a command In those circumstances you can place the commandline arguments \nin one or more argument files and supply those argument file paths as the arguments to the javadoc  tool \nNote that the argument file path is preceded by the  sign The javadoc  tool does not support J options and \nwildcards   in an argument file\n Ti p the javadoc  tool provides many options to customize the generated output files to list all  \noptions you can run it using the help  option You can use a Jversion  option to print the version  \nof the javadoc  tool\nThe following command will generate Javadoc for you\nCJavaFunjavadoc d docs html5 author version modulesourcepath docsrc module \njdojoutilityjdojojshell overview docsrcoverviewhtml\nHere are the details of each part in the command\n\t The current directory is CJavaFun \n\t The d docs  option specifies that the generated Javadoc should be copied to the  \nCJavaFundocs  directory\n\t The html5  option specifies that the generated output should be in HTML 5\n\t By default the javadoc  tool does not generate documentation for the author  and  \nversion  tags The author  and version  options instruct the tool to include the text \nfor the author  and version  tags in the generated documentation respectively\n\t The modulesourcepath docsrc  option specifies that the source for modules is \nin the CJavaFundocsrc  directory\n\t The module jdojoutilityjdojojshell  option indicates that you want  \nto generate Javadoc for the two modules jdojoutility  and jdojojshell   \nIf you want to generate Javadoc for more modules place their source code in the \ndocsrc  directory and include their names in this list\n\t The overview docsrcoverviewhtml  option specifies the location of the HTML \nfile that contains the overview comment for the application for which you are \ngenerating the JavadocAppendix B  document Ation comments\n978You can use one or more argument files to store all the arguments to the javadoc  tool Note that J \noptions and wildcards   are not supported in argument files You must use the command line to enter \nthese two types of arguments Suppose the following are the contents of a file named argstxt  which is \nplaced in the CJavaFun  directory\nd docs\nhtml5\nauthor\nversion\nmodulesourcepath docsrc\nmodule jdojoutilityjdojojshell\noverview docsrcoverviewhtml\nYou can run the javadoc  tool that will use arguments from the argstxt  file as shown here All relative \npaths in the argument file are resolved with respect to the current directory\nCJavaFunjavadoc argstxt\nYou can split the arguments for the javadoc  into multiple files You can pass multiple argument files  \nto the javadoc  tool by separating them by a space as shown here Options can be distributed among \nmultiple argument files in any order You can use a relative path eg argstxt  or the absolute path  \neg CJavaFunargstxt  of the argument file to the javadoc  tool\nCprojectsjavadoc args1txt args2txt args3txt\nThe NetBeans IDE lets you generate Javadoc for your project On the Properties dialog box for your \nproject choose Build  Documenting to get the Javadoc properties sheet where you can specify all options \nfor the javadoc  tool To generate the Javadoc select Generate Javadoc from the rightclick menu options for \nyour project or from the Run menu\n Generated Documentation Files\nThe javadoc  tool generates many HTML files All generated files can be classified into three categories\n\t Files for modules classes interfaces enums annotations packages and overviews\n\t Files to crossreference some pieces of information from one HTML page to another \nsuch as an index page a class hierarchy page for each package a use page for each \npackage etc\n\t Support files\nThe tool generates one HTML file per classinterfaceenumannotation The files are placed in \ndirectories that mimic the package hierarchies of classes interfaces enums and annotations The file names \nare the same as the program elements for which they contain the documentation A packagesummaryhtml  \nfile is included in every package directory that contains package documentation An overviewsummary\nhtml  file is generated for all packages to serve as overview documentation Separate pages are generated for \nmodules\nThe generated HTML pages include the class hierarchy pages a deprecated API page constant values \npages serialized form pages etc These files have selfexplanatory names and they contain a hyphen in their \nnames Support files include any image files a helpdochtml  file to describe the generated documentation \nfiles etcAppendix B  document Ation comments\n979 Viewing Generated HTML Documentation\nYou can view the documentation generated by the javadoc  tool in an HTML page The javadoc  tool \ngenerates an indexhtml  file which is placed at the root in the output directory You need to open the \nindexhtml  file in a browser for example Microsoft Internet Explorer Google Chrome Mozilla Firefox \nSafari etc to view the documentation using HTML\u00a0You can click the Index to get the Index classes \nand methods listed alphabetically of the documentation The HTML page is organized as shown in \nFigure B1\nFigure B2 shows the indexhtml  page opened in normal mode for the Javadoc that you created It \nshows the Javadoc for the Calc  class in the comjdojoutility  packageNavigation Search\nDetails\nFigure B1  Arrangement of the HTML pages that are generated by the javadoc toolAppendix B  document Ation comments\n980The indexhtml  page contains three areas\n\t A navigation area with Overview Module Package and other links at the top left\n\t A Search box area at the top right\n\t A details area at the center\nThe topleft area contains links to Overview all classes all packages and all modules the current \nmodule and the current package When you click a module the page displays all packages in that module \nWhen you click a package it displays all the classes interfaces enums exceptions and annotations in that \npackage It also displays the documentation for the module or the package\n Searching Javadoc\nConsider this scenario You are looking for logic to implement something in Java and you find a piece of \ncode on the Internet which uses a class but does not show the import  statement importing that class You \nhave access to the Javadoc for Java SE and you want to know a little more about the class How do you get \nthe package name of the class which is needed to get to the documentation of the class You search the \nInternet again This time search for the class name which might get you a link to the Javadoc for the class \nAlternatively you can copy and paste the piece of code in a Java IDE such as NetBeans and Eclipse and the \nIDE will help you generate the import  statements to give you the package name of the class Dont worry \nabout this inconvenience of searching for the package name of a class in Java\nThere is another addition to the page  in the Javadoc generated by the javadoc  tool All pages display a \nSearch box on the top right see Figure B2 The Search box lets you search the Javadoc The javadoc  tool \nprepares an index of terms that can be searched To know what is searchable you need to know the terms \nthat are indexed\nFigure B2  The g enerated HTML page for the Calc classAppendix B  document Ation comments\n981\t You can search for declared names of modules packages types and members The \ntypes of formal parameters of constructors and methods are indexed but not the \nnames of those parameters So you can search on the type of formal parameter If you \nenter String int int  in the search box it will find you the list of constructors \nand methods that take three formal parameters of String  int and int If you enter \nutil  as a search term it will show you a list of all packages types and members \nthat contain the term util  in their names\n\t You can search for all keywords and phrases specified with an index  inline tag\nEverything else that is not listed in this list is not searchable using the Javadoc Search box The Search \nbox displays the found results as a list when you enter the search term The results list is divided into \ncategories such as Modules  Packages  Types  Members  and SearchTags  The SearchTags  category contains \nresults found from the indexed keywords that are specified using index  tags\n Tip the Ja vadoc search does not support regular expressions the entered search keyword is searched for \nits occurrence an ywhere in the indexed terms\nFigure B3 shows using the Javadoc Search box with the list of results We generated the Javadoc for \nthe comjdojoutility  module and used it to search for jdojo  as shown on the left of the figure We used \nJavadoc to search for the term Module  as shown on the right of the figure\nFigure B3  The J avadoc Search box with keywords and search resultsAppendix B  document Ation comments\n982You can use the up and down arrow keys or mouse to navigate through the search results You can view \nthe details of the search results in one of the following two ways\n\t Click a search result to open the Javadoc for that topic\n\t When a search result is highlighted using the updown arrows press Enter to open \nthe details about that topic\n Ti p Y ou can use the noindex  option with the javadoc  tool to disable the Javadoc search no index will \nbe generated and no search box will be available in the generated Javadoc\nA Javadoc search is performed locally using clientside JavaScript There is no computation or search \nlogic implemented in the server If you have disabled JavaScript in your browser you will not be able to use \nthe Javadoc search feature\n Summary\nJava allows writing comments in source code that can be used to generate documentation The \ndocumentation comment starts with   and ends with  The javadoc  tool which is included in the \nJDK is used to extract and generate the documentation comments from source code The tool generates \ndocumentation in HTML format The tool contains support for many custom tags with special meaning It \nalso lets you use HTML tags inside the documentation\nApart from HTML tags you can also use some special tags A tag in a documentation comment is a \nspecial type of keyword that is interpreted and processed by the javadoc  tool Two types of tags can be used \nblock tags and inline tags\nA block tag starts with an  character which is followed by the tag name The tag text follows the tag \nname A block tag must appear at the beginning of a line in a documentation comment Note that the \nasterisks whitespace and the  characters are ignored by the javadoc  tool if they appear at the beginning \nof a line\nAn inline tag can appear anywhere in the documentation comment where text can appear An inline tag \nis enclosed in braces\nThe hidden  tag hides a program element in the generated Javadoc The provides  and uses  tags are \nused only on module declarations to document the services provided and used by modules The index  \ntag is used to specify a searchable keyword in the Javadoc\nThere is a Search box at the top right of each page You can search for program element names and \nthe keywords specified with the index  tag If you do not want the Search box to appear in the generated \nJavadoc use the noindex  option with the javadoc  tool983\n Kishori Sharan and Adam L Davis 2022 \nK Sharan and A L Davis Beginning Java 17 Fundamentals   \nhttpsdoiorg1010079781484273074Index\nA\nAbstraction\nabstract data types ADTs 21\nbenefits 23\ncharacteristics 14\ncomponents 20\nconstructor operation 22 347\ncontextkeyboard 15\ndata abstraction 2023\ndecomposition 14\ndefinition 15\ngetRangeSum 16\nhiding complexities 1520\nhidingsuppressing 15\nmethodsobjects 21\nmonolithic program 14\nrequirement 14\nsubprogram 14\nAmerican Standard Code for Information \nInterchange ASCII 948952\nApplication programming interface API\ncase diagram 938\ncreate method 938\nevaluation engine 937\nevent handlers 941\nJava virtual machine 96\njdkjshell module 937\nJShell class 938  939\nJShellApiTest Class 942946\nJShellBuilder class 938\nmain method 944\nmodules 384386\nsnippet class 939941\nsnippetEventHandler method 944\nSourceCodeAnalysis class 938\nArithmetic operator\nmultiplication  156\ndivision  156158\nmodulus \nlefthand operand 159\nmodulus operator 160NaN 159  160\noperation 159\nremainder 158\nruntime error 159\naddition  153155\nunary plus  160\nincrement decrement  163165\ncompound arithmetic assignment 161163\ncompound assignment 162\nintegerfloating point 158\nlist of 152\nsubtraction  155  156\nunary minus  161\nArrays\narraycopy method 690\narray declarations 682\nassignmentcompatible 718  719\nbinarySearch method 723\ncommandline arguments 705708\ncomparecompareUnsigned \nmethods 723725\ncopyOf method 691  725\ndeclaration syntax 714  715\ndefinition 681\nexplicit initialization 689  690\nfill method 725\nforeach loop 713  714\ngetClass method 716\nhashCode method 726\nindividual element 684  685\ninitialization 686  687\njdojoarray module 681\nlearning process 681\nlength property 685  686\nlimitations 690693\nlist conversion 719  720\nmismatch method 724\nmultidimensional  see Multidimensional array\nobjects 683  684  716718\noperations 721  722\nparallel accumulation 726984passing parameter\nclone method 698\nclonedIds array 699\nclonedNames array 700\nelements 701704\nmethodconstructor 696\nreference 701\nswap method 697  698\ntoString method 697\ntryStateChange method 703\nreferencetype object 687689\nremove method 695\nruntime bounds checks 715  716\nsortparallelSort methods 726\nSystemarraycopy method 692\ntoArray method 719\nstring method 722\nvariable declarations 681  682\nvariablelength arrays 693696\nAssertions\nassert statement 502\nAssertionStatusTest class 509\nassert statement 503\nBankAccount class 507\nclass hierarchy 507  508\ncredit method 507\nea andda Switches 506\nenablingdisabling option 505507\nerrorMessageExpression 502  503\ngetPrice method 502\nhardcoded integer values 501\njdojoassertion module 501\nlearning process 501\nliteral meaning 501\nNetBeans project 504\nreComputeState class 508\nstatus 508  509\ntesting 503  504\ntoString method 508\nvalidAccount method 508\nAssignment operator  149151\nB\nBarycentric Dynamical Time TDB 541\nBinary representation\nbinary number 130\nbyteoctet 129\ncomplement forms 132\ncomplements 130\ndecimal number 129\ndigits 129\ndiminished radix complement 130  131\nfloatingpoint systemadvantages 134\n32bit singleprecision 134137\ndenormalsubnormal numbers 133\nexponent value 135  136\nIEEE 7541985 standard 132134\nnormalized form 134\n1925 number 133\nrepresentation 133\nsign bit 135\nsignificand 136  137\nleast significant bit LSBmost significant bit \nMSB 130\nradix complement 131  132\nBitwise operator\nAND  180\nbit patterns 180\ncomplement operator 181\ncompound 183\nright shift  183\nlist 180\nleft shift  182\nNOT  181\nOR  181\nrighthand operand 182\nXOR  181\nBoolean logical operator\nAND operator  177\nshortcircuit AND operator  175177\ncompound Boolean assignment  and \n 179\nNOT operator  175\nOR operator  178\nshortcircuit OR operator  177\nsubsequent sections 174\nXOR operator  178\nC\nCalendar systems\ncalendric systems 544\nGregorian 545\nISO calendar system 591  592\nJulian 544  545\nlunar phase cycle 544\nlunisolar 544\nsolar 544\ntime units 544\nCharacter encoding\nabstract characters 947\nASCII 948952\n8bit character sets 953\nbit combinations 947\ncharacter repertoire 947\ncoded character set 947  948\nglyph 947Arrays  cont \n INDEX985Java virtual machine 956  957\nUCS  see Universal MultipleOctet Coded \nCharacter SetUCS\nChecked and unchecked exceptions\ncatchdeclare\ncatch block 475\nIOException 475\nm1method 471\nmethods declaration 472\npoints 470\nreadChar method 473\nReadInput class 472\nReadInput2readChar method 473  474\nSysteminread method 470\nthrows class 471  472\nerrors 469\nexceptional conditions 468\nreadChar method 468  470\nReadInput class 470\nReadInputreadChar method 468\nRuntimeException class 469\nstandard input 468\nstatic initializer 476478\nunchecked 469\nClasses 225\naccess level modifiers 235238\napproach 226\nattributes 227\nbuilding blocks 254\ncomponents 226\nconstructors 226  253\ndeclaration 226  227\ndefault initialization 234  235\ndot notationaccess fields 231234\nfield declaration 227  228\nfields and methods 226\nHuman instance creation 229\nimport  see Import declarations\ninitialization 226\ninstance creation 228230\ninstances 225\nmain method 225\nmodule dependency 238\nnested class 226\nnull reference type 230  231\npackages 254\nproperties 225\npublicpackagelevel access 254\nrecord declaration 253  254\ntechnical concept 225\nCloning objects\nclone method 413\ncompound object 416\ncontainer object 417\ndeclaration 413DeepClone class 419  420\nDoubleHolder class 414  415\nmeaning 432\nreturn statement 416\nShallowClone class 417  418\nShallowCloneTest class 420\nshallow method 416\nsuper keyword 414\ntest class 415  418\nCoercion polymorphism 28 29\nCommandline options\nGNUstyle options 80\nnamevalue separator 81\nsyntax 80\nUNIXstyle option 80\nCompilation unit 23\nCompiling process\nbytecode 60\nclass files 62\ncomjdojointrojar file 63\ndirectories 62\nerror message 60\nfile path syntax 60\nJAR file 62\nmodule descriptor 63\npackaging code 6264\nPATH environment 61\nsource code 5962\nWelcomeclass 61\nConstructor\naccess level modifier 332336\nanonymous class 338\ncalling class 330332\ncompiletime constants 350\ndeclaration\nCat class 325\nmodifiers 323\nnew operator 325\nsyntax 323\nTest2 class 324\ntest class 324  325\ndefault constructor 336  337  350\ndefinition 323  350\nerror message 331\nfinal keyword\nblank final variable 341\nclass variable 345\ncompiletime error 341\ncompiletime vs runtime final constant \n346  347\ncontexts 340\ninstance variable 342345\nlocal variable 342\nmeaning 340\nparameters 342\n INDEX986reference variable 345  346\nvariable declaration 341\ngeneric class\nabstractionpolymorphism 347\nmapper class 348\ndefinition 347\nget method 349\ntype parameter 347\nWrapperT 348\ninnernested class 336\ninstance initialization block 338  339\noverloading 326  327\npackagelevel access 350\nparameterized classes 350\npolymorphic code 350\nreturn statement 332\nsingleton pattern 334\nSmartDog class 327\nstatic initialization block 339  340\nstatic keyword 337\nsuper method 336\nthis keyword 350\nwriting code 327329\nConstructors 323\nConstructorsinheritance\nmanager class 766\ncompiler modification 768\nCSuperCSub class 764\nemployee class 763  766\nmemory allocation 763\nMemory allocation 763\nnoargs constructor 764  767\nNoSubclassingAllowed class 769\nstring argument 768\nsuper class 765\nsuperclass 768\nD\nData abstraction 2326\nDataTime API\nclasses  see Legacy datetime classes\nformatting\nDateTimeFormatter object 592\nDateTimeFormatterBuilder class 602  603\nformat method 594\nformatTo method 592\nlocalespecific formats 600602\nparsing 592\npredefined format 592594\nsymbols and descriptions 596\ntextual representation 592\nuserdefined patterns 595600\nwithLocale method 595parsing process\ndatatime creation 603\ninstanceof operator 605\nLocalDate class 603\nobject 603\nOffsetDateTime 604\nparse method 603\nparseBest method 604  605\nTemporalAccessor object 604\nData types\nbinary  see Binary representation\nBoolean 145\nbyteshort 144\ncase sensitive 103\nchar literals 145\ncompilerunicode character 127\ncomponents 101  102\ndouble 145\nfloat literals 145\nfloatingpoint numbers 137139\nidentifier 102104\nIEEE floatingpoint standard 141143\nintlong 145\nint type variables 106  107\njdojodatatype declaration 128  129\nkeywords 144\nkeywordsreserved words 104  105\nlearning process 101\nlittleendianbigendian 143  144\nlocal variable type inference 110\nnumbers 105109\nparameterspassing mechanisms 306318\nprimitive data type 102  110\nqualifiedsimple names 102\nreference variables 108  109\nrounding modes 139141\nstring literals 109\nunderscores numeric literals 126\nunicode escape sequences 127\nuserdefined data types 101\nvalid and invalid identifiers 104\nwrapper classes 435\nDateTime API\nadjustments\ndate adjuster 585  586\ndayOfWeek 583\nsource code 583  584\nTemporalAdjusters class 581583\nwith method 582\ncalendars  see Calendar systems\ncentral time zone 543\nclasses 537  613\nclock 574  575\ncomponents 538\ndaylight savings time 543Constructor  cont \n INDEX987design principles 538\nexploring methods\natXxx method 549\nfrom method 548\ngetXxx method 549\nminusXxx method 550\nmultiplication division and negation 550\nnumerous methods 547\nofXxx methods 548\npackagessubpackages 548\nplusXxx method 550\ntoXxx methods 549\nwithXxx method 548\nhumans  see Humanscale time\nhumanscale time constants 556\ninstantsdurations\ncategories 553\ncompTime method 553\nconvertretrieve parts 554  555\ndividedBy method 554\nDuration class 551\ngetEpochSecond and getNano \nmethods 552\nInstant classnow method 551\noperations 552  553\ntimeline representation 550  551\ntoHoursPart method 554\ntruncatedTo method 555\nISO8601 standards 546  547\njavatime packages 613\njdojodatetime module 537\nlearning process 537\nLocalDateLocalTime methods 539  540\nlocal time zonesdaylight saving time 543\nmachineshumans 538\nnegative zone 543\npartials 539  579581\nperiods\nbetweenuntil methods 578  579\nduration 577\nperiod class 576\nplusminus methods 576\nstatic factory methods 576\ntime definition 575\nquerying objects\nCustomQueries class 589\nDatetime objects 587\nquery method 586\nTemporalAccessor class 588\nTemporalQuery class 588\ntoLocalTime method 590\nutility methods 586\nZonedDateTime 590\nsame instantdifferent time  \nzone 573  574tick method 575\ntimekeepingevolution\napparentsolar day 541\natomic time scale 541\ncomponents 541\ncounteraccumulator 541\nEphemeris Time ET 541\nfrequency standard 541\nhuman civilization 541\nmeaning 540\nTAI scale 541\nUniversal Time UT 541\nUniversal Time Zero UT0 541\nUTC representation 542\nDocumentationJavadoc comments\ncalc class declaration 959\nblockinline tags\nadd and multiply  \nmethods 965\nauthor tag 963\ncode font 968\ncontexts 962\ndeprecated tag 963\ndocRoot 968\nexception tag 963\ngetId method 969\nhidden block tag 971\nthrows section 967\nindex inline tag 971\ninheritDoc 968  969\nlink 969\nlinkplain 970\nliteral text 970\nparam 964\nreturn tag 964\nsee reference 964  965\nserial serialized 965  966\nserialData 966\nserialField tags 966  967\nsince tag 967\nsource code 961\nvalue package 970\nversion text 968\ncalc class source code 974\ncomjdojo module 974976\ncommandline tool 959\ndeclaration 959\ndescription selection 962\ngenerated files 978\nHTML tags 960  961\nindexhtml file 979  980\njavadoc tool 976978\njdojoutility module 974976\nkeywordssearch results 981\noverview comment 973\n INDEX988package declaration\npackagehtml file 973\npackageinfojava file 973\nsource files 972\nprovides block tag 972\nsearching process 980982\nskipping source file processing 974\ntypes 960\nunprocessed files 974\nuses block tag 972\nwriting source code 960962\nDuplicate modules\ndirectories 78 80\nerror message 80\njdojointro module 79\nmodulepath 78\npartial output 79\npossibilities 79\nE\nEditcompileexecute loop  \nECEL 890\nEncapsulation 23\nEnumeration enum types\naccess modifier 867\napproaches 866  867\nCommandList 883\nconstants 868\nequality operator  880\nBasicColor enum 880\nbody association 875\ncompareTo method 879\nequals method 880\nETemp enum type 875\ngetProjectedTurnaroundDays method \n874  875\ngetValue method 876\nSmartSeverity declaration 873875\nSuperSmartSeverity method 877879\nDefectUtil class 866  872\ndefinition 865\ninteger constants 867\ninterfaces 882  883\njdojoenums module 865\nlearning process 865\nMerriamWebster online  \ndictionary 867\nname and ordinal type 869\nnested declaration 881  882\nordinal values 869\nranges 884  885\nreverse lookup 883  884\nseverity class 866superclass 869872\nswitch statements 872  873\ntypesafe constants 885\ntype variable 868\nvalueOf method 870\nequals method 723\nException handling\nabnormal condition 456\ncatching 457\ncheckedunchecked  see Checked and \nunchecked exceptions\nclass creation 479482\nclass hierarchy 463465\ndefinition 455\nerror handling code 456  457\nfinally block 482485\ngetStackTrace method 481\ninheritance hierarchy 462464\njdojoexception module 455\nlearning process 455\nmultiple catch blocks\nclass hierarchy 466\nmulticatch block 467\nMyException type 465\nreference variable 464\nRuntimeException class 467\nsource code 466\ntry block 466\nvaild statement 464467\nMyException class 479\nobjects 458\nprintStackTrace method 481\nrethrowing process\nanalysis 488  489\ndefinition 485488\nfillInStackTrace method 487\ninitCause method 487\nMyException 489\nRuntimeException method 487\nsource code 488\nthrows clause 489  490\nstack threads\ndefinition 490493\nfillInStackTrace method 492\ngetStackTrace method 491\nlastin firstout memory 490\nm1 m2 and m3 methods 491\nmemory arrangement 490\nThrowable class 492494\nthrow statement 478\nthrowing class 458  480\ntransfer of control 461  462\ntrycatch block 458461\ntrywithresources 493498\nuncaught exceptions 459DocumentationJavadoc comments  cont \n INDEX989F G\nFloatingpoint operation\nbinary 132137\nbit pattern 139\ndenormalized number 139\nIEEE standard 141143\ninfinities 137\nnotanumber NaN 138\nprimitive 121126\nsigned zeros 137\nFormatting data\napplyPattern method 618\ngetInstance method 616\ngetTime method 620\njavatext package 615\njdojoformat module 615\nlearning process 615\nlocale object 616\nparsing dates 620622\npredefined date 616618\nprintfstyle  see Printfstyle  \nformatting\nSimpleDateFormat class 618620\nnumber object\napplyPattern method 623\nclasses 622\nDecimalFormat class 623  624\nparse method 624  625\npredefined number  \nformats 622  623\nH\nHumanscale time\nclassescomponents 556\nenums representing constants\ncomponent 560\ndatetime fields 562  563\ndayOfWeek 561  562\ngetLong method 562\nisSupported method 562\nminus and plus methods 563\nmonth enum 560  561\nunits 563  564\ngaps and overlaps 571\nmachine time 556\nlocal datetimedatetime  \nclass 564569\nOffsetTimeOffsetDateTime  \nclasses 569  570\nZonedDateTime  \nclass 570573\nZoneId class 557560\nZoneOffset class 556  557I\nIEEE floatingpoint standard\nbinary 132\ndefinition 141\ndivision 141\ninexact exception 142\ninvalid operation exception 141\nJava implementation 143\noverflow exception 142\nparameters 143\ntypes 141\nunderflow exception 142\nImmutable object\nadvantages 422\ncopy constructor 427\ngetHalfValue method 424\ngetIntHolder method 426\nhalfValue instance variable 424\ninternal and external state 422\nIntHolder class 422  423\nIntHolderWrapper class 425  426\nIntWrapper class 424\nmutable object 422  423\nsetValue method 423\nsource code 423\nstring class 425\nvalueHolder instance variable 425\nImport declarations\nautomatic declaration 248  249\ncompilation unit 238  239\ncompiletime error 240  252\nimportondemand  \ndeclaration 241243\npackage declaration 238\nrules 238\nsinglestatic declaration 250\nsingletype 239241\nsingletype import 242\nstatic declarations 250\nstatic variablesmethods 249252\ntest method 252\ntype search order\ncompilation error 244\ncompilation process 243\ncompiletime error 245  246\nimportondemand  \ndeclarations 247\nremove method 246\nrules 248\nsearches 244\nsingletype 244  245\ntype reference 243\nInclusion polymorphism 29 30\nInformation hiding 23 24\n INDEX990Inheritance 25 26 731\nabstract classesmethods\ncircle class 780  781\nconcrete class 777\ndraw method 778\ndrawShapes and printShapeDetails \nmethods 782\ngetArea and getPerimeter methods 779\ngetArea method 781\ngetName and setName methods 779\nshape class 778\nimplementation 783  784\nprintShapeDetails method 782\nrectangle class 779\nshapes 777\nShapeUtil class 781  782\nsource code 779\naggregation 788\nAOSuper class 757\nbaseparent class 732\nbinding\nearly binding 745748\nlate binding 748750\nLateBindingSuper class 748  749\nmyObject reference variable 744\nnonstaticnonfinal methods 748\nsetName method 748\nstatic methods 747\nclasses 732\ncomposition 788\nconstructors  see Constructorsinheritance\ndefinition 731\ndisable subclassing method 776  777\ndowncasting 740743\nemployee class 733\nequals method 743\nextends keyword 732\nfield declaration 772776\ngetName and setName 731\nhierarchical relationship 735  736\ninstanceof operator 742744\njdojoinheritance module 731\nmanager class 734\nmethod hiding 770774\nmethod overriding\naccess levels 754\nadd method 762\nBadEmpIdException 756\nclass declarations 751  752\nclass definition 754\nconstraints 757\ndeclarations 754\ndifferences 760\nEmpNotFoundException class 755\ngeneric method signatures 785  786getEmp method 753  755\ninstance method 752\nisahasapartof relationship 788  789\nmethod declaration 756\noverridden method 757\nparameters 753\nprint method 751  752\npublic protectedpackage level 754\nreturn types 753\nsource code 755\ntest program 761\nthrows clause 754  759\ntypo danger 786788\nMHidingSuper class 770\nmultiple classes 790  791\nobject class declarations 735\nobjects 731\noverridden method 757  758\npatternmatching 742\npattern switch statementexpression 790\nprintName method 739  740\nsealed class feature 777\nsubclass 736  737\nsuperclass 733\nclass declaration 732\nobject class 735\nsubclass 732\nstack and vector classes 789\ntype erasure 785\nupcasting 738741\nIntegrated development environments IDEs 97\nInterfaces\nannotation 850\ncomparing objects\nComparablePerson class 852  853\ncomparator 853857\ncompareTo method 851  852\ncomparable 851853\nconcept 797\nconflicting implementation\nobject class 842\ngetRate method 845\ninheritance 842\nisEmpty method 843\nsizeable interface 843\nemployeemanager classes 841\nMultiTalented class 845\noverride classes 844  845\nsuperclass 841\nsuperinterfaces 841  844\ntoString method 842\nrunner interface 842\ndeclaration 806  807\ndynamic binding 860\nenumeration 882  883\n INDEX991person class 798  802\nfunctional interface 850  851\ngetWalkMethod method 800\nideal solution\ncat class 805\nduck class 803\nmethod parameter 804\nreference type 806\nrevised person class 803\nsteps 802\ntest class 805\nwalk method 803  804\nWalkable declaration 803\nWalkables class 804\ninheritance\nCharitySinger interface 836  840\nCharitySingerPlayer interface 838\nconflicting method 838\nmelodist class 837\nerror message 838\ngetRate method 839\ngetRatesetRate method 840\nsinger 835\nmelodist class 837\noverriding method 838\nplayer 835\nsetRate and getRate methods 835\nSingerPlayer interface 837\nSingerWriter interface 836\nsuperinterfacessubinterface 835\nwriter 835\ninstanceof operator 845849\nfish class 824\njdojointerfaces module 797\nlearning process 797\nletDucksWalk method 801\nletThemWalk method 799  801\nmarker interface 849  850\nmember declaration\nabstract methods 810812\nconcrete method 816\nconstant fields 808  809\ndefault implementation 812816\nisAtOddpos and isAtEvenPos \nmethods 817\nmethods 809  810\nmovable interface 812  815\nnamed interface 815\nnested type declaration 818820\nmovable interface 814\npen class 813\nplay stop forward and rewind 810\nprivate methods 816818\nstatic modifier 811  812\nsupported modifiers 818types 807\nWalkableletThemWalk method 812\nwithdraw method 811\nmethod declaration\nbanker interface methods 828\nArbitraryException class 829\noverriding method 830\nthrows clause 827830\nUnstablePredictableBank class 828\nwithdraw and deposit methods 827829\nmultiple implementation 830832\npartial implementations 832834\npolymorphism  see Polymorphism\nreference type 820823\nspecificationimplementation 823827\nsuperinterfacesubinterface relationship \n840  841\nsupertypesubtype relationship 834\nSwimmableTest class 820\nturtle class 831\nduck class 799\nwalk method 798\nWalkables class 798801\nInternational Air Transport Association IATA \nprovider 560\nJ K\nJava development kit JDK\narrangements 36\ndirectory structure 3437\ninstallation directories 3436\nJAVAHOME 34\nJDKHOME 34\nJREHOME 34\nJShell tool 38\nNetBeans 125\ndialog box 42\nIDE screen 39\ninstallation 38\nplatform manager 40\nstart page menu item 38\ntype box 41\nPATH environment 38\nroot directories 35 36\nverification 37 38\nversion information 37 38\nweb pages 33 34\nJava programming language\napplets 12\nbugdebugging 13\nbytecode 12\ncharacteristics 12\ncomments 48 49\ncompilermodified declaration 50\n INDEX992compiletime errors 13\ndistributed application 13\nerrors 13\nfeatures 12\ngoal statement 45 46\nJavadoc comments 49\nlogic errors 13\nmodule declaration 4951\nmultiline comment 49\nobjectoriented paradigm\nabstraction 1322\nencapsulation 23 24\ninformation hiding 23\ninheritance hierarchy 25 26\npolymorphism 2630\nprinciples 13\nprogram development 46\nrunning program\nbuiltin modules 67\nclass file 70\njdojointro module 67 68\nlauncher 64\nmodule graph 6567\nmoduleinfoclass file 68\nmodulepath 67 68\nmodules 65\nobservableroot modules 65\nuserdefined modules 67\nWelcome class 65 69\nruntime errors 13\nsimplicity 12\nsingleline comment 48\nsource code 47 48\nstructure 47\ntypes  see Type declaration \nwrite once run anywhere WORA 12\nJava Runtime Environment JRE 34\nJava shell JShell\nAPI evaluation 937945\narchitecture 892  893\nautocompletion\nslash  and press Tab 917\narguments 918\nassignment expression 919\nfeature 916\nkey combinations 916\nLocalDate class 919\nShiftTab 918\nShiftTabI 919\nsubstring method 918\ntab key 916\nstring class 917\nchecked exception 915  916\ncommandline tool 889command prompt 893895\nconfiguration 925\ncontextspecific format 931\ncustom feedback modes 929933\nDEFAULTPRINTINGJAVASE script 935\nfeedback mode 927929\nkverbose 929\npredefined scripts 935\nsilent mode 932\nsnippet editor 925  926\nstartupjsh 933\nstartup snippets and commands 933936\ndivide method 920\nexecution environment 914  915\nexit tool 895\nexpression evaluates 897  898\nextensive documentation 936  937\nimport statements 907910\njdojojshell module 889\njshelljsh file 922\nlearning process 889\nmethod declaration 910  911\nphrases 889\nreading stack trace 920  921\nreloading command 923925\nREPL  see ReadEvalPrint loop REPL\nresetting effects 923\nreusing sessions 921  922\nsnippets  see Snippets\nSystemoutprintln method 894\ntype declarations 911914\nJava virtual machine JVM 3\napplication programming interface 96\nbytecode 98\ncharacter encodings 956  957\ncomponents 97\nroot modules 98\nscenes\nadvantages 95\narchitectureneutral 95\nbytecode format 95\ncontexts 95\nFrenchman communicate 94\ninterpreter 96\nplatform 95\nruntime system 95\nspecification 94\ntranslator 94\nJShell tool 46\nL\nLegacy datetime classes\nadd method 608\ndate class 606  607Java programming language  cont \n INDEX993calendarabstract class 607  608\nconversion 610612\nGregorianCalendar class 608\ninteroperability 606  609613\nofInstant method 612\nroll method 608  609\ntoInstant method 610\nLegacy mode\nasterisk 78\nclassesmodules 76\nclasspath 76 77\njavabase module 76\nmoduleinfoclass file 77\nmodulelegacymixed mode 76\nsynonymous options 76\nunnamed module 78\nWelcome class 77\nWindows 77\nM\nMethods\naccess levels\nAccessLevel class 278  280  281\naccount class 283285\nclass members 276  277\ncompiletime errors 280\ncredit and debit methods 284\ncredit method 288\ndeclarations 278\nintermodule 277\nisValidAmount method 287\nkeywords 276\nmodifiers 276\npackagelevel  \naccess 276  282\nprivateprotectedpublicpackage \nlevel 283\npublic class 277\nqualified export 277\ntest class 279\nactual parameters 260\nadd method 258\nclass definition 257\ndeclaration 257262\nformal parameters 259\ninvokingcalling method 267  268\nlearning process 257\nlocal variables 262\ncompiletime error 263\ndeclaration 263\ninstanceclass methods 266  267\ninstanceclass variable 263  264\nNameHidingTest2 class 264\nNameHidingTest3 class 265static and nonstatic methods 266\nvariable declaration 263\nmain method 268271\nMethodTypeTest class 269\nobjectobject classes 397  398\nparameters 257\npassing parameters 295318\nprintMN method 267\nprintPoem method 261  262\nreturn statement 260\nsignaturesdeclarations 259\nthis keyword\ncontext type 275\nclass variable 271\ncompiletime error 275\nCorrectThisTest3 class 272\ndeclaration 271\nerror message 271\ngetId method 275\ninstance method 273\ninstance variable 274\ninitialization expression 272\ninstance methods 276\nprintNum method 273  274\nThisTest3 class 272\nvariable name hiding 273\nthrows clause 258\nvarargs  see Varargs method\nModule options\ncommandline options 70\ndescribe 72 73\ndescription 74 75\ndryrun program 74\nduplicate modules 7880\nlegacy  see Legacy mode\nlimiting option 71 72\nlist observable modules 70 71\nprinting details 73\nModules\naggregator 384  392\nautomatic module 392\nclass dependency analyzer 387  388\nclasses and interfaces 392\ndeclaration 356  357\naddress class 361  362\ndependency 360\nexporting 358\njavabase module 359\njdojoaddress module 361\njdojoperson module 365\njdojopolicy module 358  360\nmodule graph 361363\nNetBeans project 364\npackages 358\nperson class 363\n INDEX994qualified exports 359\nqualifiedmodulefriendly exports 358\nrequires statement 359\nunqualified export 358\ndirectives 357\ndisassemble class files 388391\nexplicit module 392\nexports statement 392\ngetClass method 384\ngetDescriptor method 385\ngetModule method 385  392\ngetName method 385\nimplicit dependence 367373\nlearning process 355\nmigration path 386  387\nModuleInfo class 385\nnamedunnamed module 392\nnormal module 392\nopen module 392\noptional dependence 373  374\nordinarymodular compilation units 356\npackages 355\ncompiletime access 374\ndeep reflection 375\ngetFirstName method 374\nopen modifier 375\npackages 376\nreflection 374\nruntime verifies 374\nstrong encapsulation 375\ntypes 374\nrestrictions 377\nruntime API 384386\nsplitting packages 377  392\nstatements 357\ntransitive modifier 392\ntroubleshooting\nempty package error 366\njohngetAddress method 369\nmodule not found error 366\npackage exist error 366\nresolution exception 367\nscenarios 366\ntypes of\nautomatic module 379383\ndefinitions 378\nexplicit 383\nflow diagram 378\nnormalsimply module 379\nopen modifier 379\nunnamed module 383  384\nMultidimensional array\naccessing elements 712\narray of arrays 710initialization 713\nragged array 711\ntwodimensional array 709  710\nzerorow and zerocolumn 713\nN\nNested block statements 194\nNetBeans IDE\ncategories 92\nclasses 91\ndirectory structure 91\nmodular JAR 90\nproject creation\nclass details 88\ndialog screen 83\ngraph project 87\nJava17Fundamentals 84\njdojointro module 87\nmain method 89\nmenu module 85\nmodular application dialog 84\nmodule dialog 86\nmoduleinfojava file 86\noutput tab 90\nprojects files and services tab 85\nstartup page 82\nsteps 82\nwelcome class 89 90\nproperties 9193\nsource code 93\nworking process 81\nNetBeans projects modules 364\nO\nObjectobject classes\nequality operator  404409  432\nbounds checks 427  428\nclass definition 398  399\ncloning  see Cloning objects\ncompare method 428\ncomparison 404409\ncompute hash codes 428\nfinalize method 420422  433\ngarbage collector 420\ngetClass method 399  432\nhash code 400404\nbusketcontainer 400\ncomputing process 400\ndefinition 400\nequals and hashCode  \nmethods 409\nhashCode method 401403  432\nidentitystate comparisons 407Modules  cont \n INDEX995immutable 422427\ninstanceof operator 396\njavalang package 395\njavautil package 427\njdojoobject module 395\nlearing process 395\nmethod categories 397  398\nmethod declaration 396\nnull method 429\nObjectshash Method 428\noperation 427\nreference variable 396\nstring representation\ndefinition 410\nmethods 430\nSmartIntHolder class 410\nsource code 410\nSystemoutprintln  \nmethod 413\ntoString method 410412\ntest class 430432\ntoString method 432\nvalidating arguments 429\nObjectoriented OO paradigm\nclasss definition 9\nconstructor 10\ndataalgorithm definition 9\nfeatures 11\ninstance variables 10\nmethods 9 10\nrealworld persons 10\nstateinterface 11\nofDateAdjusterDatetime API 583\nOperators\nassignment operator  \n 149151\narithmetic operator  see Arithmetic operator\nassignment 151\nbinary operator 148\nbitwise 180184\nBoolean logical operator 174179\ncategories 148\ndeclaration 151\ndefinition 147\ninitialization 151\njdojooperator 147\nlearning process 147\npostfixprefix unary operator 148\nprecedence hierarchy 184  185\nrelational operator 169174\nstring concatenation 165169\nternary operator 148  179\ntypes 147\nunary operator 148\nOverloading polymorphism 27 28P Q\nParameterspassing mechanisms\ncomponents 295\nconstant reference value 304\ndereferencing 296\nmethods 295\nparameters 296\nparameters names 305  306\npass by constant value 299\npass by need 306\npass by reference 299303\npass by value\nactualformal parameters 297\nadvantagesdisadvantages 299\nincrement method 297  298\nparameters 297\nsmartIncrement method 298\nswap method 299\nprimitivereference data type\nCar statement 308\nchangeString method 317\ncompiler error 316\nmemory state 306318\nmyCar reference variable 309  314\nnull reference 314\nnull statement 309\nparameters 312\npass by constant value 312  314\npass by reference value 315317\npublic instance variables 307\nreference variables 308  311  312\nswap method 313\ntest method 313  315\nxyCar reference variable 309\nxyCar referencing object 310\nreference value 303  304\nreference variable 296\nrelationship 295  296\nresult 304\nsquareDivide method 306\nsyntaxsymbols 295\nvalue result 304  305\nvariablereference variable 296\nPolymorphism\nad hoc polymorphism 26\nanObject variable 859\nbite walk and swim 859\ncategories 26\ncoercion 28 29\ndefinition 858\nflowchart 858\ninclusion 29 30\ninstanceof operator 859\nmeaning 26\n INDEX996overloading 27 28\nprocessDetails method 29\nsquare method 28\nuniversal polymorphism 2630\nturtle class 858\nWalkableSwimmable interfaces 858\nwidening conversion 28\nPrimitive data types\nbyte variable 115  116\ncategories 110\ncharacter literal\nboolean literals 120\nescape sequence 118  119\nformats 117\noctal escape sequence 119  120\nsingle quotes 118\nunicode escape sequence 119\nfloatingpoint\nconstants 123  125\ndecimal number format 122\ndouble literals 124126\nfixedpoint number format 121\nfloat literals 122125\nnumeric data types 121\nreal number 121\nrepresentations 121\nscientific notation 122  125\ninteger literals 112  113\nintegral data type 111\njdojodatatype declaration 128  129\nlist of 110\nliteral type 111\nlong type 113115\nnumericboolean 110\nreference type 108  109\nshort variable 117\nwrapper classes 435\nprintfstyle formatting\nargument specifier\nargument 630\nexplicit indexing 632\nordinary indexing 630  631\nrelative indexing 632  633\nsource code 630\nconversion characters 634\ncategories 634\ncharacter formatting 639\ndatetime formatting 645648\nfloatingpoint number  \nformat 642645\nformatTo method 637  638\ngeneral formatting 635639\nint and BigInteger argument types 642\nintegral number format 640642numeric formatting 639645\nwriting code 637639\ndatetime\nsuffix characters 645  647\nsyntax 645\nTemporalAccessor 645\ndetails 628630\nFileNotFoundException 627\nflags 633  634\nformat method 627\njavautilFormatter  \nclass 625628\nprintf function 625\nspecifiers 629\nSystemoutprintln and  \nSystemoutprint methods 626\ntoString method 626\ntrywithresources block 627\nProgramming concepts\naheadoftime AOT compiler 3\nassembly codeassemblermachine code 2\nassembly language 2\nbinary format 1 2\ncompiled code 3\ncompilermachine codesource code 3\ncomponents 4\nhuman communication 1\ninterpreterbytecode 3\nJava  see Java programming language\nlowlevelhighlevel details 2\nmachine language 2\nmeaning 1\nparadigms\nanalysis phase 5\ndata and algorithm 6\ndeclarative 7\ndefinition 4 5\nfunctional paradigm 8\nimperative 6\nlogic paradigm 8 9\nobjectoriented OO paradigm 911\nphilanthropists solution 5\nprocedure 7\nrealworld problem 4 5\nshortage of food 5\nrequirement 1\nsource code 3\nR\nRegular expressions\nappendReplacement method 673\nappendReplacement and appendTail \nmethods 674\nappendReplacement method 674Polymorphism  cont \n INDEX997appendTail method 674\nbackslashes 661\nboundary matchers 662  663\ncharacter class\nclass constructfiles 654\ndefinition 654  655\npredefined classes 655  656\nclasses 656\ncompile method 656  657\nemail address validation 652  671\nend method 658\nfind method 658\nfindandreplace 671675\ngroup method 659\ngroupsback reference\npattern and matcher classes 667\ngroupCount method 663668\nmain method 668\nreplaceAllreplaceFirst  \nmethods 667\nreplaceAll method 666  667\nreplaceAllString and  \nreplaceFirstString methods 667\nreplacement text 666\njdojoregex module 651\nlearning process 651\nmatcher method 658\nmatches method 652  653\nmatch pattern 658660\nmetacharacters 654\nnamed groups 668670\npattern object 657\npatterns 651\nquantifiers 661  662\nquerying process 660  661\nreplaceAll method 653\nreplaceFirst method 653\nreset method 671\nresults method 675\nstart and end methods 670\nstart method 658\nstreams 675677\nstrings 651  652\ntoList and toSet 676\ntoMatchResult method 660\nword boundary 663\nRelational operator\ninequality  172  173\nequality  170172\nerror messsage 171\ngreater than  173\ngreater thanequal to  173\ninstanceof operator 169\nless than  174\nless thanequal to  174NaN classes 171\nnegativepositive zero 171\nReadEvalPrint loop REPL\nconceptual diagram 890\nHello world message 890\ninteractive language shell 890\nprimitive functions 890\nsynthetic classes 892\nRounding modes\nnearest 141\nnegative infinity 140\npositive infinity 140\ntruncationchop mode 140\ntypes 139\nzero 140\nS\nSingle abstract method SAM 850\nSnippets\nAPI events 939941\nclass diagram 940\ncommands 895  896\ndefault editor 925  926\nedit tool 902904\nevent handlers 941\nexpressions 897  898\nhistory 919\nlist command 899901\nnavigation keys 902\nrerun previous 904\nspecification 896\nstartupcommands 933936\ntext modification 902\nstring array 944\nvariable declaration 904906\nStatements\nblock 193195\nbreak statement 201  215217\ncategories 192\ncontinue 218  219\ncontrol flow 193\ndeclaration 192\ndowhile statement 213215\nempty 219  220\nexpressions 192  193\nifelse statement 195199\njdojostatement file 191\nlearning process 191\nspecification 191\nfor statement\nbreak 207\ncondition expression 207\nemptynull statement 206\nexpression list 207210\n INDEX998flow diagram 205\nforloop 204206\nforeach loop 210\ninitialization 204207\nswitch statement 199203\nswitch expressions 203  204\nwhileloop 211213\nString objects\nconcatenation operator  512\nappend methods 529\nCharSequence 513\ncomparison 516518\nconcatenation  532\ncreation 513\ndefinition 511\nemptyStr variable 513\nescape sequence characters 512\nimmutable 515  516\nintern method 519\njdojostring module 511\nlanguagesensitive comparisons 533  534\nlearning process 511\nlengthcapacity methods 530\nlength method 514\nliterals 512\nmultiline 532  533\nobjects 514\noperations 520\ncharAt method 520\nempty 521\nequalsIgnoreCase method 520\nindexOf and lastIndexOf methods 522\nreplacing part 523\nrepresentation 522\nstartsWithendsWith method 524\nsubstring method 522\ntoLowerCasetoUpperCase method 521\ntrim method 522\npalindromes 527  528\npool 518\nreference variable 515\nsplittingjoining method 524  525\nStringBuilderStringBuffer classes 529531\nswitch statement 525527\ntesting\nempty 521\nequality 520\nunicode escapes 513\nString concatenation operator \naddition operator 165  168\ncompiletime error 167\nexpression 166\nparentheses 167primitive data types 165  166\nprintlnprint method 168\nsource code 168  169\nSystem requirements 33\nT\nTemps Atomique International  \nTAI 541  542\nTernary operator 179\nTerrestrial Dynamical Time TDT 541\nTrywithresources block\napproaches 497\nAutoCloseable resource class 494\nclose method 494  495\nfinal keyword 497\ngetSuppressed method 496\nmultiple resources 494  497\nMyResource object 495\nResourceTest class 498\nsource code 493\nType declaration\nclass 5459\ncompilation unit 51 55\nfully qualified name 59\nimport 53 54\nmethod declaration 56\nmodulepath 53\npackage 5254\nparameter 57\nsimple name 59\nunnamed package 53\nWelcomejava 59\nU\nUCS Transformation Format 16 UFT 955\nUnderscores 126\nUnicode character set 954\nUniversal MultipleOctet Coded Character \nSet UCS\nbasic multilingual plane BMP 954\ncharacter encoding methods 954\ndefinition 953\nfourdimensional structure 953\nhexadecimal digits 954\noctets 953\nUCS 2UCS 4 954\nUnicode 954\nUTF 8 sequences 955  956\nUTF 16 955\nzones 954\nUniversal polymorphism 2630\nUniversal Time UTC 542Statements  cont \n INDEX999V\nVarargs method\naMethod method 291\narity 288\nellipsis 290\nforeach loop 292\nint data type 290\nmain method 294\nMathUtil class 289\nMathUtil2 class 289\nMathUtil3max method 290\nMathUtil4max method 292\nMathUtil5max method 293\nmax method 288  291  292\noverloading rules 293  294\nrestrictions 291\nutility class 293\nW X Y Z\nWrapper classes\nautoboxingunboxing\ncomparison operations     \nand  450\nadd and get methods 452\nadd method 445collections 452  453\ndefinition 446\nmain method 446\ninteger objects 444446\nnull values 446\noverloaded method 447450\nprimitive types 444446\ntest methods 448  449\ntwostep process 447\ncharacter class 441\nconstructors 437\ncharacter class 441\njdojowrapper module 435\nobject creation 436\nboolean class 442\noverview 435\nprimitivereference types 435\nnumberic classes\ndeclaration 438440\nint value 439\nintValue method 438\nNumberFormatException 439\nparseDouble method 440\nparseInt method 439  440\nprimitive values 439\nunsigned numeric operations 442444\nvalueOf method 436  437\n INDEX"
}
