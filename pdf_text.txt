
©Manning Publications Co.  To comment go to  liveBook 
MEAP Edition 
Manning Early Access Program 
The Well-Grounded Python Developer 
Version 8 
Copyright 202 2 Manning Publications 
For more information on this and other Manning titles go to 
manning.com  
©Manning Publications Co.  To comment go to  liveBook welcome 
Thank you for purchasing the MEAP for The Well-Grounded Python Developer . The goal of this 
book is to take you past beginning Python programming to the point where you think and 
feel like a software developer. Where the syntax and grammar of Python are not only 
comfortable for you but become the tools of a craftsman. With these tools you’ll be able to 
take on bigger and more complex projects. 
I first discovered Python when I moved from the world of Windows development to 
the Linux environment. I was an accomplished C/C++ developer, but was interested in 
learning the scripting languages available in Linux. Fortunately, I came across Python 
because of its strong support for Object Oriented Programming, which I enjoyed in C++. 
Since then I’ve never looked back, and Python has become my primary language. 
There are a lot of beginner Python books, Python cookbooks and reference titles, and 
many of them are very good. To get the most from this book you should be past the beginner 
level and comfortable with Python. My hope is this book provides a middle ground that gives 
you more context about how and why you should take certain paths when developing a 
program. 
You’ll take the loops, conditionals and statements you know now and create larger 
constructs to handle bigger programming challenges. You’ll learn some conventions and 
patterns that will reduce the cognitive load on you solving smaller syntactic issues and begin 
to think how to solve the big picture problems. How the tools you have, and will learn 
about, can be combined to take goal from problem to solution. 
The book does this by taking you along on a development journey to build a web 
application providing a simple blogging platform. While I think that’s an interesting application 
to build, the creation of that application isn’t the end goal of the book. The journey is far more 
important, the ideas and implementation of those ideas as code, is the real value. 
The chapters progress and build on the previous ones to illustrate why certain choices were 
made, and how those choices can be altered and improved as more is learned later in the 
book. 
As developers we are at an interesting place in the history of the industry. Engineering 
standards are as important in software development as they are in other disciplines. However, 
the pace of change in the software world changes those standards as well and provides an 
opportunity for a great deal of craftsmanship and artistry from a developer. Python gives you 
a powerful palette of tools to express that. 
Please feel free to share your comments, questions, and suggestions in Manning’s liveBook 
Discussion Forum for my book. 
—Doug Farrell 
©Manning Publications Co.  To comment go to  liveBook brief contents 
PART 1:   GROUNDWORK  
  1  Becoming a Pythonista 
  2  Your Development  Environment 
  3  That’s a Good Name
  4  Where Developers and Computers Meet   
  5  The Object of Conversation 
  6  Exceptional Events
PART 2:   FIELDWORK  
  7  Sharing With the World   
  8  Doing it With Style      
 9  Do I Know You?  
10  Persistence Means Never Having to say Goodbye 
11  I’ve Got Something to Say  
12  Are We There Yet?
©Manning Publications Co.  To comment go to  liveBook  1 
Becoming a Pythonista  
This chapter covers  
•Who is the intended audience?
•Being a developer
•Reaching goals
•Using Python
•The Version of Python to use
Welcome to The Well -Grounded Python Developer! I'm happy to have you here for a journey 
I hope takes you to a place where you'll become not only a more robust programmer but one 
who thinks like a developer and expresses those thoughts using Python.  
Right away, I want to clarify the use of a few terms, programmer, developer, and 
Pythonista. You might think pro grammers and developers are interchangeable; indeed, many 
job descriptions use the words that way. It's easy to think that way because the two are 
related.  
A programmer is very focused on creating program code, using technology in that process 
and implemen ting designs. A developer can, and often does, all of those things as well, but 
additionally thinks about the bigger picture. The big picture includes the architecture of more 
extensive applications, the design to achieve it, and pulling all the disparate parts together to 
implement it.  
If you've read material online in the Python community, you've probably seen the term 
Pythonista. This term is an endearing name in the community to refer to ourselves and others 
who are enthusiastic about Python.  
Along the  way, we'll create programs and applications that will build upon each other, 
introducing ways to take on larger projects and break them up into smaller, more manageable 
pieces. As a developer, that's what you'll do. You'll be able to take on complex proje cts using 
1
©Manning Publications Co.  To comment go to  liveBook  multiple technologies and see not only what you need to do, but how you can create them. 
You'll be able to see your way clear to develop the code that brings a project to life.  
Rather than start with a complex system breaking it down into smaller  pieces and work 
through them in the chapters of this book, we'll take a different approach. We'll start by 
building a foundation of skills and tools generally useful to developers. We’ll use those tools to 
build standalone applications demonstrating those  tools.  
Once your toolbelt has been expanded you’ll create a straightforward web application to 
get comfortable with the challenges it presents. Then modify that application to incorporate 
new features. Each step will build on this knowledge to introduce one or more new abilities, 
techniques, modules, and solutions.  
Python can take you to wonderful places. You only need to take those first steps. With that 
in mind, let's get started!  
1.1 Who is the intended audience?  
One of the stated goals of this book  is to help you become a Pythonista. With that in mind, 
who is the intended reader of this book? I think there are a few broad types of readers who 
will benefit from the material presented here.  
The first type of reader is someone who knows the basics of P ython programming, how to 
write loops, conditional statements, and use variables to get things done. This reader has 
written  utility programs that exist in a single file and knows how to run them from the command 
line. They might want to build more c omplex applications, but don't understand how to do so. 
They could be thinking about writing a web server using Python, and what technologies they'd 
have to know to do that. Essentially this reader has a basic toolset, has hammered things 
together, and wan ts to build something more significant.  
The second type is currently a developer in another language who is interested in 
broadening their skill set to include Python. They could be tw because Python is growing in 
popularity in both usage and interest. Or  it could be out of necessity for a project at their 
current job. They know how to get things done in the language they currently know and want 
to learn how to do similar work with Python in a Pythonic way.  
The third type could be someone involved with data science and big data research. Python 
is becoming one of the key players in this space, with many well -developed libraries serving 
the needs of this kind of work. This book won't get into the use of those libraries; that would 
be another book onto itself, -- but it will help readers involved in that space. Many who work 
in data science aren't necessarily software developers. Coding is a means to an end, a tool to 
help reach a goal. Learning to use that tool better, with greater ex pressiveness, by becoming 
a Python developer will take coding out of the problem domain, giving more room to focus on 
the task at hand.  
1.2 Being a developer  
Being a developer is an unusual pursuit. Developers spend time creating something out of 
nothing, and even then, it's hard to describe the thing we just created. Ever try explaining 
what being a developer is at a party? Even if you're a good enough storyteller to keep people 
from wandering off immediately, it's still challenging to reach the "aha" moment w here 
2
©Manning Publications Co.  To comment go to  liveBook  someone might know what you're talking about. And it's not a failing on the listener's part. It's 
just objectively hard to describe what being developer is.  
Putting conversations about Artificial Intelligence aside for the moment, computers are 
except ionally static devices. Programs are a way for humans to express what we want a 
computer to do in a language we can read and write, and the computer can understand. The 
trick is being exact enough to get the computer to do what's intended, rather than some thing 
else. 
People can function in the world and achieve great things because we thrive with the 
inexactness of human communication. We get meaning from context, intention, inflection, and 
subtlety - all of the things that provide great richness to our com munication. None of that 
exists for a computer. They require an almost maddening exactness to function. The attention 
to minutiae to express that exactness, the patience to do so, and the ability to learn and stay 
open to new ideas -- are part and parcel of being a developer.  
1.2.1  Solving Problems  
There is a great deal of software available in the world: retail, commercial and industrial 
software, spreadsheets, databases, web applications, games and tons of software that almost 
no one would ever know exist ed. All of this software exists to solve problems and/or provide 
functionality. And that's great. If there is an existing software solution to a problem you're 
trying to solve, absolutely use it and don't re -invent the wheel.  
On the other hand, the world i s filled with unique problems, and it is generating more all 
the time. These unique problems require custom software solutions. And this is the primary 
role of a developer. Whether you're solving a problem for your projects, or those of your  
employer , the goal of being a developer is to solve problems.  
1.2.2  Process  
Developing software involves a great deal of process and has steps that help lead to a 
successful outcome. Much like a classic story it has a beginning, middle, and end.  
On a personal level, it means how you approach a programming problem and break it down 
to produce a software solution. Being a developer includes the ability to recognize the 
boundaries of different parts of a problem and to understand how the technologies you know 
(or know about ) can help decouple things along those boundaries. An example of this is 
knowing how to use a database to persist data and how to get data to and from that database 
to the user interface, which provides separation between the two.  
If you work as a develope r in an organization there are defined processes that apply to 
your work. What coding standards, if any, does the team support? What kind of source code 
control model does the organization practice? Do you follow an Agile management process or 
some other m ethodology? How is software tested, approved, and deployed? All of these things 
and more make up the Software Development Life Cycle (SDLC). The process can help and 
hinder your development life, but it exists in a team context and in the broader context o f that 
team in an organization.  
There is one other process that in my experience is worth mentioning and valuable to your 
success as a developer. Unless you're developing entirely on your own, you'll be working with 
other people. The list is of people you may be working with can be pretty long and includes 
3
©Manning Publications Co.  To comment go to  liveBook  designers, accountants, managers, customers, both internal and external), clients, 
contractors, and more. Being able to communicate well across disciplines is an invaluable skill. 
The written word ( email, wikis, messaging) is a critical conduit of information and deserves 
your attention. Think about how you present yourself personally when talking to people; 
connections and relationships are essential to a working developer. Not only will good 
commun ication skills immeasurably improve the information, help, and support flowing 
between groups, but they just makes your life as a developer more enjoyable.  
1.2.3  Your Customers  
Even if you're writing software only for yourself, you do have a customer, you. Al l software 
has a user or users. Even software that's only ever used by another piece of software has a 
customer. The customer experience you create has a significant impact on the success or 
failure of the programs you write. It's not a revelation that a g reat deal of the success of Apple 
products has to do with the customer experience those products provide.  
If you write a command -line program that works and gets the job done, and other 
developers can use it, that might be good enough. However, you shouldn 't be surprised if a 
user in customer service dislikes the command line experience. If you're creating software for 
public consumption, an Internet web application with a user interface, for example, bad 
customer experiences can make people leave and possi bly never return. Studies show patience 
for bad customer experience is approaching zero.  
If the service your software provides is crucial to your users, which might put them in the 
position of having to use what you’ve created, this will color their opinio ns and acceptance of 
anything else you might create.  
Even when you are creating a library module intended only for other developers, if the 
interface isn't well thought out and reasonable, you're going to hear about it. And if those 
users are sitting next to you in the office, you're going to hear about it forever.  
From a high -level point of view, any single problem you're trying to solve with software 
means you have two problems. One is the actual work you're trying to capture in code. The 
other is the interaction, or user interface, to get that work done.  
It's challenging to put yourself in the place of your customer when designing software. 
You'll be well acquainted with how you've created the application in the way you intended, 
rather than how a new user will use the application . It's worth thinking about how someone 
else will use what you've written. It's also advantageous to talk with your customers, if 
possible, to learn what they want and expect, and listen to their feedback about what you've 
created. Adopting an iterative process and mindset about development design and 
implementation can make a great deal of difference in keeping a customer or losing them.  
1.2.4  Commitment to Learning  
Learning how to get better at technol ogy and developing with Python is a valuable skill. 
Working to improve yourself as a Python developer has two benefits. The first being able to 
take on larger projects with the confidence you can complete them and create a working 
system. The second is the  practice of learning. Being a lifetime learner isn't just a catchy 
educational phrase; it's the reality of being a software developer.  
4
©Manning Publications Co.  To comment go to  liveBook  For example, during my career as a developer, I've worked in several languages; Fortran, 
Pascal, C/C++, PHP, and now Python and JavaScript. Some of those languages I learned 
because that was what was in use where I was working. In other cases, the language was well 
suited to the task at hand. I considered myself a strong C/C++ programmer and enjoyed 
working on the applic ations I wrote with it. However, I don't have an interest in dusting off my 
C/C++ skills and doing that kind of coding again. Right now, for me, Python is the sweet spot 
as a language I want to use. It appeals to my desire to work in an object -oriented pro gramming 
style but doesn't limit me to only that. Python's syntax and grammar are clear and expressive 
enough that I can think about solutions in pseudocode that closely resembles Python code that 
would almost run.  
If software development is your vocation,  or you want it to be, keep in mind a career is 
long, and changes happen continuously. Committing to learning new technology and languages 
is the answer to both those things. In this rapidly changing world there is very little job security , 
the only real security are the skills you can bring to the table.  
1.3 Reaching goals  
This book has some goals, one of which is implied in the title, “The Well -Grounded Python 
Developer”, helping you become a stronger developer. If you're reading this book, then I think  
that's a goal you have as well.  
1.3.1  Thinking like a developer  
Learning a programming language means learning the syntax and grammar of that language: 
how to create variables, build loops, make decisions, and execute program statements. These 
are your b asic tools but thinking like a developer also means knowing how to put those tools 
together to create a useful program. The analogy goes much further towards building bigger 
and more powerful tools.  
This process of seeing how to use smaller tools to build  bigger tools is key to thinking like 
a developer. The steps of creating one thing from other things eventually help you see the big 
picture. As you learn how to construct more powerful blocks of code, seeing the big picture as 
a developer means understand ing the problem you're trying to solve and mentally being able 
to travel back and forth along with steps you can take to implement a solution. From the 
smallest block of code to more extensive functionality, you'll be able to follow the path to 
success.  
1.3.2  Building Applications  
In developer terms, an application is a complete program providing useful functionality and a 
user interface. An obvious one I’m sure you know already is Microsoft Word, a big desktop 
application. Google's Gmail is a big web application . These are both examples of large 
applications that provide many features with a great deal of functionality.  
There are many smaller applications; for example, if you're familiar with the command line 
available on most computer systems, you may have used  the ping command. This application 
is often used to determine if another computer on a network is responding to a 'ping'  request. 
5
©Manning Publications Co.  To comment go to  liveBook  Using ping is a simple troubleshooting test to see if the remote computer is running at all 
before digging further into any p roblem that might exist with it.  
The ping application is pretty much on the other end of the spectrum from applications like 
Word or Gmail, but it is a complete application in its own right. It provides a useful function 
and has a user interface from the command line in a terminal window.  
There are other blocks of code that developers work on, and these are libraries of code. 
They provide useful functionality and have interfaces, but for the most part, they are used by 
a larger application that want access  to the contained functionality. The standard modules that 
come with Python, a feature commonly referred to as "batteries included," is an excellent 
example of library code.  
Libraries provide an Application Programmers Interface (API), which defines how to  use, or 
'call', the functionality provided by the library. The API can be called directly, as in the case of 
importing and using a standard library module in Python. They can also be called remotely 
over a network. Examples of this would be an application  that makes calls to a database server, 
or calling an HTTP API interface, like that provided by Twitter.  
You'll be creating library modules to use in the applications we'll develop as we move 
forward through this book. We'll also be creating applications t hat provide an HTTP API 
interface as well as their main functionality.  
1.4 Using Python  
For the most part everything you've read up till now about thinking like a developer could 
apply to just about any programming language. What makes Python an excellent choice to 
pursue thinking like a developer? As I mentioned in the section about reaching goals, I believe 
Python provides a sweet spot for application development. Let's talk about why I think that, 
and I hope you come to feel the same way.  
If you're already on board with Python, feel free to jump to section 1.5 of this chapter, 
which introduces what version of Python this book will use.  
1.4.1  Whitespace, The Final Frontier  
When first introduced to Python, people often have a strong opinion about the la nguage syntax. 
They either think that it's good or it's not. I find the language syntax to be terse but wonderfully 
expressive. The ability to code functionality almost as fast as you can type minimizes the 
cognitive load  of programming. It also allo ws you to continue working towards the big picture 
rather than getting tangled in syntactical requirements.  
But let's talk about one thing you might have heard about Python in a negative context:  
the required whitespace. In Python, a space is required aft er the 'for' keyword and before the 
iteration variable. It's also required after the 'if' keyword and before the conditional statement 
that follows. This use of whitespace replaces the use of parenthesis in other languages.  
The start of a block of code is  indicated by the ':' character at the end of a program 
statement line. Every line after the ':' that's indented with whitespace is intended to be in that 
block’s scope. The next outdented line after the block indicates the block of code has ended. 
The whi tespace used to create the indented lines within the block are significant to the 
language and required.  
6
©Manning Publications Co.  To comment go to  liveBook  The whitespace required as part Python's syntax causes consternation among developers 
who use other languages, particularly languages that derive some of their syntax and structure 
from the C language. In those languages, the beginning of a block of code is denoted by the 
use of a '{' character. This is followed by the program lines intended to be in the block, and 
the block is ended, or closed, by the u se of a '}' character. This is known as curly brace 
notation. Many popular programming languages use curly brace notation, like C, C++, Java, 
JavaScript, TypeScript, PHP, and more.  
Those languages are also 'free -form' because no particular coding style is necessary. 
JavaScript takes advantage of this to pack code files by removing all unnecessary whitespace 
to reduce the number of bytes transmitted over a network to a browser. Because these 
languages are free form, there’s debate over what is the right way to style code.  
• Do curly braces stand alone on their own line or part of another line?  
• How many spaces should be used to indent a code block for readability: 2, 4, 8?  
• Should space characters be used after a 'for' or an 'if' keyword for readability or  not? 
• Should the code in a block maintain indentation at all?  
As a developer you should adopt a consistent coding style to support readability. If you 
work in a team, it's beneficial for the team to agree on and choose a coding style as well. Code 
is read far more than it's written, and having a consistent style reduces the white noise of 
reading code in different styles than what you've read before.  
Code oriented editors are aware of the syntax of the language you're writing within them 
and will do w hat they can to automate the writing process. For example, if you're coding in a 
C derived language and type the opening curly brace character '{', followed by a carriage 
return, the editor will most likely auto -indent for you. It will continue to do so fo r all the lines 
of code you write after that until you type the closing curly brace character'}', followed by a 
carriage return. At which point, the editor will automatically outdent for you. Many editors give 
the user options to change the style you'd lik e to use, but whatever you choose, the style will 
be consistent within that editor for that language.  
It's at this point where the argument against Pythons' required whitespace gets silly. If a 
coding style is beneficial to developers to read and write pro grams, and code editors 
automatically provide assistance to write with a coding style, what was the objection to 
Python's use of whitespace again?  
The Python community provides guidance and tools to help create consistently styled 
Python code. The PEP 8 (P ython Enhancement Proposal 8) is a detailed proposal for styling 
Python code. That document exists here: https://peps.python.org/pep -0008/ . There is also a 
Python tool called flake8 ( https://pypi.org/project/flake8/ ) that can point out and fix styling 
issues. It can also be configured to better match your own styling choices.  
1.4.2  Variables  
If you run Python at the command line you get what’s called a REPL, or Read , Evaluate, Print 
Loop, which is an interactive Python. The REPL is a nice place to try out short snippets of 
Python code.  
In Python, variables are dynamically typed. What does this mean? A variable is declared 
with a line like this:  
7
©Manning Publications Co.  To comment go to  liveBook  >>> x = 10  
The variable 'x' is created and bound to an integer object whose value is 10. The type of 
variable 'x' is inferred at runtime from the object to which it is bound. As an example, these 
Python statements:  
>>> x = 10  
>>> type(x)  
<class 'int'>  
>>> 
Create the variable 'x' and bind it to an integer object with a value of 10. The type(x)  
function call returns the type of the variable 'x', which tells you it's an integer.  
Being dynamically typed also means the type of a variable can be changed at runtim e by 
binding it to a differently typed object. This means program statements like the following are 
perfectly fine:  
>>> x = 10  
>>> print(x)  
10 
>>> x = 'Python'  
>>> print(x)  
Python 
Here the variable ' x' is created with a type of integer by binding it to an integer object with 
a value of 10. Then the print(x)  statement prints out the value object x is bound to, which 
is the integer 10. The type of the x variable is changed to String when it is re -bound to a string 
object with the literal string value of 'Pyth on'. Finally, the print(x)  statement prints the value 
of the object bound to x, which is the string 'Python'.  
In statically typed languages like Java, the type information (integer, string, float, etc.) is 
bound to the variable itself. For example, declari ng an integer variable 'x' in Java looks like 
this: 
int x = 10;  
This indicates to the Java compiler the variable 'x' is of type integer and to assign the value 
10 to it. This also means no other type than an integer can ever be assigned to the variable 
'x'. For example, this:  
x = 'Java';  
will generate an error at compile time in Java. Developers who use statically typed languages 
sometimes deride Python because its dynamically typed. And to a degree , they have a point , 
binding a variable declaration to the type at compile time does catch a certain class of error 
conditions. It's something to be aware of when using Python.  
However, I've been writing Python code for a long time, and the dynamically typed nature 
of Python variables has rarely caused a problem  and often presents opportunities for 
expressiveness.  
8
©Manning Publications Co.  To comment go to  liveBook  1.4.3  Programming Paradigms  
Most, if not all, of the languages in everyday use draw their abilities from other languages and 
programming paradigms. Python is a member of this club in good standing. If you've 
programmed at all in Python you know it's a flexible language that covers a lot of ground. Part 
of the flexibility of the language is the many ways in which you can work with it:  
• The ability to code with control flow provided by loops, nested loops, condit ional 
evaluation, and procedure calls makes Python a structured programming language.  
• Python is a procedural language in that you can create functions (procedures), allowing 
you to create blocks of code that can be re -used in other parts of your program.  
• You can code using class -based Object -Oriented Programming (OOP), which captures 
state information along with code that operate on that state.  
• Python, though not strictly a functional language, provides features that allow you to 
program in a functional way. Functions in Python are first -class objects and can be 
passed to other functions. T his feature is required by functional programming and 
Python’s provision of this feature is useful when working in a functional style.  
• Event -driven programs, like a windowing GUI application, where events determine the 
program control flow, are entirely po ssible with Python.  
Any and all of these paradigms can be brought to bear using Python to solve programming 
problems and create applications.  
1.4.4  Creating Maintainable Code  
When you create an application, you expect it will be used, which means it will have a lifetime. 
During that lifetime bugs will manifest themselves in your code and testing doesn't always 
reveal every potential problem. Even if you're the only user of the application, a change in how 
you use it, or the  environment in which you do so, c ould well reveal problems you can resolve 
and improve.  
If other people use your application, what's required of it will change. Changing 
requirements mean changes will need to be made to the existing code to add new features.  
Nothing in the software develo pment world is more constant or happening faster than 
change. When I said earlier that code is read more than it is written now has meaning because 
what you write will change over time. If you come back to your code after a surprisingly short 
amount of tim e has passed, it will amaze you how much you have to read your own work to 
get back into the context in which it was created. If you work in a team, and someone else in 
the team will be modifying your work, that person will bless or curse you based on how 
maintainable and readable your code is.  
Writing maintainable code is a developer strength worth pursuing. Adopting a coding style 
and consistently using it goes a long way towards this goal. Using intelligent and meaningful 
variable names, function names, and class names are important. I'm a firm believer that no 
programming language, even Python, is completely self -documenting. Comments that clarify 
the intention of a section of code can go a long way towards understanding the code's purpose 
and intent.  
9
©Manning Publications Co.  To comment go to  liveBook  Another important aspect of writing maintainable code is making it flexible. It's difficult to 
anticipate how the functions and classes you create might be used further on in the 
development of an application.  
A simplistic example would be a function perform ing some complex calculation, formatting 
the results, and then printing those formatted results to standard output . The future use of 
that function is severely limited to how it's currently implemented and likely can't be re -used 
for anything else. I f explaining what a function does has an "and" in the explanation, it should 
be implemented as two functions.  
Re-factoring this example leads to a function that does the complex calculation and returns 
the raw results. Then the function can be used later i n the application to format and output 
the results to a destination device. By leaving the formatting and output until it's needed, the 
output can be directed to any device: a display screen, a web page, a printer, or perhaps a 
response to an API call. The  underlying calculation function remains unchanged.  
1.4.5  The Language Community  
The most popular programming languages currently in use have large and active communities 
of people who are willing to share their experiences, problems, and expertise with others. 
Python has a particularly welcoming community with a minimum of flame wars or bullying. The 
community is a valuable resource for the newcomer to programming, as well as old hands who 
are working out new problems.  
Very often when working out Python puzzles,  others have worked on similar puzzles before 
and published solutions. The Python Package Index ( https://pypi.org/ ) is an absolutely 
invaluable resource when building applications and looking for libraries and modules to h elp 
that process along.  
Beyond searching Google for Python help, here’s a short list of some of the available, useful 
Python resources:  
• https://realpython.com  – Real Python is an excellent source of tutorials about Python  
• https://pythonbytes.fm  – a Python podcast delivering interesting headlines and banter  
• https://talkpython.fm  – The Talk Python To Me podcast has interv iews with people and 
personalities in the community.  
• https://pythonpodcast.com  – Podcast.__init__ is another good interview podcast  
• https://testandcode.com  – Test and  Code, a podcast about software testing and Python  
• https://www.pythonweekly.com  – the sign -up page for a weekly Python newsletter 
containing links to useful articles and information  
• https://pycoders.com  – The sign -up page for another great Python newsletter  
1.4.6  The Developer Tooling  
As a developer, one of your goals is to get your thoughts and ideas from your mind and into a 
Python code file with as few impediments as possible. A good keyboard that works for you, 
proper lighting, a decent screen; all of these things contribute to the flow of the work you're 
trying to do. A powerful editing tool is also essential. There are many good editors out there 
that recognize Python code and syntax highlight it as you write, making it easier to find errors 
and keywords.  
10
©Manning Publications Co.  To comment go to  liveBook  Notice that I said "editing tool" above; this was intentional. A good editor is essential, but 
beyond that, a good IDE is even more so. An IDE, o r Integrated Development Environment, is 
a big step up from an editor when productively writing code. Not only will it have a good editor 
with syntax highlighting, but it will have knowledge of the language itself. This gives you 
additional assistance when  writing code, which is commonly called  IntelliSense. Intellisense 
provides code completion aide interactively, refactoring of existing code, symbolic name 
information and usage, and much more.  
One last thing a good IDE should provide is a debugger. A deb ugger allows you to run a 
program interactively and set breakpoints. A breakpoint is a marker you can set on a program 
line where the code will stop running when it attempts to execute that line. While the program 
is paused, you can examine the variables t hat are within the current scope and see what the 
program is doing at that point. You can even modify the value of a variable, which will affect 
the execution from that point forward. You can single -step through the code from the 
breakpoint following the b ehavior of the program on a line by line basis. You'll be able to step 
into a function call and follow the behavior within it.  
Being able to debug a program is an invaluable tool and skill to have at your disposal. It 
goes far beyond inserting print()  statements in your code to try and glean what's happening 
inside. Python has standalone debugging tools as well as mature and powerful IDE's available 
to it.  
• Visual Studio Code by Microsoft is an advanced source code editor that has extensions 
making it a com plete IDE for Python. With the Microsoft extension for Python installed, 
it's not only an excellent editing environment with syntax highlighting and IntelliSense, 
but it's also a very powerful debugger. It's available across Windows, Mac, and Linux 
platfor ms, which is a win if you work on multiple different computers. It's also free to 
download and use.  
• PyCharm is one of the suites of development tools provided by JetBrains and is a 
commercial Python IDE. It also has syntax highlighting, IntelliSense, and a  powerful 
debugger, as well as tools to integrate with databases and source code control systems. 
It's a powerful tool for the development of Python code and applications and runs on 
Windows, Mac, and Linux.  
• WingIDE is yet another powerful, commercial Pyth on IDE with syntax highlighting, 
IntelliSense, and has an advanced debugger with features useful in data science work. 
This platform is also available for Windows, Mac, and Linux.  
1.4.7  Performance  
The runtime performance of any programming language is an often debated, highly charged, 
and complex topic. Python is often compared to other languages, like C or Java, regarding 
execution performance. Beyond blanket statements about this or that being faster, it's here 
those comparisons get more complicated.  
What's be ing compared, CPU speed, or memory speed? How is it being measured? Is the 
benchmark software optimized for one language, but not the other? Does the benchmark make 
the most of efficient coding practices in both languages being compared?  
11
©Manning Publications Co.  To comment go to  liveBook  At the risk of sou nding flippant, I don't care very much about any of this. It's not that I 
don't care about performance (we'll get to that), but the argument about this language being 
faster than that language is not worth engaging in.  
Computers are well past the point in time where CPU cycles and memory access times are 
worth considering very much in any performance calculation. To steal a business idiom:  
OPTIMIZE YOUR MOST EXPENSIVE RESOURCE  
You are the most expensive resource.  And if you work for a company as a software developer, 
you are the most expensive resource connected to their computer resources. Optimizing your 
performance as a developer is paramount, and if you can transpose the big picture in your 
mind directly into pseudocode that very nearly runs, you have be come invaluable. This is where 
Python shines, to borrow part of an old joke, "Python is executable pseudocode…". If you can 
express an idea into code and get it up and running faster and improve time to market, that 
is a huge win.  
All of this is not to say  I don't care about performance. When I first got into programming, 
I was obsessed with speed and would go to great lengths to shave CPU cycles from my code. 
Along the way, I learned a lot about what's important and what's not.  
The firs t thing you should do  before beginning any optimization effort is to determine if it's 
necessary at all. Is there a speed requirement your application needs to meet? If so, does a 
metric exist to measure your application defining when it is fast enough? If the answer to these 
questions determines that your application is already fast enough, then you have struck upon 
the ultimate in terms of time spent optimizing, zero.  
On the other hand, if it’s determined your application does need to be faster, then you need 
to take the seco nd step. This second step is to profile the application to measure where it is 
spending time. Python comes with a good profiler, and the IDE's I mentioned above help you 
use it.  
With this measurement in hand, you can apply the 90/10 rule of code optimization. The 
rule states that 90% of an application's execution time is spent in 10% of the code. This rule 
is a generalization, to be sure, but it does provide a roadmap where you should pursue 
optimization. Spending time in anything other than the 1 0% of code where the application 
spends it’s time is time poorly spent that won't improve the overall speed of your application.  
Any optimization work needs to be done iteratively and in tandem with profiling. This tells 
you if your optimization efforts ar e making improvements or not. It will also help you decide if 
the improvements you've made are incremental or orders of magnitude better. Small gains in 
performance need to be balanced against the complexity of the code. Optimization efforts often 
lead to more complex implementations making code maintenance and feature improvement 
harder. Incremental optimizations that bring more complexity should be looked at carefully. 
Consider taking a broader view of the problem and think about changing the algorithm or  data 
structure instead. These kinds of changes can lead to more significant gains in performance.  
Lastly, know when to quit. With a target of what performance metric your application has 
to meet, you'll know when to stop optimizing and ship. Shipping is a  feature that can't be 
overstated.  
12
©Manning Publications Co.  To comment go to  liveBook  1.5 Python Version to Use  
The code in this book is based on Python version 3.10.3. If you are relatively new to Python, 
you might know there are two major versions of Python versions in existence, 2.* and 3.*. 
The 3.* version has been around for a long time, since December of 2008.  It took a while for 
this version to gain traction with users because libraries and frameworks those users depended 
on weren't compatible with this version, so they stayed with the 2.* version. The time when 
that was true is well behind us and there is no legitimate reason to start new Python projects 
in anything other than the 3.* version.  
From this point in time forward the Python 3.* version will have newer features, the latest 
syntax, and more developer support. It also means important libraries and fr ameworks are 
dropping support for the 2.* version. This implies developing programs with Python 2.* will 
have to pin the use of those libraries and frameworks to older versions that will no longer get 
new features or bug fixes. This last item is particular ly important in relation to security 
concerns.  
In addition, the Python 2.* version reached EOL (End Of Life) on January 1, 2020.  This 
means the core Python development team has stopped supporting that branch completely. 
This clean break by the core d evelopers frees them from some compromises made to continue 
supporting 2.*.  
Lastly, and I think this is very important, the Python community at large has moved to the 
3.* version. This means documentation, articles, books, questions, and answers on forums  will 
leave the old version behind and focus more on the new version(s). As a developer, this is an 
important issue. First, because everything you need to know as a developer is too big to have 
in mind all at once. This makes finding relevant information o f paramount importance. And 
second, the pace of change is ongoing and rapid, which makes trying to know it all an exercise 
in futility. It's much more useful as a developer to understand what you need and want to do 
and then be able to find how to do it. H ands down this beats being a catalog of facts that 
become outdated almost as fast as you learn them.  
1.6 Summary  
This chapter has introduced you to information about Python:  
• Why you'd want to use it on your journey to become a developer.  
• Why Python is an excel lent choice of programming language to learn and work in as a 
developer.  
I realize you might be feeling overwhelmed by the scope of becoming a developer. In some 
ways you’re looking up at the night sky and trying to take it all in. Trust me, I’ve been ther e.  
My wish is that starting to read this book gives you a small telescope to view that endless 
sky, narrow your field of view and show you more details about where we’re going. I hope this 
whets your appetite to take the next step in your development jour ney. 
  
13
©Manning Publications Co.  To comment go to  liveBook  2 
Your Development Environment  
This chapter covers  
•Building a development environment
•Python virtual environments
•Setting up Visual Studio Code
As a Python developer you need an environment on your PC in which to work. This developer 
environment cove rs a lot of ground. In general it includes a set of tools you’re familiar with 
and some ideas about how you will structure project directories. Depending on your computer, 
it might also include environment variables you’ve set to help make things more auto matic 
and useful.  
You’ll find what you’re about to create and configure is a good starting point on the way to 
building your own useful and powerful development environment. For those of you who already 
have a development environment you’re comfortable wit h, feel free to skim or move to the 
next chapter . However, be aware of any differences presented here, you’ll need to account for 
them in your environment.  
2.1 Installing Python  
First, you’re going to need Python installed on your computer. This might seem obvious, but 
it’s a little more involved than it might first appear. Not all operating systems come with Python 
installed, and sometimes when Python is installed it’s older than  currently available versions. 
Even if the version of Python installed on your computer is recent, it’s still a good idea to install 
Python for your use while developing.  
If Python is installed along with the operating system, there’s a good chance it’s b eing used 
for system -level functions by the operating system. If that’s the case, there’s a good chance 
your operating system is dependent on the version of Python it came with, and any modules 
that were installed for that version to use.  
14
©Manning Publications Co.  To comment go to  liveBook  The programming e xamples in this book will ask you to install additional third -party 
libraries using the Python package management tool pip. It’s a bad idea to install these 
additional libraries in your system Python. This is because a newly installed version of a library 
might change the functionality of an existing system requirement and break it.  
You also don’t want updates to the operating system to change the Python functionality 
you depend on for your development efforts.  
With that in mind you’ll install version 3.10 .3 of Python that will be distinct from any 
operating system installed version. The newly installed version of Python is entirely under your 
control and independent of the operating system. This means you can add, remove, and update 
library modules as you see fit, and only your program code will be affected.  
You’ll need to install the stable 3.10.3 version of Python so you’ll have the same Python 
version the example programs in this book were coded and tested against to minimize runtime 
problems.  
2.1.1  Windows  
Depending on when you’re reading this book, Python may or may not be installed by default 
on Windows. The Windows operating system isn’t known to use Python, so once Python is 
installed it’s available solely for your development work.  
Recent Windows version s make Python available in the Microsoft Store, making installation 
very easy. The Microsoft Store version of Python at the time of this writing is being evaluated, 
and not all features are guaranteed to be stable. This doesn’t mean you shouldn’t use it, j ust 
that you should be aware of these issues.  
If you prefer, use the stable 3.10.3 version of Python available for your version of Windows 
by navigating to http://www.python.org  in your browser and following the Do wnloads links. 
For most users, the right version to use is the executable installer suitable for your CPU and 
OS version.  
During the installation process the installer allows you to check a box that adds Python to 
your PATH environment variable. Check this  box and save yourself some trouble later. If you 
miss this and Python doesn’t run from within PowerShell at the command prompt, you can 
always re -run the installer and add Python to the path.  
2.1.2  Mac  
On the Mac there is currently an older version of Python i nstalled, which you should avoid using 
for your development. Instead, install the 3.10.3 version of Python that’s completely separate 
from the system. To perform this installation use the pyenv  utility program. This program lets 
you install as many version s of Python as you’d like and switch between them. For the purposes 
of the examples in this book install Python version 3.10.3.  
You’ll need to have the Homebrew program  installed on your Mac to follow the next steps. 
Homebrew is a package manager fo r Mac OS you can use to install many useful command -line 
tools, like pyenv . The Homebrew program and its installation instructions are available here, 
https://brew.sh . After installing the brew program, open your terminal pr ogram and follow 
these command line steps to install pyenv : 
  
15
©Manning Publications Co.  To comment go to  liveBook  1. Run the command:  brew install pyenv  
2. Run command to add pyenv support to your  configuration file (.zshrc for me, could be 
.bash_profile for you):  
a) echo -e 'if command -v pyenv 1>/dev/null 2>&1; then \n  eval "$(pyenv 
init -)"\nfi' >> ~/.zshrc  
3. Run the command :  exec “$SHELL”  
4. Run the command:  pyenv install 3.10.3  
5. Run the command:  pyenv versions  
Line 1 installs the pyenv  utility program on your Mac.  
Line 2 adds useful setup information to your terminal configuration file to make using pyenv  
easier.  
Line 3 re -runs your shell initialization scripts, making the commands in line 2 active.  
Line 4 installs Python version 3.10.3 onto your Mac in your home folder in the .pyenv folder.  
Line 5 shows the versions of Python installed, and if this is the first time using pyenv , this 
will show the system version and the 3.10.3 version you just installed.  
If you have a recent Mac with an M1 CPU be aware the above steps might be somewhat different for you.  
2.1.3  Linux  
There are so many versions of Linux in general use and it would be awkward and outside the 
scope of this book to present pyenv  installation instructions for all those versions. However, if 
you’re using Linu x as your development platform, you’re probably already familiar with how to 
find what you need to install applications like pyenv  on the Linux system you’re using.  
Even on Linux systems that have Python 3 installed, it’s better to install and explicitly 
control the version of Python you’re going to use for development. Once pyenv  is installed, use 
it to install Python version 3.10.3 with the following command lines:  
• pyenv install 3.10.3  
• pyenv versions  
The first command installed the version of Python y ou’re going to use for the examples in 
this book in a directory controlled by pyenv. That version is kept separate from any other 
Python versions installed with pyenv, and the system version of Python. The second will list 
the versions installed, which sho uld show the version you just installed.  
2.2 Python Virtual Environment  
Now that you have Python 3.10.3  installed on your computer, completely separate from any 
system installed Python, you might think you’re ready to go. Even with a version of Python 
installe d using the pyenv  utility, you’ll want to use another level of decoupling from that version 
in your projects.  
Python 3.10.3 provides the built -in ability to create virtual environments. Python virtual 
environments are not virtual machines you might be fami liar with, like VMWare, Parallels or 
VirtualBox. These tools allow an entire OS to run as a guest inside a different OS. A Python 
16
©Manning Publications Co.  To comment go to  liveBook  virtual environment only creates a Python installation inside your project directory.  This Python 
installation can have mod ules added to it with the pip command, and these modules are only 
installed and available from the project -specific Python.  
This is useful so you can have many projects that use the same version of Python installed 
by pyenv , but each Python virtual enviro nment is separate from the other. This means you can 
have different versions of modules installed by the pip command without conflict in each virtual 
environment.  
The pip command line tool that comes with Python is a fantastic utility. It is the package 
installer for Python that allows you to add additional modules from the Python Package Index 
(https://pypi.org/ ). The modules available from the Python Package Index provides 
functionality above and beyond what comes with th e Python standard library. The code 
examples in this book uses quite a few modules from that resource.  
2.2.1  Windows  
In a Windows system you installed Python directly rather than using pyenv , which works fine 
as Windows doesn’t use Python as part of its operatio n. You’ll still want to use a project -specific 
Python virtual environment to keep your system -level Python installation separated from any 
modules you’re going to install with pip.  
To run the Python virtual environment activation and deactivation scripts, you’ll need to 
change the Execution Policy of your computer. To do that, you’ll need to run the PowerShell 
program as an administrator. To do this follow these steps:  
6. Click on the Windows Start icon  
7. Scroll down to the PowerShell menu selection and drop down the sub -menu  
8. Right-click on the PowerShell sub -menu item  
9. From that context menu select Run as Administrator  
a) Once you’re in PowerShell running as administrator, run this command:  
b) Set-ExecutionPolicy Unrestricted  
The system will prompt you with a questi on, which you answer with ‘y’ and then hit the 
return key. At this point, exit PowerShell so you’re no longer in Administrator mode. You only 
need to do this once as it’s a system -wide setting.  
Open the PowerShell program again, not as an administrator, to  get to a command line 
prompt and follow these steps to create a new Python virtual environment specific to the 
project directory:  
10. Run the command mkdir <project directory name>  
11. Run the command cd <project directory name>  
12. Run the command python -m venv .ve nv 
13. Run the command . venv/Scripts/activate  
14. Run the command  python -m pip install –-upgrade pip  
Line 1 creates a new project directory with whatever name you want to give it.  
Line 2 changes your current working context into the newly -created directory.  
Line 3 uses the pyenv  installed Python to create the Python virtual environment. This might 
take a few moments to complete.  
17
©Manning Publications Co.  To comment go to  liveBook  Line 4 activates the virtual environment, prepending  the command prompt with (.venv) , 
indicating the environment is active. Once the environment is active, any additional libraries 
installed will be installed in the .venv  directory and won’t affect the Python version you 
previously installed. To deactivate the virtual environment just enter deactivate  at the 
command prompt.  
Line 5 is optional and upgrades the version of the pip command that exists within the 
Python virtual environment you’ve just set up. If pip detects you are running an older version, 
it will print out a message informing you that you’re running an older version, and you should 
update that version. You can ignore the information and skip line 5 if you like, I included it 
because I ran the command to stop seeing that message.  
2.2.2  Mac and Linux  
Setting up a Python virtual environment on the Mac is straightforward if you’ve installed the 
Python 3.10.3 version using pyenv,  as described previously. Open your terminal program and 
follow these steps to create a new Python virtual environment specific t o the project directory:  
15. Run the command mkdir <project directory name>  
16. Run the command cd <project directory name>  
17. Run the command pyenv local 3.10.3  
18. Run the command python -m venv .venv  
19. Run the command source .venv/bin/activate  
20. Run the command  pip install –-upgrade pip [optional]  
Line 1 creates a new project directory with whatever name you want to give it.  
Line 2 changes your current working context into the newly -created directory.  
Line 3 creates the local file .python -version, which pyenv us es to control what version of 
Python to run when you’re working in this directory, in this case the 3.10.3 version.  
Line 4 uses the local Python version to create the Python virtual environment in the .venv  
directory.  
Line 5 activates the virtual environm ent, prepending the command prompt with (.venv) , 
indicating the environment is active. Once the environment is active, any additional libraries 
installed will be installed in the .venv  directory and won’t affect the pyenv  Python version 
previously installe d. To deactivate the virtual environment, enter deactivate  at the command 
prompt.  
Line 6 is optional and upgrades the version of the pip command that exists within the 
Python virtual environment you’ve set up previously. If pip detects you are running an o lder 
version, it will print out a message informing you that you’re running an older version, and 
you should update that version. You can ignore the information and skip line 6 if you like, I 
included it because I ran the command it to stop seeing that mes sage.  
2.3 Setting up Visual Studio Code  
It’s possible to write Python code using just a text editor application. Within the context of 
writing Python program code, a text editor is precisely that -- an editor that adds no more or 
18
©Manning Publications Co.  To comment go to  liveBook  less than what you type at the  keyboard. The notepad application on Windows and the Textedit 
application on Mac are both examples of simple, capable text editors.  
Microsoft Word, while a powerful editor, is not a good choice to create plain text, as its 
default is to save what you type  with a great deal of additional information about formatting, 
font choices, etc., that has nothing to do with program code. Any word processor application 
makes writing plain Python code more complicated than using a text editor.  
Python programs are just plain text files having the ‘.py’ file extension. Many text editors 
understand that a file with the ‘.py’ extension is a Python file. These editors will provide 
whitespace indenting automatically when you hit the enter key at the end of a line of code that  
includes the block indicator character `:`.  They will also syntax highlight your code, which 
means changing the color of the text to highlight Python keywords, strings, variables, and 
other visual cues about the program you’re creating.  
Microsoft provides  a free code editor called Visual Studio Code (VSCode for short), and it 
is a great choice to use as a Python program editor. Besides being an excellent editor, it has 
many extensions available to make it an even better system to work with when developing 
Python applications. You’ll install one of those extensions for Python that turns Visual Studio 
Code into a complete Integrated Development Environment (IDE). This extension provides 
Python syntax highlighting and other language -specific features. The most  powerful feature is 
the ability to run and debug your code interactively from within the editor.  
2.3.1  Installing Visual Studio Code  
At the time of this book’s publication, you can download Visual Studio Code by navigating to 
this URL: https://code.visualstudio.com . This link takes you to the Microsoft web page that has 
links to download VSCode for Windows, Mac, and Linux.  Visual Studio Code is a separate 
application from Visual Studio, which is Microsoft’s much  larger and commercial application 
development system.  
For Windows and Mac installation, the process is relatively simple: click on the link to 
download the installation program, then double -click on the downloaded file to install the 
application. For Linu x installations, click on the link and, depending on your Linux version, 
choose the package manager that will run the installation process.  
After installation add the VSCode application icon to the Windows taskbar, Mac dock, or 
the Linux desktop/applicatio n menu to make it more readily accessible.  
2.3.2  Installing Python Extension  
Once VSCode is installed, you’ll need to add the Python extension from Microsoft. This 
extension is what provides the syntax highlighting, IntelliSense, debugging capabilities, and 
many  other features. To do this follow these steps:  
1. Open the VSCode application  
2. Within VSCode open the Extensions  
a) Click on the extensions icon  
b) Select View -> Extensions  
19
©Manning Publications Co.  To comment go to  liveBook  3. In the “Search Extensions in Marketplace” labeled text box, enter “python”  and hit the 
return key.  
4. The first item in the returned list will be the Python extension from Microsoft.  
5. On that first item, click the install button.  
Create a new Python code file with the “.py” file extension and enter some Python code. 
Does VSCode syn tax highlight the code? Are you able to save and run the code from within 
VSCode?  
At this point, VSCode is configured to work with Python files. Take some time and read the 
documentation about the Python extension in the right -hand windowpane of the appli cation.  
2.3.3  Other Useful Extensions  
Besides the Python extension provided by Microsoft, there are other useful extensions 
available.  
PYTHON DOCSTRING GENERATOR  
This extension automatically generates Python docstring comments when you enter triple 
quotes (“””)  immediately after a function or method definition and hit the enter key. The 
docstring is a template containing all the parameters and return value in an easy to navigate 
manner, making documenting your code much easier.  
CODE RUNNER  
The extension makes it  easier to run Python code files from a right -click context menus within 
VSCode  
DOTENV 
This extension adds syntax highlighting for .env files, which are local environment files useful 
to initialize environment variables outside of code files.  
BETTER JINJA 
This extension adds syntax highlighting to the Jinja templating language, which is the default 
for Flask web applications.  
AREPL  FOR PYTHON  
This extension provides a window alongside the editing window that will evaluate the code 
you’re writing as you wri te it. This can sometimes be useful.  
2.3.4  Starting From the Command Line  
VSCode  is a powerful GUI application which can be started by double -clicking on its icon from 
your computer, or by clicking on its name/icon from a visual menu. This is a common use case 
for visual tools on the desktop but isn’t the most helpful way to start the  application for your 
purposes. Because all of this book’s example code will use a Python virtual environment, it’s 
useful to create a virtual environment before starting VSCode. It’s also helpful to be able to 
start VSCode from the command line from withi n the project directory containing the virtual 
environment. Starting VSCode this way will help it ‘see’ and use the virtual environment in the 
20
©Manning Publications Co.  To comment go to  liveBook  directory. To configure VSCode to start from the command line in the directory you’re in, do 
the following:  
1. Windo ws 
a) After installing VSCode, the system is already configured to open the current 
directory by typing “ code . ” from a PowerShell command prompt.  
2. Mac 
a) Start VSCode  
b) Navigate to the Command Palette (View -> Command Palette)  
c) Enter “shell command” to find the “S hell Command: Install ‘code’ command in 
PATH command”  
d) Click on the above  
3. Linux  
a) After installing VSCode, the system is already configured to open the current 
directory by typing “ code . ” from a terminal.  
2.3.5  Starting a Project  
With VSCode installed and configur ed to start from the command line, you can go through the 
steps of creating a project directory and starting VSCode to use it. Starting VSCode this way 
is used for all the example projects in this book, and in general, is an excellent way to create 
project s of your own. Follow these steps to create a new project:  
1. Open a terminal or PowerShell and get to a command prompt  
2. Change your directory to where you’d like to create your project  
3. In that directory create a new directory “ mkdir <project name> ” 
4. Change you r directory to the newly created <project name> directory  
5. For Mac and Linux, enter this command pyenv local 3.10.3  
6. Enter this command python -m venv .venv  
At this point, the project is set up to use the Python version 3.10.3 virtual environment 
installed i n the .venv directory. The name .venv is commonly used as the directory name for 
a locally installed virtual environment.  
You can activate your local Python environment and see it’s working by following these 
steps:  
1. Activate your Python virtual environment  
a) Mac and Linux enter this command source .venv/bin/activate  
b) Windows enter this command .venv\Scripts\activate  
2. Your command prompt will be prepended with (.venv)  
3. Enter this command python –-version  
4. The system will respond with Python 3.10.3  
Now that your Python virtual environment is created in your project directory, VSCode will 
discover this when you start it from the command line. Entering “code .” from the command 
21
©Manning Publications Co.  To comment go to  liveBook  line will open VSCode in the project directory. Since you created a Python virtual environment 
in the directory, VSCode will be aware of this and prompt you if you want to use that 
environment, to which you should respond yes. Follow these steps to continue configuring 
VSCode to work with any Python code you create within your pr oject:  
1. Open the Command Palette (View -> Command Palette)  
2. Type “Select Interpreter” in the text box and click “Python: Select Interpreter”  
3. In the popup menu that appears, select the virtual environment you created  
a) Windows - .venv \Scripts \python.exe  
b) Mac and  Linux - .venv/bin/python  
4. Create a new file (File -> New File)  
5. In the file editor window that’s created and enter the following code:  
 print(“hello world”)  
6. Save the file as a Python file (File -> Save -> “test.py”)  
a) VSCode will pop up a prompt informing you , “Linter pylint is not installed”. Click 
the “Install” button. VSCode will use the pip command from your virtual 
environment to install PyLinter. A linter is a pre -runtime tool that checks your 
code for syntax errors, bugs, unusual constructs, and more, a nd is a useful tool 
to have installed for every project.  
7. Right-click on the “test.py” editor window and select “Run Python File in Terminal”  
After the last step, you should see “hello world” printed in a terminal window opened within 
VSCode. Congratulation s, you’ve just run your first Python program within your powerful 
project environment!  
2.4 Some Advice  
There’s one more thing to emphasize as the most useful tool available to you, yourself. Invest 
time to optimize how you work as a developer. Having a suitable development environment 
you’re familiar with is powerful but setting up a productive personal wor king environment is 
time well spent. If you’re going to develop software, for yourself, professionally or both, you’re 
going to spend a considerable amount of time doing so. A reasonable desk, a comfortable 
chair, a good monitor, and a suitable keyboard ar e all part of that environment.  
This last piece of advice is my opinion based on years of working as a developer, both 
singly and in teams . It may not apply to you, so please disregard it if it doesn’t. Spend time 
making the interface between you and yo ur code as fast and seamless as possible . Learn to 
touch type  and make use of keyboard shortcuts in lieu of using the mouse . My mom made me 
take typing classes in junior high back in the days of the IBM Selectric typewriter. I can tell 
you I was none too h appy about it and didn’t appreciate it for many years. Now it is one of the 
many gifts she gave me I am thankful for every day.  
There are many things you’ll write as a developer besides code: documents, wiki pages, 
web pages, presentations, notes, emails -- the list is long and only getting longer. Being able 
22
©Manning Publications Co.  To comment go to  liveBook  to get your thoughts through your fingers and onto the screen quickly and accurately gets the 
mechanics out of the way and lets your thoughts and ideas flow.  
2.5 Summary  
In this chapter, you’ve accomplish ed quite a lot:  
• You’ve got Python installed in a way that won’t interfere with any system python on 
your computer.  
• You’ve learned how to create Python virtual environments and installed and configured 
a powerful editor for creating and running Python code . 
Knowing how to do these things will help you now and in the future to configure a development 
environment on a computer and start developing.  
In subsequent chapters, you’ll use this development environment to build and run example 
programs to begin the p rocess of learning new skills, how and where to apply them, and 
ultimately use what you’ve learned to create more complex and professional applications.  
This chapter has given you a better telescope to view the development night sky and 
revealed more detai l about what you’ve seen before. It’s also revealed more things to see. It 
might still feel overwhelming, but this book and what’s to come will keep adding detail and 
bring the field of view in to a manageable level.  
  
23
©Manning Publications Co.  To comment go to  liveBook  3 
That’s a Good Name  
This chapter c overs  
•Names
•Naming Conventions
•Namespaces
The names we give things and concepts help us navigate the world and communicate with 
everyone else who shares it with us. The idea that names matter is even more important in 
the world of software development. Pro gramming languages have keywords, grammar, and 
syntax that is generally a subset of a common, in -use language. In the case of Python, that 
language is English.  
For programming languages this means we have keywords, grammar, and syntax to create 
programs  that will eventually run. Naming things in those programs, however, is entirely within 
your control. You can use anything from the rich set of English words and phrases to name the 
things you create in a program. You can even use strings of nonsense characters if that suits 
you. But should you?  
"There are only two hard things in Computer Science: cache invalidation and naming things."  
The quote is attributed to Phil Karlton, a programmer with Netscape, the developers of the 
first widely used web browser. Putting aside cache invalidation, you might be thinking, "what's 
so hard about naming things." Let's find out.  
3.1 Names  
Back when I first started out writing code, I worked on a system based on Pascal. It was the 
first language I worked on allowi ng almost unlimited choice when it came to naming variables 
in the programs. One of the other young guys on the team created two global variables he 
used to test for True and False. He named them "cool" and "uncool." At the time, we both 
24
©Manning Publications Co.  To comment go to  liveBook  thought this was p retty funny and made for some laughs when writing conditional statements 
and testing function return values.  
Over time those variable names were all over the code, losing their humorous quality and 
just became more challenging to think about and maintain.  What was the meaning of "cool" 
and "uncool"? If you didn't know the actual value behind the symbol, was the meaning distinct, 
or could it be more of the English use of the words, which in many ways implied a range of 
meaning?  
Giving a name to something is  a way for you and Python to identify it. Usually, this means 
you want to identify something uniquely, so it's distinct from all the other named things in a 
program. For example, Social Security numbers in the United States are given to people so 
they can uniquely identify themselves within usage context in the country. This unique string 
of numbers helps people get employment, do their taxes, get insurance, all kinds of activities 
that require a nationally unique identifier.  
Does this mean a Social Securit y number is a good name for a unique thing? Not really. 
Unless you have access to the systems that use the number, it's entirely opaque. It conveys 
no information about the thing it's identifying.  
Let's take this idea of unique names to anothe r level. There are identifiers called Universally 
Unique Identifier (UUID) and Globally Unique Identifiers (GUID).  GUID's are a variation of 
UUID's used mostly in the Microsoft world. If you've ever installed Microsoft Windows, you're 
familiar with the in stallation key, which is a GUID. Both are mechanisms to generate a 
sequence of characters that for all practical purposes are unique across the entire world. A 
sample UUID looks like this:  
f566d4a9 -6c93 -4ee6 -b3b3 -3a1ffa95d2ae  
If you ensure the leading character isn’t a number, and you convert the dash ‘ -‘ characters 
to underbars ‘_’, this would be a valid Python variable name. You could generate UUID values 
and use them as variable names to uniquely identify everything in your programs. These 
variable names would be unique within your entire application and across the known world. 
Naming variables this way would also be a completely unusable naming convention. The UUID 
conveys absolutely no information about the thing it identif ies, that's part of its purpose. They 
are often used to identify something and keep any other information about the identified thing 
opaque, like any sequencing information or hints about the set of information containing the 
UUID. They're also very long t o type, impossible to remember, and unwieldy to use.  
3.1.1  Naming Things  
Naming things is not only about uniqueness but also about attaching information to named 
things. Trying to provide the name you assign meaning, or an indication of how the thing is 
used,  adds meta information that's very useful when developing Python programs. For 
example, naming a variable t versus total . You'd have to examine the context of the 
surrounding code to know what t is, whereas total  has meaning in English that gives 
unders tanding how a variable named this way is used.  
25
©Manning Publications Co.  To comment go to  liveBook  Based on the UUID example above, the length of the name you give to something is also 
relevant to the effort of writing code. Programming does involve a lot of typing, which means 
the balance between meanin g and brevity matters.  
You're suddenly in a position where an entire language is your hunting ground for words 
and phrases to name things. Your goal is to find words that attach meta information and yet 
are short enough to not get in the way of writing, or reading, a line of program code. This 
constrains what you could or should do when naming things. Like a painter working from a 
limited palette of colors, you can choose to be frustrated, or get imaginative within that 
constraint and build somet hing with artfulness and creativity.  
Many of the programs you’ll write will include looping over a collection of things,  counting 
things, and adding things together. Here's an example of code iterating through a 2 -
dimensional table:  
table = [[12, 11,  4], [3, 22, 105], [0, 47, 31]]  
for i, row in enumerate(table):  
    for j, item in enumerate(row):  
            process_item(i, j, item)  
This code is perfectly functional. The table  variable consists of a Python list of lists, which 
represents a 2 -dimension al table. The process_item()  function needs to know the row and 
column position of the item within the table to correctly process it. The variables i and j are 
entirely serviceable but give the reader no information about their intent.  
You might be incline d to think it's not a big deal for this example code but imagine if there 
were many more lines of code between each invocation of the for loop. In that case the 
declaration of the i and j variables are visually separated from their use. The reader would 
probably have to go back and find the declaration to understand the intent of the variable. 
Keep in mind the reader might well be you six months after writing this code when the meaning 
and intent is not so fresh in your mind. Here's a better implementation of the above code:  
table = [[12, 11, 4], [3, 22, 105], [0, 47, 31]]  
for row_index, row in enumerate(table):  
    for column_index, item in enumerate(row):  
        process_item(row_index, column_index, item)  
The code has changed, so i is now row_index,  and j is now column_index . The variable 
names indicate what they contain and the meaning of their intended use. If the variable 
declarations in the for loops are separated from their use by many lines of code, the reader 
could still quickly deduce what the var iables mean and how to use them.  
Another common operation in development is counting things and creating totals. Here are 
some simple examples:  
total_employees = len(employees)  
total_parttime_employees = len([ 
    employee for employee in employees if empl oyee.part_time  
]) 
total_managers = sum ([ 
    employee for employee in employees if employee.manager  
]) 
26
©Manning Publications Co.  To comment go to  liveBook  You can see a couple of pretty good naming conventions in the above example. The name 
employees  give the variable meaning. The use of the plural employees  indicates it's an iterable 
collection. It also shows the collection has one or more things inside it that would represent 
an employee.  
The variable employee  inside the list comprehension indicates it is a single item from within 
the employees  collection.  
The variables total_employees , total_parttime_employees , and total_managers  
indicate what they refer to by the use of "total" as part of their names. Each of them is a total 
count of something. The second part of each variable name indicates the thing being count.  
Besides numerical calculations, you'll often deal with things that have names already, like 
people within a company, community, or group. When you're gathering user input or searching 
for someone by name, having a useful variable name ma kes it much easier to think about the 
thing you're representing in code.  
full_name = "John George Smith"  
Depending on the purpose of the code you're writing, this might be a perfectly acceptable 
variable name to represent a person by name. Often when working with people's names, you'll 
need more granularity and will want to represent a person’s name in parts.  
first_name = "John"  
middle_name = "George"  
last_name = "Smith"  
The variable names above also work well, and like full_name , give the variable nam es 
meaning about what they represent. Here's another variation:  
fname = "John"  
mname = "George"  
lname = "Smith"  
This version adopts a convention for how the variables are named. A convention like this 
means you're choosing a pattern to create the variable names of people. Using a convention 
means the reader has to know and understand the convention in use. The trade -off in the 
example above is less typing, but still clear variable name meaning. It also might be more 
visually appealing to you as the variable  names line up vertically in a monospaced editing font.  
Adopting conventions is one technique to be more creative and productive within the 
constraints of variable naming. If the above shorthand naming convention is more visually 
appealing to you,  this lends itself to recognizing patterns and identifying typos when visually 
parsing code.  
3.1.2  Naming Experiment  
You may not remember but in the early days of personal computers they had tiny hard drives. 
Early operating systems also had no concept of direct ories or sub -directories; all the files on 
the hard drive existed in one global directory. Additionally, file names were limited to eight 
characters, plus a three -character extension, which was generally used to indicate what the 
file contained. Because of  this, bizarre and complex file naming conventions were invented to 
27
©Manning Publications Co.  To comment go to  liveBook  maintain uniqueness and prevent file name collisions. These naming conventions came at the 
cost of logically meaningful filenames.  
The solution to this problem was adding support to the o perating system for named sub -
directories and removing the filename character length limit. Everyone is familiar with this now 
as you're able to create almost infinitely deep structures of directories and sub -directories.  
EXPERIMENT  
Here's a specification  you've been asked to meet. The accounting department where you work 
requires all expense reports to have the same filename: "expenses.xlsx". You need to create 
a directory structure where all your "expenses.xlsx" files can exist and not collide or overwri te 
each other to save and track these expense files.  
The constraint is the requirement all expense report files have a fixed filename. The implied 
constraint is that whatever directory structure you devise has to work for as many expense 
reports as your w ork generates. The ability to create sub -directories is the tool you have to 
work with to solve this problem  and keep the expense report files separated.  
POSSIBLE SOLUTIONS  
Any solution depends on how many expense reports you create to do your jo b. If you're 
working as a junior software developer, you might only travel a few times a year. In this case 
you would only have to provide coarse granularity to keep your "expenses.xlsx" files separated. 
Something like this would be suitable:  
 
This simple structure gathers all the expense reports under a single root directory named 
"expenses ". Each expense report exists in  a directory named with the fully qualified date when 
the expense report was created. Using a date format of YYYY -MM-DD cause s the directories to 
sort in a useful chronological  order on many operating systems when displayed.  
However, if you're  a sales engineer , you're  most likely traveling all the time and possibly 
meeting multiple clients per day. This changes how you handle the constraint and  require s 
your directory structure to support much more granularity to keep all the "expenses.xlsx " files 
separate. Here's  a possible solution for a sales engineer using the year, month , and day values 
as sub -directories : 
28
©Manning Publications Co.  To comment go to  liveBook   
The directory structure above breaks the dates into separate subdirectories based on year, 
month, day, and client name. Doing this allows you to keep the "expe nses.xlsx" files distinct 
even when visiting multiple clients per day. This creates a convention that each part of the 
path to a particular "expenses.xlsx" file has meaning as well as a value.  
It might not be evident based on the experiment above, but what  you've created are 
variable names having meaning and convention. Look at the path to a particular expense 
report:  
 
What you've done is to create namespaces, each one narrowing the scope of what it 
contains. Reading the path from left to right each segmen t of the path separated by the / 
character creates a new, narrower namespace within the context of the previous one.  
Suppose you are the accountant who has mandated the file naming convention for expense 
reports. As the accountant, you'll have to save all the expense reports employees submit. 
You'd be under the same constraint as the employees who are generating the expense reports, 
but with the added complexity of keeping all the employee expense reports distinct and 
separated from each other.  
29
©Manning Publications Co.  To comment go to  liveBook  Creating a directory structure to handle the added complexity could include higher -level 
abstractions of department and employee. Creating a directory structure providing this level 
of granularity to track and save all the employee expense reports is possible.  
Thinki ng about how to create the structure makes it clear it's time for the accounting 
department to rethink the requirement and constraints and design a better system.  
3.2 Namespaces  
A namespace creates an abstraction contain ing other named things, includ ing other 
namespaces. The name of the city or town where you live is an example.  The city  name 
provides a namespace containing all the people who live in that city.  The city name may not 
be unique on its own, but within the context of the hierarchy its in, county, s tate, etc., it would 
be. 
Going further, the streets and roads where people live all have names. The street and road 
names become a namespace within the city namespace. For example, there are many streets 
named "Main Street" throughout the United States. Ho wever, there is usually only one "Main 
Street" in each city.  
This hierarchy of namespaces creates the convention that is a United States mailing 
address. The full address for John Smith, working at the Empire State Building might be 
something like this:  
Janet Smith  
Empire State Building, Suite 87A  
20 W 34th Street  
New York, New York 10001  
By convention, the mailing address namespace scope gets narrower reading from bottom 
to top. A software developer might remove redundant information and represent this add ress 
like the directory experiments above in a left to right form:  
10001|20 W 34th Street|Empire State Building|Suite 87A|Janet Smith  
Here the city and state have been removed because the zip code contains that information. 
The namespace fields have been d elimited with the '|' character because it doesn't appear in 
the addresses text. Continuing from left to right, you come to the final leaf node, the person 
the address applies too.  
Like the directory structure experiment, reading from left to right, the sc ope of information 
contained within each distinct namespace gets narrower. Also, like the directory structure 
hierarchy the position of each namespace follows a convention that gives each meaning.  
3.3  Python Namespaces  
The Python programming language provides the ability to create namespaces. Namespaces 
give you a great deal of power and control when handling the constraints of naming variables, 
giving them meaning, keeping them relatively short, and avoiding collisions. You do thi s by 
placing variable names in namespaces.  
Before you get to the point of creating namespaces of your own, let's look at the one 
provided by the language.  
30
©Manning Publications Co.  To comment go to  liveBook  3.3.1  Builtins Level  
When Python starts running an application it creates a builtins namespace. builtins is  the 
outermost namespace in Python and contains all of the functions you can access at any time. 
For example the print()  and open()  functions exist in the builtins namespace.  
You can see what's in the builtins namespace by entering this command at a Pytho n 
interactive prompt:  
>>> dir(__builtins__)  
This command runs the dir (directory) command on the __builtins__  object. You'll see 
all of the exceptions and functions listed that are available everywhere in Python.  
You might not have thought about functions like print() , open() , and others as existing 
in a namespace, and you don't have to use them. The idea that they are in a namespace is 
useful as you learn more about creating your own namespaces and the scope of the objects 
within them.  
There is something to keep in mind when working with the builtins namespace: it's entirely 
possible to overwrite an object in a namespace with something of  your own. For example, you 
could define a function like this:  
def open(…):  
    # run some code here  
Creating a function like this would be perfectly fine; however, the side -effect of doing this 
is shadowing the open()  function already defined in the built ins namespace. It might make 
perfect sense for the program you're writing to name your function open() , but shadowing 
Python's open()  function, and making it inaccessible, is probably not what you intended.  
You can handle this by creating your function lik e this:  
def my_own_open(…):  
    # run some code here  
The code works, but you've sacrificed brevity and simple meaning for uniqueness to avoid 
your function's name colliding with Python's open()  function. Using a namespace provides a 
better solution.  
3.3.2  Module  Level  
The Python program file you create that starts your program running is considered the entry 
point for your program as a whole. When it starts, the objects in the builtins namespace are 
created and available anywhere in your Python programs. In Pytho n, everything is an object, 
variables, functions, lists, dictionaries, classes, everything. Anything you create and give a 
name to is also an object in the main program file and has the potential to collide with and 
overwrite the objects in builtins and ot her things you create and name. You can, and should, 
avoid this.  
Breaking up your program code into multiple files containing logically grouped functionality 
is a useful convention to adopt. Doing so has the following benefits:  
  
31
©Manning Publications Co.  To comment go to  liveBook  • Keeps similar functionalit y together where it's easier to reason about it  
• Prevents program files from becoming too long to edit and manage reasonably  
• Creating namespaces  
Each Python code file creates a namespaces for your use. If you wanted to create two 
functions named add()  havin g different behavior, and you created a main.py  file that looked 
like this:  
def add(a, b):  
    return a + b  
 
def add(a, b):  
    return f”{a} {b}”  
 
print(add(12, 12))  
print(add(12, 12))  
When you run this program  it won't function the way you might think. There's no way to 
indicate ing the code above which add()  function is being called in the print(add(12, 12)) 
statement. When Python executes this code, it defines the first add()  function, then 
immediately redefi nes it with the second, shadowing it and losing the first definition.  
The behavior of the two functions is different, the first performs a mathematical addition 
on the two parameters, and the second performs a specialized "string" addition (concatenation)  
on the two parameters. However, as far as Python is concerned, the name of the function is 
the distinguishing feature. And since they are both defined in the same namespace, the second 
shadows the first and takes precedence.  
To get both add()  functions to  exist you need to create a namespace into which you can 
put one of the add()  functions. To do this create a "utility.py" file that looks like this:  
def add(a, b):  
    return f”{a} {b}”  
Then change your "main.py" file to this:  
import utility  
 
def add(a, b ): 
    return a + b  
 
print(add(12, 12))  
print(utility.add(12, 12))  
When you run the " main.py " file, you get the intended output of:  
24 
12 12 
Creating the "utility.py" file separates the two add()  function definitions so they both can 
exist. In the "main.py " file, the import utility statement tells Python to pull all the objects in 
the "utility.py" file to a new namespace called utility.  
32
©Manning Publications Co.  To comment go to  liveBook  Be aware the namespace created by importing a file creates a namespace based on the 
basename of the file, which is the def ault behavior. You can override this default behavior in 
this way:  
import utility as utils  
This statement tells Python to pull all the objects in the " utility.py " file into a namespace 
called utils . Being able to alias the namespace specifically can be a u seful feature if you want 
to replace a namespace with other objects that provide different functionality.  
It's also possible to mask a namespace when importing functionality. Using your current 
"main.py " example, this is done like this:  
from utility import *  
 
def add(a, b):  
    return a + b  
 
print(add(12, 12))  
print(utility.add(12, 12))  
The code tells Python to pull all the objects in the " utility.py " file into the current 
namespace. This program now ha s an error in it because the utility namespace no longer 
exists, so the print(utility.add(12, 12))  statement doesn't work. Removing utility from 
the print statement makes the program work, but you're back to a variation of the original 
problem. The add()  function defined in the " utility.py " file is shadowed by the add()  
function defined in the " main.py " file. For this reason, it's usually not a good idea to use the 
from <filename> import * form when importing files.  
Being able to create namespaces based on files is useful, but Python's support goes further. 
By capitalizing on the file system directory structure, you can create namespace hierarchies. 
Just like the previous directory structure naming experiment, this gives you more tools to 
create meaning and scope for the hierarchies you create.  
If you take your example a little further, you might decide to get more specific with the 
functionality you're creating. The utility.add()  function is specific to string handling, why 
not make that clearer?  
Create a n ew directory called "utilities" in the same folder as your " main.py " file. Move the 
"utility.py " file to the "utilities" directory and rename it " strings.py ". You now have a 
directory hierarchy that looks like this:  
utilities/strings.py  
This adds meaning just as the directory structure experiment does, "utilities" indicates that 
everything under the directory is considered a utility.  
One thing to keep in mind when creating directory hierarchies to contain functionality is 
the need to cre ate an __init__.py  file. This file has to exist in each directory to let Python 
know the directory contains functionality or the path to it. When the __init__.py  file exists in 
a directory, that directory is a Python package.  
Often the __init__.py  file is empty, but it doesn't have to be. Any code inside the file is 
executed whenever the path containing it is part of an import statement.   
33
©Manning Publications Co.  To comment go to  liveBook  Based on this, create an __init__.py  file in your "utilities" directory. Once that's done, 
modify your "main.py" file l ike this:  
from utilities import strings  
 
def add(a, b):  
    return a + b  
 
print(add(12, 12))  
print(strings.add(12, 12))  
The from utilities import strings  statement tells Python to navigate to the utilities 
package and pull all the objects from the "strings .py" file into the strings  namespace. The 
print(strings.add(12, 12))  line has been changed to use the strings  namespace to access 
the add()  functionality. Now the namespace plus function name combine to increase the clarity 
and intention of the add functio n. 
When you create a Python file that you intend to import into other parts of your program, 
it's common to think of the file as a module. The module contains functionality that's useful to 
your program. This idea is very much like the "Batteries Included"  statement that's often 
associated with Python. Python comes with a large selection of standard modules you can 
import and use in your programs.  
If you've used any of Python's standard modules, like " sys", you might notice those 
standard modules don't exis t in the working directory of your program like the " strings.py " 
module you've created above. Python searches for modules you want to import through a list 
of paths, the working directory being first.   
If you start a Python interpreter and enter these sta tements at the prompt:  
>>> import sys  
>>> sys.path  
You'll see output that looks something like this:  
['', '/Users/dfarrell/.pyenv/versions/3. 8.0/lib/python37.zip', 
'/Users/dfarrell/.pyenv/versions/3. 8.0/lib/python3. 8', 
'/Users/dfarrell/.pyenv/versions/3. 8.0/lib/python3. 8/lib-dynload', 
'/Users/dfarrell/tmp/sys_path_test/.venv/lib/python3. 8/site-packages']  
The output is the list of paths Python will search through when it runs across an " import " 
or "from" statement in your  code. The above list is specific to my Mac, the listing you see will 
most likely be different depending on whether you're using a Windows or Mac computer and if 
you're running Python in a virtual environment.  
The first element in the above list is an empt y string. Python will look in the current working 
directory for modules. This is how it found the " utilities " package and the "strings" module in 
that package.  
It also means that if you create a module and name it identically to a Python system 
module, Py thon will find your package first and use it, ignoring the system package. When 
naming your packages and modules, keep this in mind.  
34
©Manning Publications Co.  To comment go to  liveBook  In our short example, the " import sys " statement causes Python to search the above list 
of paths. Since a " sys" module does n't exist in your working directory, it looks in the other 
paths, where it does find the standard modules.  
The list of paths above is used when you install a package or module with the pip command. 
The pip command will install the package in one of the pat hs from the list. As mentioned 
before, it's recommended to use Python virtual environments to prevent pip from installing 
into your computer systems version of Python.  
3.3.3  Function Level  
There is another level of namespace control available to you. When you cr eate a Python 
function, you are creating a namespace for variable name creation. Another word used for this 
is scope. The functions you create exist in a module, either the main Python file of your 
program or separate module files.  
The module file creates  a namespace, and any functions you create in the module exist 
within that namespace. What does this mean? Take your " strings.py " module and make the 
following changes to it:  
prefix = "added" 
 
def add(a, b):  
    return f "{prefix}: {a} {b} " 
The changes abov e create a variable named preface  at the module level namespace and 
initialize it with the string, "added".   
If you run your main program, you'll see the output of the strings.add(12, 12)  now 
outputs "added: 12 12". When the add()  function is executed, Py thon looks for the prefix  
variable inside the function namespace, and not finding one, looks at the module -level 
namespace. It finds the prefix  variable in the module and uses it in the string formatting 
returned by the function.  
Change the strings.py code  again and make it look like this:  
prefix = "added" 
 
def add(a, b):  
    prefix = "inside add function " 
    return f "{prefix}: {a} {b} " 
Inside the add()  function, you've created a variable named prefix  and initialized it to a 
different string. If you rerun your code, you'll see the output of the strings.add(12, 12)  
function outputs “inside added: 12 12”.  
What's happening here is Python now finds the prefix  variable in the add()  function's local 
namespac e and uses it. Not only is the prefix  variable defined inside the add()  function's 
namespace, it's created in the function's scope. We’ll talk about scope more in the next section  
35
©Manning Publications Co.  To comment go to  liveBook  3.3.4  Namespace Scope  
Names and namespaces are essential in your Python tool box and are related to another tool 
as hinted at in the previous section. The scope of a variable is an important consideration when 
creating and using variables.  
The scope of a variable relates to it s accessibility and lifetime in a module, a Python file. In 
Python, a variable is created when a value is assigned to it:  
prefix = "prefix" 
The statement above creates the variable prefix  and assigns it the string value "prefix: 
". The variable prefix  also has a type of string, which Python determines at the time of 
assignment from the object being assigned, in this case, " prefix: ". 
If the prefix  variable were created in a function:  
def print_prefix():  
    prefix = "prefix" 
    print(prefix)  
The prefix  variable would be within the scope of the print_prefix( ) function and would 
exist only when that function is running. Any code surrounding the function that tried to access 
the prefix  variable would generate an exception.  
If you were to create a new module fi le named " message.py " that looked like this:  
prefix = "prefix" 
 
def my_message(text):  
    new_message = f”{prefix} : {text}” 
    return new_message  
You have created things having different scopes and lifetimes. The prefix  variable is in 
the global module sc ope. It is accessible anywhere within the " message.py " module. It also 
has the same lifetime as the module. If you import message  into your code, the prefix  
variable and my_message  function are around for as long as the message module is. It is still 
within the message namespace and would be accessible to programs that import it like this:  
import message  
print(message.prefix)  
print(message.my_message("Hello World"))  
The variables defined inside the my_message(text)  function have function -level scope. This 
means they are only accessible within the function, and their lifetime is from the point of their 
creation to the end of the function statements.  
Because the my_message(text)  function is contained within the modul e level scope, the 
code within the function can access the prefix  variable.  
At the module scope, what's declared at that level is accessible, prefix , and my_message . 
The my_message  function is part of the module level (global) scope, but all the variables  
declared inside the function are not.  
36
©Manning Publications Co.  To comment go to  liveBook  Inside the my_message  function, the two variables text and new_message  are accessible as 
they are in the local scope, but aren't accessible outside the function. The module variable 
prefix  is in the global scope and is also accessible inside the function.  
The program above shows that scope is nested. Inner scopes have access to scopes that 
enclose them, as demonstrated by the my_message  function having access to the prefix  
variable. Outer scopes do not have access to  the scopes they enclose.  
Figure 1  below illustrates this nesting relationship:  
 
3.3.5  Namespace Experiment  
Using what you've learned about names and namespaces, try this experiment using the 
information to solve a problem. This problem is about using meaningful names and 
namespaces to solve an otherwise awkward development issue.  
EXPERIMENT  
You're the developer in charge of maintaining the software for an online community of users 
interested in similar things. The community wants the software to email them about upcoming 
events and to include non -community members who register to receive event emails. This 
latter group consists of potential new members who are interested but not yet committed to 
joining.  
The software can send personalized emails t o the mailing list of registered users, both 
members and non -members. When creating the personalized email, the current software calls 
a function get_name(person)  to get the name to render into the email based on the  person 
object passed to it.  
The c ommunity wants to change how personalized email is rendered by creating a concept 
of "formal", "informal", and "casual" for the name. Email sent to non -members would always 
use the "formal" version. Email sent to members would base the name on the user's a ccount 
settings and could use any of the three name versions.  
37
©Manning Publications Co.  To comment go to  liveBook  This becomes your requirement: how can the logically named get_name(person)  function 
return three different values for three different use cases?  
POSSIBLE SOLUTION  
One possible solution is to cr eate three new versions of the get_name(person)  function like 
this: 
def get_name_formal(person):  
 
def get_name_informal(person):  
 
def get_name_casual(person):  
The code above is understandable and direct but is awkward to make use of in the rest of 
the appl ication currently calling get_name(…) . Using this approach requires you to modify every 
instance of a call to get_name(…)  to be an if/elif/else  conditional to call the correct function 
above. You'd also have to make the conditional information that selects  the right function 
available for those if/elif/else  condition tests.  
Another approach would be to change the get_name(person)  function to take an additional 
parameter that indicates how to format the response. Something like this would work:  
def get_name( person, tone: str):  
In the example above, the variable tone is a string theoretically set to "formal", "informal", 
or "casual". The value of tone would be used to format the name in an expected manner.  
The example above would also work but is only a marginal improvement over the 
individually named functions. Choosing this method requires you to find and edit every instance 
where the get_name(…)  function is called in the entire program and update it to include the 
new tone parameter. If there are many places where the function is used, this could become 
a maintenance headache.  
The use of namespaces could provide a workable solution that doesn't disru pt the other 
parts of the software. Rather than change the name signature of the get_name(person)  
function, or changes its parameter list, you could use namespaces to create a solution.  
As a contrived example here is a "main.py" program that simulates send ing out an email 
to the community, before accounting for the required changes:  
from utilities.names import get_name  
 
# generate a community list of three of the same people  
community = [{  
        "title": "Mr.",  
        "fname": "John",  
        "lname": "Smith"  
    } for x in range(3)  
] 
# iterate through the community sending emails  
for person in community:  
    # other code that calls get_name many times  
    print(get_name(person))  
The get_name(person)  function fr om the “names.py” module might look like this:  
38
©Manning Publications Co.  To comment go to  liveBook  def get_name(person):  
    title = person.get("title", "")  
    fname = person.get("fname", "")  
    lname = person.get("lname", "")  
    if title:  
        name = f"{title} {fname} {lname}"  
    else: 
        name = f"{fname} {lname}"  
    return name  
This function looks at the person  information, and depending on if the person has a title 
value or not, formats the name accordingly and returns it. The get_name(person)  function is 
the formal version and can be used as -is.  
The change requirements are to create a “formal”, “informal” and “casual” greeting for the 
emails based on the tone determined by the account. You already have a formal version of the 
get_name(person)  function, and just need to create the informal an d casual versions. Create 
a module file called “informal.py” in the utilities package directory that looks like this:  
def get_name(person):  
    fname = person.get("fname", "")  
    lname = person.get("lname", "")  
    name = f"{fname} {lname}"  
    return nam e 
This function concatenates the first and last name and leaves out the title. Create another 
module called “casual.py” in the utilities package directory that looks like this:  
def get_name(person):  
    fname = person.get("fname", "")  
    name = f"{fname}"  
    return name  
This function returns the person's first name and nothing more.  
Based on the change requirements you also need to create a way to define the tone to use 
in the email based on the com munity members' account information. The information to 
examine is whether or not they are a member, and if they are a member, what is the greeting 
setting in the account.  
For this experiment, you can create an "account.py" module in the utilities package 
directory. The "account.py" module contains this code:  
from random import choice  
 
def get_tone(person):  
    return choice(["formal", "informal", "casual"])  
This code returns a randomly selected value from the list of tone strings, "formal", 
"informal", and  "casual". In a real application the tone would probably be retrieved from a 
database table containing information about the users.  
Now you have everything you need to meet the requirements and change how the mailing 
list is processed. Here's an updated li sting of the "main.py" program showing how the 
namespaces you've created are used:  
  
39
©Manning Publications Co.  To comment go to  liveBook  from utilities import names  
from utilities import informal  
from utilities import casual  
from utilities import account  
 
community = [{  
        "title": "Mr.", 
        "fname": "John",  
        "lname": "Smith"  
    } for x in range(3)  
] 
 
for person in community:  
    tone = account.get_tone(person)  
    if tone == "formal":  
        get_name = names.get_name  
    elif tone == "informal":  
        get_name = informal.get_name  
    elif tone == "casual":  
        get_name = casual.get_name  
    else: 
        get_name = names.get_name  
 
    # other code that calls get_name many times  
    print(get_name(person))  
This version of the "main.py" progra m imports the three new modules, informal , casual , 
and account . At the top of the community iteration, the tone is retrieved based on the person 
passed to account.get_tone(person)  function call. The tone variable is used in an 
if/elif/else  set of statement s to set the get_name  variable.  
Notice the get_name  variable is set to the get_name  function from a specific module 
depending on the value of tone. The code sets the get_name  variable to refer to a function, 
not call the function. Now that get_name  is a fu nction object; it can be used just like a function 
in the print(get_name(person))  statement.  
The get_name(person)  function call will do the right thing because it refers to the desired 
modules get_name(person)  function at each iteration when the tone varia ble is set.  
All of this work upfront to create the modules, and the code within them was done to avoid 
losing a good logical name like the get_name  function and allow it to be used unchanged 
anywhere else within the program. The work also prevents name con flicts through the use of 
namespaces.  
  
40
©Manning Publications Co.  To comment go to  liveBook  3.4 Summary  
You've learned a lot in this chapter about the names we give things and how namespaces can 
help you collect those things into meaningful groups. There is no shortage of symbols you can 
use to name things; using good ones gives you benefits that pay off the larger and more 
complex the applications you build become.  
You’ve delved deeper into the development world and gained more insight and details about 
how to see and think about the applications you ’ll build. You’ll continue to look closer at the 
elements of software development with Python. The chapters that follow in this book will build 
on the concepts of logical names and namespaces to make the programs you develop easier 
to follow and manage.  
  
41
©Manning Publications Co.  To comment go to  liveBook  4 
Where Developers and Computers 
Meet  
This chapter covers  
•What Is An Application Programming Interface (API)
•What Is A Well Designed API
•How To Create Good APIs
Communicating with people through the spoken and written word, gestures, expressions, and 
inflection is one of the cornerstones of our advancement as a species. Even across different 
languages and cultures we can communicate with each other, perhaps with a bit more effort, 
but we can learn to convey meaning, intent, information , goals and more.  
The evolution of computers has also created many and varied ways for us to communicate 
with a computer, and it with us. Keyboards, mice, touchpads, voice, screens, printers, 
networks, motion sensors and more are all devices that have diff erent uses providing 
communication between people and computers.  
All of these devices are examples of interfaces designed to convey information to and from 
a computer system. Keyboards provide a mechanical way for us to enter the written word into 
a system . A computer mouse provides one way to indicate gestures and events to a computer 
system. A display screen provides the computer a way to represent digital information in a 
way we can receive it. Speakers give a computer an interface to produce audio infor mation.  
All the complexities of capturing a keystroke, getting the mouse position into a computer, 
or generating a sound from a computer, is simplified, hidden and provided by the interace.  
Interfaces exist to receive information, act on it and send back r esults. The interfaces we’ve 
talked about so far are essential to computer users. As developers of applications, we also use 
interfaces that exist at a deeper level of computer systems.  
The operating system of a computer provides hundreds, perhaps thousan ds, of interfaces 
that give access to all the services and functionality the computer is capable of. Access to the 
42
©Manning Publications Co.  To comment go to  liveBook  file system, and ultimately the storage system, of a computer is provided to applications 
through an interface. If a computer is connected to  a network, there are interfaces an 
application uses to access those networks. If an application renders visual information, there 
are interfaces to get that information onto the connected displays.  
These kinds of interfaces fall under the larger general c ategory called an Application 
Programming Interface, or API.  
4.1 Starting a Conversations  
A computer screen provides a level of abstraction between how the users sees things and how 
the computer represents things. A mouse provides a level of abstraction betwee n our hand 
movements and button clicks to the computer as selections and intentions.  
An Application Programming Interface provides the same kinds of abstraction. However, it 
does so not between a person and a computer, but between sections of programming c ode. 
All programs are composed of custom code, modules, and libraries of existing code. Even the 
most straightforward Python program performing a print("Hello World")  is using standard 
library code provided with the Python language.  
Having library code is a huge advantage allowing you to focus on what you're trying to 
accomplish rather than coding everything yourself. Imagine having to write a print  function 
every time you started a new project or having to create something more complex like network 
access.  
Python is well known as having "batteries included," meaning it comes with an extensive 
and powerful standard library of modules providing all kinds of functionality you can use and 
not have to create yourself. There's also a large selection of modules yo u can install from the 
Python Package Index ( https://pypi.org/ ) that cover diverse and well -supported areas of 
interest.  
Because of these numerous modules, Python is sometimes called a "glue language" as it 
creates a way to connect powerful libraries of co de in interesting ways. Thinking of Python as 
a glue language doesn't diminish its power but instead shows its versatility.  
Python as a glue language is possible because of the Application Programmers Interface 
(API) the modules support, like calling print("Hello World").  This calls the print  function, 
passing the literal string argument "Hello World" , abstracting the complexities of outputting 
text to a display. The API a module supports makes it possible to use complex, sophisticated 
code in your programs . 
4.1.1  A Contract Between Pieces Of Code  
Aside from the rather abstract discussion about what an API is, what is it in practice? One way 
to think about it is to consider an API a contract between your code and another piece of code 
whose functionality you want to use. Like a contract between people, it specifies if one party 
does this, then the other party does that . 
In programming terms this often means when calling a function or method in a particular 
way, it performs some work and returns some information or both. In Python, when you create 
a function to be used elsewhere in your code, you've created an API. The name you give the 
function expresses some meaning about what the API does. The function’s input parameters 
43
©Manning Publications Co.  To comment go to  liveBook  pass information to the API to specify the work to perform and the data to perform it on. If 
the function returns information, this is the output of the API.  
This idea of passing some information into a piece of code, and getting some information 
or action out of it, has been around in computer sci ence for a long time and is known as the 
'black -box' model. What a black -box expects as input and the output it creates is well 
understood to the point that knowing what goes on inside isn't necessary. Only the behavior 
needs to be known, not the implement ation. The term black -box comes from the internals of 
the invoked functionality being opaque, blocked from view.  
Visually the use of a black -box function looks like this:  
 
As a developer you don't have to know about the internal functionality of the print() 
function . All you need to know is that passing the function a string invokes its default behavior, 
print that string to the screen.  
A local API is a function or class you  create, or a module your code imports. The API is 
within the context of your program code and is accessed directly by calling the functions and 
class instance methods provided.  
It is also possible to call an API that's hosted remotely. An example would be  connecting 
to a database server and accessing data. Here the API is accessed over a network connection 
providing the transport mechanisms for your code to make calls to the remote API and for the 
API to respond. We'll get more into this in a later chapter  specifically about databases.  
4.1.2  What's Passed as Input  
When your code calls a function or method of an API it’s engaging in one part of the contract 
between your program and the functionality provided by the API. The input arguments are the 
information pass ed from the context of your program code to the context of the API. Python 
functions and methods support positional and keyword arguments. The positional arguments 
ordering, and names of the keyword arguments, are considerations when using and building 
an API. 
For example, Python's print function is most often used like this:  
>>> msg = "Hello World " 
>>> print(msg)  
Hello World  
When this function executes it prints the string variable msg to the screen. The API provided 
by the print function is simple enough to understand; it takes the input argument and performs 
the work necessary to output it to the screen.  
44
©Manning Publications Co.  To comment go to  liveBook  The complete API of the print function shows it is a more versatile function. Here is the 
print function signature:  
print(*objects, sep=' ', end=' \n', file=sys.stdout, flush=False)  
This signature indicates that the first parameter is a tuple of non -keyword arguments 
followed by additional keyword arguments with default values.  
The *objects  parameter allows the caller to pass multiple, comma -separated value s to the 
print function. This means:  
>>> print("Hello World")  
Hello World  
Outputs the same thing to the display as:  
>>> print("Hello", "World")  
Hello World  
Calling the print function this way works because the function iterates through the objects  
tuple pa rameter, converting each to a string if need be and outputs each object to sys.stdout  
(the screen), separated by the default separator string, a space character.  
The sep=' '  named parameter provides the default space separation string and lets you 
change i t to something else to separate the objects when output to the screen.  
The end='\n' parameter provides a carriage return as the default to end the output and 
lets you change how the output ends.  
The file=sys.stdout  parameter defines the default destinati on, called standard output, 
which is usually the screen. Changing this parameter lets you change that destination. The 
object you set the file parameter equal to must have a write(string)  method for it to work 
as a file destination. If the object doesn’t h ave a write(string)  method, the AttributeError  
exception is raised when the print  function is called.  
The flush=False  parameter provides a way to forcibly push what's sent to the stream to 
the output destination rather than buffering it if set True. 
All of this tells us the print function API is well designed and surprisingly powerful. The use 
of the initial non -keyword *objects  tuple, followed by the keyword arguments with default 
values, lets you use the print function's most common use case. The re st of its functionality is 
there if needed but can be ignored otherwise.  
Imagine if the print function was handled differently. A naïve API implementation might 
remove all the keyword parameters with default values and look something like this:  
print(objec t) 
A print function like this would satisfy the common use case but would start to fall apart 
beyond that. Suppose not long after this version is in use, it's required to print more than one 
object at a time. One way to extend the simple implementation is to create additional print 
function variations:  
print_two(object, object)  
print_three(object, object, object)  
45
©Manning Publications Co.  To comment go to  liveBook  What if additional requirements were placed on this naïve  expansion of the  API to have a 
different separator character , perhaps the pipe '|' chara cter? Following the established simple 
variation pattern would lead to something like this : 
print(object)  
print_pipe_sep(object)  
print_two(object, object)  
print_two_pipe_sep(object, object)  
print_three(object, object, object)  
print_three_pipe_sep(object, o bject, object)  
This solution doesn't scale well and code that uses this would have to change to use a 
different permutation of the API.  
The goal of this example is not to show the progression down an ill -conceived path of API 
development, but to draw close r attention to the details of what makes Python's default print 
function a good API. There is work going on inside the print function to support the function 
signature and the use cases where it's applied.  
This is one of the earmarks of a good API. It prov ides useful functionality that can be 
expanded on without exposing the work involved in doing so. As a developer, you don't have 
to worry too much about how the print function works. You get to use it, knowing its 
functionality is well defined and containe d. 
When developing an API, how you define the input can dramatically influence its utility and 
future use.  
4.1.3  What's Expected as Output  
The other part of the contract provided by an API is its output. The output of a function consists 
of three parts:  
1. Return value  
2. Actions on the system sometimes thought of as side -effects  
3. Exceptions  
RETURN VALUE  
The most commonly thought of output of a function is the return value. For example, this code:  
>>> abs( -10) 
10 
The code looks like a mathematical expression, and that's very close to what it's modeled 
after. The input to the abs function is a number, and the output is the absolute value of that 
number.  
A great deal of programming is creating and using functions that accept parameters, 
process those parameters, and return the results. Building up an application is a process of 
orchestrating function calls and feeding the returned values into other functions until you arrive 
at the desired outcome.  
Because everything in Python is an object, a function return value is also an object. This 
means you can build a function as part of your API that returns more than just a single scalar 
value like the abs function.  
46
©Manning Publications Co.  To comment go to  liveBook  One example commonly seen in Python is to return a tuple. Returning a tuple allows you 
to pass back more than one value to the calling function, which can then unpack the tuple into 
variables. Here's some code from CH_04/example_01.py : 
from typing import Tuple  
 
def split_fullname(full_name: str) -> Tuple[str, str, str]:  
    fname = mname = lname = " " 
    parts = full_name.split()  
    if len(parts) >= 1:  
        fname = parts[0]  
    if len(parts) >= 2:  
        mname = parts[1]  
    if len(parts) == 3:  
        lname = parts[2]  
    if not lname:  
        mname, lname = (lname, mname)  
    return (fname, mn ame, lname)  
 
# use case  
fname, mname, lname = split_fullname("John James Smith")  
The split_fullname()  function takes in a full name and returns the name parts, fname , 
mname,  and lname . Even if the full_name  parameter contains only one or two names, the 
function behaves correctly. If there are only two parameters, it assumes the second is the last 
name and sets mname  to an empty string.  
The use case shows how the tuple returned by the function can be unpacked into three 
variables. You can also assign the ret urn value from split_fullname()  to a single tuple 
variable, but it's often useful to unpack the returned tuple directly into waiting named 
variables.  
ACTIONS ON THE SYSTEM  
Many API functions perform work to transform data passed to them, create new data, or 
perform calculations based on the data passed. This new, or transformed data, is returned to 
the caller of the API for further processing.  
API functions can also perform actions on the system it's running on. For example, if you 
are using an API t hat is part of a robot and call a function to rotate a motor attached to that 
robot, you'd expect the motor to start rotating.  
The actions taken by API functions are what make applications useful. The ability to open, 
create, read, and write files, interac ting with networks, printing documents, and controlling 
real-world devices are all actions an application can execute provided by API functionality.  
An API function performing an action doesn't necessarily have to return any data to the 
caller if its prima ry purpose is to perform that action. That doesn't mean it can't return output 
data. The API function for the robot motor example could return a True or False  value to 
indicate whether or not the motor is rotating.  
EXCEPTIONS  
Exceptions and how to handle t hem are a fact of life as a developer. Disk drives fail, networks 
can be unreliable, and any number of other unexpected behaviors can occur.  
47
©Manning Publications Co.  To comment go to  liveBook  The API functionality you create can generate exceptions from operations, such as divide 
by zero or raise exception s because the functionality created an unexpected or exceptional 
state.  
When creating an API function, one of your goals is to prevent exceptions when you can 
and handle them gracefully when you can't. As an example, if your functionality is performing 
network IO and the network becomes unreliable, what can you do?  
One possibility is to retry the operation several times with a gradually longer timeout 
between retries. If the network stabilizes within the retry attempts the function can continue 
and succeed.  However, if the retries all fail a network exception is raised and passed upward 
to the caller.  
On the other hand, if a divide by zero exception is raised because of an input parameter, 
there's nothing you can do but let the exception bubble upwards to so me higher -level 
functionality that handles it.  
Handling an exception is knowing whether you can do something about it or not. Never 
silence an exception without having a specific reason for doing so; this throws information 
away and makes an API untrustwor thy. 
Users of your API need to be aware of and prepared to handle the exceptions your API 
generates, as they do with any other exceptional condition when developing. Documenting 
your API is an excellent way to inform the users of your API what exceptions t hey might expect.  
Exceptions are covered in more detail in a later chapter.  
4.2 Function API  
Functions provide the mechanism to interface with an API. In object -oriented programming 
where you think about methods on an object, they are functions tied to that ob ject instance.  
Let's spend some time talking about ideas you can put in place to create useful functions, 
and by extension, good APIs.  
4.2.1  Naming  
As we talked about in a previous chapter, names matter in development. How you name the 
functions you create goes  a long way towards making the API you're creating make sense.  
Function names should use full English words and use the snake_case format. There is no 
reason to use abbreviations to shorten the name. Every modern code editor has 
autocompletion abilities ma king typing the full name a one -time-only occurrence at the time 
of function definition.  
Using domain -specific acronyms is also discouraged as users who aren't familiar with the 
domain the API is working in would find the different naming conventions confu sing. 
The name indicates or hints at the use case of the function, what it returns, and what it 
accepts. Additionally, the documentation string (docstring) can elaborate further on the 
intended use. In Python, a function docstring is a tripled quoted strin g containing information 
about a function and immediately follows the function definition  
In the case where function name collisions are possible because the logical name choice is 
similar, or the same, use namespaces and separate the functionality into mo dules.  
48
©Manning Publications Co.  To comment go to  liveBook  4.2.2  Arguments  
When creating a function to provide an API for some functionality you want to encapsulate, 
you can think about the Python print function presented earlier. That seemingly simple function 
offers a surprising amount of functionality because  of the interface construction and the way 
the encapsulated code is built.  
There are four ways to pass arguments to the functions you create:  
POSITIONAL ARGUMENTS  
These are the most common form of arguments used with functions and help define usability. 
Here is an example function definition with positional arguments:  
def full_name(fname, mname, lname):  
    return f "{fname} {mname} {lname}"  
The name of the function indicates what it returns, and the positional arguments fname , 
mname , and lname  make clear what it expects as input. Calling the function with string literals 
looks like this : 
print(full_name("John", "James", "Smith"))  
The code assigns the string literals to the positional arguments in the same order created 
when the function wa s defined.  
It is possible to call the function using argument names in this manner:  
print(full_name(fname= "John", mname= "James", lname= "Smith")) 
It's also possible to change the order of the arguments by calling the function and using 
keyword arguments:  
print(full_name(mname= "James", lname= "Smith", fname= "John")) 
Positional arguments are mandatory and must have a value assigned to them when calling 
the function. Otherwise, Python raises a TypeError  exception.  
KEYWORD ARGUMENTS  
Keyword arguments aren't mand atory as they have default values. Often these are used for 
optional arguments allowing the function to operate with known default parameter values when 
the caller doesn’t supply one. The full_name  function defined above can be altered to use 
keyword argum ents like this:  
full_name(fname, mname=None, lname=None)  
Now the function has one positional argument, fname , and two keyword arguments, mname  
and lname , each with a default value of None. The function makes fname  the only mandatory 
argument implying the f unction operates correctly if mname  and lname  aren't provided by the 
caller.  
It's also possible to use the keyword arguments in a different order than defined by the 
function. For instance, calling the function in this manner:  
49
©Manning Publications Co.  To comment go to  liveBook  full_name("John", lname="Smit h") 
The code above indicates the function handles the case where fname  and lname  are 
supplied, but mname  is assigned the default value of None. 
When defining a function, once you create an argument with a default value (keyword 
argument), any arguments fol lowing it must also be keyword arguments and have default 
values.  
ARGUMENT LIST 
In the Python print function, the first argument was of the form *objects . The *objects 
parameter is an example of passing a variable number of positional parameters to a funct ion. 
Inside the print function, the objects  argument is a tuple containing all the remaining 
positional arguments in the function. A variable number of positional parameters is commonly 
named *args , but that's just a convention, not a requirement.  
Modifyin g the full_name()  function to use an argument list looks like this:  
def full_name(fname, *names):  
    return " ".join([fname, *names])  
In this form the full_name()  function creates a temporary list of the fname  parameter and 
the elements in the names  to join them together separated by a space character. This form is 
useful to pass multiple, similar arguments but can be confusing to the users of the function. 
The function will join any number of elements in the *names  argument tuple, which might not 
be your intention.  
Defining the function in the original form where all the arguments have names is a better 
way to go in this case. From the Zen of Python, explicit is better than implicit.  
KEYWORD ARGUMENT DICTIONARY  
The keyword argument dictionary is akin to the argument list; it's a way of wrapping up all 
keyword arguments into a single argument to a function. You'll often see it defined as 
**kwargs , but again, this is only a convention. Changing the full_name()  function to use this 
form looks like this:  
def full_name(** kwargs): 
    return f "{kwargs.get('fname', '')} {kwargs.get('mname', '')} {kwargs('lname', '')} " 
Internally the full_name()  function examines the names dictionary looking for the 
keywords fname , mname , and lname . Without documentation, the user of this function would 
not know what to include as key -value pairs in the names  dictionary parameter.  
The caller can also add other key -value pairs to the names  dictionary that would possibly 
have no meaning to t he full_name()  function. The extra key -value pairs are ignored by the 
full_name()  function but could have meaning to functions it calls by passing the names  
parameter along. Take care when using this form and do so intentionally.  
ARGUMENTS IN GENERAL  
The a bility to create proper function signatures includes being aware of patterns and 
consistency. Many APIs consist of multiple functions working together to accomplish 
50
©Manning Publications Co.  To comment go to  liveBook  something. This often means passing the same data into more than one function, so each 
function is aware of the state of the working data. If you're processing data contained in a 
dictionary that's passed to multiple functions, it's a good idea to make the argument position 
and name representing the common data the same for all (or as many as po ssible) functions 
that work with it.  
For example, make the dictionary the first argument of the function, and all the additional 
arguments pass information about how to process the dictionary. The first parameter dictionary 
is the common, state data struct ure being passed between functions that act on that state 
data:  
email_user(user_data, content, from)  
populate_user_address(user_data, address, city, state, zipcode)  
The email_user function gets the email address from the user_date  structure, then 
generates  an email with the content  and from parameters and sends the email.  
The popuplate_user_address  function adds address information to the existing user_data  
structure.  
The same thing would apply to system resources passed to functions, file handles, databas e 
connections, and cursors. If multiple functions need these resource objects, it helps make the 
API more readily understandable if the functions have a consistent signature.  
A function that has many arguments starts to stretch our cognitive abilities and often 
indicates the function does too much and should be refactored into smaller functions, each 
with a single purpose.  
It's tempting to make a long list of function arguments into one using the keyword 
argument ability of Python. Unless the dictionary pas sed as the **kwargs  is documented, it 
just obscures what the function is expecting. It's also side -steps the original issue that perhaps 
the function needs to be refactored.  
4.2.3  Return Value  
As you've seen, one half of the API contract is what's returned by a function. In Python, even 
if you don't have a return statement in your function code, a value of None is returned 
automatically.  
If the function you create performs system actions (file IO, network activity, system -level 
changes), you can return a True or False to indicate the success or failure of the function.  
4.2.4  Single Responsibility  
Strive to create functions that do only one thing; this is the Single Responsibility Principle. 
Writing a useful function is already considerable work, especially if your goal is to make the 
function flexible through thoughtful  input arguments  and processing code . Trying to make it 
do two things more than doubles the difficulty . 
Here's a contrived example function from CH_04/example_02.py  that illustrates this:  
  
51
©Manning Publications Co.  To comment go to  liveBook  def full_name_and_print(fname:str , mname: str, lname: str) -> None: 
    """Concatenates the names together and prints them  
     
    Arguments:  
        fname {str} -- first name  
        mname {str} -- middle name  
        lname {str} -- last name  
    """ 
    full_name = " ".join( name for name in [fname, mname, lname]  if name) 
    print(full_name)  
This function concatenates the arguments to create the full_name  variable and prints it to 
sys.stdout . The list comprehen sion inside the " ".join is to ensure there is only a single 
space between the names should mname  be left out when the function is called. This function 
is not as useful as it could be because it's trying to do too much.  
It's not useful to other functions  needing the full name because it isn't returned. Even if 
the full name was returned, any function calling this has to expect the full name to be printed.  
Also, the function is difficult to test because it doesn't return anything. To test this, you'd 
have to redirect sys.stdout in some way so a test could see the output , which could get 
messy quickly.  
Here is a better version from CH_04/example_02.py : 
def full_name(fnameNone, mname=None, lname=None) -> str: 
    """Concatenates the names together and return s the full name  
     
    Arguments:  
        fname {str} -- first name  
        mname {str} -- middle name  
        lname {str} -- last name  
     
    Returns:  
        str -- the full name with only a single space between names  
    """ 
    full_name = " ".join (name for name in [fname, mname, lname] if name)  
    return full_name  
This version only does one thing: it creates the full name and returns it to the caller. Now 
the return value of the function can be used with the print function, included in a web page,  
added to a data structure, converted to a JSON document, and more.  
This function has also become easy to test because you can test the return value, and the 
same input arguments always produce the same output.  
4.2.5  Function Length  
Related to the Single Responsibility Principle is the length of the functions you write. As people, 
it's difficult to keep too much context and detail in our heads at once. The longer a function 
gets, the more difficult it becomes to reason about and under stand its behavior.  
There is no hard and fast rule to adhere to regarding the length of a function. A good rule 
of thumb is around 25 lines, but this is entirely dependent on your comfort level.  
52
©Manning Publications Co.  To comment go to  liveBook  If you create a function that's too long to comprehend easil y, it probably means the function 
is trying to do too much. The solution is to refactor it and break some of the functionality out 
to other functions.  
Another idea if refactoring a function leads to multiple functions that work together on the 
same data or  processing is to create a class with the functions as the methods of that class.  
If you follow good naming practice and make the new functions do only one thing well, 
you'll create more readable code.  
4.2.6  Idempotentence  
Though an ominous -sounding word, idempo tent in developer terms means a function that 
always returns the same result given the same input argument values. No matter how many 
times it's called, the same input yields the same output.  
The output of the function isn't dependent on outside variables,  events, or IO activity. For 
example, creating a function that uses the arguments along with the clock time to create the 
return value wouldn't be idempotent. The return value is dependent on when the function is 
called.  
Idempotent functions are easy to te st because the behavior is predictable and can be 
accounted for in test code.  
4.2.7  Side Effects  
Functions can create side effects that change things outside the scope of the function itself. 
They can modify global variables, print data to the screen, send infor mation across a network, 
and a whole host of other activities.  
In your functions the side effects should be intended, what was referred to as actions on 
the system previously. Unintended side effects need to be avoided. Modifying a global variable 
is somet hing a function can do but should be thought about carefully as other, possibly 
surprising, functionality could be affected by those modifications.  
When opening a file, it's good practice to close it when through with it to avoid the 
possibility of corrupt ing the file. Database connections should be closed when unused so other 
parts of the system can access them. In general, it's good programming practice to clean up 
and release system resources as soon as your function or application is finished with them.  
There is another side effect to be aware of when working with Python. Because all 
arguments to functions are passed by reference, the function has the potential of altering 
variables outside of the function's scope. Example program CH_04/example_03.py  
demonstrates this:  
  
53
©Manning Publications Co.  To comment go to  liveBook  from copy import copy  
 
def total(values: list, new_value: int) -> int: 
    """This function adds new_value to the values list,  
    totals the contents and returns the total  
     
    Arguments:  
        values {list} -- list of values to to tal 
        new_value {int} -- value to include in total  
     
    Returns:  
        int -- total of values in list  
    """ 
    values.append(new_value)  
    return sum(values)  
 
 
def better_total(values: list, new_value: int) -> int: 
    """This function adds new_value to the values list,  
    totals the contents and returns the total  
     
    Arguments:  
        values {list} -- list of values to total  
        new_value {int} -- value to include in total  
     
    Returns:  
        int -- total of values in list  
    """ 
    temp_list = copy(values)  
    temp_list.append(new_value)  
    return sum(temp_list)  
 
 
values_1 = [1, 2, 3]  
total_1 = total(values_1, 4)  
print(f"values_1 has been modified: {values_1}")  
print(f"total_1 is as expected: {to tal_1}")  
print() 
values_2 = [1, 2, 3]  
total_2 = better_total(values_2, 4)  
print(f"values_2 unchanged: {values_2}")  
print(f"total_2 is as expected: {total_2}")  
When this program runs the following output is produced:  
values_1 has been modified: [1, 2, 3, 4] 
total_1 is as expected: 10  
 
values_2 unchanged: [1, 2, 3]  
total_2 is as expected: 10  
Both the total()  and better_total()  functions return the same value, 10, but only 
better_total()  is idempotent. The code in the total()  function is changing the values_1 
list passed to it as a parameter and exists outside of its scope.  
This happens because of the way the sum is calculated. The total()  function appends 
new_value  directly to the values  list argument passed to it. Because arguments are passed 
by reference, this means the list variable values_1  outside the function and the variable 
54
©Manning Publications Co.  To comment go to  liveBook  values  inside the function both reference the same list. When new_value  is appended to the 
list, it's modifying the same list that values_1  referenced.  
Inside the better_total()  function makes a copy of the values  argument, creating a new 
list variable temp_list  independent of the one referenced by the values_2  list. Then it 
appends new_value  to temp_list  and returns the sum of temp_list . This leaves the values_2  
list variable untou ched, which is the intended behavior.  
The better_total()  function is idempotent because it returns the same results for a given 
set of inputs with no side -effects.  
4.3 Documentation  
Documentation is a necessary process when building and defining an API. Funct ions and the 
modules they are part of should have documentation that briefly describes the functionality of 
the module and the functions it contains.  
Modules should have docstrings at the top of the file describing the functionality the module 
provides and  possibly the exceptions that might be raised.  
Functions and class methods should have docstrings that briefly describe what the function 
does, what the parameters are for and the expected return value. The functions in the example 
programs shown previousl y include example docstrings.  
You might hear people say documenting Python code is unnecessary because the code is 
so readable and therefore self -documenting. The readability part is genuine, but the intent of 
any reasonably complex piece of code can only benefit from documentation, helping the reader 
understand that intent.  
Documenting code does take effort; however modern code editors like VS Code make it 
easier to insert docstring templates. A template for the docstrings in the example programs 
was gener ated by hitting return at the end of the function definition, typing triple double -
quotes (""") and hitting return again.  
Many tools extract and process Python docstrings as part of external documentation 
systems. Besides being a benefit to readers of the code, including the original author, there is 
another win. If you're at the Python prompt and type help(<function name>),  the built -in 
help system presents the docstring of the function for reference. This includes not only the 
builtin functions but those you create. The existence of a docstring makes this possible.  
  
55
©Manning Publications Co.  To comment go to  liveBook  4.4 Summary  
This chapter covered useful information about APIs : 
• What an API is and what a good one looks like  
• How to create a good API  
• Specific things to think about  
• Steps to take while coding.  
Creating a good API is important because ease of use is important. Users of your APIs, 
which includes yourself, want to make use of the functionality provided, not struggle with how 
to get that functionality to work.  
Creating useful APIs is challenging; there are a lot of moving parts and considerations. Well 
named modules, functions, and classes with consistent, logical pa rameters and documentation 
help give an API good affordance or discoverability.  
Like many things, the work put in to create something now pays rewards later when using 
what you've created as a trusted tool.  
  
56
©Manning Publications Co.  To comment go to  liveBook  5 
The Object of Conversation  
This chapter covers  
•Object -oriented APIs
•Designing Objects with Classes
•What Inheritance Is
•What Polymorphism Is
•What Composition Is
When having a conversation, particularly one with any complexity, it’s helpful if everyone in 
the conversation has the same context. It would be difficult to have conversations if every time 
someone began a new sentence, they had to present all of the context about the object of the 
conversation that had passed before.  
From the standpoint of software functions the context is the current state of  the information 
the functions are working with. In the previous chapter we talked about creating function 
signatures where the data state is passed around the function calls in consistent ways.  
This is a useful and powerful way to conduct conversations b etween functions that work on 
stateful data. It gets a little more complicated if the same functions are being passed multiple, 
distinct stateful data contexts. The data and the functions that work on that data are separate 
from each other and it’s up to t he developer to keep them organized and connect them.  
Python provides another layer of abstraction to reduce complexity by using the object -
oriented programming model.  
5.1 Object -Oriented Programming  
The ability to place functions into modules provides many op portunities for structuring an API. 
The type and order of the parameters passed to the functions that make up an API offer 
possibilities to make your API more discoverable and useful.  
57
©Manning Publications Co.  To comment go to  liveBook  Using the concept of single responsibility and keeping functions to mana geable lengths 
makes it more likely your API will consist of multiple functions. Users of the API's functionality, 
which may itself call other API functions further modifying the data or state, produces the final 
result returned to the user.  
Often the data  structures passed between functions are collection objects, lists, sets, and 
dictionaries. These objects are powerful and taking advantage of what they offer is important 
in Python development.  
By themselves, data structures don't do anything, but the fun ctions they are passed to 
know what to do with the data structures they receive as input.  
Since everything in Python is an object, you can create interesting objects using object -
oriented programming. One of the goals of creating objects is to encapsulate data and the 
methods that act on that data into one thing. Conceptually you're making something with the 
functionality you designed and implemented. Doing this creates something you can think about 
as an object, or thing, that has behavior. Creating classe s is how you design these objects, 
connecting data and functionality to them.  
5.1.1  Class Definition  
Python provides object -oriented programming by defining classes that can be instantiated into 
actual objects when needed. Instantiation is the act of taking something from a definition (the 
class) to reality. You could say the blueprint for a house is the class definition, and building 
the house instantiates it.  
Here's a simple class definition for a Person class from the CH_05/example_01  application 
code: 
class Person:  
    """Defines a person by name"""  
 
    def __init__(self, fname: str, mname: str = None, lname: str = None):  
        self.fname = fname  
        self.mname = mname  
        self.lname = lname  
 
    def full_name(self) -> str: 
        """This method returns the person's full name"""  
        full_name = self.fname  
        if self.mname is not None:  
            full_name = f"{full_name} {self.mname}"  
        if self.lname is not None:  
            full_name = f"{full_name} {self.lname}"  
        return full_name  
This class definition creates a Person template containing a person's first, middle, and last 
names. It also provides the full_name()  method to get the person's full name based on the 
information passed to the object by its constructor, th e __init__()  method. A function 
associated with a class is often referred to as a method. This is a convention to make a 
distinction between a regular function and one that’s part of a class.  
Creating and using an instantiated person object from the Person  class looks like this:  
  
58
©Manning Publications Co.  To comment go to  liveBook  >>> p1 = Person(“George”, “James”, “Smith”)  
print(p1.full_name())  
The self parameter passed as the first parameter of every method of the Person  class is 
the reference to the person instance just created. In this way, your code ca n create as many 
Person  instances as needed, and each will be distinct because the self value of each will 
reference a particular instance and the state attributes (data) it contains.  
This class can be represented visually in UML (Unified Modeling Language ) as well. UML is 
a standardized way to present the design of systems visually. It's not necessary to use UML 
diagrams when designing and building a system, but it can be useful to introduce abstract 
concepts difficult to present concisely with text alone.  Here is the UML diagram for the Person 
class:  
 
The UML diagram for the Person class shows the name of the class, the attributes it 
contains, and the methods it provides.  
The plus sign character '+' in front of the attribute and method names indicates they are 
public. In Python, attributes and methods of a class are always public and have no notion of 
protected or private access.  
Python's class design originates with the idea "we're all adults here," and the developers 
who use your classes wil l behave accordingly. Using plain attributes should be the default when 
designing your classes. You'll see later how class properties can gain control of how attributes 
are accessed and used.  
A simple use case for the Person class is presented in the CH_05/example_01  application:  
def main():  
    # Create some people  
    people = [  
        Person("John", "George", "Smith"),  
        Person("Bill", lname="Thompson"),  
        Person("Sam", mname="Watson"),  
        Person("Tom"),  
    ] 
 
    # Print out the full names of the people  
    for person in people:  
        print(person.full_name())  
This code creates four instances of the Person class, each representing a different person 
and exercising all the variations of the constructor. The for loop iterates through t he list of 
59
©Manning Publications Co.  To comment go to  liveBook  Person object instances and calls the full_name()  method of each. Notice the full_name()  
method is not passed any state data, it uses the data attributes associated with the class 
instance.  
5.1.2  Drawing With Class  
The rest of the examples you're going to build are object -oriented applications that animate 
some shapes on the screen. Readers who hav e experience with object -oriented programming 
will probably recognize the analogy, a generic shape from which specific shapes, like rectangles 
and squares inherit. This analogy has been used to present object -oriented techniques for a 
long time and has bec ome somewhat contrived. I acknowledge that but am using it anyway 
because it has advantages.  
The use of shapes is something familiar enough outside of programming that readers can 
relate to them and the idea that new shapes can be derived from them. Additi onally, a program 
that moves shapes around on a computer screen is also familiar to most readers. The idea of 
moving shapes having speed and direction, staying within the boundaries of the program 
window, are accepted behaviors for computer rendered graphi cs. 
Because of this familiarity with shapes, the cognitive demand of learning about the object -
oriented program can be focused on just that, not on any abstract quality of the object itself. 
For this reason, I'd ask you to bear with any contrived nature of  the examples to see the larger 
picture.  
Each of the examples that follow expands on the previous one to present the following 
concepts:  
• Inheritance – parent/child relationships between classes  
• Polymorphism – using an object as if it had multiple forms  
• Composition – using composition instead of inheritance to give attributes and behavior 
to a class  
To create the drawing application, you'll be using the arcade module available in the Python 
Package Index ( https://pypi.org/project/arcade/ ). This module provides the framework to 
build a drawing surface on the computer screen and draw and animate objects on that screen.  
The first thing to do is to define a class f or a rectangle to draw on the screen. Starting with 
the UML diagram for the Rectangle class:  
60
©Manning Publications Co.  To comment go to  liveBook   
The UML diagram shows the attributes encapsulated in the class necessary to render a 
rectangle on -screen. All of these attributes are initialized during the cons truction of a Rectangle 
object:  
• x, y, width, height – define the position of the Rectangle on screen and the dimensions 
to use when drawing it  
• pen_color, fill_color – define the colors used to outline the Rectangle and fill it  
• dir_x, dir_y – the direction of movement relative to the screen x and y axes, these are 
either 1 or -1 
• speed_x, speed_y – the speed at which the Rectangle is moving in pixels per update  
The diagram also includes the definition of three methods the class supports:  
• set_pen_color() – provides a mechanism to set the pen color used to draw the rectangle 
instance object  
• set_fill_color() - provides a mechanism to set the fill color used to fill a rectangle 
instance object  
• draw() – draws a Rectangle object instance on the screen  
This UML diagr am is converted to a Python class definition in code. The example code in 
the repository has docstring comments, however here they’ve been removed as I think they 
are a distraction in the book. Here's the Rectangle class based on the above diagram from 
CH_05/example_02 application : 
  
61
©Manning Publications Co.  To comment go to  liveBook  class Rectangle:  
    def __init__(  
        self, 
        x: int, 
        y: int, 
        width: int,  
        height: int,  
        pen_color: tuple = COLOR_PALETTE[0],  
        fill_color: tuple = COLOR_PALETTE[1],  
        dir_x: int = 1,  
        dir_y: int = 1,  
        speed_x: int = 1,  
        speed_y: int = 1  
    ): 
        self.x = x  
        self.y = y  
        self.width = width  
        self.height = height  
        self.pen_color = pen_color  
        self.fill_color = fill_color  
        self.dir_x = 1 if dir_x > 0 else -1 
        self.dir_y = 1 if dir_y > 0 else -1 
        self.speed_x = speed_x  
        self.speed_y = speed_y  
 
    def set_pen_color(self, color: tuple) -> Rectangle:  
        self.pen_color = color  
        return self  
 
    def set_fill_color(self, color: tuple) -> Rectangle:  
        self.fill_color = color  
        return self  
 
    def draw(self):  
        arcade.draw_xywh_rectangle_filled(  
            self.x, self.y, self.width, sel f.height, self.fill_color  
        ) 
        arcade.draw_xywh_rectangle_outline(  
            self.x, self.y, self.width, self.height, self.pen_color, 3  
        ) 
This class defines a simple Rectangle  object. The object is initialized with the x, and y 
coordinates, the width and height, pen and fill colors, the direction, and speed of motion of the 
Rectangle. In the arcade module the screen origin is in the lower -left corner, which is how 
most of us th ink about x and y axes on paper, but is different from many other screen rendering 
tools.  
Modifying the values of the x and y attributes moves the Rectangle around the screen 
maintained by the arcade module and the instance of the Window class in the appli cation. The 
Window class has two methods used to animate the objects on the screen; on_update()  and 
on_draw() . The first updates the position of all the objects to render on the screen, and the 
second draws those updated objects on the screen. The on_updat e() method is called every 
refresh iteration and is where the application modifies the position of the rectangles in the 
self.rectangles  collection. The on_update()  method looks like this:  
  
62
©Manning Publications Co.  To comment go to  liveBook  def on_update(self, delta_time):  
    for rectangle in self.rectan gles: 
        rectangle.x += rectangle.speed_x  
        rectangle.y += rectangle.speed_y  
This code iterates through the collection of rectangles and updates the position of each one 
by its x and y speed values, changing its position on the screen.  
The updat ed rectangles are drawn on the screen by the Window instance method 
on_draw() , which looks like this:  
def on_draw(self):  
    # Clear the screen and start drawing  
    arcade.start_render()  
 
    # Draw the rectangles  
    for rectangle in self.rectangles:  
        rectangle.draw()  
Every time the on_draw()  method gets called, the screen clears and the self.rectangles  
collection is iterated through, and each rectangle has its draw() method called.  
The Rectangle class has behavior defined by the methods set_pen_co lor(),  
set_fill_color() and draw() . These methods use and alter the state data encapsulated by 
the class definition. They provide the API you interact with when using the class. Using the 
methods abstracts away having to modify the state data directly.  
Look at the set_pen_color()  and set_fill_color()  methods and you’ll see they return 
self. Returning self can be useful to chain methods of the class together into a series of 
operations. Here's an example from CH_05/example_02.py  using the Rectangle class. Th is 
code changes the pen and fill colors when the arcade schedule functionality code is called every 
second:  
def change_colors(self, interval):  
    for rectangle in self.rectangles:  
        rectangle.set_pen_color(choice(COLOR_PALETTE)).set_fill_color(  
            choice(COLOR_PALETTE)  
        ) 
The change_colors()  method of the Window instance is called by an arcade schedule 
function every second. It iterates through the collection of rectangles and calls the 
set_pen_color()  and set_fill_color()  in a chained manner to set random colors picked 
from the globally defi ned COLOR_PALETTE  list. 
When the CH_05/example02  application runs, it creates a window on the screen and 
animates a vertically aligned rectangle up and right at a 45 -degree angle. It also changes the 
pen and fill colors of the Rectangle every second the ap plication runs. Here's a screenshot of 
the running application:  
63
©Manning Publications Co.  To comment go to  liveBook   
PROPERTIES  
As mentioned earlier, direct access to the attributes of a class should often be the default. The 
Rectangle example above follows this practice. However, there are situations where you'll want 
more control over how the attributes of a class are used or changed.  
The definition of the Rectangle class includes attributes for the x and y origin of the 
Rectangle, which helps draw it in the window. That window has dimensio ns, and if you run the 
CH_05/example_02  application long enough you'll see the Rectangle move off the screen.  
Currently, the origin of a Rectangle instance is set to any integer value. No known screen 
has a resolution as large as the range of integer value s, and none at all deal with negative 
numbers directly. The window declared in the application has a width of 600 and a height of 
800 in pixels.  
The boundaries of where rectangle objects can be drawn should be constrained to within 
those window dimensions.  Constraining the values of x and y means having code in place to 
limit the values that can be assigned to them. Your goal is to make the rectangle bounce 
around within the screen window.  
If you've come from other languages supporting object -oriented progr amming, you might 
be familiar with getters and setters. These are methods provided by the developer to control 
access to attributes of a class instance. Those methods also give the developer a place to insert 
behavior when the attributes are retrieved or m odified. The behavior you want to insert into 
setting or getting the x and y values is to limit the range of values those attributes can be set 
to. 
Adding getter and setter methods to the Rectangle x and y attributes could be done by 
defining methods like this: 
64
©Manning Publications Co.  To comment go to  liveBook  def get_x(self):  
def set_x(self, value):  
def get_y(self):  
def set_y(self, value):  
Using these getter and setter functions also means changing the example code from this:  
rectangle.x += 1  
rectangle.y += 1  
to this:  
rectangle.set_x(rectangle.get_x() + 1 ) 
rectangle.set_y(rectangle.get_y() + 1)  
In my opinion, using getters and setters works, but sacrifices readability when compared 
to the direct attribute access version/syntax.  
By using Python property decorators, you can control how class attributes are a ccessed 
and modified while still using the direct attribute access syntax. The Rectangle class can be 
modified to use property decorators offering this behavior. The updated portion of the 
Rectangle class from example program CH_05/example_03 is shown belo w: 
  
65
©Manning Publications Co.  To comment go to  liveBook  class Rectangle:  
    def __init__(  
        self, 
        x: int, 
        y: int, 
        width: int,  
        height: int,  
        pen_color: str = "BLACK",  
        fill_color: str = "BLUE",  
    ): 
        self._x = x  
        self._y = y  
        self.width = width  
        self.height = height  
        self.pen_color = pen_color  
        self.fill_color = fill_color  
 
    @property  
    def x(self):  
        return self._x  
 
    @x.setter  
    def x(self, value: int):  
        if self._x + value < 0:  
            self._x = 0  
        elif self._x + self._width + value > Screen.max_x:  
            self._x = Screen.max_x - self._width  
        else: 
            self._x = value  
 
    @property  
    def y(self):  
        return self._y  
 
    @y.setter  
    def y(self, value):  
        if self._y + value < 0:  
            self._y = 0  
        elif self._y + self._height + value > Screen.max_y:  
            self._y = Screen.max_y - self._height  
        else: 
            self._y = value  
The first thing to notice is the attributes x and y are prefixed with a single underscore '_' 
character. Using the underscore this way is a convention to indicate the attribute should be 
considered private and not accessed directly. It doesn't enforce any notion of a private 
attribute, however.  
The second thing to notice is the new decorated methods in the class. For example the two 
new methods for accessing the self._x  attribute are:  
  
66
©Manning Publications Co.  To comment go to  liveBook      @property  
    def x(self):  
        return self._x  
 
    @x.setter  
    def x(se lf, value):  
        if not (0 < value < SCREEN_WIDTH - self.width):  
            self.dir_x = -self.dir_x  
        self._x += abs(self._x - value) * self.dir_x  
The @property  decorator over the first def x(self)  function defines the getter 
functionality, in t his case, just returning the value of self._x . 
The @x.setter  decorator over the second def x(self, value)  function defines the setter 
functionality. Inside the function self._x is constrained to within the screen x -axis minimum 
and maximum dimensions. If s etting the value of self._x  would place any part of the 
Rectangle outside the screen area, the direction of travel is negated to start it moving in the 
opposite direction.  
Having the above -decorated methods in the Rectangle  class means code like this works  
again:  
rectangle.x += 1  
The program statement appears to be setting the rectangle instance x attribute directly, 
but the decorated methods above are called instead. The += operation calls the getter method 
to retrieve the current value of self._x , adds 1 to that value, and uses the setter method to 
set self._x to that new value. If the resulting change would place the Rectangle outside of 
the screen dimensions, the direction of travel along the x -axis is reversed.  
The beautiful part of this is you can defi ne your classes using direct attribute access initially. 
If it becomes necessary to constrain access to an attribute, you can define getter and setter 
property methods. Existing code using your class doesn't have to change at all. From the point 
of view of  the caller, the API of the class is the same.  
Take note of another feature of using setter and getter decorated methods. You don't need 
to create both setter and getter decorated functions on attributes. You can create only a getter, 
which creates a read-only attribute. Likewise, you can create only a setter creating a write -
only attribute.  
There is also a @deleter  decorator to delete an attribute, but this feature is rarely used.  
DECORATORS  
Before moving on much further, let's talk about decorators. In Python, a decorator is a way to 
extend or modify the behavior of a function without changing the function itself. Decorating a 
function sounds confusing, but an example will help make the intent clearer. As has been 
stated before, functions are objects in Python. One thing this means is functions can be passed 
to and returned from other functions like any other object.  
The function defined below is used to demonstrate the use of decorators:  
  
67
©Manning Publications Co.  To comment go to  liveBook  from time import sleep  
 
def complex_task( delay): 
    sleep(delay)  
    return "task done" 
When the above function is called it uses the delay parameter to emulate some complex 
task that takes time to perform. It then returns the string "task done" when the function ends.  
Suppose it's required to log infor mation before and after this function is called that includes 
how long it took to execute. That could be done by adding the logging information to the 
function itself, but that creates code maintenance issues as every function to be timed would 
have to be updated if the timing code changes. You can instead create a decorator function to 
wrap complex_task  with the desired new functionality. The decorator function looks like this:  
def timing_decorator(func):  
    def wrapper(delay):  
        start_time = time()  
        print("starting timing")  
        result = func(delay)  
        print(f"task elapsed time: {time() - start_time}")  
        return result  
    return wrapper  
This looks odd because the timing_decorator  function defines another function inside 
itself c alled wrapper . The timing_decorator  outer function also returns the wrapper  inner 
function. This is perfectly fine Python syntax because functions are objects, the wrapper  
function is created and returned when the outer timing_decorator  function is execute d. 
The func parameter of the timing_decorator  is the function object being decorated. The 
delay  parameter of the wrapper  function is the parameter passed to the decorated function.  
The code inside the wrapper  function will execute, including calling the de corated func 
object. An example will help clarify what's going on:  
new_complex_task = timing_decorator(complex_task)  
print(complex_task(1.5))  
Here the complex_task  function object is passed to the timing_decorator  function. Notice 
there are no parenthesis on complex_task , the function object itself is being passed, not the 
results of calling the function. The new variable new_complex_task  is assigned the return value 
of timing_decorator,  and since it returns the wr apper function, new_complex_task  is a 
function object.  
The print statement calls new_complex_task  passing it a delay value and printing the 
following information:  
starting timing  
task elapsed time: 1.6303961277008057  
task done  
The output above shows the fu nctionality added by timing_decorator  and the original 
functionality of complex_task  that is executed.  
68
©Manning Publications Co.  To comment go to  liveBook  The example is interesting but not that useful as every invocation of complex_task  would 
have to be passed as a parameter to timing_decorator  to get the additional timing 
functionality. Python supports a syntactic shortcut making this easier. By adding 
@timing_decorator  right before the definition of the complex_task  function. This has the 
effect of "decorating" complex_task  and creating a callable instanc e of the now wrapped 
function. This is shown below:  
@timing_decorator  
def complex_task(delay):  
    sleep(delay)  
    return "task done"  
 
print(complex_task(1.5))  
The CH_05/example_04  program demonstrates wrapping the task directly and using the 
decorator sy ntax, and when run produces this output:  
starting timing  
task elapsed time: 1.5009040832519531  
task done  
 
starting timing  
task elapsed time: 1.5003101825714111  
task done  
The output above shows complex_task  running, but it also indicates the 
@timing_decorated  has wrapped complex_task  with additional functionality that is also 
running and generating log messages about the elapsed time. The complex_task  code hasn't 
changed to provide this; the wrapper  function  inside timing_decorator  does this work. Also, 
any function with the same signature as complex_task  can be decorated with the 
@timing_decorator  to generate timing information.  
5.1.3  Inheritance  
Being able to merge data and behavior relevant to that data into cla sses gives you very 
expressive ways to structure your programs. When building classes there arise situations 
where functionality is common to more than one class. As a developer it becomes part of our 
nature to follow the DRY (Don't Repeat Yourself) princi ple. You can follow this principle when 
creating objects in Python by using inheritance.  
Like parents and children, a parent's child inherits attributes and behavior from the parent 
but aren't exact duplicates. When talking about object -oriented programmin g class design, the 
terms "parent" and "child" are used because the metaphor works well. The terms "base class" 
and "derived class" can also be used to indicate the parent/child relationship.  
You'll also see the words like "superclass" used to refer to the  parent and "subclass" as the 
child. These are all terms applied to the relationship between objects when talking about 
inheritance.  
One of the reasons to use inheritance is to add attributes and behavior unique to the child, 
possibly modifying the ones inherited from the parent. It's also useful to derive multiple 
69
©Manning Publications Co.  To comment go to  liveBook  children from a parent class, each with its own set of unique attributes  and behaviors, but still 
imbued with characteristics from the parent.  
To create an inheritance relationship between two classes in Python is performed like this:  
class ParentClass:  
    pass 
 
class ChildClass(ParentClass):  
    pass 
The ParentClass  definiti on creates a root level class definition. The definition of the 
ChildClass  includes the class to inherit from inside the parenthesis, in the example above it 
inherits from ParentClass . The pass statement in both the class definitions above is a nop 
(no ope ration) in Python and is necessary to make the class definitions syntactically correct 
but having no functionality.  
In the CH_05/example02 code, a Rectangle  class was created with a position on the 
screen, a pen color to draw with, and a color to fill the Rectangle. What if you wanted to create 
other shapes, like squares and circles? Each shape would have a position and dimension on 
the screen and a pen and fill color.  
The direct approach would be to create complete Square  and Circle  class definitions and 
draw instances of each on the screen. Each class would have all of the attributes and methods 
of the Rectangle  class but with a different draw()  method to draw that unique shape. Creating 
separate classes for Square  and Circle  would work for the relatively small number of shapes 
involved but wouldn't scale well if many more shapes were required.  
This presents an opportunity to use inheritance to gather these attributes and their 
associated behavior into a parent class you could call Shape. This Shape parent class would be 
used to collect the common attributes and methods in one place. Any shape to be drawn on 
screen would be a child of the Shape parent  
You'll start by reproducing the functionality of the CH_05/example_03  application by making 
use of inherita nce. The examples below come from the CH_05/example_04  application. The 
Shape  and Rectangle  inheritance is shown with the UML diagram below:  
70
©Manning Publications Co.  To comment go to  liveBook   
The diagram shows the attributes and methods of the Rectangle  class definition have 
moved to the Shape  class, and  the Rectangle  now inherits from it. The Shape  class name is in 
italic to indicate it's an abstract class and shouldn't  be instantiated directly. The draw()  method 
is also in italic because it exists in the Shape  definition, but has no functionality of its  own. The 
functionality must be provided by the child class, in this case, Rectangle . 
Because the Shape  class is essentially what the Rectangle  was, the code won't be shown 
here. Instead, the updated Rectangle  class is shown below:  
class Rectangle(Shape):  
 
    def draw(self):  
        arcade.draw_xywh_rectangle_filled(  
            self.x, self.y, self.width, self.height, self.fill_color  
        ) 
        arcade.draw_xywh_rectangle_outline(  
            self.x, self.y, self.width, self.height , self.pen_color, 3  
        ) 
The first line of the Rectangle  class has been modified to include the Shape  within 
parenthesis. This is how the Rectangle  class inherits from the Shape class.  
The Rectangle has been refactored to have only a unique draw()  method to draw itself on 
the screen. The draw()  method overrides the empty one provided by the Shape  class. 
71
©Manning Publications Co.  To comment go to  liveBook  Everything else is managed and maintained by the Shape  class. Even the __init__()  
constructor has been removed because the constructor from the Shape  class is sufficient.  
It's reasonable to ask what's the advantage of splitting the original Rectangle into two new 
classes, Shape and Rectangle. You'll see that in the next examples when Square and Circle 
shapes are added to the application. For now, gettin g the application running presents a screen 
exactly as seen before, a single rectangle bouncing around the screen and changing colors.  
 
MULTIPLE SHAPES  
Now that you have an inheritance structure defined, you can use it to create multiple kinds of 
shapes with different attributes and behavior. Adding a Square  and a Circle  class to the 
inheritance structure is straightforward. Each additional class inherits  from a parent class 
providing the most c ommon attributes and methods useful to the n ew child class. A UML 
diagram, including Shape , Rectangle , Square,  and Circle  classes, is shown below:  
72
©Manning Publications Co.  To comment go to  liveBook   
This diagram shows a few interesting things about the inheritance structure. Notice the 
Square  class inherits from Rectangle instead of Shape . This is because a square is a special 
case of a rectangle with the height and width being equal to each other.  
This brings up a concept about inheritance and the relationships between objects. As just 
mentioned, a Square  IS-A Rectangle , and a Rectangle  IS-A Shape . This also means a Square  
IS-A Shape  as well. Below is the class definition code for the Square  class:  
  
73
©Manning Publications Co.  To comment go to  liveBook  class Square(Rectangle):  
 
    def __init__(  
        self, 
        x: int, 
        y: int, 
        size: int,  
        pen_color: tuple = COLOR _PALETTE[0],  
        fill_color: tuple = COLOR_PALETTE[1],  
        dir_x: int = 1,  
        dir_y: int = 1,  
        speed_x: int = 1,  
        speed_y: int = 1,  
    ): 
        super().__init__(  
            x, y, size, size, pen_color, fill_color, dir_x, dir_ y, speed_x,                
speed_y 
        ) 
The Square  class has an __init__()  constructor even though it's parent class, the 
Rectangle, doesn't. The Square  provides this unique __init__()  method because it only needs 
to get a single dimension value, size, and not height and width. It then uses the parameters 
in the __init__()  method when it makes a call to super().__init__() . Because the 
Rectangle  class doesn’t have an __init__()  method, the super().__init__()  calls the 
Shape  class constructor, passing th e size parameter for both height  and width  to set the 
attribute dimensions.  
The Square  class doesn't need to provide a draw()  method as the one inherited from the 
parent Rectangle  class works fine, just with the height and width attributes having the same 
value.  
The Circle  IS-A Shape  because it inherits directly from the Shape  class. The code that 
creates the Circle  class is shown below:  
  
74
©Manning Publications Co.  To comment go to  liveBook  class Circle(Shape):  
 
    def __init__(  
        self, 
        x: int, 
        y: int, 
        radius: int,  
        pen_color: tuple = COLOR_PALETTE[0],  
        fill_color: tuple = COLOR_PALETTE[1],  
        dir_x: int = 1,  
        dir_y: int = 1,  
        speed_x: int = 1,  
        speed_y: int = 1,  
    ): 
        super().__init__(  
            x, 
            y, 
            radius * 2,  
            radius * 2,  
            pen_color,  
            fill_color,  
            dir_x, 
            dir_y, 
            speed_x,  
            speed_y,  
        ) 
 
    def draw(self):  
        radius = self.width / 2  
        center_x = self.x + radius  
        center_y = self.y + radius  
        arcade.draw_circle_filled(center_x, center_y, radius, self.fill_color)  
        arcade.draw_circle_outline(center_x, center_y, radius, self.pen_col or, 3) 
Like the Square  class, the Circle  provides its own __init__()  constructor method so the 
caller can provide a radius  for the circle. The radius  parameter is used in the 
super().__init__()  call to set the height and width dimensions of the area the Circle is 
within.  
Unlike the Square  class, the Circle  does provide a unique draw()  method because it calls 
different drawing functions in the arcade module to draw itself on -screen.  
When the CH_05/example_05 application runs, it creates a window with three d ifferent 
shapes bouncing around within the window and changing colors. Initially, it looks like this:  
75
©Manning Publications Co.  To comment go to  liveBook   
NOTE  
Inheritance in object -oriented programming is a feature allowing you to create useful and 
powerful class hierarchies. Keep in mind that just like human genealogies, the descendants 
become less and less like the root parent class as you descend the tree. Large hierarchies of 
classes can become complex to use and understand, and the root class functionality can 
become wholly obscured in distant child classes.  
In my work, I've never gone beyond four levels in any parent/child relationships in class 
hierarchies I've built.  
5.1.4  Polymorphism  
There is another feature of inheritance that can be useful when creating class hierarchies, and 
it's called polymorphism . The word polymorphism means "many forms," and in relation to 
programming it means calling a method of multiple objects by the same method name, but 
getting different behavior depending on which instance of an object is called.  
The CH_05/example_05  applic ation has already taken advantage of polymorphism when 
rendering the different shapes in the window. Each of the shapes in the program supports a 
draw()  method. The Rectangle  class provides a draw()  method to render itself on the 
application screen. The Square class uses the inherited Rectangle  draw()  method, but with a 
constraint on the height and width to create a Square . The Circle  class provides its own 
draw()  method to render itself. The Shape  root parent class also provides a draw()  method, 
but it has  no functionality.  
Because the Rectangle , Square,  and Circle  classes all have an IS -A relationship with the 
Shape  class, they all can be considered instances of Shape  and use the methods provided by 
the class.  
76
©Manning Publications Co.  To comment go to  liveBook  This is what happens in the Display  class when the on_update() , on_draw(),  and 
change_colors()  methods are called. The Display  class has a collection of shapes in the 
self.shapes = []  list created in the constructor. For example, here is the code in the 
on_draw()  method:  
def on_draw(self):  
 
    # Clear the screen and start drawing  
    arcade.start_render()  
 
    # Draw the rectangles  
    for shape in self.shapes:  
        shape.draw()  
This code is called every time the system wants to draw the objects on the screen, which 
is approximately 60 times a second when using the arcade module. When the method is called, 
the first thing it does is clear the screen.  
Then the code takes advantage  of polymorphism to iterate through the list of shapes and 
call the draw()  method of each one. It doesn't matter that each shape is different, they all 
support a draw()  method, and all the shapes are rendered on screen.  
Any number of different shapes could  be defined in a class, and so long as they support a 
draw()  method that renders the shape on the screen, the above loop would work.  
NOTE 
It is common to use real -world objects or concepts when writing about inheritance. The 
examples above do exactly this,  using the idea of shapes, rectangles, squares, and circles. 
Using concepts already familiar to you is a useful metaphor because they are things you know 
already. There are plenty of other new concepts presented when talking about inheritance to 
think abou t, using familiar ideas reduces the cognitive load while learning.  
However, the use of this metaphor can get in the way of creating useful hierarchies of 
classes in your applications. Because we've been talking about things that have behavior like 
actual o bjects in the real world, this can color how you think about your class design. The 
objects you create from the classes you design don't have to model real -world objects at all.  
Many of the objects which are useful to model with classes have no analog in t he real world 
and trying to adhere to the analogy too strictly can hinder the work you're trying to accomplish.  
5.1.5  Composition  
In the inheritance section, you saw the relationships between the Rectangle , Square , Circle,  
and Shape  classes. These relationships  allowed the child classes to inherit attributes and 
behavior from their parent class. This creates the idea that a Rectangle  IS-A Shape , and a 
Square  IS-A Rectangle , which also means a Square  IS-A Shape  as well.  
These relationships also imply a certain si milarity between attributes and behaviors of the 
parent classes and the child classes that inherit from them. But this isn't the only way to 
include attributes and behavior into classes.  
Look at the Shape  class, it has two attributes for pen and fill color . These two attributes 
provide color to the shape and are distinguished from each other by their names. But they 
77
©Manning Publications Co.  To comment go to  liveBook  offer the same thing, a color, most likely from a palette of colors the system can create. This 
means the color is a common attribute within th e Shape  itself and expressed twice.  
It's possible with inheritance to handle this and add to the hierarchy in the examples by 
creating a Color  class having pen and fill color attributes and having the Shape  class inherit 
from it.  
Doing this would work, but  the inheritance feels awkward. You can make a Shape  have an 
IS-A relationship to a Color  class in code, but logically it doesn't make sense. A shape is not 
a color, and it doesn't fit the IS -A mental model of an inheritance structure.  
Instead of trying to  force inheritance to provide the desired behavior, you can use 
composition. You've already been using composition when giving classes attributes that are 
integers and strings. You can take this further and create custom classes to be used as 
attributes, c omposing behavior into your own classes.  
Creating a new class Color  provides a consistent abstraction for color in the application. It 
has a class -level definition for the colors supported and has a mechanism to allow only defined 
colors to be set.  
The UM L diagram showing the addition of a Color class to the hierarchy structure looks like 
this: 
78
©Manning Publications Co.  To comment go to  liveBook   
The Color class is connected to the Shape class as a composite, indicated in the diagram 
above by the connecting line with the filled black diamond symbol. Here i s what the Color  
class looks like from the CH_05/example_06  application program:  
  
79
©Manning Publications Co.  To comment go to  liveBook  @dataclass  
class Color:  
 
    PALETTE = [  
        arcade.color.BLACK,  
        arcade.color.LIGHT_GRAY,  
        arcade.color.LIGHT_CRIMSON,  
        arcade.color.LIGHT_BLUE,  
        arcade.color.LIGHT_CORAL,  
        arcade.color.LIGHT_CYAN,  
        arcade.color.LIGHT_GREEN,  
        arcade.color.LIGHT_YELLOW,  
        arcade.color.LIGHT_PASTEL_PURPLE,  
        arcade.color.LIGHT_SALMON,  
        arcade.color.LIGHT_TAUPE,  
        arcade.color.LIGHT_SLATE_GRAY,  
    ] 
    color: tuple = PALETTE[0]  
    _color: tuple = field(init=False)  
 
    @property  
    def color(self) -> tuple:  
        return self._color  
 
    @color.setter  
    def color(self, value: t uple) -> None: 
        if value in Color.PALETTE:  
            self._color = value  
The Color  class moves the allowable color list within the scope of the class and out of the 
global module namespace. It's also a Python dataclass, which can make defining sim ple classes 
that are mostly data easier to implement. The class provides getter and setter property 
decorators to make using the color within the class more straightforward.  
In order to use the Color  class, the Shape  class is modified to use it for the pen  and fill 
color attributes. The __init__()  constructor for the class is shown below:  
  
80
©Manning Publications Co.  To comment go to  liveBook  class Shape:  
     
    def __init__(  
        self, 
        x: int, 
        y: int, 
        width: int,  
        height: int,  
        pen: Color = Color(),  
        fill: Color = Color(),  
        dir_x: int = 1,  
        dir_y: int = 1,  
        speed_x: int = 1,  
        speed_y: int = 1,  
    ): 
        self._x = x  
        self._y = y  
        self.width = width  
        self.height =  height 
        self.pen = Color(Color.PALETTE[0])  
        self.fill = Color(Color.PALETTE[1])  
        self.dir_x = 1 if dir_x > 0 else -1 
        self.dir_y = 1 if dir_y > 0 else -1 
        self.speed_x = speed_x  
        self.speed_y = speed_y  
The attribu te names for pen and fill color have been simplified to just pen and fill because 
they are both Color  class instances. The initial default values have been set to black for the 
pen and light gray for the fill colors. Adding the Color class to the Shape  class this way creates 
a HAS-A relationship; a Shape  has Color  attributes but isn't a Color itself. 
The set_pen_color()  and set_fill_color()  methods have also been modified to use the 
new pen and fill attributes. Setting a color for the pen now looks like thi s: 
def set_pen_color(self, color: tuple) -> Rectangle:  
    self.pen.color = color  
    return self  
Running the CH_05/example_06  application produces a screen exactly like you've seen 
before, three shapes bouncing around the window and changing colors every second.  
The use of composition gives you a way to add attributes and behavior to a class without 
having to create contrived hi erarchies of inheritance.  
5.2 Summary  
Creating classes and class hierarchies gives you another way to create code that's clean and 
well-controlled in its usage. Classes are another avenue to give your users an API into 
application functionality.  
A class defin ition also provides another way to create namespaces and control scope. A 
module provides a namespace, and classes defined within that module creates more 
namespaces within it. The attributes and methods of a class are within the scope of instance 
objects of the class.  
81
©Manning Publications Co.  To comment go to  liveBook  In this chapter, you've learned about classes, inheritance, and how to create class 
hierarchies. Using classes is a powerful way to take advantage of code reuse and adhere to 
the DRY principle.  
You've also learned about polymorphism and how that can make using related classes more 
straightforward by taking advantage of the relationships inherent in class hierarchies.  
Lastly, you've seen how using composition can be used to apply the single responsibility 
principle to class design to avoid con trived and disjointed class design.  
You’ve moved closer to particular elements of the developer domain and are using 
binoculars to get more detailed views of those domains. We’ll continue to scan useful and 
powerful domains for insights on our journey.  
  
82
©Manning Publications Co.  To comment go to  liveBook  6 
Exceptional Events  
This chapter covers  
•What an exception is
•Why they occur in programs
•How to handle exceptions
•How to raise an exception
•Creating custom exceptions
Developing software can lead you to think in a binary way. Things are either on or off, the y 
work or don't work, something is either True or False. However, the real world is far from 
binary, it is a sea of variety. The software you create for yourself, and others, lives in that 
world.  
The real world is not black or white; it is an infinitely va riable field of grey. Computer 
systems that run software lose power and fail. The networks connecting systems are slow, 
intermittent, or unreliable. The storage systems software depends on to save information 
become full, unreliable or fail outright. The u sers of your software make incorrect assumptions 
and enter wrong or misleading data.  
In addition to the sometimes -problematic world where software runs, you will create bugs 
in the code you write. Software bugs are errors or failures, causing an applicatio n to produce 
unexpected results. Most software applications providing something useful are complex enough 
that bugs will creep in. These come from wrong assumptions on the part of the developer, 
oversights, and just everyday mistakes.  
All of this shouldn't discourage you as a developer but broaden the way you think about 
creating software applications. The problems outlined above can be managed and handled and 
are part of the challenge of becoming a developer. How you handle these chall enges is 
dependent on the requirements of the application and its users. If you're knocking together a 
quick program to solve an issue for yourself, creating something that might crash if given 
incorrect input is probably acceptable. On the other hand, if you're creating something 
83
©Manning Publications Co.  To comment go to  liveBook  hundreds, or thousands, of users will access, it will take longer to develop and build in code to 
handle conditions that might arise.  
Many of you might already be familiar with a Venn diagram like this:  
 
This diagram shows the re lationship between three things related to the development of 
software applications.  
Good in this context represents the software application quality is good; it meets the 
requirements and the user's expectations with a low occurrence to bugs.  
Fast and Che ap are a little harder to define as they relate to time and money, as the adage 
goes.  
The intersection of Good and Cheap can represent the time to develop a software 
application and indicates taking more time to create. This can happen if an inexperienced 
developer, or small team of developers, works for a period of time to create a good application.  
The intersection of Good and Fast also represents time and indicates creating the 
application quickly with good quality. This almost always means more experien ced developers 
able to create an application in a shorter amount of time.  
The intersection of Fast and Cheap means making tradeoffs in quality to create the 
application quickly. An application created this way might be acceptable for a one -off utility 
application, but generally should be avoided.  
Only the intersection of two of the circles can ever be achieved, even though the diagram 
shows the intersection of all three circles. The intersection of all three circles is where magical 
unicorns live. Trying to  find a path to the land of the unicorns will keep you from actually 
creating something useful.  
A software application with good quality meets the needs of its users in a couple of ways. 
It provides the functionality intended and the user expect, and it do esn't behave in unexpected 
ways if things go wrong.  
As mentioned during the introduction to this chapter, in the real -world unexpected events 
happen all the time. Storage devices become full, networks disconnect, and users enter 
incorrect data, unintentio nally or otherwise.  
Unexpected events can occur at any time, and handled in Python by raising an exception.  
84
©Manning Publications Co.  To comment go to  liveBook  6.1 Exceptions  
Python handles unexpected events in running applications by raising exceptions. You can think 
of these as exceptional conditions occurrin g while an application runs, and they're not all 
necessarily errors.  
If you've written any Python programs at all, you've seen exceptions raised. A simple math 
error in a program statement will raise an exception, as shown below:  
>>> print(10/0)  
Traceback (most recent call last):  
  File "<stdin>", line 1, in <module>  
ZeroDivisionError: division by zero  
The exception ZeroDivisionError  is raised by Python because the results of dividing 10 
by 0 are undefined. The exception ZeroDivisionErro r is a child, or sub class, of the base 
Exception  class. The Exception  class is the base, or parent, of most other exceptions Python 
can raise. In this way, the Exception  class is precisely like the Shape class is the parent of 
the Rectangle  class in the previous chapter.  
When an exception occurs in a program Python will stop executing your program code and 
start working its way back up the call stack looking for an exception handler.  
The call stack is the series of function calls leading to the code that raised the exception. 
Python is looking for a handler to intercept the exception and do something with it. If no 
exception handler is found, Python exits the application and prints a stack trace.  
The stack trace is a chronological listing des cending from the root of the application down 
the series of functions called to reach the point the exception was raised. Each function listed 
in the stack trace also shows the line number in the module where the function in the stack 
trace is called. The stack trace continues until the last function called, where the line number 
that raised the exception is displayed.  
The example program CH_06/example_01.py  demonstrates this:  
def func_a():  
    dividend = float(input("Enter a dividend value: "))  
    divisor = float(input("Enter a divisor value: "))  
    result = func_b(dividend, divisor)  
    print(f"dividing {dividend} by {divisor} = {result}")  
 
def func_b(dividend: float, divisor: float) -> float: 
    return func_c(dividend, divisor)  
 
def func_c(dividend: float, divisor: float) -> float:  
    return dividend / divisor  
 
func_a()  
This program shows func_a() getting input from the user for the dividend  and divisor  
and converting those input string s to floating -point values. It then calls func_b() , which calls 
func_c() , which performs the division operation on the two passed parameters. Running this 
program produces the following output for the values entered at the prompts:  
  
85
©Manning Publications Co.  To comment go to  liveBook  Enter a dividend value : 12.2 
Enter a divisor value: 0  
Traceback (most recent call last):  
  File "<path to code> /code/project/CH_0 6/example_01.py", line 20, in <module>  
    func_a()  
  File "<path to code> /code/project/CH_0 6/example_01.py", line 8, in func_a  
    result = func_b(d ividend, divisor)  
  File "<path to code> /code/project/CH_0 6/example_01.py", line 13, in func_b  
    return func_c(dividend, divisor)  
  File "<path to code> /code/project/CH_0 6/example_01.py", line 17, in func_c  
    return dividend / divisor  
ZeroDivisionError : float division by zero  
The code shows Python encountering an exception in func_c()  when it tries to divide 12.2 
by 0, then going back up the call stack to func_b()  and then to func_a()  looking for a handler 
to intercept the exception. Since there isn't a  handler, Python exits the program, prints the 
exception and stack trace that caused the application to crash.  
Another possible exception the program can raise happens if the user enters a string at 
either of the two prompts that can't be converted to a floating -point value. Here is an example 
of running the program raising that exception:  
Enter a dividend value: Python  
Traceback (most recent call last):  
  File "<path to code> /project/CH_0 6/example_01.py", line 20, in <module>  
    func_a()  
  File "<path to code> /code/project/CH_0 6/example_01.py", line 6, in func_a  
    dividend = float(input("Enter a dividend value: "))  
ValueError: could not convert string to float: 'Python'  
In this example, the stack trace only shows func_a()  because the ValueError  exception 
was raised within that function when the program tried to convert the string "Python" to a 
floating -point value.  
6.2 Handling Exceptions  
Handling exceptions in Python is done by using a try / except  block in your program code:  
try: 
    # code that might raise an exception  
except Exception as e:  
    # code that executes if an exception occurs  
else: 
    # code that executes if no exception occurs (optional)  
finally:  
    # code that executes whether an exception occurs or not (optional)  
The try statement begins a block of code that might raise an exception your program can 
handle. The except Exception as e:  statement ends the block of code and is where an 
exception is intercepted and assigned to the e variable. The use of e is not required syntax 
and the variable name e is just my convention.  
Because of the except  Exception as e:  in the handler part of the block, the example 
above will catch any exception raised by the code within the try / except  block.  
86
©Manning Publications Co.  To comment go to  liveBook  The else and finally  clauses of the try / except  block are optional and used less often 
in practice.  
6.2.1  Handle An Exception If the Code Can Do Something About It  
When thinking about exceptions, it's easy to get into a frame of mind to handle them 
everywhere they might occur. Dep ending on where in the program the exception occurs, this 
might be a logical choice.  
Often exceptions happen within the context of a function where the code is acting on passed 
parameters. At this point, the scope of work the code is performing is narrow, and the broader 
context of what the program is trying to accomplish is at a higher level.  
When an exception occurs in a function it's possible the exception handler can make choices 
that make sense within the context of the function. The handler might be a ble to retry the 
operation for a fixed number of attempts before letting the exception flow upwards in the call 
stack to a higher context. It could make assumptions based on the exception and correct or 
change the state of data to make the code continue wi thout raising an exception.  
6.2.2  Allow Exceptions to Flow Upward In Your Programs  
Unless the code where the exception occurs can do something useful about the exception, it's 
better to let the exception flow upwards through the call stack to a higher level of context.  
At higher levels of context decisions can be made about how to handle the exception. The 
higher -level context might be the point where choices about retrying operations are made. At 
the higher levels of context more information might be available about what the program is 
trying to accomplish and what alternative paths can be taken. At this point you can decide 
what information to present to the user so they can make choices about how to proceed.  
The program should also log the exception, and the s tack trace associated with it, so the 
application developers have information about the path taken that generated the exception. 
This is incredibly useful information to have when debugging an application and trying to 
resolve problems.  
Where in the code t o log exceptions depends partially on whether the exception was 
handled or not. If the exception was handled, it may not be necessary to log information about 
it. However, it might be useful to output a log message not as an error, but at the information 
level to make it visible.  
It's also possible an exception is fatal to the program, and nothing can be done other than 
logging the exception stack trace and exiting the program. Exiting an application is an entirely 
reasonable course of action for some appli cations, like utility programs and command -line 
tools.  
6.2.3  Informing the User  
Keeping the application user informed about the status of an application and the events 
occurring in it is also useful. An exception handler in the right context of the application flow 
can inform the user to take steps towards corrective action allowing the application to retry an 
action and succeed.  
87
©Manning Publications Co.  To comment go to  liveBook  The type of exception and the message attached to it can help generate the message to 
present to the user.  
6.2.4  Never Silence an Exception  
It's possible to handle an exception and silence it. Silencing an exception is shown in the next 
two examples:  
try: 
    # some code that might raise an exception  
except: 
    pass 
and this:  
try: 
    # some code that might raise an exception  
except Exceptio n: 
    pass 
The first example catches all exceptions, including system and keyboard events like (CTRL -
C to exit a program), which generates the exception KeyboardInterrupt. This is a system 
exception and not necessarily an error, just an exceptional event.   
The second catches a narrower scope of exceptions, many of which can be considered error 
conditions, but it's still far too broad.  
Worse than catching to broad a scope of exceptions, the above code lets the exception pass 
silently. It doesn't inform the user or log the exception stack trace. The user is deprived of 
information about why the application is malfunctioning, and the developer isn't given any 
information about what the exception is or where it's occurring.  
The presence of either of these block s of code is an indication of a low -quality application. 
Trying to find the source of a problem where this pattern of code exists in an application is 
frustrating and time -consuming.  
EXAMPLE 1 IMPROVED  
The following example code acts on the discussion abo ve to show when to let exceptions flow 
upward in the calls stack, and when an exception handler to be used to try and correct the 
situation that caused the exception.  
The program CH_06/example_01.py  can be improved to handle exceptions and provide a 
better user experience. The program CH_06/example_02.py  demonstrates this improvement:  
  
88
©Manning Publications Co.  To comment go to  liveBook  def func_a():  
    dividend = float(input("Enter a dividend value: "))  
    divisor = float(input("Enter a divisor va lue: "))  
    result = func_b(dividend, divisor)  
    print(f"dividing {dividend} by {divisor} = {result}")  
 
def func_b(dividend: float, divisor: float) -> float:  
    return func_c(dividend, divisor)  
 
def func_c(dividend: float, divisor: float) -> float:  
    return dividend / divisor  
 
successful = False  
while not successful:  
    try: 
        func_a()  
    except ZeroDivisionError as e:  
        print(f"The divisor can't be a zero value, error:", e)  
    except ValueError as e:  
        print( 
            f"The di vidend and divisor must be a string that represents a number, error:",  
            e, 
        ) 
    else: 
        successful = True  
    finally:  
        if successful:  
            print("Thanks for running the program")  
        else: 
            print("Try entering a dividend and divisor again")  
In the example above the functions func_a() , func_b()  and func_c()  are unchanged and 
don’t catch exceptions. They follow the pa ttern of letting any exceptions flow upward through 
the stack to a higher -level context.  
That higher -level context is where func_a() . Now there is a while loop around the function 
that will keep trying func_a()  until it can complete successfully.  
Within th e while loop there is a handler catching two exceptions, ZeroDivisionError  and 
ValueError . Both of these handlers prompt the user with information about what went wrong 
and provide advice about how to proceed.  
The else clause of the handler only executes i f func_a()  can run successfully without 
raising an exception. When this happens it sets the successful  variable to True, which signals 
the enclosing while loop to exit.  
The finally  clause takes advantage of the state of the successful  variable to either 
indicate the program is done or encourage the user to try again.  
Running this program with possible input from the user looks like this:  
  
89
©Manning Publications Co.  To comment go to  liveBook  Enter a dividend value: Python  
The dividend and divisor must be a string that represents a number, error: could not 
convert string to float: 'Python'  
Try entering a dividend and divisor again  
Enter a dividend value: 12.2  
Enter a divisor value: 0  
The divisor can't be a zero value, error: float division by zero  
Try entering a dividend and divisor again  
Enter a dividend value : 12.2 
Enter a divisor value: 3.4  
dividing 12.2 by 3.4 = 3.5882352941176467  
Thanks for running the program  
This program follows most of the recommendations to handle exceptions:  
• Allow the exceptions to flow upward to a higher context  
• Handle an exception if  the code can do something useful about it  
• Inform the user about the problem and suggest a solution  
• Don't silence an exception  
The program doesn't log the exception and the stack trace as this would be distracting 
information for the user given the simplicity of this program. This program handled the 
exception as part of is expected program flow, which makes logging the exception information 
unnecessary.  
That's not to say the  information couldn't be added to the handlers for ZeroDivisionError  
and ValueError if it were deemed useful.  
Logging an exception can be handled by using Python's logging module in this manner:  
import logging  
logger = logging.getLogger(__name__)  
logger.setLevel(logging.DEBUG)  
ch = logging.StreamHandler()  
ch.setLevel(logging.DEBUG)  
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')  
ch.setFormatter(formatter)  
logger.addHandler(ch)  
 
try: 
    x = 10 / 0  
except Exception as e:  
    logger.error("something bad happened")  
The cod e above imports the logging  module and creates a simple logger  instance named 
after the module name the instance is created in. It then sets the terminal as the output of log 
messages, creates a formatter for what messages should look like and adds the han dler to the 
logger instance. Configuring a logger more fully will be part of later examples when we start 
building the MyBlog web application.  
Calling logger.error()  inside the exception handler will print the message. That message 
will be formatted and lo ok like this:  
2022-07-23 18:50:29,803 - __main__ - ERROR - something bad happened  
90
©Manning Publications Co.  To comment go to  liveBook  The output includes a timestamp when the exception occurred, the module name, the error 
level and the message. In the example above the __main__  name exists because this exam ple 
was run as a standalone application.  
If the above code was imported into a larger application as a module __main__  would be 
replaced with the name of the module. In a larger application this information is useful to 
narrow down the area where the exce ption occurred.  
In this simple example the output of the logger is directed to stdout , which is the console, 
or screen for most users. Most use cases of loggers are directed to log files to keep logging 
information from interfering with any output the prog ram is producing for the user.  
The introduction to this section states an exception should never be silenced, and that is 
predominantly the right way to think about handling exceptions. There are situations where 
the developer’s knowledge about the code wo uld make silencing an exception acceptable, if 
taken with forethought. The recommendations above still hold, however.  
This kind of code:  
try: 
    # some code that might raise an exception  
except: 
    pass 
and this:  
try: 
    # some code that might raise an exception  
except Exception:  
    pass 
Is still far too broad as it will catch all exceptions. Something that catches a specific Python 
exception, or a custom exception, narrows the scope of what will be handled to somethi ng 
intentional. That is the real goal, to make exception handling intentional rather than accidental.  
6.3 Raising An Exception  
In Python you can raise exceptions programmatically in your code. Raising an exception might 
seem like an odd thing to do since most of the time an exception equates to errors. However, 
raising an exception is a useful way to handle conditions within your programs that you decide 
are exceptional and not necessarily programmatic errors.  
As an example, suppose you're writing a quiz applic ation providing calculations based on 
user input. One of the calculation functions only works if a user -entered parameter is greater 
than 0 and less than or equal to 100. The code should define a range of values acceptable to 
the function.  
Since integers i n Python have a much larger range your program code will need to limit the 
user input to within the range 0 < parameter <= 100. Restricting the range is easy enough to 
do at the point of use in the function, but what should the function do about it if the range is 
violated?  
Most likely the function should do nothing as it doesn't have the context to do anything 
useful if the range restriction is violated. Keeping in mind the idea of letting exceptions flow 
upwards to where they can be handled, raising an ex ception can be useful.  
91
©Manning Publications Co.  To comment go to  liveBook  Here is one way to handle the range restriction in the function:  
def range_check_user_input(parameter):  
    if not 0 < parameter <= 100:  
        raise ValueError("parameter range exceeded", parameter)  
    # additional functionality  
At the very top of the function a conditional statement checks if the parameter is not within 
the acceptable range, and if not a ValueError  exception is raised. If the parameter is within 
range the function continues normally.  
The code passed the responsibi lity for handling the out of range ValueError  exception up 
the call stack to the calling function. The calling function most likely does have the context 
necessary to handle the exception, perhaps by prompting the user to enter the parameter 
value again.  
Handling the ValueError  exception in the calling function might look like this:  
def get_data_from_user():  
    # initialization and gather user input  
    try: 
        range_check_user_input(parameter)  
    except ValueError as e:  
        print(e)  
        # restart code to get user input  
The get_data_from_user()  function calls the range_check_user_input()  function inside 
a try / except  block that handles a ValueError  exception, prints the error out for the user, 
and restarts the pro cess to get data from the user.  
6.4 Creating Your Own Exceptions  
Python allows you to create custom exception classes your code can raise. Creating a custom 
exception might seem unnecessary since Python has a rich set of exception classes already 
defined. Ther e are a couple of good reasons to create custom exceptions:  
• Exception namespace creation  
• Exception filtering  
In the previous section, the ValueError  was raised by the range_check_user_input()  
function, so an exception handler at a higher level in the get_data_from_user()  function can 
intercept and do something about it.  
But suppose the range_check_user_input()  function raised an unrelated ValueError  
later in the function? The exception would flow upwards through the stack to the calling 
function and be caug ht by the exception handler in get_data_from_user() . 
At that point what should the get_data_from_user()  function do? The code can't assume 
the correct behavior is to show the error to the user and restart the process of gathering data 
because the range che ck isn't the only possible source of the exception.  
One option is to examine the exception arguments by looking at the e.args  attribute tuple. 
Then the code can make choices within the exception handler to determine the source of the 
exception.  
92
©Manning Publications Co.  To comment go to  liveBook  This soluti on is brittle since it depends on the arguments passed at the point where 
ValueError  was raised, and those might change sometime later.  
A better design is to create an exception specific to the needs of the program, narrowing 
the scope of the exceptions to  handle. You create a custom exception handler in the module 
that defines the range_check_user_input()  function like this:  
class OutsideRangeException(Exception):  
    pass 
 
def range_check_user_input (parameter):  
    if not 0 < parameter <= 100:  
        raise OutsideRangeException(“parameter range exceeded”, parameter)  
    # additional functionality  
The code above creates a new exception class named OutsideRangeException  that inherits 
from the parent Exception  class. This new exception class is used in the 
range_check_user_input()  function and raised if the parameter  value is outside the defined 
range of acceptable values.  
Now the abbreviated program code looks like this:  
class OutsideRangeException(Exception):  
    pass 
 
def get_data_from_user (): 
    # initialization and gather user input  
    try: 
        calculated_result = calculate(parameter)  
    except OutsideRangeException as e:  
        print(e)  
        # restart code to gather user input  
 
def range_check_user_input  (parameter):  
    if not 0 <  parameter <= 100:  
        raise OutsideRangeException("parameter range exceeded", parameter)  
    # additional functionality  
If the parameter value is outside the acceptable range, the get_data_from_user()  
function can catch that specific exception and han dle it. If any other exception is raised by the 
range_check_user_input()  function, that exception will flow upward to a handler catching 
that specific exception (or just the base class Exception ). 
A complete example program using the logging module that demonstrates this is shown 
here with comments removed for brevity:  
  
93
©Manning Publications Co.  To comment go to  liveBook  import math  
import logging  
 
logger = logging.getLogger(__file__)  
 
class OutsideRangeException(Exception):  
    pass 
 
def range_che ck_user_input(parameter: int) -> float:  
    if not 0 < parameter <= 100:  
        raise OutsideRangeException("range exceeded", parameter)  
 
    return parameter  
 
def get_data_from_user():  
    successful = False  
    while not successful:  
        parameter = input(  
            "Please enter a integer greater than 0 and less than or equal to 100: ")  
 
        try: 
            parameter = int(parameter)  
        except ValueError as e:  
            logger.exception("Som ething happened", e)  
            print(e)  
            continue  
 
        try: 
            result = range_check_user_input(parameter)  
        except OutsideRangeException as e:  
            logger.exception("Parameter outside of range", e)  
            print( 
                "Entered value outside of acceptable range,"  
                " please re -enter a valid number"  
            ) 
            continue  
 
        print(f"Parameter within range = {result}")  
        successful = True  
 
def main():  
    get_data_from_ user() 
 
if __name__ == "__main__":  
    main() 
  
94
©Manning Publications Co.  To comment go to  liveBook  6.5 Summary  
In this chapter, you've learned these things about exceptions:  
• What exceptions are  
• Why they occur  
• How to handle exceptions  
• How to raise your own exceptions  
• How to create custom exceptions  
Understanding how to handle and use exceptions is essential to a developer. They are 
events our programs receive from the real world about the things happening to our programs, 
and the result of the actions our programs take.  
A goal of development is to cr eate something useful in the world. Exceptions and how we 
handle them are tools allowing you to develop successful programs that will be used and well -
received in that world.  
Exceptions and exception handling are another slice of the developer’s world. Loo king at 
them closely and gaining understanding about their details allows you to use exceptions well 
as we examine other aspects of developing applications.  
  
95
©Manning Publications Co.  To comment go to  liveBook  7 
Sharing With the World  
This chapter covers  
•The Project Application
•What a Web Server Does
•The Fl ask Microframework
•Running the Server
You've covered a lot of material in the previous chapters about being a developer. Now you’re 
going to put that knowledge to work. Choosing an application to create is tricky because the 
domain of possibilities is so large. The project you'll be creating i s a small but well -featured 
blogging platform we'll be referring to as MyBlog. The MyBlog application will be available as 
a web -based Python application.  
The MyBlog web application will provide tools so users can join the blogging community 
and create blo g posts. Registered users can post content using markdown for styling. All users 
will be able to view the posted content, and registered users will be able to comment on it. 
Administration users will be able to mark any content or comments inactive as they  see fit. 
Registered users will be able to mark any content they've created as inactive.  
7.1 Sharing Your Work  
The MyBlog web application is a way to not only share your thoughts, and the thoughts of the 
applications users, but to share your work. The applicat ion serves a particular purpose with a 
host of features. The work involved to pull together the technologies to create the MyBlog 
features is a skill worth showing off.  
7.1.1  Web Application Advantages  
The project choice to create a web application is bas ed on a few considerations. First and 
foremost, creating a useful web application builds on the topics covered in previous chapters 
96
©Manning Publications Co.  To comment go to  liveBook  quite well. Pulling together the topics of development tools, naming and namespaces, API use 
and creation, and class design will play into the big picture of the application.  
Other types of applications also offer some of these opportunities to express what you've 
learned but can be challenging to share with others. For example, creating a desktop GUI 
application offers interes ting challenges to a developer. However, distributing a GUI application 
for widespread use can be difficult. It's certainly possible to do so with Python, but the steps 
necessary are outside of the scope of this book.  
A web server has some advantages in te rms of distributing an application. The web server 
itself and the features and services are centrally located and are not running on the many and 
varied computer environments that users have. Having the server centralized like this means 
changes and update s to the application happen in one place. Restarting the server, or pushing 
changes out interactively, makes the changes and updates available immediately to all users.  
Another advantage of a web server -based application is making a user interface availabl e. 
A web application takes advantage of something installed on just about every computer in 
existence, a web browser. Modern web browsers provide a powerful platform on which to build 
user interfaces. Data can be formatted and presented in almost infinite ways. Images and 
multimedia are also well supported. Users can interact with applications hosted on browsers 
using interface elements like buttons, lists, drop -down lists and forms.  
7.1.2  Web Application Challenges  
This isn’t to say using a web browser as an app lication platform isn’t without challenges. 
Creating a web application means you'll be working in multiple technical domains. Along with 
Python, you'll be creating HTML, CSS, and JavaScript code files. Additionally, desktop -based 
applications offer m ore direct access to the computer hardware and the tremendous computing 
power personal computers bring to bear.  
However, with continuing advancements in browsers, new and expanding web 
technologies, and ever -increasing Internet speed that's widely availab le, the performance gap 
between desktop and web -based applications is narrowing. In addition, web -based systems 
have grown to have widespread acceptance as a method of delivering applications. This 
acceptance makes creating them a valid path for both perso nal and professional development.  
There are existing blogging platforms available to use or download and run yourself. The 
MyBlog application won’t be in competition with them. What the application offers isn't 
groundbreaking features or technology; bloggi ng software is well -understood. This is one of 
the MyBlog’s advantages, already knowing what a blog application is intended to supply.  
The goal isn't to create a groundbreaking blog but to see the big picture of the application's 
intent and think like a de veloper to pull the necessary parts together to paint that picture into 
existence.  
7.2 Servers  
The MyBlog web application is a subset of what a server application in general provides. One 
definition of a server is an application running on a computer, or comp uters, providing 
functionality to other applications across a network. This arrangement of multiple applications 
accessing the functionality of a central server is known as the client -server model.  
97
©Manning Publications Co.  To comment go to  liveBook  As you build out the MyBlog application you'll be running it on your local computer, which 
will essentially turn it into a server. The software running on a computer is what makes it a 
server, not the computer hardware configuration. Commercial server hardware are built to 
optimize the access that server software  needs to run well, but otherwise are just computers.  
We all use social networks and work with the programs that run on our desktop or mobile 
devices. Those tools are client applications using the functionality of many servers. If you play 
any multiplayer games, the game application uses a server's functionality to coordinate all the 
players' actions in the game.  A diagram of a server connected to several clients is shown 
below:  
 
7.2.1  Request / Response Model  
One common server implementation is the request -response model. The client application 
makes a request to the server, which processes the request and returns a response. In this 
kind of application, the server takes no action unless requested to do so.  
In a web application the client browser mak es an HTTP request to the server for a response. 
The response is very often a stream of text representing an HTML page. When the client 
browser receives the response, it will render the HTML to the browser window. Depending on 
the HTML code that creates th e page it might also make additional requests to the server for 
information like CSS (Cascading Style Sheet) and JavaScript files.  
The diagram below represents a simplified view of the request/response communication 
occurring between a client and server ov er time. Initially the client makes a request to the 
server, which might need to retrieve data from a database in order to compose the response. 
When the response is created it is transmitted back to the client.  
In this example the response is an HTML page  the client application will render in the 
browser window. Part of the HTML code includes links to CSS and JavaScript files which 
98
©Manning Publications Co.  To comment go to  liveBook  generates additional requests to the server. The server retrieves the requested files from the 
server’s hard disk and sends th em as a response to the client.  
 
The request/response model is the primary means the MyBlog  web application will use to 
get data from the server and build and present the application information to the users.  
7.3 Web Servers  
A web server is an application responding to HTTP requests from a client application . A web 
browser is a client appli cation that makes requests to the web server and interprets the 
responses and displays them on the screen. Often what's sent to the client's web browser are 
HTML documents the browser interprets and renders as web pages. HTML documents are the 
content the client requested.  
There are many other interactions between a client's browser and a web server. The 
browser can request the server to send pictures, audio and video content, even downloading 
other applications to the client computer.  
HTML documents can co ntain links to CSS and JavaScript files. When the HTML received is 
rendered by the web browser the embedded links to those files generate additional HTTP 
requests to the web server. The web server responds by sending the requested content.  
CSS files contai n styling information applied to the content in the HTML document displayed 
on the screen. The CSS code modifies a web page's look and feel and is the presentation layer 
to the HTML's content.  
JavaScript files contain code that runs in the client's browser . Once downloaded the web 
browser will start to execute the JavaScript code. This code can be connected to on -screen 
button clicks, updates to the display, and just about any action the user can make on a web 
page can be handled by JavaScript code.  
99
©Manning Publications Co.  To comment go to  liveBook  JavaScr ipt code can also make HTTP requests to web servers for text and data. These 
requests can be initiated by user actions or programmatically and can change and update web 
pages dynamically.  
HTTP  REQUESTS  
The HTTP protocol definition is not the intent of this  book and is beyond its scope, but some 
basic information is useful. Here is an example HTTP request to a web server:  
GET /path_part/ index.html HTTP/1.1  
Host: fictional_website.com:80  
Accept: image/gif, image/jpeg, */*  
<CR-LF> 
The line numbers in the examp le above are not part of the request but were added to 
reference the lines in the explanation of the protocol:  
1. GET /path_part/index.html HTTP/1.1 – This is the start of the request  to the web 
server. The word GET indicates the HTTP method to use, in this case to retrieve the 
document located at /path_part/index.html  using HTTP protocol version 1.1  
2. Host: fictional_website.com:80  – Indicates the domain , suffix, and  port number 
where the request is sent. The port number (80) is optional, and if absent, defaults to 
80. 
a) The domain suffix is the text name of the server hosting the website. This name is 
translated by a DNS (Domain Name Server) to an IP address so the net work 
protocol can direct the request to the right server on the Internet.  
b) The suffix is a list of suffixes that help manage and differentiate domains on the 
Internet. You're probably already familiar with suffixes like '.com' and '.net', but 
there are many  others. This makes 'myserver.com' and 'myserver.net' two 
distinct names.  
c) Ethernet network cards can support 65353 logical ports, with those from 0 to 1023 
reserved for well -known ports used by common applications. For example web 
servers commonly use port  80, which is why it's the default if not specified in the 
URL. However, a server, including web servers, can run on any port in the range 
that's not already in use.  
3. Accept: text/html, */*  - Is header information , which is optional. In this example 
it indi cates to the server the kinds of responses the client can accept. There can be 
many headers, each containing additional information from the client that can be 
useful to the web server.  
4. <CR-LF> - Indicates carriage return/line feed characters or a blank li ne, which is a 
required part of the HTTP protocol and ends the list of headers and tells the server to 
start processing the request.  
When I was first getting into web development it surprised me that small amount of text 
was literally what was sent across the network to the server.  
The first two lines of the request create a URL, or Uniform Resource Locator, which uniquely 
identifies what the client is requesting. In the example above , the U RL is: 
100
©Manning Publications Co.  To comment go to  liveBook   
The server receives this request and takes one of the following steps:  
• Maps the request to a file in the server's control and returns it to the client.  
• Maps the request to a handler (program code) and returns the output of the handler to 
the client  
• Determines the request can't be answered and returns an erro r message  
The use of the '/' slash character is very much like that used as the path separator for 
directories and files on a file system. This pattern is a useful way to present a logical path 
hierarchy of the resources and content originating at the root  domain 
fictional_website.com . 
By allowing for multi -part paths, a logical hierarchy is created. The hierarchy can be 
navigated by a browser application to access different parts of the web server. The end point 
of a URL can be an actual file resource the web server provides, but it doesn't have to be. The 
logical path created can have no relation to the actual file path to a resource on the server's 
file system . 
7.4 Flask  
You're going to build the MyBlog application using Flask, a lightweight web applica tion 
framework for Python. Flask provides the mechanisms and plumbing necessary for Python to 
be used as a web application server to create useful applications that perform and scale well. 
Flask includes the ability to answer HTTP requests for URL resource s and connect those 
requests to Python code that dynamically builds the response.  
Flask https://flask.palletsprojects.com/en/2.1.x/  is not part of the standard library modules 
that come with Python but is available as a third -party module hosted by the Pyt hon Package 
Index ( https://pypi.org/ ). Like other modules available to Python, this makes it installable 
using the pip utility.  
7.4.1  Why Flask  
Python is in the fortunate position of being popular as a language to build web applications. 
Because of this there are many tools and frameworks Python can use to create web 
applications, Flask being one of them. There’s Django, Bottle, Pyramid, Turbogear s, CherryPy, 
and more. All of the frameworks are useful; some have a more particular use case than others, 
some are faster than others, and some are more specialized for creating certain kinds of web 
applications and services.  
101
©Manning Publications Co.  To comment go to  liveBook  Flask lives in the middle gro und and is popular because it's small and has a minimal initial 
learning curve and is more than capable as your skills and needs grow. There are many 
modules available that integrate with Flask that you'll use as the MyBlog application grows. 
These modules  will give the MyBlog application access to databases, authentication, 
authorization, and form creation. Part of the beauty of Flask is not having to learn or use these 
expanded capabilities until they're needed and you're ready to create new features with  them.  
As a developer myself, I've worked with some of the other web application frameworks 
available to Python. Flask is the one I've used the most and am most familiar with. That 
influences the choice to use it because I can write about it with confidenc e that I can present 
Flask to your best advantage and not miss details I might otherwise if I were to choose a 
framework I’m not as familiar with.  
7.4.2  Your First Web Server  
Now that you know where you're  headed let's get started. The first server comes right f rom 
the Flask website quick start example and is as good as anywhere to begin getting familiar 
with Flask. This is the “Hello World” example programmed expressed as a web application. The 
code for the server is available in the repository as examples/CH_07 /examples/01/app.py : 
from flask import Flask     #A 
 
app = Flask(__name__)     #B 
 
@app.route("/")     #C 
def home():    #D 
    return "Hello World!"  
#A Import the Flask system into the application  
#B Create a Flask instance object passing it the name of the c urrent file  
#C This decorator connects the home function to the “/” application route  
#D The home function will run when the user navigates to the “/” route  
After running the install steps for the chapter examples and starting your Python virtual 
enviro nment, the application is run by opening a terminal window and navigating to the 
examples/CH_7/examples/01  directory. Enter the following command for Mac and Linux:  
export FLASK_ENV=development  
export FLASK_APP=app.py  
For Windows users, enter the command:  
set FLASK_ENV=development  
set FLASK_APP=app.py  
Once done, enter the command flask run  and the application will output the following 
text to the terminal window:  
  
102
©Manning Publications Co.  To comment go to  liveBook   * Serving Flask app "app.py" (lazy loading)  
 * Environment: development  
 * Debug mode: on  
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)  
 * Restarting with stat  
 * Debugger is active!  
 * Debugger PIN: 325 -409-845 
The messages above might look  ominous, but it's just informing you the web server is 
running in development mode, which isn't suitable for production. Production in this context 
means running the web server so it's publicly available. The Flask built in development server 
isn't optimi zed or secure enough to be used out in the wild.  
You'll also notice the last line informs you that to stop the application you'll need to press 
the CTRL -C keys. Notice also the terminal cursor doesn’t return. This is because the flask run  
command is runnin g the app instance in an infinite loop waiting to receive and process 
requests.  
A server is intended to run long term and in fact would never stop unless instructed to do 
so. The server you've just started is in an idle state waiting to receive and process  HTTP 
requests. The Flask development server defaults to running at IP address 127.0.0.1 on port 
5000.  
The IP address 127.0.0.1 is known as localhost and is the loopback interface of your 
computer network interface. This means you can create servers on th is address and access 
them even if you don't have a network card installed on your computer. The port value of 5000 
is just an unused port number out of the 65535 available on network interfaces.  Both of these 
values can be configured, but the defaults ar e fine for now.  
To interact with the server you need to open a web browser on your computer and navigate 
to http://127.0.0.1:5000  as the URL and click enter. The browser will respond by printing 
"Hello World!" in th e content window. You'll also see a log message in the terminal window 
where the server is running indicating the request was received and processed correctly, 
indicated by the 200 at the end of the log message. The 200 value is the HTTP status code for 
"Ok", which means the requested was handled successfully.  
CONNECTING ROUTES  
One of the important things to notice about the application is how Python code is connected to 
a valid URL route the server will respond to. The @app.route(“/”)  line of code is a dec orator 
provided by the Flask app instance and applied to the home()  Python function. The decorator 
is how the home()  function is registered with Flask and connected to the URL “/” route, and 
will be called when a user browses to http:127.0.0.1:5000 . Becaus e the route is defined the 
server will respond with the results of running the home()  function, returning the “Hello World” 
string.  
SERVING FOREVER  
Once the server is running it will continue responding to requests until it’s stopped, essentially 
running f orever waiting for HTTP requests to respond to. There is no explicit loop in the 
application code, so how is the server running forever? The loop is part of the functionality in 
103
©Manning Publications Co.  To comment go to  liveBook  the Flask app instance. When the flask run  command is invoked at the terminal command 
line it looks for an object named app and if found starts the server event loop.  
The event loop is where the server waits for events to process. The events are data showing 
up on the network socket at port 5000. Unlike what you might think of as an  infinite loop in 
application code, the server is idle while waiting for events and using very little CPU time.  
UNDEFINED ROUTES  
If you go back to the browser and modify the URL to be http://127.0.0.1:5000/so mething  and 
hit the enter key the browser will respond with a "Not Found" error. Looking at the log 
messages in the terminal window you'll see a message the request was received, but the server 
responded with a 404 status code. The HTTP protocol status cod e 404 essentially equates to 
"Page Not Found".  
This makes sense if you look at your web server application code. At the moment the only 
URL supported is the home route "/", there is nothing defined to handle the "/something"  
route . The server didn't crash because it didn't have the route defined, instead the server 
handled it as an error and informed the browser about the error.  
The ability to handle errors and continue to function is an important part of the server's 
design and implementation. As you devel op the MyBlog application you'll use the errors 
handled and returned by the Flask server to help determine where problems exist in the 
application and where to go to resolve them.  
7.4.3  Serving Content  
Getting your first web server coded and running is a big step. There's a remarkable amount of 
functionality implemented and executed by the very small amount of code in app.py . The 
home()  function shows how you can map Python code to a URL the web serve r will support. 
You can add new functions and map them to additional routes and the web server would 
provide additional pages the browser could navigate to.  
To create a proper web page you could replace the "Hello World!" string returned by the 
home()  function with a string containing HTML code. By doing this the browser would receive 
the HTML and render it in the browser window. However, useful and well -designed web pages 
are created with HTML code that can run to hundreds, even thousands, of lines of code . 
Embedding strings of HTML code directly into your web server would make it difficult to 
maintain and wouldn't take advantage of features available to you through Flask.  
It's better to keep HTML content and Python code separated and build HTML pages as fi les, 
which is what we’ll do next.  
DYNAMIC CONTENT  
The content served to the browser by the home()  function is the string "Hello World!" , which 
is returned to the browser every time the page is accessed or refreshed. Because home()  is a 
Python function it c ould have returned anything, including information and data that is 
generated dynamically. The function could have returned the result of the random()  function 
and the browser would have rendered a random value every time the page was accessed. The 
home()  function could have returned the results of a calculation, data retrieved from a database 
or the return value of some other HTTP web based service . 
104
©Manning Publications Co.  To comment go to  liveBook  Creating and returning dynamic information is one of the cornerstones of creating useful 
web applications , the MyBlog project being one of them. How do you merge dynamic 
information with HTML content that can be meaningfully rendered by browsers? Flask includes 
access to a template language called Jinja2. A template can be thought of as a document that 
will b e combined with data to produce a completed end result document. Here's an example 
using Python f -string formatting to illustrate the idea:  
name = "Joe"  
result = f "My name is {name} " 
print(result)  
My name is Joe  
Here the variable name is set to the string "Joe"  and the Python format string f"My name 
is {name}"  acts as the template. The result  variable is created, and then printed, and "My 
name is Joe"  is output. Python's f -string formatting is like a small templating language, it 
takes in data in the form o f the name variable and creates the resulting string output. Jinja2 
works much like this as well as having many other features.  
By using a templating language, you can place your HTML code in a template file and then 
have Jinja2 substitute your dynamic in formation and data into the right places in that template.  
USING A TEMPLATE LANGUAGE  
Let’s modify the previous web server code to use Jinj2 templates and pass dynamic data to 
the template to render in the browser window. The modified code is found in 
examples/CH_07/examples/02/app.py : 
from flask import Flask, render_template     #A 
from datetime import datetime     #B 
 
app = Flask(__name__)  
 
@app.route("/")  
def home():  
    return render_template("index.html", now=datetime.now())     #C 
#A Import the Flask func tion render_template in order to use Jinja2  
#B Import the datetime functionality to generate dynamic data  
#C Use the render_template function to connect the index.html template file with the now data element  
The first parameter to the render_template  function is the string "index.html" . This is the 
filename of a template file containing Jinja2 instructions. Everything else passed to 
render_template  is a named parameter. In the example above the named parameter  is now 
and it is the value returned by the code datetime.now() , the current timestamp.  
By default, Flask initially searches for template files in a directory called "templates". The 
template directory should exist in the same directory as the app.py  file, so create that now.  
Inside the "templates" directory you'll need to create a file named "index.html" . In the 
example application the "index.html"  file looks like this:  
  
105
